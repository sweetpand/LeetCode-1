{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"LeetCode Solutions Getting Started In this repository, I'll work on solutions to all LeetCode problems by C++, Java, and Python. Coding Style I believe messy code is costing you. C++ code is formatted by clang-format following the Google C++ Style Guide . You can see the configuration here . Java code is formatted by Language Support for Java(TM) by Red Hat . Python code is formatted by PEP 8 -- Style Guide for Python Code . Besides, this is the convention I follow for consistency. More Information The repository is still under construction, and the goal is to keep up with the growth of LeetCode problems by Aug 2020! For more information, please visit my GitHub . By Jay Chen on Feb 23, 2019. Revised on Dec 25, 2019.","title":"Preface"},{"location":"#leetcode-solutions","text":"","title":"LeetCode Solutions"},{"location":"#getting-started","text":"In this repository, I'll work on solutions to all LeetCode problems by C++, Java, and Python.","title":"Getting Started"},{"location":"#coding-style","text":"I believe messy code is costing you. C++ code is formatted by clang-format following the Google C++ Style Guide . You can see the configuration here . Java code is formatted by Language Support for Java(TM) by Red Hat . Python code is formatted by PEP 8 -- Style Guide for Python Code . Besides, this is the convention I follow for consistency.","title":"Coding Style"},{"location":"#more-information","text":"The repository is still under construction, and the goal is to keep up with the growth of LeetCode problems by Aug 2020! For more information, please visit my GitHub . By Jay Chen on Feb 23, 2019. Revised on Dec 25, 2019.","title":"More Information"},{"location":"convention/","text":"Naming Convention This document is discussed with @hsins . Fundamental Rules Class : UpperCamelCase Function : lowerCamelCase Variable : lowerCamelCase Constant : UPPERCASE with underline Field : lowerCamelCase Database : SELECT * FROM name_table constexpr (TBD) Examples // Class class MyClass { ... } // Function function myFunction () { ... } // Variable int myVariable ; // Constant #define MY_CONSTANT; // Database Table SELECT * FROM my_table Template Rules There should only be one public function. Declare the variables in the proper scope as slow as possible. Declare ans as soon as possible. Since LeetCode is just an online judge system rather than a big project, we don't scatter all variables in different sections. However, we still sort the variables based on the time we first use each of them. Code section (there should be one blank line between each sections.) public boundary conditions initial variables There may be many kernels separated with one blank line, but there shouldn't be any blank line in each kernel. return private private variables private function(s) Schematic Template Blank one single line between each section. However, if there\u2019s no sec 12 , no blank line between sec 11 and sec 13 . class Solution { public : // There should only be one public function. func () { // (sec 0) boundary conditions // (sec 1) initial variables // (sec 10) size/length // (sec 11) ans // (sec 12) declaration & operation // (sec 13) purely declaration // (sec 2) kernels // (sec 3) modify original initial variables // (sec 4) kernels // (sec n) return } private : // private variables // private function(s) helper () { ... } dfs () { ... } }; Example ( 873. Length of Longest Fibonacci Subsequence ): w/o comment: class Solution { public : int lenLongestFibSubseq ( vector < int >& A ) { const int n = A . size (); int ans = 0 ; unordered_map < int , int > numToIndex ; vector < vector < int >> dp ( n , vector < int > ( n , 2 )); for ( int i = 0 ; i < n ; ++ i ) numToIndex [ A [ i ]] = i ; for ( int j = 0 ; j < n ; ++ j ) for ( int k = j + 1 ; k < n ; ++ k ) { int ai = A [ k ] - A [ j ]; if ( ai < A [ j ] && numToIndex . count ( ai )) { int i = numToIndex [ ai ]; dp [ j ][ k ] = dp [ i ][ j ] + 1 ; ans = max ( ans , dp [ j ][ k ]); } } return ans ; } }; w/ comment: class Solution { public : int lenLongestFibSubseq ( vector < int >& A ) { // Only get the value of size or length // when we use it twice or more times. // Add `const`, and separate this line from next section a blank line. const int n = A . size (); // Declare the variables in the proper scope as slow as possible. // Declare `ans` as soon as possible. // Order: ans -> STL -> dp -> pointers (TBD) int ans = 0 ; unordered_map < int , int > numToIndex ; vector < vector < int >> dp ( n , vector < int > ( n , 2 )); for ( int i = 0 ; i < n ; ++ i ) numToIndex [ A [ i ]] = i ; // single line based on clang-format for ( int j = 0 ; j < n ; ++ j ) for ( int k = j + 1 ; k < n ; ++ k ) if ( A [ k ] - A [ j ] < A [ j ] && numToIndex . count ( A [ k ] - A [ j ])) { // use `numToIndex.count` rather than `numToIndex.find` pattern int i = numToIndex [ A [ k ] - A [ j ]]; dp [ j ][ k ] = dp [ i ][ j ] + 1 ; ans = max ( ans , dp [ j ][ k ]); } return ans ; } }; Boundary Conditions // Linked-List if ( l1 || l2 ) { ... } if ( ! l1 || ! l2 ) { ... } // String if ( str . empty ()) { ... } if ( str . length () <= 2 ) { ... } // Vector if ( vec . size () <= 2 ) { ... } Return Value return ans ; return {}; Data Structures // C++ unordered_set < string > seen ; unordered_map < char , int > count ; // numToIndex, prefixSumToIndex vector < int > count ; // sometimes it's a better choice than `unordered_map` stack < char > stack ; queue < TreeNode *> queue ; deque < TreeNode *> deque ; auto compare = []( const ListNode * a , const ListNode * b ) { return a -> val > b -> val ; }; priority_queue < ListNode * , vector < ListNode *> , decltype ( compare ) > pq ( compare ); // Java Set < String > seen = new HashSet <> (); Map < Character , Integer > count = new HashMap <> (); int [] count = new int [ n ] ; Stack < Character > stack = new Stack <> (); Queue < Integer > queue = new LinkedList <> (); Deque < Integer > deque = new ArrayDeque <> (); Queue < ListNode > pq = new PriorityQueue <> (( l1 , l2 ) -> l1 . val - l2 . val ); # Python seen = set () # or wordSet = set() if you like count = {} count = collections . defaultdict ( int ) count = collections . defaultdict ( list ) count = collections . Counter () queue = collections . deque ([ root ]) deque = collections . deque ([ root ]) stack = [] Two Pointers / Sliding Windows Always prefer to one character to represent index variables. Use i , j , k in the loop, in that order. int i = 0 ; for ( int num : nums ) { ... } int j = 0 ; for ( int i = 0 ; i < n ; ++ i ) { ... } int k = 0 ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = i ; j < n ; ++ j ) { ... } int l = 0 ; int r = nums . size () - 1 ; Binary Search Always prefer to one character to represent index variables. Always prefer to use [l, r) pattern. int l = 0 ; int r = nums . size (); // or nums.size() - 1 while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( f ( m )) return m ; // optional if ( g ( m )) l = m + 1 ; // new range [m + 1, r) else r = m ; // new range [l, m) } return l ; // nums[l] ListNode ListNode dummy ( 0 ); // allocated on stack instead of heap ListNode * curr ; ListNode * prev ; ListNode * next ; ListNode * slow ; ListNode * fast ; ListNode * head ; ListNode * tail ; ListNode * l1 ; ListNode * l2 ; 2D Vector / 2 Strings // 2D Vector const int m = matrix . size (); const int n = matrix [ 0 ]. size (); // if there're two strings const int m = str1 . length (); const int n = str2 . length (); // if there's only a string const int n = str . length (); Traversing // vector<int> nums; for ( int i = 0 ; i < nums . size (); ++ i ) { ... } for ( int num : nums ) { ... } // vector<string> words; for ( const string & word : words ) { ... } // string str; for ( int i = 0 ; i < str . length (); ++ i ) { ... } for ( char c : str ) { ... } // unordered_set<int> set; for ( int num : set ) { ... } // unordered_map<char, int> map; for ( const auto & [ key , value ] : map ) { ... } // ListNode* head; for ( ListNode * curr = head ; curr ; curr = curr -> next ) { ... } Pattern Find the length of a given linked-list int length = 0 ; // name `length` rather than `len` for ( ListNode * curr = head ; curr ; curr = curr -> next ) ++ length ; length = 0 curr = head while curr : length += 1 curr = curr . next Initialize a dummy ListNode ListNode dummy ( 0 ); dummy -> next = head ; ListNode * curr = & dummy ; DFS pattern class Solution { public : vector < vector < int >> permute ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; vector < bool > used ( nums . size (), false ); dfs ( nums , nums . size (), used , path , ans ); return ans ; } private : void dfs ( vector < int >& nums , int target , vector < bool >& used , vector < int >& path , vector < vector < int >>& ans ) { if ( target == 0 ) { ans . push_back ( path ); return ; } for ( int i = 0 ; i < nums . size (); ++ i ) { if ( used [ i ]) continue ; used [ i ] = true ; path . push_back ( nums [ i ]); dfs ( nums , target - 1 , used , path , ans ); path . pop_back (); used [ i ] = false ; } } }; bool dfs ( vector < vector < char >>& board , string & word , int i , int j , int pos ) { if ( i < 0 || j < 0 || i >= board . size () || j >= board [ 0 ]. size () || board [ i ][ j ] != word [ pos ] || board [ i ][ j ] == '*' ) return false ; Others Always prefer to use str.length() over str.size() . Always use camelCase nomenclature when not listed above. // C++ int currNum ; int maxProfit ; TreeNode * currNode ; When there's confliction in expression and function or reserved key word: // C++ min , std :: min () max , std :: max () # Python mini , min maxi , max summ , sum seen , set count , dict When there are two maps/stacks, use meaningful names. // C++ unordered_map < char , int > countA ; unordered_map < char , int > countB ; When we need to count something, use sum , count and total , in that order. Initialize with 0 or false implicitly . (TBD) const is used if we get value of size() or length() . const auto is used when we iterate through a map Use & whenever possible except int and char because reference typically takes 4 bytes, while int takes 2/4 bytes and char takes 1 byte Prefer to name variables in a \"adjactive + noun\" order. For example, maxLeft is better than leftMax .","title":"Naming Convention"},{"location":"convention/#naming-convention","text":"This document is discussed with @hsins .","title":"Naming Convention"},{"location":"convention/#fundamental","text":"","title":"Fundamental"},{"location":"convention/#rules","text":"Class : UpperCamelCase Function : lowerCamelCase Variable : lowerCamelCase Constant : UPPERCASE with underline Field : lowerCamelCase Database : SELECT * FROM name_table constexpr (TBD)","title":"Rules"},{"location":"convention/#examples","text":"// Class class MyClass { ... } // Function function myFunction () { ... } // Variable int myVariable ; // Constant #define MY_CONSTANT; // Database Table SELECT * FROM my_table","title":"Examples"},{"location":"convention/#template","text":"","title":"Template"},{"location":"convention/#rules_1","text":"There should only be one public function. Declare the variables in the proper scope as slow as possible. Declare ans as soon as possible. Since LeetCode is just an online judge system rather than a big project, we don't scatter all variables in different sections. However, we still sort the variables based on the time we first use each of them. Code section (there should be one blank line between each sections.) public boundary conditions initial variables There may be many kernels separated with one blank line, but there shouldn't be any blank line in each kernel. return private private variables private function(s)","title":"Rules"},{"location":"convention/#schematic-template","text":"Blank one single line between each section. However, if there\u2019s no sec 12 , no blank line between sec 11 and sec 13 . class Solution { public : // There should only be one public function. func () { // (sec 0) boundary conditions // (sec 1) initial variables // (sec 10) size/length // (sec 11) ans // (sec 12) declaration & operation // (sec 13) purely declaration // (sec 2) kernels // (sec 3) modify original initial variables // (sec 4) kernels // (sec n) return } private : // private variables // private function(s) helper () { ... } dfs () { ... } }; Example ( 873. Length of Longest Fibonacci Subsequence ): w/o comment: class Solution { public : int lenLongestFibSubseq ( vector < int >& A ) { const int n = A . size (); int ans = 0 ; unordered_map < int , int > numToIndex ; vector < vector < int >> dp ( n , vector < int > ( n , 2 )); for ( int i = 0 ; i < n ; ++ i ) numToIndex [ A [ i ]] = i ; for ( int j = 0 ; j < n ; ++ j ) for ( int k = j + 1 ; k < n ; ++ k ) { int ai = A [ k ] - A [ j ]; if ( ai < A [ j ] && numToIndex . count ( ai )) { int i = numToIndex [ ai ]; dp [ j ][ k ] = dp [ i ][ j ] + 1 ; ans = max ( ans , dp [ j ][ k ]); } } return ans ; } }; w/ comment: class Solution { public : int lenLongestFibSubseq ( vector < int >& A ) { // Only get the value of size or length // when we use it twice or more times. // Add `const`, and separate this line from next section a blank line. const int n = A . size (); // Declare the variables in the proper scope as slow as possible. // Declare `ans` as soon as possible. // Order: ans -> STL -> dp -> pointers (TBD) int ans = 0 ; unordered_map < int , int > numToIndex ; vector < vector < int >> dp ( n , vector < int > ( n , 2 )); for ( int i = 0 ; i < n ; ++ i ) numToIndex [ A [ i ]] = i ; // single line based on clang-format for ( int j = 0 ; j < n ; ++ j ) for ( int k = j + 1 ; k < n ; ++ k ) if ( A [ k ] - A [ j ] < A [ j ] && numToIndex . count ( A [ k ] - A [ j ])) { // use `numToIndex.count` rather than `numToIndex.find` pattern int i = numToIndex [ A [ k ] - A [ j ]]; dp [ j ][ k ] = dp [ i ][ j ] + 1 ; ans = max ( ans , dp [ j ][ k ]); } return ans ; } };","title":"Schematic Template"},{"location":"convention/#boundary-conditions","text":"// Linked-List if ( l1 || l2 ) { ... } if ( ! l1 || ! l2 ) { ... } // String if ( str . empty ()) { ... } if ( str . length () <= 2 ) { ... } // Vector if ( vec . size () <= 2 ) { ... }","title":"Boundary Conditions"},{"location":"convention/#return-value","text":"return ans ; return {};","title":"Return Value"},{"location":"convention/#data-structures","text":"// C++ unordered_set < string > seen ; unordered_map < char , int > count ; // numToIndex, prefixSumToIndex vector < int > count ; // sometimes it's a better choice than `unordered_map` stack < char > stack ; queue < TreeNode *> queue ; deque < TreeNode *> deque ; auto compare = []( const ListNode * a , const ListNode * b ) { return a -> val > b -> val ; }; priority_queue < ListNode * , vector < ListNode *> , decltype ( compare ) > pq ( compare ); // Java Set < String > seen = new HashSet <> (); Map < Character , Integer > count = new HashMap <> (); int [] count = new int [ n ] ; Stack < Character > stack = new Stack <> (); Queue < Integer > queue = new LinkedList <> (); Deque < Integer > deque = new ArrayDeque <> (); Queue < ListNode > pq = new PriorityQueue <> (( l1 , l2 ) -> l1 . val - l2 . val ); # Python seen = set () # or wordSet = set() if you like count = {} count = collections . defaultdict ( int ) count = collections . defaultdict ( list ) count = collections . Counter () queue = collections . deque ([ root ]) deque = collections . deque ([ root ]) stack = []","title":"Data Structures"},{"location":"convention/#two-pointers-sliding-windows","text":"Always prefer to one character to represent index variables. Use i , j , k in the loop, in that order. int i = 0 ; for ( int num : nums ) { ... } int j = 0 ; for ( int i = 0 ; i < n ; ++ i ) { ... } int k = 0 ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = i ; j < n ; ++ j ) { ... } int l = 0 ; int r = nums . size () - 1 ;","title":"Two Pointers / Sliding Windows"},{"location":"convention/#binary-search","text":"Always prefer to one character to represent index variables. Always prefer to use [l, r) pattern. int l = 0 ; int r = nums . size (); // or nums.size() - 1 while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( f ( m )) return m ; // optional if ( g ( m )) l = m + 1 ; // new range [m + 1, r) else r = m ; // new range [l, m) } return l ; // nums[l]","title":"Binary Search"},{"location":"convention/#listnode","text":"ListNode dummy ( 0 ); // allocated on stack instead of heap ListNode * curr ; ListNode * prev ; ListNode * next ; ListNode * slow ; ListNode * fast ; ListNode * head ; ListNode * tail ; ListNode * l1 ; ListNode * l2 ;","title":"ListNode"},{"location":"convention/#2d-vector-2-strings","text":"// 2D Vector const int m = matrix . size (); const int n = matrix [ 0 ]. size (); // if there're two strings const int m = str1 . length (); const int n = str2 . length (); // if there's only a string const int n = str . length ();","title":"2D Vector / 2 Strings"},{"location":"convention/#traversing","text":"// vector<int> nums; for ( int i = 0 ; i < nums . size (); ++ i ) { ... } for ( int num : nums ) { ... } // vector<string> words; for ( const string & word : words ) { ... } // string str; for ( int i = 0 ; i < str . length (); ++ i ) { ... } for ( char c : str ) { ... } // unordered_set<int> set; for ( int num : set ) { ... } // unordered_map<char, int> map; for ( const auto & [ key , value ] : map ) { ... } // ListNode* head; for ( ListNode * curr = head ; curr ; curr = curr -> next ) { ... }","title":"Traversing"},{"location":"convention/#pattern","text":"Find the length of a given linked-list int length = 0 ; // name `length` rather than `len` for ( ListNode * curr = head ; curr ; curr = curr -> next ) ++ length ; length = 0 curr = head while curr : length += 1 curr = curr . next Initialize a dummy ListNode ListNode dummy ( 0 ); dummy -> next = head ; ListNode * curr = & dummy ; DFS pattern class Solution { public : vector < vector < int >> permute ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; vector < bool > used ( nums . size (), false ); dfs ( nums , nums . size (), used , path , ans ); return ans ; } private : void dfs ( vector < int >& nums , int target , vector < bool >& used , vector < int >& path , vector < vector < int >>& ans ) { if ( target == 0 ) { ans . push_back ( path ); return ; } for ( int i = 0 ; i < nums . size (); ++ i ) { if ( used [ i ]) continue ; used [ i ] = true ; path . push_back ( nums [ i ]); dfs ( nums , target - 1 , used , path , ans ); path . pop_back (); used [ i ] = false ; } } }; bool dfs ( vector < vector < char >>& board , string & word , int i , int j , int pos ) { if ( i < 0 || j < 0 || i >= board . size () || j >= board [ 0 ]. size () || board [ i ][ j ] != word [ pos ] || board [ i ][ j ] == '*' ) return false ;","title":"Pattern"},{"location":"convention/#others","text":"Always prefer to use str.length() over str.size() . Always use camelCase nomenclature when not listed above. // C++ int currNum ; int maxProfit ; TreeNode * currNode ; When there's confliction in expression and function or reserved key word: // C++ min , std :: min () max , std :: max () # Python mini , min maxi , max summ , sum seen , set count , dict When there are two maps/stacks, use meaningful names. // C++ unordered_map < char , int > countA ; unordered_map < char , int > countB ; When we need to count something, use sum , count and total , in that order. Initialize with 0 or false implicitly . (TBD) const is used if we get value of size() or length() . const auto is used when we iterate through a map Use & whenever possible except int and char because reference typically takes 4 bytes, while int takes 2/4 bytes and char takes 1 byte Prefer to name variables in a \"adjactive + noun\" order. For example, maxLeft is better than leftMax .","title":"Others"},{"location":"cpp/","text":"LeetCode in C++ C++ code is formatted by clang-format following the Google C++ Style Guide . You can see the configuration here . Use the standard library as possible as I could. Capable of being compiled with -stdc++=2a .","title":"Preface"},{"location":"cpp/#leetcode-in-c","text":"C++ code is formatted by clang-format following the Google C++ Style Guide . You can see the configuration here . Use the standard library as possible as I could. Capable of being compiled with -stdc++=2a .","title":"LeetCode in C++"},{"location":"cpp/0001-0100/0001-0010/","text":"1. Two Sum $\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : vector < int > twoSum ( vector < int >& nums , int target ) { unordered_map < int , int > numToIndex ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( numToIndex . count ( target - nums [ i ])) return { numToIndex [ target - nums [ i ]], i }; numToIndex [ nums [ i ]] = i ; } throw ; } }; 2. Add Two Numbers $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : ListNode * addTwoNumbers ( ListNode * l1 , ListNode * l2 ) { ListNode dummy ( 0 ); ListNode * curr = & dummy ; int carry = 0 ; while ( carry || l1 || l2 ) { carry += ( l1 ? l1 -> val : 0 ) + ( l2 ? l2 -> val : 0 ); curr -> next = new ListNode ( carry % 10 ); curr = curr -> next ; carry /= 10 ; if ( l1 ) l1 = l1 -> next ; if ( l2 ) l2 = l2 -> next ; } return dummy . next ; } }; 3. Longest Substring Without Repeating Characters $\\star\\star$ Time: $O(n)$ Space: $O(128)$ class Solution { public : int lengthOfLongestSubstring ( string s ) { int ans = 0 ; vector < int > count ( 128 ); for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { ++ count [ s [ r ]]; while ( count [ s [ r ]] > 1 ) -- count [ s [ l ++ ]]; ans = max ( ans , r - l + 1 ); } return ans ; } }; 4. Median of Two Sorted Arrays $\\star\\star\\star$ Time: $O(\\log\\min(m, n))$ Space: $O(1)$ class Solution { public : double findMedianSortedArrays ( vector < int >& nums1 , vector < int >& nums2 ) { const int n1 = nums1 . size (); const int n2 = nums2 . size (); if ( n1 > n2 ) return findMedianSortedArrays ( nums2 , nums1 ); int l = 0 ; int r = n1 ; while ( l <= r ) { const int partition1 = l + ( r - l ) / 2 ; const int partition2 = ( n1 + n2 + 1 ) / 2 - partition1 ; const int maxLeft1 = partition1 == 0 ? INT_MIN : nums1 [ partition1 - 1 ]; const int maxLeft2 = partition2 == 0 ? INT_MIN : nums2 [ partition2 - 1 ]; const int minRight1 = partition1 == n1 ? INT_MAX : nums1 [ partition1 ]; const int minRight2 = partition2 == n2 ? INT_MAX : nums2 [ partition2 ]; if ( maxLeft1 <= minRight2 && maxLeft2 <= minRight1 ) return ( n1 + n2 ) % 2 == 0 ? ( max ( maxLeft1 , maxLeft2 ) + min ( minRight1 , minRight2 )) * 0.5 : max ( maxLeft1 , maxLeft2 ); else if ( maxLeft1 > minRight2 ) r = partition1 - 1 ; else l = partition1 + 1 ; } throw ; } }; 5. Longest Palindromic Substring $\\star\\star$ Time: $O(n^2)$ Space: $O(1)$ class Solution { public : string longestPalindrome ( string s ) { const int length = s . length () * 2 + 3 ; // Manacher's Algorithm string T ( length , '#' ); T [ 0 ] = '$' ; T [ length - 1 ] = '@' ; for ( int i = 2 ; i < length - 2 ; i += 2 ) T [ i ] = s [ i / 2 - 1 ]; int center = 1 ; int right = 1 ; vector < int > P ( length , 0 ); for ( int i = 1 ; i < length - 1 ; ++ i ) { int mirr = 2 * center - i ; if ( i < right ) P [ i ] = min ( P [ mirr ], right - i ); while ( T [ i + P [ i ] + 1 ] == T [ i - P [ i ] - 1 ]) ++ P [ i ]; if ( i + P [ i ] > right ) { center = i ; right = i + P [ i ]; } } // find max and the center; int max = 0 ; int c = 0 ; for ( int i = 0 ; i < length ; ++ i ) if ( P [ i ] > max ) { max = P [ i ]; c = i ; } // omit '#' and get the string desired string ans ( max , '#' ); int i = 0 ; for ( int j = c - max + 1 ; j < c + max ; j += 2 ) { ans [ i ] = T [ j ]; ++ i ; } return ans ; } }; 6. ZigZag Conversion $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : string convert ( string s , int numRows ) { string ans ; vector < vector < char >> rows ( numRows ); int k = 0 ; int direction = ( numRows == 1 ) - 1 ; for ( const char c : s ) { rows [ k ]. push_back ( c ); if ( k == 0 || k == numRows - 1 ) direction *= - 1 ; k += direction ; } for ( const vector < char >& row : rows ) for ( const char c : row ) ans . push_back ( c ); return ans ; } }; 7. Reverse Integer $\\star$ Time: $O(\\log x)$ Space: $O(1)$ class Solution { public : int reverse ( int x ) { long ans = 0 ; while ( x ) { ans = ans * 10 + x % 10 ; x /= 10 ; } return ( ans < INT_MIN || ans > INT_MAX ) ? 0 : ans ; } }; 8. String to Integer (atoi) $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : int myAtoi ( string str ) { long ans = 0 ; bool isNegative = false ; int j = 0 ; while ( j < str . length () && str [ j ] == ' ' ) ++ j ; if ( j == str . length ()) return 0 ; if ( str [ j ] == '-' ) { isNegative = true ; ++ j ; } else if ( str [ j ] == '+' ) { ++ j ; } for ( int i = j ; i < str . length (); ++ i ) { if ( str [ i ] < '0' || str [ i ] > '9' ) break ; else { ans = ans * 10 + ( str [ i ] - '0' ); if ( isNegative && - ans <= INT_MIN ) return INT_MIN ; if ( ! isNegative && ans >= INT_MAX ) return INT_MAX ; } } return isNegative ? - ans : ans ; } }; 9. Palindrome Number $\\star$ Time: $O\\log x)$ Space: $O(1)$ class Solution { public : bool isPalindrome ( int x ) { if ( x < 0 ) return false ; long ans = 0 ; int y = x ; while ( y ) { ans = ans * 10 + y % 10 ; y /= 10 ; } return ans == x ; } }; 10. Regular Expression Matching $\\star\\star\\star$ Time: $O(mn)$ Space: $O(n^2) \\to O(n)$ class Solution { public : bool isMatch ( string s , string p ) { if ( p . empty ()) return s . empty (); bool isFirstMatch = ( ! s . empty () && ( p [ 0 ] == s [ 0 ] || p [ 0 ] == '.' )); if ( p . length () >= 2 && p [ 1 ] == '*' ) return ( isMatch ( s , p . substr ( 2 )) || ( isFirstMatch && isMatch ( s . substr ( 1 ), p ))); return isFirstMatch && isMatch ( s . substr ( 1 ), p . substr ( 1 )); } };","title":"0001-0010"},{"location":"cpp/0001-0100/0001-0010/#1-two-sum-star","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : vector < int > twoSum ( vector < int >& nums , int target ) { unordered_map < int , int > numToIndex ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( numToIndex . count ( target - nums [ i ])) return { numToIndex [ target - nums [ i ]], i }; numToIndex [ nums [ i ]] = i ; } throw ; } };","title":"1. Two Sum $\\star$"},{"location":"cpp/0001-0100/0001-0010/#2-add-two-numbers-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : ListNode * addTwoNumbers ( ListNode * l1 , ListNode * l2 ) { ListNode dummy ( 0 ); ListNode * curr = & dummy ; int carry = 0 ; while ( carry || l1 || l2 ) { carry += ( l1 ? l1 -> val : 0 ) + ( l2 ? l2 -> val : 0 ); curr -> next = new ListNode ( carry % 10 ); curr = curr -> next ; carry /= 10 ; if ( l1 ) l1 = l1 -> next ; if ( l2 ) l2 = l2 -> next ; } return dummy . next ; } };","title":"2. Add Two Numbers $\\star\\star$"},{"location":"cpp/0001-0100/0001-0010/#3-longest-substring-without-repeating-characters-starstar","text":"Time: $O(n)$ Space: $O(128)$ class Solution { public : int lengthOfLongestSubstring ( string s ) { int ans = 0 ; vector < int > count ( 128 ); for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { ++ count [ s [ r ]]; while ( count [ s [ r ]] > 1 ) -- count [ s [ l ++ ]]; ans = max ( ans , r - l + 1 ); } return ans ; } };","title":"3. Longest Substring Without Repeating Characters $\\star\\star$"},{"location":"cpp/0001-0100/0001-0010/#4-median-of-two-sorted-arrays-starstarstar","text":"Time: $O(\\log\\min(m, n))$ Space: $O(1)$ class Solution { public : double findMedianSortedArrays ( vector < int >& nums1 , vector < int >& nums2 ) { const int n1 = nums1 . size (); const int n2 = nums2 . size (); if ( n1 > n2 ) return findMedianSortedArrays ( nums2 , nums1 ); int l = 0 ; int r = n1 ; while ( l <= r ) { const int partition1 = l + ( r - l ) / 2 ; const int partition2 = ( n1 + n2 + 1 ) / 2 - partition1 ; const int maxLeft1 = partition1 == 0 ? INT_MIN : nums1 [ partition1 - 1 ]; const int maxLeft2 = partition2 == 0 ? INT_MIN : nums2 [ partition2 - 1 ]; const int minRight1 = partition1 == n1 ? INT_MAX : nums1 [ partition1 ]; const int minRight2 = partition2 == n2 ? INT_MAX : nums2 [ partition2 ]; if ( maxLeft1 <= minRight2 && maxLeft2 <= minRight1 ) return ( n1 + n2 ) % 2 == 0 ? ( max ( maxLeft1 , maxLeft2 ) + min ( minRight1 , minRight2 )) * 0.5 : max ( maxLeft1 , maxLeft2 ); else if ( maxLeft1 > minRight2 ) r = partition1 - 1 ; else l = partition1 + 1 ; } throw ; } };","title":"4. Median of Two Sorted Arrays $\\star\\star\\star$"},{"location":"cpp/0001-0100/0001-0010/#5-longest-palindromic-substring-starstar","text":"Time: $O(n^2)$ Space: $O(1)$ class Solution { public : string longestPalindrome ( string s ) { const int length = s . length () * 2 + 3 ; // Manacher's Algorithm string T ( length , '#' ); T [ 0 ] = '$' ; T [ length - 1 ] = '@' ; for ( int i = 2 ; i < length - 2 ; i += 2 ) T [ i ] = s [ i / 2 - 1 ]; int center = 1 ; int right = 1 ; vector < int > P ( length , 0 ); for ( int i = 1 ; i < length - 1 ; ++ i ) { int mirr = 2 * center - i ; if ( i < right ) P [ i ] = min ( P [ mirr ], right - i ); while ( T [ i + P [ i ] + 1 ] == T [ i - P [ i ] - 1 ]) ++ P [ i ]; if ( i + P [ i ] > right ) { center = i ; right = i + P [ i ]; } } // find max and the center; int max = 0 ; int c = 0 ; for ( int i = 0 ; i < length ; ++ i ) if ( P [ i ] > max ) { max = P [ i ]; c = i ; } // omit '#' and get the string desired string ans ( max , '#' ); int i = 0 ; for ( int j = c - max + 1 ; j < c + max ; j += 2 ) { ans [ i ] = T [ j ]; ++ i ; } return ans ; } };","title":"5. Longest Palindromic Substring $\\star\\star$"},{"location":"cpp/0001-0100/0001-0010/#6-zigzag-conversion-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : string convert ( string s , int numRows ) { string ans ; vector < vector < char >> rows ( numRows ); int k = 0 ; int direction = ( numRows == 1 ) - 1 ; for ( const char c : s ) { rows [ k ]. push_back ( c ); if ( k == 0 || k == numRows - 1 ) direction *= - 1 ; k += direction ; } for ( const vector < char >& row : rows ) for ( const char c : row ) ans . push_back ( c ); return ans ; } };","title":"6. ZigZag Conversion $\\star\\star$"},{"location":"cpp/0001-0100/0001-0010/#7-reverse-integer-star","text":"Time: $O(\\log x)$ Space: $O(1)$ class Solution { public : int reverse ( int x ) { long ans = 0 ; while ( x ) { ans = ans * 10 + x % 10 ; x /= 10 ; } return ( ans < INT_MIN || ans > INT_MAX ) ? 0 : ans ; } };","title":"7. Reverse Integer $\\star$"},{"location":"cpp/0001-0100/0001-0010/#8-string-to-integer-atoi-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : int myAtoi ( string str ) { long ans = 0 ; bool isNegative = false ; int j = 0 ; while ( j < str . length () && str [ j ] == ' ' ) ++ j ; if ( j == str . length ()) return 0 ; if ( str [ j ] == '-' ) { isNegative = true ; ++ j ; } else if ( str [ j ] == '+' ) { ++ j ; } for ( int i = j ; i < str . length (); ++ i ) { if ( str [ i ] < '0' || str [ i ] > '9' ) break ; else { ans = ans * 10 + ( str [ i ] - '0' ); if ( isNegative && - ans <= INT_MIN ) return INT_MIN ; if ( ! isNegative && ans >= INT_MAX ) return INT_MAX ; } } return isNegative ? - ans : ans ; } };","title":"8. String to Integer (atoi) $\\star\\star$"},{"location":"cpp/0001-0100/0001-0010/#9-palindrome-number-star","text":"Time: $O\\log x)$ Space: $O(1)$ class Solution { public : bool isPalindrome ( int x ) { if ( x < 0 ) return false ; long ans = 0 ; int y = x ; while ( y ) { ans = ans * 10 + y % 10 ; y /= 10 ; } return ans == x ; } };","title":"9. Palindrome Number $\\star$"},{"location":"cpp/0001-0100/0001-0010/#10-regular-expression-matching-starstarstar","text":"Time: $O(mn)$ Space: $O(n^2) \\to O(n)$ class Solution { public : bool isMatch ( string s , string p ) { if ( p . empty ()) return s . empty (); bool isFirstMatch = ( ! s . empty () && ( p [ 0 ] == s [ 0 ] || p [ 0 ] == '.' )); if ( p . length () >= 2 && p [ 1 ] == '*' ) return ( isMatch ( s , p . substr ( 2 )) || ( isFirstMatch && isMatch ( s . substr ( 1 ), p ))); return isFirstMatch && isMatch ( s . substr ( 1 ), p . substr ( 1 )); } };","title":"10. Regular Expression Matching $\\star\\star\\star$"},{"location":"cpp/0001-0100/0011-0020/","text":"11. Container With Most Water $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : int maxArea ( vector < int >& height ) { int ans = 0 ; int l = 0 ; int r = height . size () - 1 ; while ( l < r ) { const int h = min ( height [ l ], height [ r ]); ans = max ( ans , ( r - l ) * h ); while ( height [ l ] <= h && l < r ) ++ l ; while ( height [ r ] <= h && l < r ) -- r ; } return ans ; } }; 12. Integer to Roman $\\star\\star$ Time: $O(1)$ Space: $O(k)$ class Solution { public : string intToRoman ( int num ) { const vector < string > M { \"\" , \"M\" , \"MM\" , \"MMM\" }; const vector < string > C { \"\" , \"C\" , \"CC\" , \"CCC\" , \"CD\" , \"D\" , \"DC\" , \"DCC\" , \"DCCC\" , \"CM\" }; const vector < string > X { \"\" , \"X\" , \"XX\" , \"XXX\" , \"XL\" , \"L\" , \"LX\" , \"LXX\" , \"LXXX\" , \"XC\" }; const vector < string > I { \"\" , \"I\" , \"II\" , \"III\" , \"IV\" , \"V\" , \"VI\" , \"VII\" , \"VIII\" , \"IX\" }; return M [ num / 1000 ] + C [ num % 1000 / 100 ] + X [ num % 100 / 10 ] + I [ num % 10 ]; } }; 13. Roman to Integer $\\star$ Time: $O(n)$ Space: $O(24)$ class Solution { public : int romanToInt ( string s ) { int ans = 0 ; vector < int > roman ( 24 ); roman [ 'I' - 'A' ] = 1 ; roman [ 'V' - 'A' ] = 5 ; roman [ 'X' - 'A' ] = 10 ; roman [ 'L' - 'A' ] = 50 ; roman [ 'C' - 'A' ] = 100 ; roman [ 'D' - 'A' ] = 500 ; roman [ 'M' - 'A' ] = 1000 ; for ( int i = 0 ; i + 1 < s . length (); ++ i ) if ( roman [ s [ i ] - 'A' ] < roman [ s [ i + 1 ] - 'A' ]) ans -= roman [ s [ i ] - 'A' ]; else ans += roman [ s [ i ] - 'A' ]; return ans + roman [ s . back () - 'A' ]; } }; 14. Longest Common Prefix $\\star$ Time: $O(nm)$, where n = len(strs) and m = len(strs[i]) Space: $O(1)$ class Solution { public : string longestCommonPrefix ( vector < string >& strs ) { if ( strs . empty ()) return \"\" ; for ( int i = 0 ; i < strs [ 0 ]. length (); ++ i ) { const char c = strs [ 0 ][ i ]; for ( int j = 1 ; j < strs . size (); ++ j ) if ( strs [ j ][ i ] != c || i == strs [ j ]. length ()) return strs [ 0 ]. substr ( 0 , i ); } return strs [ 0 ]; } }; 15. 3Sum $\\star\\star$ Time: $O(n^2)$ Space: $O(1)$ class Solution { public : vector < vector < int >> threeSum ( vector < int >& nums ) { vector < vector < int >> ans ; sort ( begin ( nums ), end ( nums )); for ( int i = 0 ; i + 2 < nums . size (); ++ i ) { if ( i > 0 && nums [ i ] == nums [ i - 1 ]) continue ; int l = i + 1 ; int r = nums . size () - 1 ; while ( l < r ) { int sum = nums [ i ] + nums [ l ] + nums [ r ]; if ( sum == 0 ) { ans . push_back ({ nums [ i ], nums [ l ], nums [ r ]}); ++ l ; -- r ; while ( nums [ l ] == nums [ l - 1 ] && l < r ) ++ l ; while ( nums [ r ] == nums [ r + 1 ] && l < r ) -- r ; } else if ( sum < 0 ) { ++ l ; } else { -- r ; } } } return ans ; } }; 16. 3Sum Closest $\\star\\star$ Time: $O(n^2)$ Space: $O(1)$ class Solution { public : int threeSumClosest ( vector < int >& nums , int target ) { int ans = nums [ 0 ] + nums [ 1 ] + nums [ 2 ]; sort ( begin ( nums ), end ( nums )); for ( int i = 0 ; i + 2 < nums . size (); ++ i ) { int l = i + 1 ; int r = nums . size () - 1 ; while ( l < r ) { int sum = nums [ i ] + nums [ l ] + nums [ r ]; if ( sum == target ) return sum ; if ( abs ( sum - target ) < abs ( ans - target )) ans = sum ; if ( sum < target ) ++ l ; else -- r ; } } return ans ; } }; 17. Letter Combinations of a Phone Number $\\star\\star$ Time: $O(n4^n)$ Space: $O(4^n)$ class Solution { public : vector < string > letterCombinations ( string digits ) { if ( digits . empty ()) return {}; vector < string > ans { \"\" }; const unordered_map < char , string > digitToLetters { { '2' , \"abc\" }, { '3' , \"def\" }, { '4' , \"ghi\" }, { '5' , \"jkl\" }, { '6' , \"mno\" }, { '7' , \"pqrs\" }, { '8' , \"tuv\" }, { '9' , \"wxyz\" }}; for ( const char d : digits ) { vector < string > temp ; for ( const string & s : ans ) for ( const char c : digitToLetters . at ( d )) temp . push_back ( s + c ); swap ( ans , temp ); } return ans ; } }; 18. 4Sum $\\star\\star$ Time: $O(n^3)$ Space: $O(1)$ class Solution { public : vector < vector < int >> fourSum ( vector < int >& nums , int target ) { vector < vector < int >> ans ; vector < int > path ; sort ( begin ( nums ), end ( nums )); nSum ( nums , target , 0 , nums . size () - 1 , 4 , path , ans ); return ans ; } private : void nSum ( vector < int >& nums , int target , int l , int r , int n , vector < int >& path , vector < vector < int >>& ans ) { if ( r - l + 1 < n || n < 2 || target < nums [ l ] * n || target > nums [ r ] * n ) return ; if ( n == 2 ) { while ( l < r ) { int sum = nums [ l ] + nums [ r ]; if ( sum == target ) { path . push_back ( nums [ l ]); path . push_back ( nums [ r ]); ans . push_back ( path ); path . pop_back (); path . pop_back (); ++ l ; while ( nums [ l ] == nums [ l - 1 ] && l < r ) ++ l ; } else if ( sum < target ) { ++ l ; } else { -- r ; } } return ; } for ( int i = l ; i <= r ; ++ i ) { if ( i > l && nums [ i ] == nums [ i - 1 ]) continue ; path . push_back ( nums [ i ]); nSum ( nums , target - nums [ i ], i + 1 , r , n - 1 , path , ans ); path . pop_back (); } } }; 19. Remove Nth Node From End of List $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : ListNode * removeNthFromEnd ( ListNode * head , int n ) { auto slow = head ; auto fast = head ; while ( n -- ) fast = fast -> next ; if ( ! fast ) return head -> next ; while ( fast -> next ) { slow = slow -> next ; fast = fast -> next ; } slow -> next = slow -> next -> next ; return head ; } }; 20. Valid Parentheses $\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : bool isValid ( string s ) { stack < char > stack ; for ( const char c : s ) if ( c == '(' || c == '{' || c == '[' ) stack . push ( c ); else { if ( stack . empty () || ( c == ')' && stack . top () != '(' ) || ( c == '}' && stack . top () != '{' ) || ( c == ']' && stack . top () != '[' )) return false ; stack . pop (); } return stack . empty (); } };","title":"0011-0020"},{"location":"cpp/0001-0100/0011-0020/#11-container-with-most-water-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : int maxArea ( vector < int >& height ) { int ans = 0 ; int l = 0 ; int r = height . size () - 1 ; while ( l < r ) { const int h = min ( height [ l ], height [ r ]); ans = max ( ans , ( r - l ) * h ); while ( height [ l ] <= h && l < r ) ++ l ; while ( height [ r ] <= h && l < r ) -- r ; } return ans ; } };","title":"11. Container With Most Water $\\star\\star$"},{"location":"cpp/0001-0100/0011-0020/#12-integer-to-roman-starstar","text":"Time: $O(1)$ Space: $O(k)$ class Solution { public : string intToRoman ( int num ) { const vector < string > M { \"\" , \"M\" , \"MM\" , \"MMM\" }; const vector < string > C { \"\" , \"C\" , \"CC\" , \"CCC\" , \"CD\" , \"D\" , \"DC\" , \"DCC\" , \"DCCC\" , \"CM\" }; const vector < string > X { \"\" , \"X\" , \"XX\" , \"XXX\" , \"XL\" , \"L\" , \"LX\" , \"LXX\" , \"LXXX\" , \"XC\" }; const vector < string > I { \"\" , \"I\" , \"II\" , \"III\" , \"IV\" , \"V\" , \"VI\" , \"VII\" , \"VIII\" , \"IX\" }; return M [ num / 1000 ] + C [ num % 1000 / 100 ] + X [ num % 100 / 10 ] + I [ num % 10 ]; } };","title":"12. Integer to Roman $\\star\\star$"},{"location":"cpp/0001-0100/0011-0020/#13-roman-to-integer-star","text":"Time: $O(n)$ Space: $O(24)$ class Solution { public : int romanToInt ( string s ) { int ans = 0 ; vector < int > roman ( 24 ); roman [ 'I' - 'A' ] = 1 ; roman [ 'V' - 'A' ] = 5 ; roman [ 'X' - 'A' ] = 10 ; roman [ 'L' - 'A' ] = 50 ; roman [ 'C' - 'A' ] = 100 ; roman [ 'D' - 'A' ] = 500 ; roman [ 'M' - 'A' ] = 1000 ; for ( int i = 0 ; i + 1 < s . length (); ++ i ) if ( roman [ s [ i ] - 'A' ] < roman [ s [ i + 1 ] - 'A' ]) ans -= roman [ s [ i ] - 'A' ]; else ans += roman [ s [ i ] - 'A' ]; return ans + roman [ s . back () - 'A' ]; } };","title":"13. Roman to Integer $\\star$"},{"location":"cpp/0001-0100/0011-0020/#14-longest-common-prefix-star","text":"Time: $O(nm)$, where n = len(strs) and m = len(strs[i]) Space: $O(1)$ class Solution { public : string longestCommonPrefix ( vector < string >& strs ) { if ( strs . empty ()) return \"\" ; for ( int i = 0 ; i < strs [ 0 ]. length (); ++ i ) { const char c = strs [ 0 ][ i ]; for ( int j = 1 ; j < strs . size (); ++ j ) if ( strs [ j ][ i ] != c || i == strs [ j ]. length ()) return strs [ 0 ]. substr ( 0 , i ); } return strs [ 0 ]; } };","title":"14. Longest Common Prefix $\\star$"},{"location":"cpp/0001-0100/0011-0020/#15-3sum-starstar","text":"Time: $O(n^2)$ Space: $O(1)$ class Solution { public : vector < vector < int >> threeSum ( vector < int >& nums ) { vector < vector < int >> ans ; sort ( begin ( nums ), end ( nums )); for ( int i = 0 ; i + 2 < nums . size (); ++ i ) { if ( i > 0 && nums [ i ] == nums [ i - 1 ]) continue ; int l = i + 1 ; int r = nums . size () - 1 ; while ( l < r ) { int sum = nums [ i ] + nums [ l ] + nums [ r ]; if ( sum == 0 ) { ans . push_back ({ nums [ i ], nums [ l ], nums [ r ]}); ++ l ; -- r ; while ( nums [ l ] == nums [ l - 1 ] && l < r ) ++ l ; while ( nums [ r ] == nums [ r + 1 ] && l < r ) -- r ; } else if ( sum < 0 ) { ++ l ; } else { -- r ; } } } return ans ; } };","title":"15. 3Sum $\\star\\star$"},{"location":"cpp/0001-0100/0011-0020/#16-3sum-closest-starstar","text":"Time: $O(n^2)$ Space: $O(1)$ class Solution { public : int threeSumClosest ( vector < int >& nums , int target ) { int ans = nums [ 0 ] + nums [ 1 ] + nums [ 2 ]; sort ( begin ( nums ), end ( nums )); for ( int i = 0 ; i + 2 < nums . size (); ++ i ) { int l = i + 1 ; int r = nums . size () - 1 ; while ( l < r ) { int sum = nums [ i ] + nums [ l ] + nums [ r ]; if ( sum == target ) return sum ; if ( abs ( sum - target ) < abs ( ans - target )) ans = sum ; if ( sum < target ) ++ l ; else -- r ; } } return ans ; } };","title":"16. 3Sum Closest $\\star\\star$"},{"location":"cpp/0001-0100/0011-0020/#17-letter-combinations-of-a-phone-number-starstar","text":"Time: $O(n4^n)$ Space: $O(4^n)$ class Solution { public : vector < string > letterCombinations ( string digits ) { if ( digits . empty ()) return {}; vector < string > ans { \"\" }; const unordered_map < char , string > digitToLetters { { '2' , \"abc\" }, { '3' , \"def\" }, { '4' , \"ghi\" }, { '5' , \"jkl\" }, { '6' , \"mno\" }, { '7' , \"pqrs\" }, { '8' , \"tuv\" }, { '9' , \"wxyz\" }}; for ( const char d : digits ) { vector < string > temp ; for ( const string & s : ans ) for ( const char c : digitToLetters . at ( d )) temp . push_back ( s + c ); swap ( ans , temp ); } return ans ; } };","title":"17. Letter Combinations of a Phone Number $\\star\\star$"},{"location":"cpp/0001-0100/0011-0020/#18-4sum-starstar","text":"Time: $O(n^3)$ Space: $O(1)$ class Solution { public : vector < vector < int >> fourSum ( vector < int >& nums , int target ) { vector < vector < int >> ans ; vector < int > path ; sort ( begin ( nums ), end ( nums )); nSum ( nums , target , 0 , nums . size () - 1 , 4 , path , ans ); return ans ; } private : void nSum ( vector < int >& nums , int target , int l , int r , int n , vector < int >& path , vector < vector < int >>& ans ) { if ( r - l + 1 < n || n < 2 || target < nums [ l ] * n || target > nums [ r ] * n ) return ; if ( n == 2 ) { while ( l < r ) { int sum = nums [ l ] + nums [ r ]; if ( sum == target ) { path . push_back ( nums [ l ]); path . push_back ( nums [ r ]); ans . push_back ( path ); path . pop_back (); path . pop_back (); ++ l ; while ( nums [ l ] == nums [ l - 1 ] && l < r ) ++ l ; } else if ( sum < target ) { ++ l ; } else { -- r ; } } return ; } for ( int i = l ; i <= r ; ++ i ) { if ( i > l && nums [ i ] == nums [ i - 1 ]) continue ; path . push_back ( nums [ i ]); nSum ( nums , target - nums [ i ], i + 1 , r , n - 1 , path , ans ); path . pop_back (); } } };","title":"18. 4Sum $\\star\\star$"},{"location":"cpp/0001-0100/0011-0020/#19-remove-nth-node-from-end-of-list-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : ListNode * removeNthFromEnd ( ListNode * head , int n ) { auto slow = head ; auto fast = head ; while ( n -- ) fast = fast -> next ; if ( ! fast ) return head -> next ; while ( fast -> next ) { slow = slow -> next ; fast = fast -> next ; } slow -> next = slow -> next -> next ; return head ; } };","title":"19. Remove Nth Node From End of List $\\star\\star$"},{"location":"cpp/0001-0100/0011-0020/#20-valid-parentheses-star","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : bool isValid ( string s ) { stack < char > stack ; for ( const char c : s ) if ( c == '(' || c == '{' || c == '[' ) stack . push ( c ); else { if ( stack . empty () || ( c == ')' && stack . top () != '(' ) || ( c == '}' && stack . top () != '{' ) || ( c == ']' && stack . top () != '[' )) return false ; stack . pop (); } return stack . empty (); } };","title":"20. Valid Parentheses $\\star$"},{"location":"cpp/0001-0100/0021-0030/","text":"21. Merge Two Sorted Lists $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : ListNode * mergeTwoLists ( ListNode * l1 , ListNode * l2 ) { if ( ! l1 || ! l2 ) return l1 ? l1 : l2 ; if ( l1 -> val > l2 -> val ) swap ( l1 , l2 ); l1 -> next = mergeTwoLists ( l1 -> next , l2 ); return l1 ; } }; 22. Generate Parentheses $\\star\\star$ Time: $O(2^{2n})$ Space: $O(n)$ class Solution { public : vector < string > generateParenthesis ( int n ) { vector < string > ans ; function < void ( const string & , int , int ) > helper = [ & ]( const string str , int l , int r ) { if ( l == 0 && r == 0 ) ans . push_back ( str ); if ( l > 0 ) helper ( str + '(' , l - 1 , r ); if ( l < r ) helper ( str + ')' , l , r - 1 ); }; helper ( \"\" , n , n ); return ans ; } }; 23. Merge k Sorted Lists $\\star\\star\\star$ Time: $O(n\\log k)$, where $n$ is # of nodes Space: $O(n)$ class Solution { public : ListNode * mergeKLists ( vector < ListNode *>& lists ) { ListNode dummy ( 0 ); ListNode * curr = & dummy ; auto compare = []( const ListNode * a , const ListNode * b ) { return a -> val > b -> val ; }; priority_queue < ListNode * , vector < ListNode *> , decltype ( compare ) > pq ( compare ); for ( ListNode * list : lists ) if ( list ) pq . push ( list ); while ( ! pq . empty ()) { curr -> next = pq . top (), pq . pop (); curr = curr -> next ; if ( curr -> next ) pq . push ( curr -> next ); } return dummy . next ; } }; 24. Swap Nodes in Pairs $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : ListNode * swapPairs ( ListNode * head ) { ListNode dummy ( 0 ); dummy . next = head ; int length = 0 ; for ( ListNode * curr = head ; curr ; curr = curr -> next ) ++ length ; ListNode * prev = & dummy ; ListNode * curr = head ; for ( int i = 0 ; i < length / 2 ; ++ i ) { ListNode * next = curr -> next ; curr -> next = next -> next ; next -> next = prev -> next ; prev -> next = next ; prev = curr ; curr = curr -> next ; } return dummy . next ; } }; 25. Reverse Nodes in k-Group $\\star\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : ListNode * reverseKGroup ( ListNode * head , int k ) { if ( ! head || k == 1 ) return head ; ListNode dummy ( 0 ); dummy . next = head ; int length = 0 ; for ( ListNode * curr = head ; curr ; curr = curr -> next ) ++ length ; ListNode * prev = & dummy ; ListNode * curr = head ; for ( int i = 0 ; i < length / k ; ++ i ) { for ( int j = 0 ; j < k - 1 ; ++ j ) { ListNode * next = curr -> next ; curr -> next = next -> next ; next -> next = prev -> next ; prev -> next = next ; } prev = curr ; curr = curr -> next ; } return dummy . next ; } }; 26. Remove Duplicates from Sorted Array $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : int removeDuplicates ( vector < int >& nums ) { int i = 0 ; for ( const int num : nums ) if ( i < 1 || num > nums [ i - 1 ]) nums [ i ++ ] = num ; return i ; } }; 27. Remove Element $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : int removeElement ( vector < int >& nums , int val ) { int i = 0 ; for ( const int num : nums ) if ( num != val ) nums [ i ++ ] = num ; return i ; } }; 28. Implement strStr() $\\star$ Time: $O((m - n)n)$, where m = len(haystack) and n = len(needle) Space: $O(1)$ class Solution { public : int strStr ( string haystack , string needle ) { const int m = haystack . length (); const int n = needle . length (); for ( int i = 0 ; i < m - n + 1 ; i ++ ) if ( haystack . substr ( i , n ) == needle ) return i ; return - 1 ; } }; 29. Divide Two Integers $\\star\\star$ Time: $O(\\log^2 n)$ Space: $O(1)$ class Solution { public : int divide ( int dividend , int divisor ) { if ( dividend == INT_MIN && divisor == - 1 ) return INT_MAX ; const int sign = dividend > 0 ^ divisor > 0 ? - 1 : 1 ; long ans = 0 ; long dvd = labs ( dividend ); long dvs = labs ( divisor ); while ( dvd >= dvs ) { long m = 1 ; long temp = dvs ; while ( temp << 1 <= dvd ) { m <<= 1 ; temp <<= 1 ; } dvd -= temp ; ans += m ; } return sign * ans ; } }; 30. Substring with Concatenation of All Words $\\star\\star\\star$ Time: $O(nk)$, where n = len(word) and k = len(s) Space: $O(n)$ class Solution { public : vector < int > findSubstring ( string s , vector < string >& words ) { if ( s . empty () || words . empty ()) return {}; const int n = words [ 0 ]. length (); vector < int > ans ; unordered_map < string , int > count ; for ( const string & word : words ) ++ count [ word ]; for ( int i = 0 ; i < s . length () - words . size () * n + 1 ; ++ i ) { unordered_map < string , int > seen ; int j ; for ( j = 0 ; j < words . size (); ++ j ) { const string word = s . substr ( i + j * n , n ); if ( ++ seen [ word ] > count [ word ]) break ; } if ( j == words . size ()) ans . push_back ( i ); } return ans ; } };","title":"0021-0030"},{"location":"cpp/0001-0100/0021-0030/#21-merge-two-sorted-lists-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : ListNode * mergeTwoLists ( ListNode * l1 , ListNode * l2 ) { if ( ! l1 || ! l2 ) return l1 ? l1 : l2 ; if ( l1 -> val > l2 -> val ) swap ( l1 , l2 ); l1 -> next = mergeTwoLists ( l1 -> next , l2 ); return l1 ; } };","title":"21. Merge Two Sorted Lists $\\star$"},{"location":"cpp/0001-0100/0021-0030/#22-generate-parentheses-starstar","text":"Time: $O(2^{2n})$ Space: $O(n)$ class Solution { public : vector < string > generateParenthesis ( int n ) { vector < string > ans ; function < void ( const string & , int , int ) > helper = [ & ]( const string str , int l , int r ) { if ( l == 0 && r == 0 ) ans . push_back ( str ); if ( l > 0 ) helper ( str + '(' , l - 1 , r ); if ( l < r ) helper ( str + ')' , l , r - 1 ); }; helper ( \"\" , n , n ); return ans ; } };","title":"22. Generate Parentheses $\\star\\star$"},{"location":"cpp/0001-0100/0021-0030/#23-merge-k-sorted-lists-starstarstar","text":"Time: $O(n\\log k)$, where $n$ is # of nodes Space: $O(n)$ class Solution { public : ListNode * mergeKLists ( vector < ListNode *>& lists ) { ListNode dummy ( 0 ); ListNode * curr = & dummy ; auto compare = []( const ListNode * a , const ListNode * b ) { return a -> val > b -> val ; }; priority_queue < ListNode * , vector < ListNode *> , decltype ( compare ) > pq ( compare ); for ( ListNode * list : lists ) if ( list ) pq . push ( list ); while ( ! pq . empty ()) { curr -> next = pq . top (), pq . pop (); curr = curr -> next ; if ( curr -> next ) pq . push ( curr -> next ); } return dummy . next ; } };","title":"23. Merge k Sorted Lists $\\star\\star\\star$"},{"location":"cpp/0001-0100/0021-0030/#24-swap-nodes-in-pairs-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : ListNode * swapPairs ( ListNode * head ) { ListNode dummy ( 0 ); dummy . next = head ; int length = 0 ; for ( ListNode * curr = head ; curr ; curr = curr -> next ) ++ length ; ListNode * prev = & dummy ; ListNode * curr = head ; for ( int i = 0 ; i < length / 2 ; ++ i ) { ListNode * next = curr -> next ; curr -> next = next -> next ; next -> next = prev -> next ; prev -> next = next ; prev = curr ; curr = curr -> next ; } return dummy . next ; } };","title":"24. Swap Nodes in Pairs $\\star\\star$"},{"location":"cpp/0001-0100/0021-0030/#25-reverse-nodes-in-k-group-starstarstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : ListNode * reverseKGroup ( ListNode * head , int k ) { if ( ! head || k == 1 ) return head ; ListNode dummy ( 0 ); dummy . next = head ; int length = 0 ; for ( ListNode * curr = head ; curr ; curr = curr -> next ) ++ length ; ListNode * prev = & dummy ; ListNode * curr = head ; for ( int i = 0 ; i < length / k ; ++ i ) { for ( int j = 0 ; j < k - 1 ; ++ j ) { ListNode * next = curr -> next ; curr -> next = next -> next ; next -> next = prev -> next ; prev -> next = next ; } prev = curr ; curr = curr -> next ; } return dummy . next ; } };","title":"25. Reverse Nodes in k-Group $\\star\\star\\star$"},{"location":"cpp/0001-0100/0021-0030/#26-remove-duplicates-from-sorted-array-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : int removeDuplicates ( vector < int >& nums ) { int i = 0 ; for ( const int num : nums ) if ( i < 1 || num > nums [ i - 1 ]) nums [ i ++ ] = num ; return i ; } };","title":"26. Remove Duplicates from Sorted Array $\\star$"},{"location":"cpp/0001-0100/0021-0030/#27-remove-element-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : int removeElement ( vector < int >& nums , int val ) { int i = 0 ; for ( const int num : nums ) if ( num != val ) nums [ i ++ ] = num ; return i ; } };","title":"27. Remove Element $\\star$"},{"location":"cpp/0001-0100/0021-0030/#28-implement-strstr-star","text":"Time: $O((m - n)n)$, where m = len(haystack) and n = len(needle) Space: $O(1)$ class Solution { public : int strStr ( string haystack , string needle ) { const int m = haystack . length (); const int n = needle . length (); for ( int i = 0 ; i < m - n + 1 ; i ++ ) if ( haystack . substr ( i , n ) == needle ) return i ; return - 1 ; } };","title":"28. Implement strStr() $\\star$"},{"location":"cpp/0001-0100/0021-0030/#29-divide-two-integers-starstar","text":"Time: $O(\\log^2 n)$ Space: $O(1)$ class Solution { public : int divide ( int dividend , int divisor ) { if ( dividend == INT_MIN && divisor == - 1 ) return INT_MAX ; const int sign = dividend > 0 ^ divisor > 0 ? - 1 : 1 ; long ans = 0 ; long dvd = labs ( dividend ); long dvs = labs ( divisor ); while ( dvd >= dvs ) { long m = 1 ; long temp = dvs ; while ( temp << 1 <= dvd ) { m <<= 1 ; temp <<= 1 ; } dvd -= temp ; ans += m ; } return sign * ans ; } };","title":"29. Divide Two Integers $\\star\\star$"},{"location":"cpp/0001-0100/0021-0030/#30-substring-with-concatenation-of-all-words-starstarstar","text":"Time: $O(nk)$, where n = len(word) and k = len(s) Space: $O(n)$ class Solution { public : vector < int > findSubstring ( string s , vector < string >& words ) { if ( s . empty () || words . empty ()) return {}; const int n = words [ 0 ]. length (); vector < int > ans ; unordered_map < string , int > count ; for ( const string & word : words ) ++ count [ word ]; for ( int i = 0 ; i < s . length () - words . size () * n + 1 ; ++ i ) { unordered_map < string , int > seen ; int j ; for ( j = 0 ; j < words . size (); ++ j ) { const string word = s . substr ( i + j * n , n ); if ( ++ seen [ word ] > count [ word ]) break ; } if ( j == words . size ()) ans . push_back ( i ); } return ans ; } };","title":"30. Substring with Concatenation of All Words $\\star\\star\\star$"},{"location":"cpp/0001-0100/0031-0040/","text":"31. Next Permutation $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : void nextPermutation ( vector < int >& nums ) { int i ; for ( i = nums . size () - 2 ; i >= 0 ; -- i ) if ( nums [ i ] < nums [ i + 1 ]) break ; if ( i >= 0 ) { int j ; for ( j = nums . size () - 1 ; j > i ; -- j ) if ( nums [ j ] > nums [ i ]) break ; swap ( nums [ i ], nums [ j ]); } reverse ( nums , i + 1 , nums . size () - 1 ); } private : void reverse ( vector < int >& nums , int l , int r ) { while ( l < r ) swap ( nums [ l ++ ], nums [ r -- ]); } }; 32. Longest Valid Parentheses $\\star\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : int longestValidParentheses ( string s ) { int ans = 0 ; s = \")\" + s ; vector < int > dp ( s . length ()); for ( int i = 1 ; i < s . length (); ++ i ) if ( s [ i ] == ')' && s [ i - dp [ i - 1 ] - 1 ] == '(' ) { dp [ i ] = dp [ i - 1 ] + dp [ i - dp [ i - 1 ] - 2 ] + 2 ; ans = max ( ans , dp [ i ]); } return ans ; } }; 33. Search in Rotated Sorted Array $\\star\\star$ Time: $O(\\log n)$ Space: $O(1)$ class Solution { public : int search ( vector < int >& nums , int target ) { int l = 0 ; int r = nums . size () - 1 ; while ( l <= r ) { const int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return m ; if ( nums [ l ] <= nums [ m ]) { if ( nums [ l ] <= target && target < nums [ m ]) r = m - 1 ; else l = m + 1 ; } else { if ( nums [ m ] < target && target <= nums [ r ]) l = m + 1 ; else r = m - 1 ; } } return - 1 ; } }; 34. Find First and Last Position of Element in Sorted Array $\\star\\star$ Time: $O(\\log n)$ Space: $O(1)$ class Solution { public : vector < int > searchRange ( vector < int >& nums , int target ) { const int leftIndex = find ( nums , target , true ); if ( leftIndex == nums . size () || nums [ leftIndex ] != target ) return { - 1 , - 1 }; return { leftIndex , find ( nums , target , false ) - 1 }; } private : int find ( vector < int >& nums , int target , bool isLeft ) { int l = 0 ; int r = nums . size (); while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( nums [ m ] > target || ( isLeft && nums [ m ] == target )) r = m ; else l = m + 1 ; } return l ; } }; 35. Search Insert Position $\\star$ Time: $O(\\log n)$ Space: $O(1)$ class Solution { public : int searchInsert ( vector < int >& nums , int target ) { int l = 0 ; int r = nums . size (); while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return m ; if ( nums [ m ] < target ) l = m + 1 ; else r = m ; } return l ; } }; 36. Valid Sudoku $\\star\\star$ Time: $O(1)$ Space: $O(1)$ class Solution { public : bool isValidSudoku ( vector < vector < char >>& board ) { unordered_set < string > seen ; for ( int i = 0 ; i < 9 ; ++ i ) for ( int j = 0 ; j < 9 ; ++ j ) { const string c ( 1 , board [ i ][ j ]); if ( c == \".\" ) continue ; if ( ! seen . insert ( c + \"@row\" + to_string ( i )). second || ! seen . insert ( c + \"@col\" + to_string ( j )). second || ! seen . insert ( c + \"@box\" + to_string ( i / 3 ) + to_string ( j / 3 )) . second ) return false ; } return true ; } }; 37. Sudoku Solver $\\star\\star\\star$ Time: NP-Complete Space: $O(1)$ class Solution { public : void solveSudoku ( vector < vector < char >>& board ) { function < bool ( int ) > dfs = [ & ]( int s ) { if ( s == 81 ) return true ; const int i = s / 9 ; const int j = s % 9 ; if ( board [ i ][ j ] != '.' ) return dfs ( s + 1 ); for ( char c = '1' ; c <= '9' ; ++ c ) if ( isValid ( board , i , j , c )) { board [ i ][ j ] = c ; if ( dfs ( s + 1 )) return true ; board [ i ][ j ] = '.' ; } return false ; }; dfs ( 0 ); } private : bool isValid ( vector < vector < char >>& board , int row , int col , char c ) { for ( int i = 0 ; i < 9 ; ++ i ) if ( board [ i ][ col ] == c || board [ row ][ i ] == c || board [ 3 * ( row / 3 ) + i / 3 ][ 3 * ( col / 3 ) + i % 3 ] == c ) return false ; return true ; } }; 38. Count and Say $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : string countAndSay ( int n ) { if ( n == 0 ) return \"\" ; string ans = \"1\" ; while ( -- n ) { string next ; for ( int i = 0 ; i < ans . size (); ++ i ) { int count = 1 ; while ( i + 1 < ans . size () && ans [ i ] == ans [ i + 1 ]) { ++ count ; ++ i ; } next += to_string ( count ) + ans [ i ]; } swap ( ans , next ); } return ans ; } }; 39. Combination Sum $\\star\\star$ Time: $O(n^{target})$, where n = len(candidates) Space: $O(target)$ class Solution { public : vector < vector < int >> combinationSum ( vector < int >& candidates , int target ) { vector < vector < int >> ans ; vector < int > path ; function < void ( int , int ) > dfs = [ & ]( int target , int s ) { if ( target < 0 ) return ; if ( target == 0 ) { ans . push_back ( path ); return ; } for ( int i = s ; i < candidates . size (); ++ i ) { path . push_back ( candidates [ i ]); dfs ( target - candidates [ i ], i ); path . pop_back (); } }; sort ( begin ( candidates ), end ( candidates )); dfs ( target , 0 ); return ans ; } }; 40. Combination Sum II $\\star\\star$ Time: $O(2^n)$ Space: $O(n)$ class Solution { public : vector < vector < int >> combinationSum2 ( vector < int >& candidates , int target ) { vector < vector < int >> ans ; vector < int > path ; function < void ( int , int ) > dfs = [ & ]( int target , int s ) { if ( target < 0 ) return ; if ( target == 0 ) { ans . push_back ( path ); return ; } for ( int i = s ; i < candidates . size (); ++ i ) { if ( i > s && candidates [ i ] == candidates [ i - 1 ]) continue ; path . push_back ( candidates [ i ]); dfs ( target - candidates [ i ], i + 1 ); path . pop_back (); } }; sort ( begin ( candidates ), end ( candidates )); dfs ( target , 0 ); return ans ; } };","title":"0031-0040"},{"location":"cpp/0001-0100/0031-0040/#31-next-permutation-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : void nextPermutation ( vector < int >& nums ) { int i ; for ( i = nums . size () - 2 ; i >= 0 ; -- i ) if ( nums [ i ] < nums [ i + 1 ]) break ; if ( i >= 0 ) { int j ; for ( j = nums . size () - 1 ; j > i ; -- j ) if ( nums [ j ] > nums [ i ]) break ; swap ( nums [ i ], nums [ j ]); } reverse ( nums , i + 1 , nums . size () - 1 ); } private : void reverse ( vector < int >& nums , int l , int r ) { while ( l < r ) swap ( nums [ l ++ ], nums [ r -- ]); } };","title":"31. Next Permutation $\\star\\star$"},{"location":"cpp/0001-0100/0031-0040/#32-longest-valid-parentheses-starstarstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : int longestValidParentheses ( string s ) { int ans = 0 ; s = \")\" + s ; vector < int > dp ( s . length ()); for ( int i = 1 ; i < s . length (); ++ i ) if ( s [ i ] == ')' && s [ i - dp [ i - 1 ] - 1 ] == '(' ) { dp [ i ] = dp [ i - 1 ] + dp [ i - dp [ i - 1 ] - 2 ] + 2 ; ans = max ( ans , dp [ i ]); } return ans ; } };","title":"32. Longest Valid Parentheses $\\star\\star\\star$"},{"location":"cpp/0001-0100/0031-0040/#33-search-in-rotated-sorted-array-starstar","text":"Time: $O(\\log n)$ Space: $O(1)$ class Solution { public : int search ( vector < int >& nums , int target ) { int l = 0 ; int r = nums . size () - 1 ; while ( l <= r ) { const int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return m ; if ( nums [ l ] <= nums [ m ]) { if ( nums [ l ] <= target && target < nums [ m ]) r = m - 1 ; else l = m + 1 ; } else { if ( nums [ m ] < target && target <= nums [ r ]) l = m + 1 ; else r = m - 1 ; } } return - 1 ; } };","title":"33. Search in Rotated Sorted Array $\\star\\star$"},{"location":"cpp/0001-0100/0031-0040/#34-find-first-and-last-position-of-element-in-sorted-array-starstar","text":"Time: $O(\\log n)$ Space: $O(1)$ class Solution { public : vector < int > searchRange ( vector < int >& nums , int target ) { const int leftIndex = find ( nums , target , true ); if ( leftIndex == nums . size () || nums [ leftIndex ] != target ) return { - 1 , - 1 }; return { leftIndex , find ( nums , target , false ) - 1 }; } private : int find ( vector < int >& nums , int target , bool isLeft ) { int l = 0 ; int r = nums . size (); while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( nums [ m ] > target || ( isLeft && nums [ m ] == target )) r = m ; else l = m + 1 ; } return l ; } };","title":"34. Find First and Last Position of Element in Sorted Array $\\star\\star$"},{"location":"cpp/0001-0100/0031-0040/#35-search-insert-position-star","text":"Time: $O(\\log n)$ Space: $O(1)$ class Solution { public : int searchInsert ( vector < int >& nums , int target ) { int l = 0 ; int r = nums . size (); while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return m ; if ( nums [ m ] < target ) l = m + 1 ; else r = m ; } return l ; } };","title":"35. Search Insert Position $\\star$"},{"location":"cpp/0001-0100/0031-0040/#36-valid-sudoku-starstar","text":"Time: $O(1)$ Space: $O(1)$ class Solution { public : bool isValidSudoku ( vector < vector < char >>& board ) { unordered_set < string > seen ; for ( int i = 0 ; i < 9 ; ++ i ) for ( int j = 0 ; j < 9 ; ++ j ) { const string c ( 1 , board [ i ][ j ]); if ( c == \".\" ) continue ; if ( ! seen . insert ( c + \"@row\" + to_string ( i )). second || ! seen . insert ( c + \"@col\" + to_string ( j )). second || ! seen . insert ( c + \"@box\" + to_string ( i / 3 ) + to_string ( j / 3 )) . second ) return false ; } return true ; } };","title":"36. Valid Sudoku $\\star\\star$"},{"location":"cpp/0001-0100/0031-0040/#37-sudoku-solver-starstarstar","text":"Time: NP-Complete Space: $O(1)$ class Solution { public : void solveSudoku ( vector < vector < char >>& board ) { function < bool ( int ) > dfs = [ & ]( int s ) { if ( s == 81 ) return true ; const int i = s / 9 ; const int j = s % 9 ; if ( board [ i ][ j ] != '.' ) return dfs ( s + 1 ); for ( char c = '1' ; c <= '9' ; ++ c ) if ( isValid ( board , i , j , c )) { board [ i ][ j ] = c ; if ( dfs ( s + 1 )) return true ; board [ i ][ j ] = '.' ; } return false ; }; dfs ( 0 ); } private : bool isValid ( vector < vector < char >>& board , int row , int col , char c ) { for ( int i = 0 ; i < 9 ; ++ i ) if ( board [ i ][ col ] == c || board [ row ][ i ] == c || board [ 3 * ( row / 3 ) + i / 3 ][ 3 * ( col / 3 ) + i % 3 ] == c ) return false ; return true ; } };","title":"37. Sudoku Solver $\\star\\star\\star$"},{"location":"cpp/0001-0100/0031-0040/#38-count-and-say-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : string countAndSay ( int n ) { if ( n == 0 ) return \"\" ; string ans = \"1\" ; while ( -- n ) { string next ; for ( int i = 0 ; i < ans . size (); ++ i ) { int count = 1 ; while ( i + 1 < ans . size () && ans [ i ] == ans [ i + 1 ]) { ++ count ; ++ i ; } next += to_string ( count ) + ans [ i ]; } swap ( ans , next ); } return ans ; } };","title":"38. Count and Say $\\star$"},{"location":"cpp/0001-0100/0031-0040/#39-combination-sum-starstar","text":"Time: $O(n^{target})$, where n = len(candidates) Space: $O(target)$ class Solution { public : vector < vector < int >> combinationSum ( vector < int >& candidates , int target ) { vector < vector < int >> ans ; vector < int > path ; function < void ( int , int ) > dfs = [ & ]( int target , int s ) { if ( target < 0 ) return ; if ( target == 0 ) { ans . push_back ( path ); return ; } for ( int i = s ; i < candidates . size (); ++ i ) { path . push_back ( candidates [ i ]); dfs ( target - candidates [ i ], i ); path . pop_back (); } }; sort ( begin ( candidates ), end ( candidates )); dfs ( target , 0 ); return ans ; } };","title":"39. Combination Sum $\\star\\star$"},{"location":"cpp/0001-0100/0031-0040/#40-combination-sum-ii-starstar","text":"Time: $O(2^n)$ Space: $O(n)$ class Solution { public : vector < vector < int >> combinationSum2 ( vector < int >& candidates , int target ) { vector < vector < int >> ans ; vector < int > path ; function < void ( int , int ) > dfs = [ & ]( int target , int s ) { if ( target < 0 ) return ; if ( target == 0 ) { ans . push_back ( path ); return ; } for ( int i = s ; i < candidates . size (); ++ i ) { if ( i > s && candidates [ i ] == candidates [ i - 1 ]) continue ; path . push_back ( candidates [ i ]); dfs ( target - candidates [ i ], i + 1 ); path . pop_back (); } }; sort ( begin ( candidates ), end ( candidates )); dfs ( target , 0 ); return ans ; } };","title":"40. Combination Sum II $\\star\\star$"},{"location":"cpp/0001-0100/0041-0050/","text":"41. First Missing Positive $\\star\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : int firstMissingPositive ( vector < int >& nums ) { const int n = nums . size (); for ( int i = 0 ; i < n ; ++ i ) while ( nums [ i ] > 0 && nums [ i ] <= n && nums [ i ] != nums [ nums [ i ] - 1 ]) swap ( nums [ i ], nums [ nums [ i ] - 1 ]); for ( int i = 0 ; i < n ; ++ i ) if ( nums [ i ] != i + 1 ) return i + 1 ; return n + 1 ; } }; 42. Trapping Rain Water $\\star\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : int trap ( vector < int >& height ) { if ( height . empty ()) return 0 ; int ans = 0 ; int l = 0 ; int r = height . size () - 1 ; int maxL = height [ l ]; int maxR = height [ r ]; while ( l < r ) if ( maxL < maxR ) { ans += maxL - height [ l ]; maxL = max ( maxL , height [ ++ l ]); } else { ans += maxR - height [ r ]; maxR = max ( maxR , height [ -- r ]); } return ans ; } }; 43. Multiply Strings $\\star\\star$ Time: $O(mn)$, where m = len(num1) and n = len(num2) Space: $O(m + n)$ class Solution { public : string multiply ( string num1 , string num2 ) { string ans ; vector < int > pos ( num1 . length () + num2 . length ()); for ( int i = num1 . length () - 1 ; i >= 0 ; -- i ) for ( int j = num2 . length () - 1 ; j >= 0 ; -- j ) { const int multiply = ( num1 [ i ] - '0' ) * ( num2 [ j ] - '0' ); const int sum = multiply + pos [ i + j + 1 ]; pos [ i + j ] += sum / 10 ; pos [ i + j + 1 ] = sum % 10 ; } for ( const int p : pos ) if ( p > 0 || ! ans . empty ()) ans += to_string ( p ); return ans . empty () ? \"0\" : ans ; } }; 44. Wildcard Matching $\\star\\star\\star$ Time: $O(mn)$, where m = len(s) and n = len(p) Space: $O(mn)$ class Solution { public : bool isMatch ( string s , string p ) { const int m = s . length (); const int n = p . length (); vector < vector < bool >> dp ( m + 1 , vector < bool > ( n + 1 )); for ( int i = 0 ; i <= m ; ++ i ) for ( int j = 0 ; j <= n ; ++ j ) if ( i == 0 && j == 0 ) dp [ i ][ j ] = true ; else if ( i == 0 ) dp [ i ][ j ] = p [ j - 1 ] == '*' && dp [ i ][ j - 1 ]; else if ( j == 0 ) dp [ i ][ j ] = false ; else { if ( s [ i - 1 ] == p [ j - 1 ] || p [ j - 1 ] == '?' ) dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ]; else if ( p [ j - 1 ] == '*' ) dp [ i ][ j ] = dp [ i - 1 ][ j ] || dp [ i ][ j - 1 ]; else dp [ i ][ j ] = false ; } return dp [ m ][ n ]; } }; 45. Jump Game II $\\star\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : int jump ( vector < int >& nums ) { int ans = 0 ; int end = 0 ; int farthest = 0 ; for ( int i = 0 ; i + 1 < nums . size (); ++ i ) { farthest = max ( farthest , i + nums [ i ]); if ( i == end ) { ++ ans ; end = farthest ; } } return ans ; } }; 46. Permutations $\\star\\star$ Time: $O(n!)$ Space: $O(n)$ class Solution { public : vector < vector < int >> permute ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; vector < bool > used ( nums . size (), false ); function < void () > dfs = [ & ]() { if ( path . size () == nums . size ()) { ans . push_back ( path ); return ; } for ( int i = 0 ; i < nums . size (); ++ i ) { if ( used [ i ]) continue ; used [ i ] = true ; path . push_back ( nums [ i ]); dfs (); used [ i ] = false ; path . pop_back (); } }; dfs (); return ans ; } }; 47. Permutations II $\\star\\star$ Time: $O(n!)$ Space: $O(n)$ class Solution { public : vector < vector < int >> permuteUnique ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; vector < bool > used ( nums . size (), false ); function < void () > dfs = [ & ]() { if ( path . size () == nums . size ()) { ans . push_back ( path ); return ; } for ( int i = 0 ; i < nums . size (); ++ i ) { if ( used [ i ]) continue ; if ( i > 0 && nums [ i ] == nums [ i - 1 ] && ! used [ i - 1 ]) continue ; used [ i ] = true ; path . push_back ( nums [ i ]); dfs (); path . pop_back (); used [ i ] = false ; } }; sort ( begin ( nums ), end ( nums )); dfs (); return ans ; } }; 48. Rotate Image $\\star\\star$ Time: $O(n^2)$ Space: $O(1)$ class Solution { public : void rotate ( vector < vector < int >>& matrix ) { for ( int min = 0 ; min < matrix . size () / 2 ; ++ min ) { int max = matrix . size () - min - 1 ; for ( int i = min ; i < max ; ++ i ) { const int offset = i - min ; const int top = matrix [ min ][ i ]; matrix [ min ][ i ] = matrix [ max - offset ][ min ]; matrix [ max - offset ][ min ] = matrix [ max ][ max - offset ]; matrix [ max ][ max - offset ] = matrix [ i ][ max ]; matrix [ i ][ max ] = top ; } } } }; 49. Group Anagrams $\\star\\star$ Time: $O(n\\log k)$, where n = len(strs) and k = len(strs[i]) Space: $O(n)$ class Solution { public : vector < vector < string >> groupAnagrams ( vector < string >& strs ) { vector < vector < string >> ans ; unordered_map < string , vector < string >> map ; for ( const string & str : strs ) { string s = str ; sort ( begin ( s ), end ( s )); map [ s ]. push_back ( str ); } for ( const auto & [ _ , value ] : map ) ans . push_back ( value ); return ans ; } }; 50. Pow(x, n) $\\star\\star$ Time: $O(\\log n)$ Space: $O(1)$ class Solution { public : double myPow ( double x , long n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 1 / myPow ( x , - n ); if ( n % 2 ) return x * myPow ( x , n - 1 ); return myPow ( x * x , n / 2 ); } };","title":"0041-0050"},{"location":"cpp/0001-0100/0041-0050/#41-first-missing-positive-starstarstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : int firstMissingPositive ( vector < int >& nums ) { const int n = nums . size (); for ( int i = 0 ; i < n ; ++ i ) while ( nums [ i ] > 0 && nums [ i ] <= n && nums [ i ] != nums [ nums [ i ] - 1 ]) swap ( nums [ i ], nums [ nums [ i ] - 1 ]); for ( int i = 0 ; i < n ; ++ i ) if ( nums [ i ] != i + 1 ) return i + 1 ; return n + 1 ; } };","title":"41. First Missing Positive $\\star\\star\\star$"},{"location":"cpp/0001-0100/0041-0050/#42-trapping-rain-water-starstarstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : int trap ( vector < int >& height ) { if ( height . empty ()) return 0 ; int ans = 0 ; int l = 0 ; int r = height . size () - 1 ; int maxL = height [ l ]; int maxR = height [ r ]; while ( l < r ) if ( maxL < maxR ) { ans += maxL - height [ l ]; maxL = max ( maxL , height [ ++ l ]); } else { ans += maxR - height [ r ]; maxR = max ( maxR , height [ -- r ]); } return ans ; } };","title":"42. Trapping Rain Water $\\star\\star\\star$"},{"location":"cpp/0001-0100/0041-0050/#43-multiply-strings-starstar","text":"Time: $O(mn)$, where m = len(num1) and n = len(num2) Space: $O(m + n)$ class Solution { public : string multiply ( string num1 , string num2 ) { string ans ; vector < int > pos ( num1 . length () + num2 . length ()); for ( int i = num1 . length () - 1 ; i >= 0 ; -- i ) for ( int j = num2 . length () - 1 ; j >= 0 ; -- j ) { const int multiply = ( num1 [ i ] - '0' ) * ( num2 [ j ] - '0' ); const int sum = multiply + pos [ i + j + 1 ]; pos [ i + j ] += sum / 10 ; pos [ i + j + 1 ] = sum % 10 ; } for ( const int p : pos ) if ( p > 0 || ! ans . empty ()) ans += to_string ( p ); return ans . empty () ? \"0\" : ans ; } };","title":"43. Multiply Strings $\\star\\star$"},{"location":"cpp/0001-0100/0041-0050/#44-wildcard-matching-starstarstar","text":"Time: $O(mn)$, where m = len(s) and n = len(p) Space: $O(mn)$ class Solution { public : bool isMatch ( string s , string p ) { const int m = s . length (); const int n = p . length (); vector < vector < bool >> dp ( m + 1 , vector < bool > ( n + 1 )); for ( int i = 0 ; i <= m ; ++ i ) for ( int j = 0 ; j <= n ; ++ j ) if ( i == 0 && j == 0 ) dp [ i ][ j ] = true ; else if ( i == 0 ) dp [ i ][ j ] = p [ j - 1 ] == '*' && dp [ i ][ j - 1 ]; else if ( j == 0 ) dp [ i ][ j ] = false ; else { if ( s [ i - 1 ] == p [ j - 1 ] || p [ j - 1 ] == '?' ) dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ]; else if ( p [ j - 1 ] == '*' ) dp [ i ][ j ] = dp [ i - 1 ][ j ] || dp [ i ][ j - 1 ]; else dp [ i ][ j ] = false ; } return dp [ m ][ n ]; } };","title":"44. Wildcard Matching $\\star\\star\\star$"},{"location":"cpp/0001-0100/0041-0050/#45-jump-game-ii-starstarstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : int jump ( vector < int >& nums ) { int ans = 0 ; int end = 0 ; int farthest = 0 ; for ( int i = 0 ; i + 1 < nums . size (); ++ i ) { farthest = max ( farthest , i + nums [ i ]); if ( i == end ) { ++ ans ; end = farthest ; } } return ans ; } };","title":"45. Jump Game II $\\star\\star\\star$"},{"location":"cpp/0001-0100/0041-0050/#46-permutations-starstar","text":"Time: $O(n!)$ Space: $O(n)$ class Solution { public : vector < vector < int >> permute ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; vector < bool > used ( nums . size (), false ); function < void () > dfs = [ & ]() { if ( path . size () == nums . size ()) { ans . push_back ( path ); return ; } for ( int i = 0 ; i < nums . size (); ++ i ) { if ( used [ i ]) continue ; used [ i ] = true ; path . push_back ( nums [ i ]); dfs (); used [ i ] = false ; path . pop_back (); } }; dfs (); return ans ; } };","title":"46. Permutations $\\star\\star$"},{"location":"cpp/0001-0100/0041-0050/#47-permutations-ii-starstar","text":"Time: $O(n!)$ Space: $O(n)$ class Solution { public : vector < vector < int >> permuteUnique ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; vector < bool > used ( nums . size (), false ); function < void () > dfs = [ & ]() { if ( path . size () == nums . size ()) { ans . push_back ( path ); return ; } for ( int i = 0 ; i < nums . size (); ++ i ) { if ( used [ i ]) continue ; if ( i > 0 && nums [ i ] == nums [ i - 1 ] && ! used [ i - 1 ]) continue ; used [ i ] = true ; path . push_back ( nums [ i ]); dfs (); path . pop_back (); used [ i ] = false ; } }; sort ( begin ( nums ), end ( nums )); dfs (); return ans ; } };","title":"47. Permutations II $\\star\\star$"},{"location":"cpp/0001-0100/0041-0050/#48-rotate-image-starstar","text":"Time: $O(n^2)$ Space: $O(1)$ class Solution { public : void rotate ( vector < vector < int >>& matrix ) { for ( int min = 0 ; min < matrix . size () / 2 ; ++ min ) { int max = matrix . size () - min - 1 ; for ( int i = min ; i < max ; ++ i ) { const int offset = i - min ; const int top = matrix [ min ][ i ]; matrix [ min ][ i ] = matrix [ max - offset ][ min ]; matrix [ max - offset ][ min ] = matrix [ max ][ max - offset ]; matrix [ max ][ max - offset ] = matrix [ i ][ max ]; matrix [ i ][ max ] = top ; } } } };","title":"48. Rotate Image $\\star\\star$"},{"location":"cpp/0001-0100/0041-0050/#49-group-anagrams-starstar","text":"Time: $O(n\\log k)$, where n = len(strs) and k = len(strs[i]) Space: $O(n)$ class Solution { public : vector < vector < string >> groupAnagrams ( vector < string >& strs ) { vector < vector < string >> ans ; unordered_map < string , vector < string >> map ; for ( const string & str : strs ) { string s = str ; sort ( begin ( s ), end ( s )); map [ s ]. push_back ( str ); } for ( const auto & [ _ , value ] : map ) ans . push_back ( value ); return ans ; } };","title":"49. Group Anagrams $\\star\\star$"},{"location":"cpp/0001-0100/0041-0050/#50-powx-n-starstar","text":"Time: $O(\\log n)$ Space: $O(1)$ class Solution { public : double myPow ( double x , long n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 1 / myPow ( x , - n ); if ( n % 2 ) return x * myPow ( x , n - 1 ); return myPow ( x * x , n / 2 ); } };","title":"50. Pow(x, n) $\\star\\star$"},{"location":"cpp/0001-0100/0051-0060/","text":"51. N-Queens $\\star\\star\\star$ Time: $O(n^n)$ Space: $O(n)$ class Solution { public : vector < vector < string >> solveNQueens ( int n ) { vector < vector < string >> ans ; vector < string > board ( n , string ( n , '.' )); vector < bool > cols ( n ); vector < bool > diag1 ( 2 * n - 1 ); vector < bool > diag2 ( 2 * n - 1 ); function < void ( int ) > dfs = [ & ]( int i ) { if ( i == n ) { ans . push_back ( board ); return ; } for ( int j = 0 ; j < n ; ++ j ) { if ( cols [ j ] || diag1 [ i + j ] || diag2 [ j - i + n - 1 ]) continue ; board [ i ][ j ] = 'Q' ; cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + n - 1 ] = true ; dfs ( i + 1 ); cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + n - 1 ] = false ; board [ i ][ j ] = '.' ; } }; dfs ( 0 ); return ans ; } }; 52. N-Queens II $\\star\\star\\star$ Time: $O(n^n)$ Space: $O(n)$ class Solution { public : int totalNQueens ( int n ) { int ans = 0 ; vector < bool > cols ( n ); vector < bool > diag1 ( 2 * n - 1 ); vector < bool > diag2 ( 2 * n - 1 ); function < void ( int ) > dfs = [ & ]( int i ) { if ( i == n ) { ++ ans ; return ; } for ( int j = 0 ; j < n ; ++ j ) { if ( cols [ j ] || diag1 [ i + j ] || diag2 [ j - i + n - 1 ]) continue ; cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + n - 1 ] = true ; dfs ( i + 1 ); cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + n - 1 ] = false ; } }; dfs ( 0 ); return ans ; } }; 53. Maximum Subarray $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : int maxSubArray ( vector < int >& nums ) { int ans = INT_MIN ; int sum = 0 ; for ( const int num : nums ) { sum += num ; ans = max ( ans , sum ); sum = max ( sum , 0 ); } return ans ; } }; 54. Spiral Matrix $\\star\\star$ Time: $O(mn)$ Space: $O(1)$ class Solution { public : vector < int > spiralOrder ( vector < vector < int >>& matrix ) { if ( matrix . empty ()) return {}; vector < int > ans ; int r1 = 0 ; int c1 = 0 ; int r2 = matrix . size () - 1 ; int c2 = matrix [ 0 ]. size () - 1 ; while ( r1 <= r2 && c1 <= c2 ) { for ( int c = c1 ; c <= c2 ; ++ c ) ans . push_back ( matrix [ r1 ][ c ]); for ( int r = r1 + 1 ; r <= r2 ; ++ r ) ans . push_back ( matrix [ r ][ c2 ]); if ( r1 < r2 && c1 < c2 ) { for ( int c = c2 - 1 ; c > c1 ; -- c ) ans . push_back ( matrix [ r2 ][ c ]); for ( int r = r2 ; r > r1 ; -- r ) ans . push_back ( matrix [ r ][ c1 ]); } ++ r1 ; ++ c1 ; -- r2 ; -- c2 ; } return ans ; } }; 55. Jump Game $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : bool canJump ( vector < int >& nums ) { int goal = nums . size () - 1 ; for ( int i = goal ; i >= 0 ; -- i ) if ( i + nums [ i ] >= goal ) goal = i ; return goal == 0 ; } }; 56. Merge Intervals $\\star\\star$ Time: $O(n\\log n)$ Space: $O(1)$ class Solution { public : vector < vector < int >> merge ( vector < vector < int >>& intervals ) { vector < vector < int >> ans ; sort ( begin ( intervals ), end ( intervals ), []( const auto & a , const auto & b ) { return a [ 0 ] < b [ 0 ]; }); for ( const vector < int >& interval : intervals ) if ( ans . empty () || interval [ 0 ] > ans . back ()[ 1 ]) ans . push_back ( interval ); else ans . back ()[ 1 ] = max ( ans . back ()[ 1 ], interval [ 1 ]); return ans ; } }; 57. Insert Interval $\\star\\star\\star$ Time: $O(n\\log n)$ Space: $O(1)$ class Solution { public : vector < vector < int >> insert ( vector < vector < int >>& intervals , vector < int >& newInterval ) { vector < vector < int >> ans ; auto it = begin ( intervals ); for (; it != end ( intervals ); ++ it ) if (( * it )[ 0 ] >= newInterval [ 0 ]) break ; intervals . insert ( it , newInterval ); for ( const vector < int >& interval : intervals ) if ( ans . empty () || interval [ 0 ] > ans . back ()[ 1 ]) ans . push_back ( interval ); else ans . back ()[ 1 ] = max ( ans . back ()[ 1 ], interval [ 1 ]); return ans ; } }; 58. Length of Last Word $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : int lengthOfLastWord ( string s ) { int ans = 0 ; int i = s . size () - 1 ; while ( i >= 0 && s [ i ] == ' ' ) -- i ; while ( i >= 0 && s [ i ] != ' ' ) { -- i ; ++ ans ; } return ans ; } }; 59. Spiral Matrix II $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : vector < vector < int >> generateMatrix ( int n ) { vector < vector < int >> ans ( n , vector < int > ( n )); int count = 1 ; for ( int min = 0 , max = n - min - 1 ; min < n / 2 ; ++ min , -- max ) { for ( int i = min ; i < max ; ++ i ) ans [ min ][ i ] = count ++ ; for ( int i = min ; i < max ; ++ i ) ans [ i ][ max ] = count ++ ; for ( int i = max ; i > min ; -- i ) ans [ max ][ i ] = count ++ ; for ( int i = max ; i > min ; -- i ) ans [ i ][ min ] = count ++ ; } if ( n & 1 ) ans [ n / 2 ][ n / 2 ] = count ; return ans ; } }; 60. Permutation Sequence $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : string getPermutation ( int n , int k ) { string ans ; vector < int > nums ( n ); vector < int > factorial ( n , 1 ); for ( int i = 0 ; i < n ; ++ i ) nums [ i ] = i + 1 ; for ( int i = 1 ; i < n ; ++ i ) factorial [ i ] = factorial [ i - 1 ] * i ; -- k ; for ( int i = n ; i >= 1 ; -- i ) { const int j = k / factorial [ i - 1 ]; k %= factorial [ i - 1 ]; ans . append ( to_string ( nums [ j ])); nums . erase ( begin ( nums ) + j ); } return ans ; } };","title":"0051-0060"},{"location":"cpp/0001-0100/0051-0060/#51-n-queens-starstarstar","text":"Time: $O(n^n)$ Space: $O(n)$ class Solution { public : vector < vector < string >> solveNQueens ( int n ) { vector < vector < string >> ans ; vector < string > board ( n , string ( n , '.' )); vector < bool > cols ( n ); vector < bool > diag1 ( 2 * n - 1 ); vector < bool > diag2 ( 2 * n - 1 ); function < void ( int ) > dfs = [ & ]( int i ) { if ( i == n ) { ans . push_back ( board ); return ; } for ( int j = 0 ; j < n ; ++ j ) { if ( cols [ j ] || diag1 [ i + j ] || diag2 [ j - i + n - 1 ]) continue ; board [ i ][ j ] = 'Q' ; cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + n - 1 ] = true ; dfs ( i + 1 ); cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + n - 1 ] = false ; board [ i ][ j ] = '.' ; } }; dfs ( 0 ); return ans ; } };","title":"51. N-Queens $\\star\\star\\star$"},{"location":"cpp/0001-0100/0051-0060/#52-n-queens-ii-starstarstar","text":"Time: $O(n^n)$ Space: $O(n)$ class Solution { public : int totalNQueens ( int n ) { int ans = 0 ; vector < bool > cols ( n ); vector < bool > diag1 ( 2 * n - 1 ); vector < bool > diag2 ( 2 * n - 1 ); function < void ( int ) > dfs = [ & ]( int i ) { if ( i == n ) { ++ ans ; return ; } for ( int j = 0 ; j < n ; ++ j ) { if ( cols [ j ] || diag1 [ i + j ] || diag2 [ j - i + n - 1 ]) continue ; cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + n - 1 ] = true ; dfs ( i + 1 ); cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + n - 1 ] = false ; } }; dfs ( 0 ); return ans ; } };","title":"52. N-Queens II $\\star\\star\\star$"},{"location":"cpp/0001-0100/0051-0060/#53-maximum-subarray-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : int maxSubArray ( vector < int >& nums ) { int ans = INT_MIN ; int sum = 0 ; for ( const int num : nums ) { sum += num ; ans = max ( ans , sum ); sum = max ( sum , 0 ); } return ans ; } };","title":"53. Maximum Subarray $\\star$"},{"location":"cpp/0001-0100/0051-0060/#54-spiral-matrix-starstar","text":"Time: $O(mn)$ Space: $O(1)$ class Solution { public : vector < int > spiralOrder ( vector < vector < int >>& matrix ) { if ( matrix . empty ()) return {}; vector < int > ans ; int r1 = 0 ; int c1 = 0 ; int r2 = matrix . size () - 1 ; int c2 = matrix [ 0 ]. size () - 1 ; while ( r1 <= r2 && c1 <= c2 ) { for ( int c = c1 ; c <= c2 ; ++ c ) ans . push_back ( matrix [ r1 ][ c ]); for ( int r = r1 + 1 ; r <= r2 ; ++ r ) ans . push_back ( matrix [ r ][ c2 ]); if ( r1 < r2 && c1 < c2 ) { for ( int c = c2 - 1 ; c > c1 ; -- c ) ans . push_back ( matrix [ r2 ][ c ]); for ( int r = r2 ; r > r1 ; -- r ) ans . push_back ( matrix [ r ][ c1 ]); } ++ r1 ; ++ c1 ; -- r2 ; -- c2 ; } return ans ; } };","title":"54. Spiral Matrix $\\star\\star$"},{"location":"cpp/0001-0100/0051-0060/#55-jump-game-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : bool canJump ( vector < int >& nums ) { int goal = nums . size () - 1 ; for ( int i = goal ; i >= 0 ; -- i ) if ( i + nums [ i ] >= goal ) goal = i ; return goal == 0 ; } };","title":"55. Jump Game $\\star\\star$"},{"location":"cpp/0001-0100/0051-0060/#56-merge-intervals-starstar","text":"Time: $O(n\\log n)$ Space: $O(1)$ class Solution { public : vector < vector < int >> merge ( vector < vector < int >>& intervals ) { vector < vector < int >> ans ; sort ( begin ( intervals ), end ( intervals ), []( const auto & a , const auto & b ) { return a [ 0 ] < b [ 0 ]; }); for ( const vector < int >& interval : intervals ) if ( ans . empty () || interval [ 0 ] > ans . back ()[ 1 ]) ans . push_back ( interval ); else ans . back ()[ 1 ] = max ( ans . back ()[ 1 ], interval [ 1 ]); return ans ; } };","title":"56. Merge Intervals $\\star\\star$"},{"location":"cpp/0001-0100/0051-0060/#57-insert-interval-starstarstar","text":"Time: $O(n\\log n)$ Space: $O(1)$ class Solution { public : vector < vector < int >> insert ( vector < vector < int >>& intervals , vector < int >& newInterval ) { vector < vector < int >> ans ; auto it = begin ( intervals ); for (; it != end ( intervals ); ++ it ) if (( * it )[ 0 ] >= newInterval [ 0 ]) break ; intervals . insert ( it , newInterval ); for ( const vector < int >& interval : intervals ) if ( ans . empty () || interval [ 0 ] > ans . back ()[ 1 ]) ans . push_back ( interval ); else ans . back ()[ 1 ] = max ( ans . back ()[ 1 ], interval [ 1 ]); return ans ; } };","title":"57. Insert Interval $\\star\\star\\star$"},{"location":"cpp/0001-0100/0051-0060/#58-length-of-last-word-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : int lengthOfLastWord ( string s ) { int ans = 0 ; int i = s . size () - 1 ; while ( i >= 0 && s [ i ] == ' ' ) -- i ; while ( i >= 0 && s [ i ] != ' ' ) { -- i ; ++ ans ; } return ans ; } };","title":"58. Length of Last Word $\\star$"},{"location":"cpp/0001-0100/0051-0060/#59-spiral-matrix-ii-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : vector < vector < int >> generateMatrix ( int n ) { vector < vector < int >> ans ( n , vector < int > ( n )); int count = 1 ; for ( int min = 0 , max = n - min - 1 ; min < n / 2 ; ++ min , -- max ) { for ( int i = min ; i < max ; ++ i ) ans [ min ][ i ] = count ++ ; for ( int i = min ; i < max ; ++ i ) ans [ i ][ max ] = count ++ ; for ( int i = max ; i > min ; -- i ) ans [ max ][ i ] = count ++ ; for ( int i = max ; i > min ; -- i ) ans [ i ][ min ] = count ++ ; } if ( n & 1 ) ans [ n / 2 ][ n / 2 ] = count ; return ans ; } };","title":"59. Spiral Matrix II $\\star\\star$"},{"location":"cpp/0001-0100/0051-0060/#60-permutation-sequence-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : string getPermutation ( int n , int k ) { string ans ; vector < int > nums ( n ); vector < int > factorial ( n , 1 ); for ( int i = 0 ; i < n ; ++ i ) nums [ i ] = i + 1 ; for ( int i = 1 ; i < n ; ++ i ) factorial [ i ] = factorial [ i - 1 ] * i ; -- k ; for ( int i = n ; i >= 1 ; -- i ) { const int j = k / factorial [ i - 1 ]; k %= factorial [ i - 1 ]; ans . append ( to_string ( nums [ j ])); nums . erase ( begin ( nums ) + j ); } return ans ; } };","title":"60. Permutation Sequence $\\star\\star$"},{"location":"cpp/0001-0100/0061-0070/","text":"61. Rotate List $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : ListNode * rotateRight ( ListNode * head , int k ) { if ( ! head || ! head -> next || k == 0 ) return head ; ListNode * tail ; int length = 1 ; for ( tail = head ; tail -> next ; tail = tail -> next ) ++ length ; tail -> next = head ; // circle the list for ( int i = 0 ; i < length - k % length ; ++ i ) tail = tail -> next ; ListNode * newHead = tail -> next ; tail -> next = nullptr ; return newHead ; } }; 62. Unique Paths $\\star\\star$ Time: $O(mn)$ Space: $O(mn) \\to O(n)$ class Solution { public : int uniquePaths ( int m , int n ) { vector < vector < int >> dp ( m , vector < int > ( n , 1 )); for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) dp [ i ][ j ] = dp [ i - 1 ][ j ] + dp [ i ][ j - 1 ]; return dp [ m - 1 ][ n - 1 ]; } }; 63. Unique Paths II $\\star\\star$ Time: $O(mn)$ Space: $O(mn) \\to O(n)$ class Solution { public : int uniquePathsWithObstacles ( vector < vector < int >>& obstacleGrid ) { const int m = obstacleGrid . size (); const int n = obstacleGrid [ 0 ]. size (); vector < vector < long >> dp ( m + 1 , vector < long > ( n + 1 , 0 )); dp [ 0 ][ 1 ] = 1 ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( ! obstacleGrid [ i - 1 ][ j - 1 ]) dp [ i ][ j ] = dp [ i - 1 ][ j ] + dp [ i ][ j - 1 ]; return dp [ m ][ n ]; } }; 64. Minimum Path Sum $\\star\\star$ Time: $O(mn)$ Space: $O(1)$ class Solution { public : int minPathSum ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( i > 0 && j > 0 ) grid [ i ][ j ] += min ( grid [ i - 1 ][ j ], grid [ i ][ j - 1 ]); else if ( i > 0 ) grid [ i ][ 0 ] += grid [ i - 1 ][ 0 ]; else if ( j > 0 ) grid [ 0 ][ j ] += grid [ 0 ][ j - 1 ]; return grid [ m - 1 ][ n - 1 ]; } }; 65. Valid Number $\\star\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : bool isNumber ( string s ) { s = trim ( s ); if ( s . empty ()) return false ; bool seenNum = false ; bool seenDot = false ; bool seenE = false ; for ( int i = 0 ; i < s . length (); ++ i ) { switch ( s [ i ]) { case '.' : if ( seenDot || seenE ) return false ; seenDot = true ; break ; case 'e' : if ( seenE || ! seenNum ) return false ; seenE = true ; seenNum = false ; break ; case '+' : case '-' : if ( i != 0 && s [ i - 1 ] != 'e' ) return false ; seenNum = false ; break ; default : if ( ! isdigit ( s [ i ])) return false ; seenNum = true ; } } return seenNum ; } private : string trim ( string & s ) { if ( s . empty ()) return s ; s . erase ( 0 , s . find_first_not_of ( ' ' )); s . erase ( s . find_last_not_of ( ' ' ) + 1 ); return s ; } }; 66. Plus One $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : vector < int > plusOne ( vector < int >& digits ) { for ( int i = digits . size () - 1 ; i >= 0 ; -- i ) { if ( digits [ i ] < 9 ) { ++ digits [ i ]; return digits ; } digits [ i ] = 0 ; } digits . insert ( begin ( digits ), 1 ); return digits ; } }; 67. Add Binary $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : string addBinary ( string a , string b ) { string ans ; int carry = 0 ; int i = a . length () - 1 ; int j = b . length () - 1 ; while ( carry == 1 || i >= 0 || j >= 0 ) { if ( i >= 0 ) carry += a [ i -- ] - '0' ; if ( j >= 0 ) carry += b [ j -- ] - '0' ; ans += char ( carry % 2 + '0' ); carry >>= 1 ; } reverse ( begin ( ans ), end ( ans )); return ans ; } }; 68. Text Justification $\\star\\star\\star$ Time: $O( sum(len(words[i]) )$ Space: $O(1)$ class Solution { public : vector < string > fullJustify ( vector < string >& words , int maxWidth ) { vector < string > ans ; vector < string > curr ; int numOfLetters = 0 ; for ( const string & word : words ) { if ( numOfLetters + ( int ) curr . size () + ( int ) word . length () > maxWidth ) { for ( int i = 0 ; i < maxWidth - numOfLetters ; ++ i ) { curr . size () - 1 == 0 ? curr [ 0 ]. append ( \" \" ) : curr [ i % ( curr . size () - 1 )]. append ( \" \" ); } ans . push_back ( join ( curr , \"\" )); curr . clear (); numOfLetters = 0 ; } curr . push_back ( word ); numOfLetters += word . length (); } ans . push_back ( ljust ( join ( curr , \" \" ), maxWidth )); return ans ; } private : string join ( vector < string >& v , string c ) { string s ; for ( auto p = begin ( v ); p != end ( v ); ++ p ) { s += * p ; if ( p != end ( v ) - 1 ) s += c ; } return s ; } string ljust ( string s , int width ) { for ( int i = 0 ; i < s . length () - width ; ++ i ) s += \" \" ; return s ; } }; 69. Sqrt(x) $\\star$ Time: $O(\\log x)$ Space: $O(1)$ class Solution { public : int mySqrt ( int x ) { unsigned l = 1 ; unsigned r = x + 1u ; while ( l < r ) { const unsigned m = l + ( r - l ) / 2 ; if ( m > x / m ) r = m ; else l = m + 1 ; } return l - 1 ; } }; 70. Climbing Stairs $\\star$ Time: $O(n)$ Space: $O(n) \\to O(1)$ class Solution { public : int climbStairs ( int n ) { vector < int > dp ( n + 1 ); dp [ 0 ] = 1 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; ++ i ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ]; return dp [ n ]; } };","title":"0061-0070"},{"location":"cpp/0001-0100/0061-0070/#61-rotate-list-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : ListNode * rotateRight ( ListNode * head , int k ) { if ( ! head || ! head -> next || k == 0 ) return head ; ListNode * tail ; int length = 1 ; for ( tail = head ; tail -> next ; tail = tail -> next ) ++ length ; tail -> next = head ; // circle the list for ( int i = 0 ; i < length - k % length ; ++ i ) tail = tail -> next ; ListNode * newHead = tail -> next ; tail -> next = nullptr ; return newHead ; } };","title":"61. Rotate List $\\star\\star$"},{"location":"cpp/0001-0100/0061-0070/#62-unique-paths-starstar","text":"Time: $O(mn)$ Space: $O(mn) \\to O(n)$ class Solution { public : int uniquePaths ( int m , int n ) { vector < vector < int >> dp ( m , vector < int > ( n , 1 )); for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) dp [ i ][ j ] = dp [ i - 1 ][ j ] + dp [ i ][ j - 1 ]; return dp [ m - 1 ][ n - 1 ]; } };","title":"62. Unique Paths $\\star\\star$"},{"location":"cpp/0001-0100/0061-0070/#63-unique-paths-ii-starstar","text":"Time: $O(mn)$ Space: $O(mn) \\to O(n)$ class Solution { public : int uniquePathsWithObstacles ( vector < vector < int >>& obstacleGrid ) { const int m = obstacleGrid . size (); const int n = obstacleGrid [ 0 ]. size (); vector < vector < long >> dp ( m + 1 , vector < long > ( n + 1 , 0 )); dp [ 0 ][ 1 ] = 1 ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( ! obstacleGrid [ i - 1 ][ j - 1 ]) dp [ i ][ j ] = dp [ i - 1 ][ j ] + dp [ i ][ j - 1 ]; return dp [ m ][ n ]; } };","title":"63. Unique Paths II $\\star\\star$"},{"location":"cpp/0001-0100/0061-0070/#64-minimum-path-sum-starstar","text":"Time: $O(mn)$ Space: $O(1)$ class Solution { public : int minPathSum ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( i > 0 && j > 0 ) grid [ i ][ j ] += min ( grid [ i - 1 ][ j ], grid [ i ][ j - 1 ]); else if ( i > 0 ) grid [ i ][ 0 ] += grid [ i - 1 ][ 0 ]; else if ( j > 0 ) grid [ 0 ][ j ] += grid [ 0 ][ j - 1 ]; return grid [ m - 1 ][ n - 1 ]; } };","title":"64. Minimum Path Sum $\\star\\star$"},{"location":"cpp/0001-0100/0061-0070/#65-valid-number-starstarstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : bool isNumber ( string s ) { s = trim ( s ); if ( s . empty ()) return false ; bool seenNum = false ; bool seenDot = false ; bool seenE = false ; for ( int i = 0 ; i < s . length (); ++ i ) { switch ( s [ i ]) { case '.' : if ( seenDot || seenE ) return false ; seenDot = true ; break ; case 'e' : if ( seenE || ! seenNum ) return false ; seenE = true ; seenNum = false ; break ; case '+' : case '-' : if ( i != 0 && s [ i - 1 ] != 'e' ) return false ; seenNum = false ; break ; default : if ( ! isdigit ( s [ i ])) return false ; seenNum = true ; } } return seenNum ; } private : string trim ( string & s ) { if ( s . empty ()) return s ; s . erase ( 0 , s . find_first_not_of ( ' ' )); s . erase ( s . find_last_not_of ( ' ' ) + 1 ); return s ; } };","title":"65. Valid Number $\\star\\star\\star$"},{"location":"cpp/0001-0100/0061-0070/#66-plus-one-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : vector < int > plusOne ( vector < int >& digits ) { for ( int i = digits . size () - 1 ; i >= 0 ; -- i ) { if ( digits [ i ] < 9 ) { ++ digits [ i ]; return digits ; } digits [ i ] = 0 ; } digits . insert ( begin ( digits ), 1 ); return digits ; } };","title":"66. Plus One $\\star$"},{"location":"cpp/0001-0100/0061-0070/#67-add-binary-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : string addBinary ( string a , string b ) { string ans ; int carry = 0 ; int i = a . length () - 1 ; int j = b . length () - 1 ; while ( carry == 1 || i >= 0 || j >= 0 ) { if ( i >= 0 ) carry += a [ i -- ] - '0' ; if ( j >= 0 ) carry += b [ j -- ] - '0' ; ans += char ( carry % 2 + '0' ); carry >>= 1 ; } reverse ( begin ( ans ), end ( ans )); return ans ; } };","title":"67. Add Binary $\\star$"},{"location":"cpp/0001-0100/0061-0070/#68-text-justification-starstarstar","text":"Time: $O( sum(len(words[i]) )$ Space: $O(1)$ class Solution { public : vector < string > fullJustify ( vector < string >& words , int maxWidth ) { vector < string > ans ; vector < string > curr ; int numOfLetters = 0 ; for ( const string & word : words ) { if ( numOfLetters + ( int ) curr . size () + ( int ) word . length () > maxWidth ) { for ( int i = 0 ; i < maxWidth - numOfLetters ; ++ i ) { curr . size () - 1 == 0 ? curr [ 0 ]. append ( \" \" ) : curr [ i % ( curr . size () - 1 )]. append ( \" \" ); } ans . push_back ( join ( curr , \"\" )); curr . clear (); numOfLetters = 0 ; } curr . push_back ( word ); numOfLetters += word . length (); } ans . push_back ( ljust ( join ( curr , \" \" ), maxWidth )); return ans ; } private : string join ( vector < string >& v , string c ) { string s ; for ( auto p = begin ( v ); p != end ( v ); ++ p ) { s += * p ; if ( p != end ( v ) - 1 ) s += c ; } return s ; } string ljust ( string s , int width ) { for ( int i = 0 ; i < s . length () - width ; ++ i ) s += \" \" ; return s ; } };","title":"68. Text Justification $\\star\\star\\star$"},{"location":"cpp/0001-0100/0061-0070/#69-sqrtx-star","text":"Time: $O(\\log x)$ Space: $O(1)$ class Solution { public : int mySqrt ( int x ) { unsigned l = 1 ; unsigned r = x + 1u ; while ( l < r ) { const unsigned m = l + ( r - l ) / 2 ; if ( m > x / m ) r = m ; else l = m + 1 ; } return l - 1 ; } };","title":"69. Sqrt(x) $\\star$"},{"location":"cpp/0001-0100/0061-0070/#70-climbing-stairs-star","text":"Time: $O(n)$ Space: $O(n) \\to O(1)$ class Solution { public : int climbStairs ( int n ) { vector < int > dp ( n + 1 ); dp [ 0 ] = 1 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; ++ i ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ]; return dp [ n ]; } };","title":"70. Climbing Stairs $\\star$"},{"location":"cpp/0001-0100/0071-0080/","text":"71. Simplify Path $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : string simplifyPath ( string path ) { string ans ; string temp ; stringstream ss ( path ); vector < string > stack ; while ( getline ( ss , temp , '/' )) { if ( temp == \"\" || temp == \".\" ) continue ; if ( temp == \"..\" ) { if ( ! stack . empty ()) stack . pop_back (); } else { stack . push_back ( temp ); } } for ( const string & s : stack ) ans += \"/\" + s ; return ans . empty () ? \"/\" : ans ; } }; 72. Edit Distance $\\star\\star\\star$ Time: $O(mn)$ Space: $O(mn) \\to O(n)$ class Solution { public : int minDistance ( string word1 , string word2 ) { const int m = word1 . length (); const int n = word2 . length (); vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 )); for ( int i = 1 ; i <= m ; ++ i ) dp [ i ][ 0 ] = i ; for ( int j = 1 ; j <= n ; ++ j ) dp [ 0 ][ j ] = j ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( word1 [ i - 1 ] == word2 [ j - 1 ]) dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ]; else dp [ i ][ j ] = min ({ dp [ i - 1 ][ j - 1 ], dp [ i - 1 ][ j ], dp [ i ][ j - 1 ]}) + 1 ; return dp [ m ][ n ]; } }; 73. Set Matrix Zeroes $\\star\\star$ Time: $O(mn)$ Space: $O(1)$ class Solution { public : void setZeroes ( vector < vector < int >>& matrix ) { const int m = matrix . size (); const int n = matrix [ 0 ]. size (); bool shouldFillFirstRow = false ; bool shouldFillFirstCol = false ; for ( int j = 0 ; j < n ; ++ j ) if ( matrix [ 0 ][ j ] == 0 ) shouldFillFirstRow = true ; for ( int i = 0 ; i < m ; ++ i ) if ( matrix [ i ][ 0 ] == 0 ) shouldFillFirstCol = true ; for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) if ( matrix [ i ][ j ] == 0 ) { matrix [ i ][ 0 ] = 0 ; matrix [ 0 ][ j ] = 0 ; } for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) if ( matrix [ i ][ 0 ] == 0 || matrix [ 0 ][ j ] == 0 ) matrix [ i ][ j ] = 0 ; if ( shouldFillFirstRow ) for ( int j = 0 ; j < n ; ++ j ) matrix [ 0 ][ j ] = 0 ; if ( shouldFillFirstCol ) for ( int i = 0 ; i < m ; ++ i ) matrix [ i ][ 0 ] = 0 ; } }; 74. Search a 2D Matrix $\\star\\star$ Time: $O(mn\\log mn)$ Space: $O(1)$ class Solution { public : bool searchMatrix ( vector < vector < int >>& matrix , int target ) { if ( matrix . empty ()) return false ; const int m = matrix . size (); const int n = matrix [ 0 ]. size (); int l = 0 ; int r = m * n ; while ( l < r ) { const int mid = l + ( r - l ) / 2 ; const int i = mid / n ; const int j = mid % n ; if ( matrix [ i ][ j ] == target ) return true ; if ( matrix [ i ][ j ] < target ) l = mid + 1 ; else r = mid ; } return false ; } }; 75. Sort Colors $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : void sortColors ( vector < int >& nums ) { int l = 0 ; int r = nums . size () - 1 ; for ( int i = 0 ; i <= r ;) if ( nums [ i ] == 0 ) swap ( nums [ i ++ ], nums [ l ++ ]); else if ( nums [ i ] == 1 ) ++ i ; else swap ( nums [ i ], nums [ r -- ]); } }; 76. Minimum Window Substring $\\star\\star\\star$ Time: $O(n)$ Space: $O(128)$ class Solution { public : string minWindow ( string s , string t ) { vector < int > count ( 128 ); int required = t . length (); int bestLeft = 0 ; int minLength = INT_MAX ; for ( const char c : t ) ++ count [ c ]; for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { if ( -- count [ s [ r ]] >= 0 ) -- required ; while ( required == 0 ) { if ( r - l + 1 < minLength ) { bestLeft = l ; minLength = r - l + 1 ; } if ( ++ count [ s [ l ++ ]] > 0 ) ++ required ; } } return minLength == INT_MAX ? \"\" : s . substr ( bestLeft , minLength ); } }; 77. Combinations $\\star\\star$ Time: $O(C(n, k))$ Space: $O(k)$ class Solution { public : vector < vector < int >> combine ( int n , int k ) { vector < vector < int >> ans ; vector < int > path ; function < void ( int , int ) > dfs = [ & ]( int k , int s ) { if ( k == 0 ) { ans . push_back ( path ); return ; } for ( int i = s ; i <= n ; ++ i ) { path . push_back ( i ); dfs ( k - 1 , i + 1 ); path . pop_back (); } }; dfs ( k , 1 ); return ans ; } }; 78. Subsets $\\star\\star$ Time: $O(2^n)$ Space: $O(n)$ class Solution { public : vector < vector < int >> subsets ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; function < void ( int ) > dfs = [ & ]( int s ) { ans . push_back ( path ); for ( int i = s ; i < nums . size (); ++ i ) { path . push_back ( nums [ i ]); dfs ( i + 1 ); path . pop_back (); } }; dfs ( 0 ); return ans ; } }; 79. Word Search $\\star\\star$ Time: $O(4^l)$, where l = len(word) Space: $O(1)$ class Solution { public : bool exist ( vector < vector < char >>& board , string word ) { function < bool ( int , int , int ) > dfs = [ & ]( int i , int j , int s ) { if ( i < 0 || i == board . size () || j < 0 || j == board [ 0 ]. size ()) return false ; if ( board [ i ][ j ] != word [ s ] || board [ i ][ j ] == '*' ) return false ; if ( s == word . length () - 1 ) return true ; const char cache = board [ i ][ j ]; board [ i ][ j ] = '*' ; bool isExist = dfs ( i + 1 , j , s + 1 ) || dfs ( i - 1 , j , s + 1 ) || dfs ( i , j + 1 , s + 1 ) || dfs ( i , j - 1 , s + 1 ); board [ i ][ j ] = cache ; return isExist ; }; for ( int i = 0 ; i < board . size (); ++ i ) for ( int j = 0 ; j < board [ 0 ]. size (); ++ j ) if ( dfs ( i , j , 0 )) return true ; return false ; } }; 80. Remove Duplicates from Sorted Array II $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : int removeDuplicates ( vector < int >& nums ) { int i = 0 ; for ( const int num : nums ) if ( i < 2 || num > nums [ i - 2 ]) nums [ i ++ ] = num ; return i ; } };","title":"0071-0080"},{"location":"cpp/0001-0100/0071-0080/#71-simplify-path-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : string simplifyPath ( string path ) { string ans ; string temp ; stringstream ss ( path ); vector < string > stack ; while ( getline ( ss , temp , '/' )) { if ( temp == \"\" || temp == \".\" ) continue ; if ( temp == \"..\" ) { if ( ! stack . empty ()) stack . pop_back (); } else { stack . push_back ( temp ); } } for ( const string & s : stack ) ans += \"/\" + s ; return ans . empty () ? \"/\" : ans ; } };","title":"71. Simplify Path $\\star\\star$"},{"location":"cpp/0001-0100/0071-0080/#72-edit-distance-starstarstar","text":"Time: $O(mn)$ Space: $O(mn) \\to O(n)$ class Solution { public : int minDistance ( string word1 , string word2 ) { const int m = word1 . length (); const int n = word2 . length (); vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 )); for ( int i = 1 ; i <= m ; ++ i ) dp [ i ][ 0 ] = i ; for ( int j = 1 ; j <= n ; ++ j ) dp [ 0 ][ j ] = j ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( word1 [ i - 1 ] == word2 [ j - 1 ]) dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ]; else dp [ i ][ j ] = min ({ dp [ i - 1 ][ j - 1 ], dp [ i - 1 ][ j ], dp [ i ][ j - 1 ]}) + 1 ; return dp [ m ][ n ]; } };","title":"72. Edit Distance $\\star\\star\\star$"},{"location":"cpp/0001-0100/0071-0080/#73-set-matrix-zeroes-starstar","text":"Time: $O(mn)$ Space: $O(1)$ class Solution { public : void setZeroes ( vector < vector < int >>& matrix ) { const int m = matrix . size (); const int n = matrix [ 0 ]. size (); bool shouldFillFirstRow = false ; bool shouldFillFirstCol = false ; for ( int j = 0 ; j < n ; ++ j ) if ( matrix [ 0 ][ j ] == 0 ) shouldFillFirstRow = true ; for ( int i = 0 ; i < m ; ++ i ) if ( matrix [ i ][ 0 ] == 0 ) shouldFillFirstCol = true ; for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) if ( matrix [ i ][ j ] == 0 ) { matrix [ i ][ 0 ] = 0 ; matrix [ 0 ][ j ] = 0 ; } for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) if ( matrix [ i ][ 0 ] == 0 || matrix [ 0 ][ j ] == 0 ) matrix [ i ][ j ] = 0 ; if ( shouldFillFirstRow ) for ( int j = 0 ; j < n ; ++ j ) matrix [ 0 ][ j ] = 0 ; if ( shouldFillFirstCol ) for ( int i = 0 ; i < m ; ++ i ) matrix [ i ][ 0 ] = 0 ; } };","title":"73. Set Matrix Zeroes $\\star\\star$"},{"location":"cpp/0001-0100/0071-0080/#74-search-a-2d-matrix-starstar","text":"Time: $O(mn\\log mn)$ Space: $O(1)$ class Solution { public : bool searchMatrix ( vector < vector < int >>& matrix , int target ) { if ( matrix . empty ()) return false ; const int m = matrix . size (); const int n = matrix [ 0 ]. size (); int l = 0 ; int r = m * n ; while ( l < r ) { const int mid = l + ( r - l ) / 2 ; const int i = mid / n ; const int j = mid % n ; if ( matrix [ i ][ j ] == target ) return true ; if ( matrix [ i ][ j ] < target ) l = mid + 1 ; else r = mid ; } return false ; } };","title":"74. Search a 2D Matrix $\\star\\star$"},{"location":"cpp/0001-0100/0071-0080/#75-sort-colors-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : void sortColors ( vector < int >& nums ) { int l = 0 ; int r = nums . size () - 1 ; for ( int i = 0 ; i <= r ;) if ( nums [ i ] == 0 ) swap ( nums [ i ++ ], nums [ l ++ ]); else if ( nums [ i ] == 1 ) ++ i ; else swap ( nums [ i ], nums [ r -- ]); } };","title":"75. Sort Colors $\\star\\star$"},{"location":"cpp/0001-0100/0071-0080/#76-minimum-window-substring-starstarstar","text":"Time: $O(n)$ Space: $O(128)$ class Solution { public : string minWindow ( string s , string t ) { vector < int > count ( 128 ); int required = t . length (); int bestLeft = 0 ; int minLength = INT_MAX ; for ( const char c : t ) ++ count [ c ]; for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { if ( -- count [ s [ r ]] >= 0 ) -- required ; while ( required == 0 ) { if ( r - l + 1 < minLength ) { bestLeft = l ; minLength = r - l + 1 ; } if ( ++ count [ s [ l ++ ]] > 0 ) ++ required ; } } return minLength == INT_MAX ? \"\" : s . substr ( bestLeft , minLength ); } };","title":"76. Minimum Window Substring $\\star\\star\\star$"},{"location":"cpp/0001-0100/0071-0080/#77-combinations-starstar","text":"Time: $O(C(n, k))$ Space: $O(k)$ class Solution { public : vector < vector < int >> combine ( int n , int k ) { vector < vector < int >> ans ; vector < int > path ; function < void ( int , int ) > dfs = [ & ]( int k , int s ) { if ( k == 0 ) { ans . push_back ( path ); return ; } for ( int i = s ; i <= n ; ++ i ) { path . push_back ( i ); dfs ( k - 1 , i + 1 ); path . pop_back (); } }; dfs ( k , 1 ); return ans ; } };","title":"77. Combinations $\\star\\star$"},{"location":"cpp/0001-0100/0071-0080/#78-subsets-starstar","text":"Time: $O(2^n)$ Space: $O(n)$ class Solution { public : vector < vector < int >> subsets ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; function < void ( int ) > dfs = [ & ]( int s ) { ans . push_back ( path ); for ( int i = s ; i < nums . size (); ++ i ) { path . push_back ( nums [ i ]); dfs ( i + 1 ); path . pop_back (); } }; dfs ( 0 ); return ans ; } };","title":"78. Subsets $\\star\\star$"},{"location":"cpp/0001-0100/0071-0080/#79-word-search-starstar","text":"Time: $O(4^l)$, where l = len(word) Space: $O(1)$ class Solution { public : bool exist ( vector < vector < char >>& board , string word ) { function < bool ( int , int , int ) > dfs = [ & ]( int i , int j , int s ) { if ( i < 0 || i == board . size () || j < 0 || j == board [ 0 ]. size ()) return false ; if ( board [ i ][ j ] != word [ s ] || board [ i ][ j ] == '*' ) return false ; if ( s == word . length () - 1 ) return true ; const char cache = board [ i ][ j ]; board [ i ][ j ] = '*' ; bool isExist = dfs ( i + 1 , j , s + 1 ) || dfs ( i - 1 , j , s + 1 ) || dfs ( i , j + 1 , s + 1 ) || dfs ( i , j - 1 , s + 1 ); board [ i ][ j ] = cache ; return isExist ; }; for ( int i = 0 ; i < board . size (); ++ i ) for ( int j = 0 ; j < board [ 0 ]. size (); ++ j ) if ( dfs ( i , j , 0 )) return true ; return false ; } };","title":"79. Word Search $\\star\\star$"},{"location":"cpp/0001-0100/0071-0080/#80-remove-duplicates-from-sorted-array-ii-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : int removeDuplicates ( vector < int >& nums ) { int i = 0 ; for ( const int num : nums ) if ( i < 2 || num > nums [ i - 2 ]) nums [ i ++ ] = num ; return i ; } };","title":"80. Remove Duplicates from Sorted Array II $\\star\\star$"},{"location":"cpp/0001-0100/0081-0090/","text":"81. Search in Rotated Sorted Array II $\\star\\star$ Time: $O(\\log n) \\to O(n)$ Space: $O(1)$ class Solution { public : bool search ( vector < int >& nums , int target ) { int l = 0 ; int r = nums . size () - 1 ; while ( l <= r ) { const int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return true ; if ( nums [ l ] == nums [ m ] && nums [ m ] == nums [ r ]) { ++ l ; -- r ; } else if ( nums [ l ] <= nums [ m ]) { if ( nums [ l ] <= target && target < nums [ m ]) r = m - 1 ; else l = m + 1 ; } else { if ( nums [ m ] < target && target <= nums [ r ]) l = m + 1 ; else r = m - 1 ; } } return false ; } }; 82. Remove Duplicates from Sorted List II $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : ListNode * deleteDuplicates ( ListNode * head ) { ListNode dummy ( 0 ); dummy . next = head ; ListNode * prev = & dummy ; while ( head ) { while ( head -> next && head -> val == head -> next -> val ) head = head -> next ; if ( prev -> next == head ) prev = prev -> next ; else prev -> next = head -> next ; head = head -> next ; } return dummy . next ; } }; 83. Remove Duplicates from Sorted List $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : ListNode * deleteDuplicates ( ListNode * head ) { ListNode * curr = head ; while ( curr ) { while ( curr -> next && curr -> val == curr -> next -> val ) curr -> next = curr -> next -> next ; curr = curr -> next ; } return head ; } }; 84. Largest Rectangle in Histogram $\\star\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : int largestRectangleArea ( vector < int >& heights ) { int ans = 0 ; stack < int > stack ; for ( int i = 0 ; i <= heights . size (); ++ i ) { while ( ! stack . empty () && ( i == heights . size () || heights [ stack . top ()] > heights [ i ])) { const int h = heights [ stack . top ()]; stack . pop (); const int w = stack . empty () ? i : i - stack . top () - 1 ; ans = max ( ans , h * w ); } stack . push ( i ); } return ans ; } }; 85. Maximal Rectangle $\\star\\star\\star$ Time: $O(mn)$, where $m = len(matrix)$ and n = len(matrix[i]) Space: $O(n)$ class Solution { public : int maximalRectangle ( vector < vector < char >>& matrix ) { if ( matrix . empty ()) return 0 ; int ans = 0 ; vector < int > temp ( matrix [ 0 ]. size ()); for ( const vector < char >& row : matrix ) { for ( int i = 0 ; i < row . size (); ++ i ) temp [ i ] = row [ i ] == '0' ? 0 : temp [ i ] + 1 ; ans = max ( ans , largestRectangleArea ( temp )); } return ans ; } private : int largestRectangleArea ( vector < int >& heights ) { int ans = 0 ; stack < int > stack ; for ( int i = 0 ; i <= heights . size (); ++ i ) { while ( ! stack . empty () && ( i == heights . size () || heights [ stack . top ()] > heights [ i ])) { const int h = heights [ stack . top ()]; stack . pop (); const int w = stack . empty () ? i : i - stack . top () - 1 ; ans = max ( ans , h * w ); } stack . push ( i ); } return ans ; } }; 86. Partition List $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : ListNode * partition ( ListNode * head , int x ) { ListNode beforeHead ( 0 ); ListNode afterHead ( 0 ); ListNode * before = & beforeHead ; ListNode * after = & afterHead ; for (; head ; head = head -> next ) if ( head -> val < x ) { before -> next = head ; before = head ; } else { after -> next = head ; after = head ; } after -> next = nullptr ; before -> next = afterHead . next ; return beforeHead . next ; }; }; 87. Scramble String $\\star\\star\\star$ class Solution { public : bool isScramble ( string s1 , string s2 ) { if ( s1 == s2 ) return true ; if ( s1 . length () != s2 . length ()) return false ; vector < int > count ( 26 ); for ( int i = 0 ; i < s1 . length (); ++ i ) { ++ count [ s1 [ i ] - 'a' ]; -- count [ s2 [ i ] - 'a' ]; } if ( any_of ( begin ( count ), end ( count ), []( int c ) { return c != 0 ; })) return false ; for ( int i = 1 ; i < s1 . length (); ++ i ) { if ( isScramble ( s1 . substr ( 0 , i ), s2 . substr ( 0 , i )) && isScramble ( s1 . substr ( i ), s2 . substr ( i ))) return true ; if ( isScramble ( s1 . substr ( 0 , i ), s2 . substr ( s2 . length () - i )) && isScramble ( s1 . substr ( i ), s2 . substr ( 0 , s2 . length () - i ))) return true ; } return false ; } }; 88. Merge Sorted Array $\\star$ Time: $O(m + n)$ Space: $O(1)$ class Solution { public : void merge ( vector < int >& nums1 , int m , vector < int >& nums2 , int n ) { int k = m + n ; while ( n > 0 ) if ( m > 0 && nums1 [ m - 1 ] > nums2 [ n - 1 ]) nums1 [ -- k ] = nums1 [ -- m ]; else nums1 [ -- k ] = nums2 [ -- n ]; } }; 89. Gray Code $\\star\\star$ Time: $O(2^n)$ Space: $O(2^n)$ class Solution { public : vector < int > grayCode ( int n ) { vector < int > ans { 0 }; for ( int i = 0 ; i < n ; ++ i ) for ( int j = ans . size () - 1 ; j >= 0 ; -- j ) ans . push_back ( ans [ j ] | 1 << i ); return ans ; } }; 90. Subsets II $\\star\\star$ Time: $O(n2^n)$ Space: $O(n)$ class Solution { public : vector < vector < int >> subsetsWithDup ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; function < void ( int ) > dfs = [ & ]( int s ) { ans . push_back ( path ); for ( int i = s ; i < nums . size (); ++ i ) { if ( i > s && nums [ i ] == nums [ i - 1 ]) continue ; path . push_back ( nums [ i ]); dfs ( i + 1 ); path . pop_back (); } }; sort ( begin ( nums ), end ( nums )); dfs ( 0 ); return ans ; } };","title":"0081-0090"},{"location":"cpp/0001-0100/0081-0090/#81-search-in-rotated-sorted-array-ii-starstar","text":"Time: $O(\\log n) \\to O(n)$ Space: $O(1)$ class Solution { public : bool search ( vector < int >& nums , int target ) { int l = 0 ; int r = nums . size () - 1 ; while ( l <= r ) { const int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return true ; if ( nums [ l ] == nums [ m ] && nums [ m ] == nums [ r ]) { ++ l ; -- r ; } else if ( nums [ l ] <= nums [ m ]) { if ( nums [ l ] <= target && target < nums [ m ]) r = m - 1 ; else l = m + 1 ; } else { if ( nums [ m ] < target && target <= nums [ r ]) l = m + 1 ; else r = m - 1 ; } } return false ; } };","title":"81. Search in Rotated Sorted Array II $\\star\\star$"},{"location":"cpp/0001-0100/0081-0090/#82-remove-duplicates-from-sorted-list-ii-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : ListNode * deleteDuplicates ( ListNode * head ) { ListNode dummy ( 0 ); dummy . next = head ; ListNode * prev = & dummy ; while ( head ) { while ( head -> next && head -> val == head -> next -> val ) head = head -> next ; if ( prev -> next == head ) prev = prev -> next ; else prev -> next = head -> next ; head = head -> next ; } return dummy . next ; } };","title":"82. Remove Duplicates from Sorted List II $\\star\\star$"},{"location":"cpp/0001-0100/0081-0090/#83-remove-duplicates-from-sorted-list-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : ListNode * deleteDuplicates ( ListNode * head ) { ListNode * curr = head ; while ( curr ) { while ( curr -> next && curr -> val == curr -> next -> val ) curr -> next = curr -> next -> next ; curr = curr -> next ; } return head ; } };","title":"83. Remove Duplicates from Sorted List $\\star$"},{"location":"cpp/0001-0100/0081-0090/#84-largest-rectangle-in-histogram-starstarstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : int largestRectangleArea ( vector < int >& heights ) { int ans = 0 ; stack < int > stack ; for ( int i = 0 ; i <= heights . size (); ++ i ) { while ( ! stack . empty () && ( i == heights . size () || heights [ stack . top ()] > heights [ i ])) { const int h = heights [ stack . top ()]; stack . pop (); const int w = stack . empty () ? i : i - stack . top () - 1 ; ans = max ( ans , h * w ); } stack . push ( i ); } return ans ; } };","title":"84. Largest Rectangle in Histogram $\\star\\star\\star$"},{"location":"cpp/0001-0100/0081-0090/#85-maximal-rectangle-starstarstar","text":"Time: $O(mn)$, where $m = len(matrix)$ and n = len(matrix[i]) Space: $O(n)$ class Solution { public : int maximalRectangle ( vector < vector < char >>& matrix ) { if ( matrix . empty ()) return 0 ; int ans = 0 ; vector < int > temp ( matrix [ 0 ]. size ()); for ( const vector < char >& row : matrix ) { for ( int i = 0 ; i < row . size (); ++ i ) temp [ i ] = row [ i ] == '0' ? 0 : temp [ i ] + 1 ; ans = max ( ans , largestRectangleArea ( temp )); } return ans ; } private : int largestRectangleArea ( vector < int >& heights ) { int ans = 0 ; stack < int > stack ; for ( int i = 0 ; i <= heights . size (); ++ i ) { while ( ! stack . empty () && ( i == heights . size () || heights [ stack . top ()] > heights [ i ])) { const int h = heights [ stack . top ()]; stack . pop (); const int w = stack . empty () ? i : i - stack . top () - 1 ; ans = max ( ans , h * w ); } stack . push ( i ); } return ans ; } };","title":"85. Maximal Rectangle $\\star\\star\\star$"},{"location":"cpp/0001-0100/0081-0090/#86-partition-list-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : ListNode * partition ( ListNode * head , int x ) { ListNode beforeHead ( 0 ); ListNode afterHead ( 0 ); ListNode * before = & beforeHead ; ListNode * after = & afterHead ; for (; head ; head = head -> next ) if ( head -> val < x ) { before -> next = head ; before = head ; } else { after -> next = head ; after = head ; } after -> next = nullptr ; before -> next = afterHead . next ; return beforeHead . next ; }; };","title":"86. Partition List $\\star\\star$"},{"location":"cpp/0001-0100/0081-0090/#87-scramble-string-starstarstar","text":"class Solution { public : bool isScramble ( string s1 , string s2 ) { if ( s1 == s2 ) return true ; if ( s1 . length () != s2 . length ()) return false ; vector < int > count ( 26 ); for ( int i = 0 ; i < s1 . length (); ++ i ) { ++ count [ s1 [ i ] - 'a' ]; -- count [ s2 [ i ] - 'a' ]; } if ( any_of ( begin ( count ), end ( count ), []( int c ) { return c != 0 ; })) return false ; for ( int i = 1 ; i < s1 . length (); ++ i ) { if ( isScramble ( s1 . substr ( 0 , i ), s2 . substr ( 0 , i )) && isScramble ( s1 . substr ( i ), s2 . substr ( i ))) return true ; if ( isScramble ( s1 . substr ( 0 , i ), s2 . substr ( s2 . length () - i )) && isScramble ( s1 . substr ( i ), s2 . substr ( 0 , s2 . length () - i ))) return true ; } return false ; } };","title":"87. Scramble String $\\star\\star\\star$"},{"location":"cpp/0001-0100/0081-0090/#88-merge-sorted-array-star","text":"Time: $O(m + n)$ Space: $O(1)$ class Solution { public : void merge ( vector < int >& nums1 , int m , vector < int >& nums2 , int n ) { int k = m + n ; while ( n > 0 ) if ( m > 0 && nums1 [ m - 1 ] > nums2 [ n - 1 ]) nums1 [ -- k ] = nums1 [ -- m ]; else nums1 [ -- k ] = nums2 [ -- n ]; } };","title":"88. Merge Sorted Array $\\star$"},{"location":"cpp/0001-0100/0081-0090/#89-gray-code-starstar","text":"Time: $O(2^n)$ Space: $O(2^n)$ class Solution { public : vector < int > grayCode ( int n ) { vector < int > ans { 0 }; for ( int i = 0 ; i < n ; ++ i ) for ( int j = ans . size () - 1 ; j >= 0 ; -- j ) ans . push_back ( ans [ j ] | 1 << i ); return ans ; } };","title":"89. Gray Code $\\star\\star$"},{"location":"cpp/0001-0100/0081-0090/#90-subsets-ii-starstar","text":"Time: $O(n2^n)$ Space: $O(n)$ class Solution { public : vector < vector < int >> subsetsWithDup ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; function < void ( int ) > dfs = [ & ]( int s ) { ans . push_back ( path ); for ( int i = s ; i < nums . size (); ++ i ) { if ( i > s && nums [ i ] == nums [ i - 1 ]) continue ; path . push_back ( nums [ i ]); dfs ( i + 1 ); path . pop_back (); } }; sort ( begin ( nums ), end ( nums )); dfs ( 0 ); return ans ; } };","title":"90. Subsets II $\\star\\star$"},{"location":"cpp/0001-0100/0091-0100/","text":"91. Decode Ways $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : int numDecodings ( string s ) { const int n = s . length (); vector < int > dp ( n + 1 , 0 ); dp . back () = 1 ; dp [ n - 1 ] = isValid ( s [ n - 1 ]); for ( int i = n - 2 ; i >= 0 ; -- i ) { if ( isValid ( s [ i ], s [ i + 1 ])) dp [ i ] += dp [ i + 2 ]; if ( isValid ( s [ i ])) dp [ i ] += dp [ i + 1 ]; } return dp [ 0 ]; } private : bool isValid ( char c ) { return '1' <= c && c <= '9' ; } bool isValid ( char c1 , char c2 ) { return c1 == '1' || c1 == '2' && '0' <= c2 && c2 <= '6' ; } }; 92. Reverse Linked List II $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : ListNode * reverseBetween ( ListNode * head , int m , int n ) { if ( ! head || m == n ) return head ; ListNode dummy ( 0 ); dummy . next = head ; ListNode * prev = & dummy ; for ( int i = 0 ; i < m - 1 ; ++ i ) prev = prev -> next ; ListNode * tail = prev -> next ; for ( int i = 0 ; i < n - m ; ++ i ) { ListNode * cache = prev -> next ; prev -> next = tail -> next ; tail -> next = tail -> next -> next ; prev -> next -> next = cache ; } return dummy . next ; } }; 93. Restore IP Addresses $\\star\\star$ Time: $O(3^4)$ Space: $O(1)$ class Solution { public : vector < string > restoreIpAddresses ( string s ) { vector < string > ans ; vector < string > path ; function < void ( int ) > dfs = [ & ]( int index ) { if ( path . size () == 4 && index == s . length ()) { ans . push_back ( path [ 0 ] + \".\" + path [ 1 ] + \".\" + path [ 2 ] + \".\" + path [ 3 ]); return ; } if ( path . size () == 4 || index == s . length ()) return ; for ( int i = 1 ; i <= 3 ; ++ i ) { if ( index + i > s . length ()) return ; // out of bound if ( i > 1 && s [ index ] == '0' ) return ; // leading '0' const string num = s . substr ( index , i ); if ( stoi ( num ) > 255 ) return ; path . push_back ( num ); dfs ( index + i ); path . pop_back (); } }; dfs ( 0 ); return ans ; } }; 94. Binary Tree Inorder Traversal $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : vector < int > inorderTraversal ( TreeNode * root ) { vector < int > ans ; stack < TreeNode *> stack ; TreeNode * curr = root ; while ( curr || ! stack . empty ()) { while ( curr ) { stack . push ( curr ); curr = curr -> left ; } curr = stack . top (), stack . pop (); ans . push_back ( curr -> val ); curr = curr -> right ; } return ans ; } }; 95. Unique Binary Search Trees II $\\star\\star$ Time: $O(3^n)$ Space: $O(3^n)$ class Solution { public : vector < TreeNode *> generateTrees ( int n ) { if ( n == 0 ) return {}; return generateTrees ( 1 , n ); } private : vector < TreeNode *> generateTrees ( int min , int max ) { if ( min > max ) return { nullptr }; vector < TreeNode *> ans ; for ( int i = min ; i <= max ; ++ i ) for ( TreeNode * left : generateTrees ( min , i - 1 )) for ( TreeNode * right : generateTrees ( i + 1 , max )) { ans . push_back ( new TreeNode ( i )); ans . back () -> left = left ; ans . back () -> right = right ; } return ans ; } }; 96. Unique Binary Search Trees $\\star\\star$ Time: $O(n^2)$ Space: $O(n)$ class Solution { public : int numTrees ( int n ) { vector < int > G ( n + 1 ); G [ 0 ] = 1 ; G [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) G [ i ] += G [ j ] * G [ i - j - 1 ]; return G [ n ]; } }; 97. Interleaving String $\\star\\star\\star$ Time: $O(mn)$, where m = len(s1) and n = len(s2) Space: $O(mn) \\to O(n)$, where m = len(s1) and n = len(s2) class Solution { public : bool isInterleave ( string s1 , string s2 , string s3 ) { if ( s1 . length () + s2 . length () != s3 . length ()) return false ; vector < vector < bool >> dp ( s1 . length () + 1 , vector < bool > ( s2 . length () + 1 )); for ( int i = 0 ; i <= s1 . length (); ++ i ) for ( int j = 0 ; j <= s2 . length (); ++ j ) if ( i == 0 && j == 0 ) dp [ 0 ][ 0 ] = true ; else if ( i == 0 ) dp [ 0 ][ j ] = s2 [ j - 1 ] == s3 [ j - 1 ] && dp [ 0 ][ j - 1 ]; else if ( j == 0 ) dp [ i ][ 0 ] = s1 [ i - 1 ] == s3 [ i - 1 ] && dp [ i - 1 ][ 0 ]; else dp [ i ][ j ] = ( s1 [ i - 1 ] == s3 [ i + j - 1 ] && dp [ i - 1 ][ j ]) || ( s2 [ j - 1 ] == s3 [ i + j - 1 ] && dp [ i ][ j - 1 ]); return dp [ s1 . length ()][ s2 . length ()]; } }; 98. Validate Binary Search Tree $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : bool isValidBST ( TreeNode * root ) { return dfs ( root , nullptr , nullptr ); } private : bool dfs ( TreeNode * root , TreeNode * minNode , TreeNode * maxNode ) { if ( ! root ) return true ; if ( minNode && minNode -> val >= root -> val || maxNode && maxNode -> val <= root -> val ) return false ; return dfs ( root -> left , minNode , root ) && dfs ( root -> right , root , maxNode ); } }; 99. Recover Binary Search Tree $\\star\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : void recoverTree ( TreeNode * root ) { vector < int > nums ; inorder ( root , nums ); findTwoSwappedNums ( nums ); recover ( root ); } private : int x = - 1 ; int y = - 1 ; void inorder ( TreeNode * root , vector < int >& nums ) { if ( ! root ) return ; inorder ( root -> left , nums ); nums . push_back ( root -> val ); inorder ( root -> right , nums ); } void findTwoSwappedNums ( vector < int >& nums ) { for ( int i = 0 ; i + 1 < nums . size (); ++ i ) if ( nums [ i ] > nums [ i + 1 ]) { y = nums [ i + 1 ]; if ( x == - 1 ) x = nums [ i ]; else break ; } } void recover ( TreeNode * root ) { if ( ! root ) return ; if ( root -> val == x ) root -> val = y ; else if ( root -> val == y ) root -> val = x ; recover ( root -> left ); recover ( root -> right ); } }; 100. Same Tree $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : bool isSameTree ( TreeNode * p , TreeNode * q ) { if ( ! p || ! q ) return p == q ; return p -> val == q -> val && isSameTree ( p -> left , q -> left ) && isSameTree ( p -> right , q -> right ); } };","title":"0091-0100"},{"location":"cpp/0001-0100/0091-0100/#91-decode-ways-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : int numDecodings ( string s ) { const int n = s . length (); vector < int > dp ( n + 1 , 0 ); dp . back () = 1 ; dp [ n - 1 ] = isValid ( s [ n - 1 ]); for ( int i = n - 2 ; i >= 0 ; -- i ) { if ( isValid ( s [ i ], s [ i + 1 ])) dp [ i ] += dp [ i + 2 ]; if ( isValid ( s [ i ])) dp [ i ] += dp [ i + 1 ]; } return dp [ 0 ]; } private : bool isValid ( char c ) { return '1' <= c && c <= '9' ; } bool isValid ( char c1 , char c2 ) { return c1 == '1' || c1 == '2' && '0' <= c2 && c2 <= '6' ; } };","title":"91. Decode Ways $\\star\\star$"},{"location":"cpp/0001-0100/0091-0100/#92-reverse-linked-list-ii-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : ListNode * reverseBetween ( ListNode * head , int m , int n ) { if ( ! head || m == n ) return head ; ListNode dummy ( 0 ); dummy . next = head ; ListNode * prev = & dummy ; for ( int i = 0 ; i < m - 1 ; ++ i ) prev = prev -> next ; ListNode * tail = prev -> next ; for ( int i = 0 ; i < n - m ; ++ i ) { ListNode * cache = prev -> next ; prev -> next = tail -> next ; tail -> next = tail -> next -> next ; prev -> next -> next = cache ; } return dummy . next ; } };","title":"92. Reverse Linked List II $\\star\\star$"},{"location":"cpp/0001-0100/0091-0100/#93-restore-ip-addresses-starstar","text":"Time: $O(3^4)$ Space: $O(1)$ class Solution { public : vector < string > restoreIpAddresses ( string s ) { vector < string > ans ; vector < string > path ; function < void ( int ) > dfs = [ & ]( int index ) { if ( path . size () == 4 && index == s . length ()) { ans . push_back ( path [ 0 ] + \".\" + path [ 1 ] + \".\" + path [ 2 ] + \".\" + path [ 3 ]); return ; } if ( path . size () == 4 || index == s . length ()) return ; for ( int i = 1 ; i <= 3 ; ++ i ) { if ( index + i > s . length ()) return ; // out of bound if ( i > 1 && s [ index ] == '0' ) return ; // leading '0' const string num = s . substr ( index , i ); if ( stoi ( num ) > 255 ) return ; path . push_back ( num ); dfs ( index + i ); path . pop_back (); } }; dfs ( 0 ); return ans ; } };","title":"93. Restore IP Addresses $\\star\\star$"},{"location":"cpp/0001-0100/0091-0100/#94-binary-tree-inorder-traversal-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : vector < int > inorderTraversal ( TreeNode * root ) { vector < int > ans ; stack < TreeNode *> stack ; TreeNode * curr = root ; while ( curr || ! stack . empty ()) { while ( curr ) { stack . push ( curr ); curr = curr -> left ; } curr = stack . top (), stack . pop (); ans . push_back ( curr -> val ); curr = curr -> right ; } return ans ; } };","title":"94. Binary Tree Inorder Traversal $\\star\\star$"},{"location":"cpp/0001-0100/0091-0100/#95-unique-binary-search-trees-ii-starstar","text":"Time: $O(3^n)$ Space: $O(3^n)$ class Solution { public : vector < TreeNode *> generateTrees ( int n ) { if ( n == 0 ) return {}; return generateTrees ( 1 , n ); } private : vector < TreeNode *> generateTrees ( int min , int max ) { if ( min > max ) return { nullptr }; vector < TreeNode *> ans ; for ( int i = min ; i <= max ; ++ i ) for ( TreeNode * left : generateTrees ( min , i - 1 )) for ( TreeNode * right : generateTrees ( i + 1 , max )) { ans . push_back ( new TreeNode ( i )); ans . back () -> left = left ; ans . back () -> right = right ; } return ans ; } };","title":"95. Unique Binary Search Trees II $\\star\\star$"},{"location":"cpp/0001-0100/0091-0100/#96-unique-binary-search-trees-starstar","text":"Time: $O(n^2)$ Space: $O(n)$ class Solution { public : int numTrees ( int n ) { vector < int > G ( n + 1 ); G [ 0 ] = 1 ; G [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) G [ i ] += G [ j ] * G [ i - j - 1 ]; return G [ n ]; } };","title":"96. Unique Binary Search Trees $\\star\\star$"},{"location":"cpp/0001-0100/0091-0100/#97-interleaving-string-starstarstar","text":"Time: $O(mn)$, where m = len(s1) and n = len(s2) Space: $O(mn) \\to O(n)$, where m = len(s1) and n = len(s2) class Solution { public : bool isInterleave ( string s1 , string s2 , string s3 ) { if ( s1 . length () + s2 . length () != s3 . length ()) return false ; vector < vector < bool >> dp ( s1 . length () + 1 , vector < bool > ( s2 . length () + 1 )); for ( int i = 0 ; i <= s1 . length (); ++ i ) for ( int j = 0 ; j <= s2 . length (); ++ j ) if ( i == 0 && j == 0 ) dp [ 0 ][ 0 ] = true ; else if ( i == 0 ) dp [ 0 ][ j ] = s2 [ j - 1 ] == s3 [ j - 1 ] && dp [ 0 ][ j - 1 ]; else if ( j == 0 ) dp [ i ][ 0 ] = s1 [ i - 1 ] == s3 [ i - 1 ] && dp [ i - 1 ][ 0 ]; else dp [ i ][ j ] = ( s1 [ i - 1 ] == s3 [ i + j - 1 ] && dp [ i - 1 ][ j ]) || ( s2 [ j - 1 ] == s3 [ i + j - 1 ] && dp [ i ][ j - 1 ]); return dp [ s1 . length ()][ s2 . length ()]; } };","title":"97. Interleaving String $\\star\\star\\star$"},{"location":"cpp/0001-0100/0091-0100/#98-validate-binary-search-tree-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : bool isValidBST ( TreeNode * root ) { return dfs ( root , nullptr , nullptr ); } private : bool dfs ( TreeNode * root , TreeNode * minNode , TreeNode * maxNode ) { if ( ! root ) return true ; if ( minNode && minNode -> val >= root -> val || maxNode && maxNode -> val <= root -> val ) return false ; return dfs ( root -> left , minNode , root ) && dfs ( root -> right , root , maxNode ); } };","title":"98. Validate Binary Search Tree $\\star\\star$"},{"location":"cpp/0001-0100/0091-0100/#99-recover-binary-search-tree-starstarstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : void recoverTree ( TreeNode * root ) { vector < int > nums ; inorder ( root , nums ); findTwoSwappedNums ( nums ); recover ( root ); } private : int x = - 1 ; int y = - 1 ; void inorder ( TreeNode * root , vector < int >& nums ) { if ( ! root ) return ; inorder ( root -> left , nums ); nums . push_back ( root -> val ); inorder ( root -> right , nums ); } void findTwoSwappedNums ( vector < int >& nums ) { for ( int i = 0 ; i + 1 < nums . size (); ++ i ) if ( nums [ i ] > nums [ i + 1 ]) { y = nums [ i + 1 ]; if ( x == - 1 ) x = nums [ i ]; else break ; } } void recover ( TreeNode * root ) { if ( ! root ) return ; if ( root -> val == x ) root -> val = y ; else if ( root -> val == y ) root -> val = x ; recover ( root -> left ); recover ( root -> right ); } };","title":"99. Recover Binary Search Tree $\\star\\star\\star$"},{"location":"cpp/0001-0100/0091-0100/#100-same-tree-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : bool isSameTree ( TreeNode * p , TreeNode * q ) { if ( ! p || ! q ) return p == q ; return p -> val == q -> val && isSameTree ( p -> left , q -> left ) && isSameTree ( p -> right , q -> right ); } };","title":"100. Same Tree $\\star$"},{"location":"cpp/0101-0200/0101-0110/","text":"101. Symmetric Tree $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : bool isSymmetric ( TreeNode * root ) { return isSymmetric ( root , root ); } private : bool isSymmetric ( TreeNode * p , TreeNode * q ) { if ( ! p || ! q ) return p == q ; return p -> val == q -> val && isSymmetric ( p -> left , q -> right ) && isSymmetric ( p -> right , q -> left ); } }; 102. Binary Tree Level Order Traversal $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : vector < vector < int >> levelOrder ( TreeNode * root ) { if ( ! root ) return {}; vector < vector < int >> ans ; queue < TreeNode *> queue {{ root }}; while ( ! queue . empty ()) { vector < int > currLevel ; for ( int i = queue . size (); i > 0 ; -- i ) { root = queue . front (), queue . pop (); currLevel . push_back ( root -> val ); if ( root -> left ) queue . push ( root -> left ); if ( root -> right ) queue . push ( root -> right ); } ans . push_back ( currLevel ); } return ans ; } }; 103. Binary Tree Zigzag Level Order Traversal $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : vector < vector < int >> zigzagLevelOrder ( TreeNode * root ) { if ( ! root ) return {}; vector < vector < int >> ans ; deque < TreeNode *> deque {{ root }}; bool isLeftToRight = true ; while ( ! deque . empty ()) { vector < int > currLevel ; for ( int i = deque . size (); i > 0 ; -- i ) if ( isLeftToRight ) { root = deque . front (), deque . pop_front (); currLevel . push_back ( root -> val ); if ( root -> left ) deque . push_back ( root -> left ); if ( root -> right ) deque . push_back ( root -> right ); } else { root = deque . back (), deque . pop_back (); currLevel . push_back ( root -> val ); if ( root -> right ) deque . push_front ( root -> right ); if ( root -> left ) deque . push_front ( root -> left ); } ans . push_back ( currLevel ); isLeftToRight = ! isLeftToRight ; } return ans ; } }; 104. Maximum Depth of Binary Tree $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : int maxDepth ( TreeNode * root ) { if ( ! root ) return 0 ; return 1 + max ( maxDepth ( root -> left ), maxDepth ( root -> right )); } }; 105. Construct Binary Tree from Preorder and Inorder Traversal $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : TreeNode * buildTree ( vector < int >& preorder , vector < int >& inorder ) { unordered_map < int , int > inorderToIndex ; for ( int i = 0 ; i < inorder . size (); ++ i ) inorderToIndex [ inorder [ i ]] = i ; function < TreeNode * ( int , int , int , int ) > helper = [ & ]( int pL , int pR , int iL , int iR ) -> TreeNode * { if ( pL > pR ) return nullptr ; const int i = inorderToIndex [ preorder [ pL ]]; TreeNode * curr = new TreeNode ( preorder [ pL ]); curr -> left = helper ( pL + 1 , pL + i - iL , iL , i - 1 ); curr -> right = helper ( pL + i - iL + 1 , pR , i + 1 , iR ); return curr ; }; return helper ( 0 , preorder . size () - 1 , 0 , inorder . size () - 1 ); } }; 106. Construct Binary Tree from Inorder and Postorder Traversal $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : TreeNode * buildTree ( vector < int >& inorder , vector < int >& postorder ) { unordered_map < int , int > inorderToIndex ; for ( int i = 0 ; i < inorder . size (); ++ i ) inorderToIndex [ inorder [ i ]] = i ; function < TreeNode * ( int , int , int , int ) > helper = [ & ]( int iL , int iR , int pL , int pR ) -> TreeNode * { if ( iL > iR ) return nullptr ; const int i = inorderToIndex [ postorder [ pR ]]; TreeNode * curr = new TreeNode ( postorder [ pR ]); curr -> left = helper ( iL , i - 1 , pL , pL + i - iL - 1 ); curr -> right = helper ( i + 1 , iR , pL + i - iL , pR - 1 ); return curr ; }; return helper ( 0 , inorder . size () - 1 , 0 , postorder . size () - 1 ); } }; 107. Binary Tree Level Order Traversal II $\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : vector < vector < int >> levelOrderBottom ( TreeNode * root ) { if ( ! root ) return {}; vector < vector < int >> ans ; queue < TreeNode *> queue {{ root }}; while ( ! queue . empty ()) { vector < int > currLevel ; for ( int i = queue . size (); i > 0 ; -- i ) { root = queue . front (), queue . pop (); currLevel . push_back ( root -> val ); if ( root -> left ) queue . push ( root -> left ); if ( root -> right ) queue . push ( root -> right ); } ans . push_back ( currLevel ); } reverse ( begin ( ans ), end ( ans )); return ans ; } }; 108. Convert Sorted Array to Binary Search Tree $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : TreeNode * sortedArrayToBST ( vector < int >& nums ) { return helper ( nums , 0 , nums . size () - 1 ); } private : TreeNode * helper ( vector < int >& nums , int l , int r ) { if ( l > r ) return nullptr ; const int m = l + ( r - l ) / 2 ; TreeNode * root = new TreeNode ( nums [ m ]); root -> left = helper ( nums , l , m - 1 ); root -> right = helper ( nums , m + 1 , r ); return root ; } }; 109. Convert Sorted List to Binary Search Tree $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : TreeNode * sortedListToBST ( ListNode * head ) { if ( ! head ) return nullptr ; if ( ! head -> next ) return new TreeNode ( head -> val ); ListNode * mid = findMid ( head ); TreeNode * root = new TreeNode ( mid -> val ); root -> left = sortedListToBST ( head ); root -> right = sortedListToBST ( mid -> next ); return root ; } private : ListNode * findMid ( ListNode * head ) { ListNode * prev = nullptr ; ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { prev = slow ; slow = slow -> next ; fast = fast -> next -> next ; } prev -> next = nullptr ; return slow ; } }; 110. Balanced Binary Tree $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : bool isBalanced ( TreeNode * root ) { if ( ! root ) return true ; return abs ( maxDepth ( root -> left ) - maxDepth ( root -> right )) <= 1 && isBalanced ( root -> left ) && isBalanced ( root -> right ); } private : int maxDepth ( TreeNode * root ) { if ( ! root ) return 0 ; return 1 + max ( maxDepth ( root -> left ), maxDepth ( root -> right )); } };","title":"0101-0110"},{"location":"cpp/0101-0200/0101-0110/#101-symmetric-tree-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : bool isSymmetric ( TreeNode * root ) { return isSymmetric ( root , root ); } private : bool isSymmetric ( TreeNode * p , TreeNode * q ) { if ( ! p || ! q ) return p == q ; return p -> val == q -> val && isSymmetric ( p -> left , q -> right ) && isSymmetric ( p -> right , q -> left ); } };","title":"101. Symmetric Tree $\\star$"},{"location":"cpp/0101-0200/0101-0110/#102-binary-tree-level-order-traversal-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : vector < vector < int >> levelOrder ( TreeNode * root ) { if ( ! root ) return {}; vector < vector < int >> ans ; queue < TreeNode *> queue {{ root }}; while ( ! queue . empty ()) { vector < int > currLevel ; for ( int i = queue . size (); i > 0 ; -- i ) { root = queue . front (), queue . pop (); currLevel . push_back ( root -> val ); if ( root -> left ) queue . push ( root -> left ); if ( root -> right ) queue . push ( root -> right ); } ans . push_back ( currLevel ); } return ans ; } };","title":"102. Binary Tree Level Order Traversal $\\star\\star$"},{"location":"cpp/0101-0200/0101-0110/#103-binary-tree-zigzag-level-order-traversal-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : vector < vector < int >> zigzagLevelOrder ( TreeNode * root ) { if ( ! root ) return {}; vector < vector < int >> ans ; deque < TreeNode *> deque {{ root }}; bool isLeftToRight = true ; while ( ! deque . empty ()) { vector < int > currLevel ; for ( int i = deque . size (); i > 0 ; -- i ) if ( isLeftToRight ) { root = deque . front (), deque . pop_front (); currLevel . push_back ( root -> val ); if ( root -> left ) deque . push_back ( root -> left ); if ( root -> right ) deque . push_back ( root -> right ); } else { root = deque . back (), deque . pop_back (); currLevel . push_back ( root -> val ); if ( root -> right ) deque . push_front ( root -> right ); if ( root -> left ) deque . push_front ( root -> left ); } ans . push_back ( currLevel ); isLeftToRight = ! isLeftToRight ; } return ans ; } };","title":"103. Binary Tree Zigzag Level Order Traversal $\\star\\star$"},{"location":"cpp/0101-0200/0101-0110/#104-maximum-depth-of-binary-tree-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : int maxDepth ( TreeNode * root ) { if ( ! root ) return 0 ; return 1 + max ( maxDepth ( root -> left ), maxDepth ( root -> right )); } };","title":"104. Maximum Depth of Binary Tree $\\star$"},{"location":"cpp/0101-0200/0101-0110/#105-construct-binary-tree-from-preorder-and-inorder-traversal-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : TreeNode * buildTree ( vector < int >& preorder , vector < int >& inorder ) { unordered_map < int , int > inorderToIndex ; for ( int i = 0 ; i < inorder . size (); ++ i ) inorderToIndex [ inorder [ i ]] = i ; function < TreeNode * ( int , int , int , int ) > helper = [ & ]( int pL , int pR , int iL , int iR ) -> TreeNode * { if ( pL > pR ) return nullptr ; const int i = inorderToIndex [ preorder [ pL ]]; TreeNode * curr = new TreeNode ( preorder [ pL ]); curr -> left = helper ( pL + 1 , pL + i - iL , iL , i - 1 ); curr -> right = helper ( pL + i - iL + 1 , pR , i + 1 , iR ); return curr ; }; return helper ( 0 , preorder . size () - 1 , 0 , inorder . size () - 1 ); } };","title":"105. Construct Binary Tree from Preorder and Inorder Traversal $\\star\\star$"},{"location":"cpp/0101-0200/0101-0110/#106-construct-binary-tree-from-inorder-and-postorder-traversal-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : TreeNode * buildTree ( vector < int >& inorder , vector < int >& postorder ) { unordered_map < int , int > inorderToIndex ; for ( int i = 0 ; i < inorder . size (); ++ i ) inorderToIndex [ inorder [ i ]] = i ; function < TreeNode * ( int , int , int , int ) > helper = [ & ]( int iL , int iR , int pL , int pR ) -> TreeNode * { if ( iL > iR ) return nullptr ; const int i = inorderToIndex [ postorder [ pR ]]; TreeNode * curr = new TreeNode ( postorder [ pR ]); curr -> left = helper ( iL , i - 1 , pL , pL + i - iL - 1 ); curr -> right = helper ( i + 1 , iR , pL + i - iL , pR - 1 ); return curr ; }; return helper ( 0 , inorder . size () - 1 , 0 , postorder . size () - 1 ); } };","title":"106. Construct Binary Tree from Inorder and Postorder Traversal $\\star\\star$"},{"location":"cpp/0101-0200/0101-0110/#107-binary-tree-level-order-traversal-ii-star","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : vector < vector < int >> levelOrderBottom ( TreeNode * root ) { if ( ! root ) return {}; vector < vector < int >> ans ; queue < TreeNode *> queue {{ root }}; while ( ! queue . empty ()) { vector < int > currLevel ; for ( int i = queue . size (); i > 0 ; -- i ) { root = queue . front (), queue . pop (); currLevel . push_back ( root -> val ); if ( root -> left ) queue . push ( root -> left ); if ( root -> right ) queue . push ( root -> right ); } ans . push_back ( currLevel ); } reverse ( begin ( ans ), end ( ans )); return ans ; } };","title":"107. Binary Tree Level Order Traversal II $\\star$"},{"location":"cpp/0101-0200/0101-0110/#108-convert-sorted-array-to-binary-search-tree-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : TreeNode * sortedArrayToBST ( vector < int >& nums ) { return helper ( nums , 0 , nums . size () - 1 ); } private : TreeNode * helper ( vector < int >& nums , int l , int r ) { if ( l > r ) return nullptr ; const int m = l + ( r - l ) / 2 ; TreeNode * root = new TreeNode ( nums [ m ]); root -> left = helper ( nums , l , m - 1 ); root -> right = helper ( nums , m + 1 , r ); return root ; } };","title":"108. Convert Sorted Array to Binary Search Tree $\\star$"},{"location":"cpp/0101-0200/0101-0110/#109-convert-sorted-list-to-binary-search-tree-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : TreeNode * sortedListToBST ( ListNode * head ) { if ( ! head ) return nullptr ; if ( ! head -> next ) return new TreeNode ( head -> val ); ListNode * mid = findMid ( head ); TreeNode * root = new TreeNode ( mid -> val ); root -> left = sortedListToBST ( head ); root -> right = sortedListToBST ( mid -> next ); return root ; } private : ListNode * findMid ( ListNode * head ) { ListNode * prev = nullptr ; ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { prev = slow ; slow = slow -> next ; fast = fast -> next -> next ; } prev -> next = nullptr ; return slow ; } };","title":"109. Convert Sorted List to Binary Search Tree $\\star\\star$"},{"location":"cpp/0101-0200/0101-0110/#110-balanced-binary-tree-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : bool isBalanced ( TreeNode * root ) { if ( ! root ) return true ; return abs ( maxDepth ( root -> left ) - maxDepth ( root -> right )) <= 1 && isBalanced ( root -> left ) && isBalanced ( root -> right ); } private : int maxDepth ( TreeNode * root ) { if ( ! root ) return 0 ; return 1 + max ( maxDepth ( root -> left ), maxDepth ( root -> right )); } };","title":"110. Balanced Binary Tree $\\star$"},{"location":"cpp/0101-0200/0111-0120/","text":"111. Minimum Depth of Binary Tree $\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : int minDepth ( TreeNode * root ) { if ( ! root ) return 0 ; int ans = 0 ; queue < TreeNode *> queue {{ root }}; while ( ! queue . empty ()) { ++ ans ; for ( int i = queue . size (); i > 0 ; -- i ) { root = queue . front (), queue . pop (); if ( ! root -> left && ! root -> right ) return ans ; if ( root -> left ) queue . push ( root -> left ); if ( root -> right ) queue . push ( root -> right ); } } throw ; } }; 112. Path Sum $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : bool hasPathSum ( TreeNode * root , int sum ) { if ( ! root ) return false ; if ( root -> val == sum && ! root -> left && ! root -> right ) return true ; return hasPathSum ( root -> left , sum - root -> val ) || hasPathSum ( root -> right , sum - root -> val ); } }; 113. Path Sum II $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : vector < vector < int >> pathSum ( TreeNode * root , int sum ) { vector < vector < int >> ans ; vector < int > path ; function < void ( TreeNode * , int ) > dfs = [ & ]( TreeNode * root , int sum ) { if ( ! root ) return ; if ( root -> val == sum && ! root -> left && ! root -> right ) { path . push_back ( root -> val ); ans . push_back ( path ); path . pop_back (); return ; } path . push_back ( root -> val ); dfs ( root -> left , sum - root -> val ); dfs ( root -> right , sum - root -> val ); path . pop_back (); }; dfs ( root , sum ); return ans ; } }; 114. Flatten Binary Tree to Linked List $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : void flatten ( TreeNode * root ) { if ( ! root ) return ; stack < TreeNode *> stack {{ root }}; while ( ! stack . empty ()) { root = stack . top (), stack . pop (); if ( root -> right ) stack . push ( root -> right ); if ( root -> left ) stack . push ( root -> left ); if ( ! stack . empty ()) root -> right = stack . top (); root -> left = nullptr ; } } }; 115. Distinct Subsequences $\\star\\star\\star$ Time: $O(mn)$ Space: $O(mn) \\to O(n)$ class Solution { public : int numDistinct ( string s , string t ) { const int m = s . length (); const int n = t . length (); vector < vector < long >> dp ( m + 1 , vector < long > ( n + 1 )); for ( int i = 0 ; i <= m ; ++ i ) dp [ i ][ 0 ] = 1 ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( s [ i - 1 ] == t [ j - 1 ]) dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ] + dp [ i - 1 ][ j ]; else dp [ i ][ j ] = dp [ i - 1 ][ j ]; return dp [ m ][ n ]; } }; 116. Populating Next Right Pointers in Each Node $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : Node * connect ( Node * root ) { Node * node = root ; while ( node && node -> left ) { Node * next = node -> left ; while ( node ) { node -> left -> next = node -> right ; node -> right -> next = node -> next ? node -> next -> left : nullptr ; node = node -> next ; } node = next ; } return root ; } }; 117. Populating Next Right Pointers in Each Node II $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : Node * connect ( Node * root ) { Node * node = root ; Node * cache = new Node ; while ( node ) { Node * curr = cache ; while ( node ) { if ( node -> left ) { curr -> next = node -> left ; curr = curr -> next ; } if ( node -> right ) { curr -> next = node -> right ; curr = curr -> next ; } node = node -> next ; } node = cache -> next ; cache -> next = nullptr ; } return root ; } }; 118. Pascal's Triangle $\\star$ Time: $O(n^2)$ Space: $O(n^2)$ class Solution { public : vector < vector < int >> generate ( int numRows ) { vector < vector < int >> ans ; for ( int i = 0 ; i < numRows ; ++ i ) ans . push_back ( vector < int > ( i + 1 , 1 )); for ( int i = 2 ; i < numRows ; ++ i ) for ( int j = 1 ; j < ans [ i ]. size () - 1 ; j ++ ) ans [ i ][ j ] = ans [ i - 1 ][ j - 1 ] + ans [ i - 1 ][ j ]; return ans ; } }; 119. Pascal's Triangle II $\\star$ Time: $O(k^2)$ Space: $O(k)$ class Solution { public : vector < int > getRow ( int rowIndex ) { vector < int > ans ( rowIndex + 1 , 1 ); for ( int i = 2 ; i < rowIndex + 1 ; ++ i ) for ( int j = 1 ; j < i ; ++ j ) ans [ i - j ] += ans [ i - j - 1 ]; return ans ; } }; 120. Triangle $\\star\\star$ Time: $O(n^2)$ Space: $O(1)$ class Solution { public : int minimumTotal ( vector < vector < int >>& triangle ) { for ( int i = triangle . size () - 2 ; i >= 0 ; -- i ) for ( int j = 0 ; j <= i ; ++ j ) triangle [ i ][ j ] += min ( triangle [ i + 1 ][ j ], triangle [ i + 1 ][ j + 1 ]); return triangle [ 0 ][ 0 ]; } };","title":"0111-0120"},{"location":"cpp/0101-0200/0111-0120/#111-minimum-depth-of-binary-tree-star","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : int minDepth ( TreeNode * root ) { if ( ! root ) return 0 ; int ans = 0 ; queue < TreeNode *> queue {{ root }}; while ( ! queue . empty ()) { ++ ans ; for ( int i = queue . size (); i > 0 ; -- i ) { root = queue . front (), queue . pop (); if ( ! root -> left && ! root -> right ) return ans ; if ( root -> left ) queue . push ( root -> left ); if ( root -> right ) queue . push ( root -> right ); } } throw ; } };","title":"111. Minimum Depth of Binary Tree $\\star$"},{"location":"cpp/0101-0200/0111-0120/#112-path-sum-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : bool hasPathSum ( TreeNode * root , int sum ) { if ( ! root ) return false ; if ( root -> val == sum && ! root -> left && ! root -> right ) return true ; return hasPathSum ( root -> left , sum - root -> val ) || hasPathSum ( root -> right , sum - root -> val ); } };","title":"112. Path Sum $\\star$"},{"location":"cpp/0101-0200/0111-0120/#113-path-sum-ii-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : vector < vector < int >> pathSum ( TreeNode * root , int sum ) { vector < vector < int >> ans ; vector < int > path ; function < void ( TreeNode * , int ) > dfs = [ & ]( TreeNode * root , int sum ) { if ( ! root ) return ; if ( root -> val == sum && ! root -> left && ! root -> right ) { path . push_back ( root -> val ); ans . push_back ( path ); path . pop_back (); return ; } path . push_back ( root -> val ); dfs ( root -> left , sum - root -> val ); dfs ( root -> right , sum - root -> val ); path . pop_back (); }; dfs ( root , sum ); return ans ; } };","title":"113. Path Sum II $\\star\\star$"},{"location":"cpp/0101-0200/0111-0120/#114-flatten-binary-tree-to-linked-list-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : void flatten ( TreeNode * root ) { if ( ! root ) return ; stack < TreeNode *> stack {{ root }}; while ( ! stack . empty ()) { root = stack . top (), stack . pop (); if ( root -> right ) stack . push ( root -> right ); if ( root -> left ) stack . push ( root -> left ); if ( ! stack . empty ()) root -> right = stack . top (); root -> left = nullptr ; } } };","title":"114. Flatten Binary Tree to Linked List $\\star\\star$"},{"location":"cpp/0101-0200/0111-0120/#115-distinct-subsequences-starstarstar","text":"Time: $O(mn)$ Space: $O(mn) \\to O(n)$ class Solution { public : int numDistinct ( string s , string t ) { const int m = s . length (); const int n = t . length (); vector < vector < long >> dp ( m + 1 , vector < long > ( n + 1 )); for ( int i = 0 ; i <= m ; ++ i ) dp [ i ][ 0 ] = 1 ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) if ( s [ i - 1 ] == t [ j - 1 ]) dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ] + dp [ i - 1 ][ j ]; else dp [ i ][ j ] = dp [ i - 1 ][ j ]; return dp [ m ][ n ]; } };","title":"115. Distinct Subsequences $\\star\\star\\star$"},{"location":"cpp/0101-0200/0111-0120/#116-populating-next-right-pointers-in-each-node-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : Node * connect ( Node * root ) { Node * node = root ; while ( node && node -> left ) { Node * next = node -> left ; while ( node ) { node -> left -> next = node -> right ; node -> right -> next = node -> next ? node -> next -> left : nullptr ; node = node -> next ; } node = next ; } return root ; } };","title":"116. Populating Next Right Pointers in Each Node $\\star\\star$"},{"location":"cpp/0101-0200/0111-0120/#117-populating-next-right-pointers-in-each-node-ii-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : Node * connect ( Node * root ) { Node * node = root ; Node * cache = new Node ; while ( node ) { Node * curr = cache ; while ( node ) { if ( node -> left ) { curr -> next = node -> left ; curr = curr -> next ; } if ( node -> right ) { curr -> next = node -> right ; curr = curr -> next ; } node = node -> next ; } node = cache -> next ; cache -> next = nullptr ; } return root ; } };","title":"117. Populating Next Right Pointers in Each Node II $\\star\\star$"},{"location":"cpp/0101-0200/0111-0120/#118-pascals-triangle-star","text":"Time: $O(n^2)$ Space: $O(n^2)$ class Solution { public : vector < vector < int >> generate ( int numRows ) { vector < vector < int >> ans ; for ( int i = 0 ; i < numRows ; ++ i ) ans . push_back ( vector < int > ( i + 1 , 1 )); for ( int i = 2 ; i < numRows ; ++ i ) for ( int j = 1 ; j < ans [ i ]. size () - 1 ; j ++ ) ans [ i ][ j ] = ans [ i - 1 ][ j - 1 ] + ans [ i - 1 ][ j ]; return ans ; } };","title":"118. Pascal's Triangle $\\star$"},{"location":"cpp/0101-0200/0111-0120/#119-pascals-triangle-ii-star","text":"Time: $O(k^2)$ Space: $O(k)$ class Solution { public : vector < int > getRow ( int rowIndex ) { vector < int > ans ( rowIndex + 1 , 1 ); for ( int i = 2 ; i < rowIndex + 1 ; ++ i ) for ( int j = 1 ; j < i ; ++ j ) ans [ i - j ] += ans [ i - j - 1 ]; return ans ; } };","title":"119. Pascal's Triangle II $\\star$"},{"location":"cpp/0101-0200/0111-0120/#120-triangle-starstar","text":"Time: $O(n^2)$ Space: $O(1)$ class Solution { public : int minimumTotal ( vector < vector < int >>& triangle ) { for ( int i = triangle . size () - 2 ; i >= 0 ; -- i ) for ( int j = 0 ; j <= i ; ++ j ) triangle [ i ][ j ] += min ( triangle [ i + 1 ][ j ], triangle [ i + 1 ][ j + 1 ]); return triangle [ 0 ][ 0 ]; } };","title":"120. Triangle $\\star\\star$"},{"location":"cpp/0101-0200/0121-0130/","text":"121. Best Time to Buy and Sell Stock $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : int maxProfit ( vector < int >& prices ) { int sellOne = 0 ; int holdOne = INT_MIN ; for ( const int price : prices ) { sellOne = max ( sellOne , holdOne + price ); holdOne = max ( holdOne , - price ); } return sellOne ; } }; 122. Best Time to Buy and Sell Stock II $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : int maxProfit ( vector < int >& prices ) { int sell = 0 ; int hold = INT_MIN ; for ( const int price : prices ) { sell = max ( sell , hold + price ); hold = max ( hold , sell - price ); } return sell ; } }; 123. Best Time to Buy and Sell Stock III $\\star\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : int maxProfit ( vector < int >& prices ) { int sellTwo = 0 ; int holdTwo = INT_MIN ; int sellOne = 0 ; int holdOne = INT_MIN ; for ( const int price : prices ) { sellTwo = max ( sellTwo , holdTwo + price ); holdTwo = max ( holdTwo , sellOne - price ); sellOne = max ( sellOne , holdOne + price ); holdOne = max ( holdOne , - price ); } return sellTwo ; } }; 124. Binary Tree Maximum Path Sum $\\star\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : int maxPathSum ( TreeNode * root ) { int ans = INT_MIN ; function < int ( TreeNode * ) > maxPathSumDownFrom = [ & ]( TreeNode * root ) { if ( ! root ) return 0 ; const int left = max ( maxPathSumDownFrom ( root -> left ), 0 ); const int right = max ( maxPathSumDownFrom ( root -> right ), 0 ); ans = max ( ans , root -> val + left + right ); return root -> val + max ( left , right ); }; maxPathSumDownFrom ( root ); return ans ; } }; 125. Valid Palindrome $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : bool isPalindrome ( string s ) { int l = 0 ; int r = s . length () - 1 ; while ( l < r ) { while ( l < r && ! isalnum ( s [ l ])) ++ l ; while ( l < r && ! isalnum ( s [ r ])) -- r ; if ( tolower ( s [ l ]) != tolower ( s [ r ])) return false ; ++ l ; -- r ; } return true ; } }; 126. Word Ladder II $\\star\\star\\star$ Time: $O(n26^l)$, where n = len(wordList) and l = len(word) Space: $O(n + kl)$, where k = #paths class Solution { public : vector < vector < string >> findLadders ( string beginWord , string endWord , vector < string >& wordList ) { unordered_set < string > wordListSet ( begin ( wordList ), end ( wordList )); if ( ! wordListSet . count ( endWord )) return {}; // prune (still AC if this line is removed) vector < vector < string >> ans ; unordered_map < string , vector < string >> parentToWords ; unordered_set < string > currentLevelWords { beginWord }; bool isFound = false ; while ( ! currentLevelWords . empty () && ! isFound ) { // remove words in current level for ( const string & word : currentLevelWords ) wordListSet . erase ( word ); unordered_set < string > nextLevelWords ; // `parent` will be used as a key in `parentToWords` for ( const string & parent : currentLevelWords ) { string nextWord = parent ; // enumerate next level words for ( int i = 0 ; i < nextWord . length (); ++ i ) { const char cache = nextWord [ i ]; for ( char c = 'a' ; c <= 'z' ; ++ c ) { nextWord [ i ] = c ; if ( wordListSet . count ( nextWord )) { if ( nextWord == endWord ) isFound = true ; nextLevelWords . insert ( nextWord ); parentToWords [ parent ]. push_back ( nextWord ); } } nextWord [ i ] = cache ; } } if ( isFound ) break ; swap ( currentLevelWords , nextLevelWords ); } // construct the ans by `parentToWords` function < void ( const string & , vector < string >& ) > dfs = [ & ]( const string & word , vector < string >& path ) { if ( word == endWord ) { ans . push_back ( path ); return ; } if ( ! parentToWords . count ( word )) return ; for ( const string & child : parentToWords [ word ]) { path . push_back ( child ); dfs ( child , path ); path . pop_back (); } }; if ( isFound ) { vector < string > path { beginWord }; dfs ( beginWord , path ); } return ans ; } }; 127. Word Ladder $\\star\\star$ Time: $O(n26^l)$, where n = len(wordList) and l = len(word) Space: $O(n)$ class Solution { public : int ladderLength ( string beginWord , string endWord , vector < string >& wordList ) { unordered_set < string > wordListSet ( begin ( wordList ), end ( wordList )); if ( ! wordListSet . count ( endWord )) return 0 ; int ans = 0 ; queue < string > queue {{ beginWord }}; while ( ! queue . empty ()) { ++ ans ; for ( int i = queue . size (); i > 0 ; -- i ) { string word = queue . front (); queue . pop (); for ( int i = 0 ; i < word . length (); ++ i ) { const char cache = word [ i ]; for ( char c = 'a' ; c <= 'z' ; ++ c ) { word [ i ] = c ; if ( word == endWord ) return ans + 1 ; if ( wordListSet . count ( word )) { wordListSet . erase ( word ); queue . push ( word ); } } word [ i ] = cache ; } } } return 0 ; } }; 128. Longest Consecutive Sequence $\\star\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : int longestConsecutive ( vector < int >& nums ) { int ans = 0 ; unordered_set < int > set { begin ( nums ), end ( nums )}; for ( long num : nums ) if ( ! set . count ( num - 1 )) { int length = 0 ; while ( set . count ( num ++ )) ++ length ; ans = max ( ans , length ); } return ans ; } }; 129. Sum Root to Leaf Numbers $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : int sumNumbers ( TreeNode * root ) { int ans = 0 ; function < void ( TreeNode * , int ) > dfs = [ & ]( TreeNode * root , int path ) { if ( ! root ) return ; if ( ! root -> left && ! root -> right ) { ans += path * 10 + root -> val ; return ; } dfs ( root -> left , path * 10 + root -> val ); dfs ( root -> right , path * 10 + root -> val ); }; dfs ( root , 0 ); return ans ; } }; 130. Surrounded Regions $\\star\\star$ Time: $O(mn)$ Space: $O(1)$ class Solution { public : void solve ( vector < vector < char >>& board ) { if ( board . empty ()) return ; const int m = board . size (); const int n = board [ 0 ]. size (); function < void ( int , int ) > dfs = [ & ]( int i , int j ) { if ( i < 0 || i == m || j < 0 || j == n ) return ; if ( board [ i ][ j ] != 'O' ) return ; board [ i ][ j ] = '*' ; dfs ( i + 1 , j ); dfs ( i - 1 , j ); dfs ( i , j + 1 ); dfs ( i , j - 1 ); }; for ( int i = 0 ; i < m ; ++ i ) { dfs ( i , 0 ); dfs ( i , n - 1 ); } for ( int j = 1 ; j < n - 1 ; ++ j ) { dfs ( 0 , j ); dfs ( m - 1 , j ); } for ( vector < char >& row : board ) for ( char & c : row ) c = ( c == '*' ? 'O' : 'X' ); } };","title":"0121-0130"},{"location":"cpp/0101-0200/0121-0130/#121-best-time-to-buy-and-sell-stock-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : int maxProfit ( vector < int >& prices ) { int sellOne = 0 ; int holdOne = INT_MIN ; for ( const int price : prices ) { sellOne = max ( sellOne , holdOne + price ); holdOne = max ( holdOne , - price ); } return sellOne ; } };","title":"121. Best Time to Buy and Sell Stock $\\star$"},{"location":"cpp/0101-0200/0121-0130/#122-best-time-to-buy-and-sell-stock-ii-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : int maxProfit ( vector < int >& prices ) { int sell = 0 ; int hold = INT_MIN ; for ( const int price : prices ) { sell = max ( sell , hold + price ); hold = max ( hold , sell - price ); } return sell ; } };","title":"122. Best Time to Buy and Sell Stock II $\\star$"},{"location":"cpp/0101-0200/0121-0130/#123-best-time-to-buy-and-sell-stock-iii-starstarstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : int maxProfit ( vector < int >& prices ) { int sellTwo = 0 ; int holdTwo = INT_MIN ; int sellOne = 0 ; int holdOne = INT_MIN ; for ( const int price : prices ) { sellTwo = max ( sellTwo , holdTwo + price ); holdTwo = max ( holdTwo , sellOne - price ); sellOne = max ( sellOne , holdOne + price ); holdOne = max ( holdOne , - price ); } return sellTwo ; } };","title":"123. Best Time to Buy and Sell Stock III $\\star\\star\\star$"},{"location":"cpp/0101-0200/0121-0130/#124-binary-tree-maximum-path-sum-starstarstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : int maxPathSum ( TreeNode * root ) { int ans = INT_MIN ; function < int ( TreeNode * ) > maxPathSumDownFrom = [ & ]( TreeNode * root ) { if ( ! root ) return 0 ; const int left = max ( maxPathSumDownFrom ( root -> left ), 0 ); const int right = max ( maxPathSumDownFrom ( root -> right ), 0 ); ans = max ( ans , root -> val + left + right ); return root -> val + max ( left , right ); }; maxPathSumDownFrom ( root ); return ans ; } };","title":"124. Binary Tree Maximum Path Sum $\\star\\star\\star$"},{"location":"cpp/0101-0200/0121-0130/#125-valid-palindrome-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : bool isPalindrome ( string s ) { int l = 0 ; int r = s . length () - 1 ; while ( l < r ) { while ( l < r && ! isalnum ( s [ l ])) ++ l ; while ( l < r && ! isalnum ( s [ r ])) -- r ; if ( tolower ( s [ l ]) != tolower ( s [ r ])) return false ; ++ l ; -- r ; } return true ; } };","title":"125. Valid Palindrome $\\star$"},{"location":"cpp/0101-0200/0121-0130/#126-word-ladder-ii-starstarstar","text":"Time: $O(n26^l)$, where n = len(wordList) and l = len(word) Space: $O(n + kl)$, where k = #paths class Solution { public : vector < vector < string >> findLadders ( string beginWord , string endWord , vector < string >& wordList ) { unordered_set < string > wordListSet ( begin ( wordList ), end ( wordList )); if ( ! wordListSet . count ( endWord )) return {}; // prune (still AC if this line is removed) vector < vector < string >> ans ; unordered_map < string , vector < string >> parentToWords ; unordered_set < string > currentLevelWords { beginWord }; bool isFound = false ; while ( ! currentLevelWords . empty () && ! isFound ) { // remove words in current level for ( const string & word : currentLevelWords ) wordListSet . erase ( word ); unordered_set < string > nextLevelWords ; // `parent` will be used as a key in `parentToWords` for ( const string & parent : currentLevelWords ) { string nextWord = parent ; // enumerate next level words for ( int i = 0 ; i < nextWord . length (); ++ i ) { const char cache = nextWord [ i ]; for ( char c = 'a' ; c <= 'z' ; ++ c ) { nextWord [ i ] = c ; if ( wordListSet . count ( nextWord )) { if ( nextWord == endWord ) isFound = true ; nextLevelWords . insert ( nextWord ); parentToWords [ parent ]. push_back ( nextWord ); } } nextWord [ i ] = cache ; } } if ( isFound ) break ; swap ( currentLevelWords , nextLevelWords ); } // construct the ans by `parentToWords` function < void ( const string & , vector < string >& ) > dfs = [ & ]( const string & word , vector < string >& path ) { if ( word == endWord ) { ans . push_back ( path ); return ; } if ( ! parentToWords . count ( word )) return ; for ( const string & child : parentToWords [ word ]) { path . push_back ( child ); dfs ( child , path ); path . pop_back (); } }; if ( isFound ) { vector < string > path { beginWord }; dfs ( beginWord , path ); } return ans ; } };","title":"126. Word Ladder II $\\star\\star\\star$"},{"location":"cpp/0101-0200/0121-0130/#127-word-ladder-starstar","text":"Time: $O(n26^l)$, where n = len(wordList) and l = len(word) Space: $O(n)$ class Solution { public : int ladderLength ( string beginWord , string endWord , vector < string >& wordList ) { unordered_set < string > wordListSet ( begin ( wordList ), end ( wordList )); if ( ! wordListSet . count ( endWord )) return 0 ; int ans = 0 ; queue < string > queue {{ beginWord }}; while ( ! queue . empty ()) { ++ ans ; for ( int i = queue . size (); i > 0 ; -- i ) { string word = queue . front (); queue . pop (); for ( int i = 0 ; i < word . length (); ++ i ) { const char cache = word [ i ]; for ( char c = 'a' ; c <= 'z' ; ++ c ) { word [ i ] = c ; if ( word == endWord ) return ans + 1 ; if ( wordListSet . count ( word )) { wordListSet . erase ( word ); queue . push ( word ); } } word [ i ] = cache ; } } } return 0 ; } };","title":"127. Word Ladder $\\star\\star$"},{"location":"cpp/0101-0200/0121-0130/#128-longest-consecutive-sequence-starstarstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : int longestConsecutive ( vector < int >& nums ) { int ans = 0 ; unordered_set < int > set { begin ( nums ), end ( nums )}; for ( long num : nums ) if ( ! set . count ( num - 1 )) { int length = 0 ; while ( set . count ( num ++ )) ++ length ; ans = max ( ans , length ); } return ans ; } };","title":"128. Longest Consecutive Sequence $\\star\\star\\star$"},{"location":"cpp/0101-0200/0121-0130/#129-sum-root-to-leaf-numbers-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : int sumNumbers ( TreeNode * root ) { int ans = 0 ; function < void ( TreeNode * , int ) > dfs = [ & ]( TreeNode * root , int path ) { if ( ! root ) return ; if ( ! root -> left && ! root -> right ) { ans += path * 10 + root -> val ; return ; } dfs ( root -> left , path * 10 + root -> val ); dfs ( root -> right , path * 10 + root -> val ); }; dfs ( root , 0 ); return ans ; } };","title":"129. Sum Root to Leaf Numbers $\\star\\star$"},{"location":"cpp/0101-0200/0121-0130/#130-surrounded-regions-starstar","text":"Time: $O(mn)$ Space: $O(1)$ class Solution { public : void solve ( vector < vector < char >>& board ) { if ( board . empty ()) return ; const int m = board . size (); const int n = board [ 0 ]. size (); function < void ( int , int ) > dfs = [ & ]( int i , int j ) { if ( i < 0 || i == m || j < 0 || j == n ) return ; if ( board [ i ][ j ] != 'O' ) return ; board [ i ][ j ] = '*' ; dfs ( i + 1 , j ); dfs ( i - 1 , j ); dfs ( i , j + 1 ); dfs ( i , j - 1 ); }; for ( int i = 0 ; i < m ; ++ i ) { dfs ( i , 0 ); dfs ( i , n - 1 ); } for ( int j = 1 ; j < n - 1 ; ++ j ) { dfs ( 0 , j ); dfs ( m - 1 , j ); } for ( vector < char >& row : board ) for ( char & c : row ) c = ( c == '*' ? 'O' : 'X' ); } };","title":"130. Surrounded Regions $\\star\\star$"},{"location":"cpp/0101-0200/0131-0140/","text":"131. Palindrome Partitioning $\\star\\star$ Time: $O(n2^n)$ Space: $O(n2^n)$ class Solution { public : vector < vector < string >> partition ( string s ) { vector < vector < string >> ans ; vector < string > path ; auto isPalindrome = []( const string & s , int l , int r ) { while ( l < r ) if ( s [ l ++ ] != s [ r -- ]) return false ; return true ; }; function < void ( int ) > dfs = [ & ]( int startIndex ) { if ( startIndex == s . length ()) { ans . push_back ( path ); return ; } for ( int i = startIndex ; i < s . length (); ++ i ) if ( isPalindrome ( s , startIndex , i )) { path . push_back ( s . substr ( startIndex , i - startIndex + 1 )); dfs ( i + 1 ); path . pop_back (); } }; dfs ( 0 ); return ans ; } }; 132. Palindrome Partitioning II $\\star\\star\\star$ Time: $O(mn)$ Space: $O(mn)$ class Solution { public : int minCut ( string s ) { const int n = s . length (); vector < vector < bool >> isPalindrome ( n , vector < bool > ( n , true )); vector < int > dp ( n , n ); for ( int length = 2 ; length <= n ; ++ length ) for ( int i = 0 , j = length - 1 ; j < n ; ++ i , ++ j ) isPalindrome [ i ][ j ] = s [ i ] == s [ j ] && isPalindrome [ i + 1 ][ j - 1 ]; for ( int i = 0 ; i < n ; ++ i ) { if ( isPalindrome [ 0 ][ i ]) { dp [ i ] = 0 ; continue ; } for ( int j = 0 ; j < i ; ++ j ) if ( isPalindrome [ j + 1 ][ i ]) dp [ i ] = min ( dp [ i ], dp [ j ] + 1 ); } return dp [ n - 1 ]; } }; 133. Clone Graph $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : Node * cloneGraph ( Node * node ) { if ( ! node ) return nullptr ; if ( map . count ( node )) return map [ node ]; map [ node ] = new Node ( node -> val , {}); for ( Node * neighbor : node -> neighbors ) map [ node ] -> neighbors . push_back ( cloneGraph ( neighbor )); return map [ node ]; } private : unordered_map < Node * , Node *> map ; }; 134. Gas Station $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : int canCompleteCircuit ( vector < int >& gas , vector < int >& cost ) { int ans = 0 ; int net = 0 ; int sum = 0 ; for ( int i = 0 ; i < gas . size (); ++ i ) { net += gas [ i ] - cost [ i ]; sum += gas [ i ] - cost [ i ]; if ( sum < 0 ) { sum = 0 ; ans = i + 1 ; } } return net < 0 ? - 1 : ans ; } }; 135. Candy $\\star\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : int candy ( vector < int >& ratings ) { const int n = ratings . size (); int ans = 0 ; vector < int > l ( n , 1 ); vector < int > r ( n , 1 ); for ( int i = 1 ; i < n ; ++ i ) if ( ratings [ i ] > ratings [ i - 1 ]) l [ i ] = l [ i - 1 ] + 1 ; for ( int i = n - 2 ; i >= 0 ; -- i ) if ( ratings [ i ] > ratings [ i + 1 ]) r [ i ] = r [ i + 1 ] + 1 ; for ( int i = 0 ; i < n ; ++ i ) ans += max ( l [ i ], r [ i ]); return ans ; } }; 136. Single Number $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : int singleNumber ( vector < int >& nums ) { int ans = 0 ; for ( const int num : nums ) ans ^= num ; return ans ; } }; 137. Single Number II $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : int singleNumber ( vector < int >& nums ) { int ones = 0 ; int twos = 0 ; for ( const int num : nums ) { ones ^= ( num & ~ twos ); twos ^= ( num & ~ ones ); } return ones ; } }; 138. Copy List with Random Pointer $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : Node * copyRandomList ( Node * head ) { if ( ! head ) return nullptr ; if ( map . count ( head )) return map [ head ]; map [ head ] = new Node ( head -> val ); map [ head ] -> next = copyRandomList ( head -> next ); map [ head ] -> random = copyRandomList ( head -> random ); return map [ head ]; } private : unordered_map < Node * , Node *> map ; }; 139. Word Break $\\star\\star$ Time: $O(n^2)$ Space: $O(n)$ class Solution { public : bool wordBreak ( string s , vector < string >& wordDict ) { const int n = s . length (); unordered_set < string > wordSet { begin ( wordDict ), end ( wordDict )}; vector < bool > dp ( n + 1 ); dp [ 0 ] = true ; for ( int i = 1 ; i <= n ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) if ( dp [ j ] && wordSet . count ( s . substr ( j , i - j ))) { dp [ i ] = true ; break ; } return dp [ n ]; } }; 140. Word Break II $\\star\\star\\star$ Time: $O(2^n)$ Space: $O(2^n)$ class Solution { public : vector < string > wordBreak ( string s , vector < string >& wordDict ) { unordered_set < string > wordSet { begin ( wordDict ), end ( wordDict )}; unordered_map < string , vector < string >> memo ; function < vector < string > ( const string & ) > dfs = [ & ]( const string s ) { if ( memo . count ( s )) return memo [ s ]; vector < string > ans ; if ( wordSet . count ( s )) ans . push_back ( s ); for ( int i = 1 ; i < s . length (); ++ i ) { const string rightWord = s . substr ( i ); if ( wordSet . count ( rightWord )) for ( const string word : dfs ( s . substr ( 0 , i ))) ans . push_back ( word + \" \" + rightWord ); } return memo [ s ] = ans ; }; return dfs ( s ); } };","title":"0131-0140"},{"location":"cpp/0101-0200/0131-0140/#131-palindrome-partitioning-starstar","text":"Time: $O(n2^n)$ Space: $O(n2^n)$ class Solution { public : vector < vector < string >> partition ( string s ) { vector < vector < string >> ans ; vector < string > path ; auto isPalindrome = []( const string & s , int l , int r ) { while ( l < r ) if ( s [ l ++ ] != s [ r -- ]) return false ; return true ; }; function < void ( int ) > dfs = [ & ]( int startIndex ) { if ( startIndex == s . length ()) { ans . push_back ( path ); return ; } for ( int i = startIndex ; i < s . length (); ++ i ) if ( isPalindrome ( s , startIndex , i )) { path . push_back ( s . substr ( startIndex , i - startIndex + 1 )); dfs ( i + 1 ); path . pop_back (); } }; dfs ( 0 ); return ans ; } };","title":"131. Palindrome Partitioning $\\star\\star$"},{"location":"cpp/0101-0200/0131-0140/#132-palindrome-partitioning-ii-starstarstar","text":"Time: $O(mn)$ Space: $O(mn)$ class Solution { public : int minCut ( string s ) { const int n = s . length (); vector < vector < bool >> isPalindrome ( n , vector < bool > ( n , true )); vector < int > dp ( n , n ); for ( int length = 2 ; length <= n ; ++ length ) for ( int i = 0 , j = length - 1 ; j < n ; ++ i , ++ j ) isPalindrome [ i ][ j ] = s [ i ] == s [ j ] && isPalindrome [ i + 1 ][ j - 1 ]; for ( int i = 0 ; i < n ; ++ i ) { if ( isPalindrome [ 0 ][ i ]) { dp [ i ] = 0 ; continue ; } for ( int j = 0 ; j < i ; ++ j ) if ( isPalindrome [ j + 1 ][ i ]) dp [ i ] = min ( dp [ i ], dp [ j ] + 1 ); } return dp [ n - 1 ]; } };","title":"132. Palindrome Partitioning II $\\star\\star\\star$"},{"location":"cpp/0101-0200/0131-0140/#133-clone-graph-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : Node * cloneGraph ( Node * node ) { if ( ! node ) return nullptr ; if ( map . count ( node )) return map [ node ]; map [ node ] = new Node ( node -> val , {}); for ( Node * neighbor : node -> neighbors ) map [ node ] -> neighbors . push_back ( cloneGraph ( neighbor )); return map [ node ]; } private : unordered_map < Node * , Node *> map ; };","title":"133. Clone Graph $\\star\\star$"},{"location":"cpp/0101-0200/0131-0140/#134-gas-station-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : int canCompleteCircuit ( vector < int >& gas , vector < int >& cost ) { int ans = 0 ; int net = 0 ; int sum = 0 ; for ( int i = 0 ; i < gas . size (); ++ i ) { net += gas [ i ] - cost [ i ]; sum += gas [ i ] - cost [ i ]; if ( sum < 0 ) { sum = 0 ; ans = i + 1 ; } } return net < 0 ? - 1 : ans ; } };","title":"134. Gas Station $\\star\\star$"},{"location":"cpp/0101-0200/0131-0140/#135-candy-starstarstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : int candy ( vector < int >& ratings ) { const int n = ratings . size (); int ans = 0 ; vector < int > l ( n , 1 ); vector < int > r ( n , 1 ); for ( int i = 1 ; i < n ; ++ i ) if ( ratings [ i ] > ratings [ i - 1 ]) l [ i ] = l [ i - 1 ] + 1 ; for ( int i = n - 2 ; i >= 0 ; -- i ) if ( ratings [ i ] > ratings [ i + 1 ]) r [ i ] = r [ i + 1 ] + 1 ; for ( int i = 0 ; i < n ; ++ i ) ans += max ( l [ i ], r [ i ]); return ans ; } };","title":"135. Candy $\\star\\star\\star$"},{"location":"cpp/0101-0200/0131-0140/#136-single-number-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : int singleNumber ( vector < int >& nums ) { int ans = 0 ; for ( const int num : nums ) ans ^= num ; return ans ; } };","title":"136. Single Number $\\star$"},{"location":"cpp/0101-0200/0131-0140/#137-single-number-ii-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : int singleNumber ( vector < int >& nums ) { int ones = 0 ; int twos = 0 ; for ( const int num : nums ) { ones ^= ( num & ~ twos ); twos ^= ( num & ~ ones ); } return ones ; } };","title":"137. Single Number II $\\star\\star$"},{"location":"cpp/0101-0200/0131-0140/#138-copy-list-with-random-pointer-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : Node * copyRandomList ( Node * head ) { if ( ! head ) return nullptr ; if ( map . count ( head )) return map [ head ]; map [ head ] = new Node ( head -> val ); map [ head ] -> next = copyRandomList ( head -> next ); map [ head ] -> random = copyRandomList ( head -> random ); return map [ head ]; } private : unordered_map < Node * , Node *> map ; };","title":"138. Copy List with Random Pointer $\\star\\star$"},{"location":"cpp/0101-0200/0131-0140/#139-word-break-starstar","text":"Time: $O(n^2)$ Space: $O(n)$ class Solution { public : bool wordBreak ( string s , vector < string >& wordDict ) { const int n = s . length (); unordered_set < string > wordSet { begin ( wordDict ), end ( wordDict )}; vector < bool > dp ( n + 1 ); dp [ 0 ] = true ; for ( int i = 1 ; i <= n ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) if ( dp [ j ] && wordSet . count ( s . substr ( j , i - j ))) { dp [ i ] = true ; break ; } return dp [ n ]; } };","title":"139. Word Break $\\star\\star$"},{"location":"cpp/0101-0200/0131-0140/#140-word-break-ii-starstarstar","text":"Time: $O(2^n)$ Space: $O(2^n)$ class Solution { public : vector < string > wordBreak ( string s , vector < string >& wordDict ) { unordered_set < string > wordSet { begin ( wordDict ), end ( wordDict )}; unordered_map < string , vector < string >> memo ; function < vector < string > ( const string & ) > dfs = [ & ]( const string s ) { if ( memo . count ( s )) return memo [ s ]; vector < string > ans ; if ( wordSet . count ( s )) ans . push_back ( s ); for ( int i = 1 ; i < s . length (); ++ i ) { const string rightWord = s . substr ( i ); if ( wordSet . count ( rightWord )) for ( const string word : dfs ( s . substr ( 0 , i ))) ans . push_back ( word + \" \" + rightWord ); } return memo [ s ] = ans ; }; return dfs ( s ); } };","title":"140. Word Break II $\\star\\star\\star$"},{"location":"cpp/0101-0200/0141-0150/","text":"141. Linked List Cycle $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : bool hasCycle ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ) return true ; } return false ; } }; 142. Linked List Cycle II $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : ListNode * detectCycle ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ) { slow = head ; while ( slow != fast ) { slow = slow -> next ; fast = fast -> next ; } return slow ; } } return nullptr ; } }; 143. Reorder List $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : void reorderList ( ListNode * head ) { if ( ! head || ! head -> next ) return ; ListNode * mid = findMid ( head ); ListNode * reversed = reverse ( mid ); merge ( head , reversed ); } private : ListNode * findMid ( ListNode * head ) { ListNode * prev = nullptr ; ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { prev = slow ; slow = slow -> next ; fast = fast -> next -> next ; } prev -> next = nullptr ; return slow ; } ListNode * reverse ( ListNode * head ) { ListNode * prev = nullptr ; ListNode * curr = head ; while ( curr ) { ListNode * next = curr -> next ; curr -> next = prev ; prev = curr ; curr = next ; } return prev ; } void merge ( ListNode * l1 , ListNode * l2 ) { while ( l2 ) { ListNode * next = l1 -> next ; l1 -> next = l2 ; l1 = l2 ; l2 = next ; } } }; 144. Binary Tree Preorder Traversal $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : vector < int > preorderTraversal ( TreeNode * root ) { if ( ! root ) return {}; vector < int > ans ; stack < TreeNode *> stack {{ root }}; while ( ! stack . empty ()) { root = stack . top (), stack . pop (); ans . push_back ( root -> val ); if ( root -> right ) stack . push ( root -> right ); if ( root -> left ) stack . push ( root -> left ); } return ans ; } }; 145. Binary Tree Postorder Traversal $\\star\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : vector < int > postorderTraversal ( TreeNode * root ) { if ( ! root ) return {}; vector < int > ans ; stack < TreeNode *> stack {{ root }}; while ( ! stack . empty ()) { root = stack . top (), stack . pop (); ans . push_back ( root -> val ); if ( root -> left ) stack . push ( root -> left ); if ( root -> right ) stack . push ( root -> right ); } reverse ( begin ( ans ), end ( ans )); return ans ; } }; 146. LRU Cache $\\star\\star$ Time: $O(1)$ Space: $O(capacity)$ class LRUCache { public : LRUCache ( int capacity ) : capacity ( capacity ) {} int get ( int key ) { if ( ! map . count ( key )) return - 1 ; const auto & node = map [ key ]; cache . splice ( begin ( cache ), cache , node ); return node -> value ; } void put ( int key , int value ) { if ( map . count ( key )) { const auto & node = map [ key ]; node -> value = value ; cache . splice ( begin ( cache ), cache , node ); return ; } if ( cache . size () == capacity ) { const Node & lastNode = cache . back (); map . erase ( lastNode . key ); cache . pop_back (); } cache . push_front ( Node ( key , value )); map [ key ] = begin ( cache ); } private : struct Node { int key ; int value ; Node ( int key , int value ) : key ( key ), value ( value ) {} }; int capacity ; list < Node > cache ; unordered_map < int , list < Node >:: iterator > map ; }; 147. Insertion Sort List $\\star\\star$ Time: $O(n^2)$ Space: $O(1)$ class Solution { public : ListNode * insertionSortList ( ListNode * head ) { ListNode dummy ( 0 ); ListNode * curr = head ; while ( curr ) { ListNode * prev = & dummy ; while ( prev -> next && prev -> next -> val < curr -> val ) prev = prev -> next ; ListNode * next = curr -> next ; curr -> next = prev -> next ; prev -> next = curr ; curr = next ; } return dummy . next ; } }; 148. Sort List $\\star\\star$ Time: $O(n\\log n)$ Space: $O(1)$ class Solution { public : ListNode * sortList ( ListNode * head ) { int length = 0 ; for ( ListNode * curr = head ; curr ; curr = curr -> next ) ++ length ; ListNode dummy ( 0 ); dummy . next = head ; for ( int k = 1 ; k < length ; k *= 2 ) { ListNode * curr = dummy . next ; ListNode * tail = & dummy ; while ( curr ) { ListNode * l = curr ; ListNode * r = split ( l , k ); curr = split ( r , k ); auto [ mergedHead , mergedTail ] = merge ( l , r ); tail -> next = mergedHead ; tail = mergedTail ; } } return dummy . next ; } private : ListNode * split ( ListNode * head , int k ) { while ( -- k && head ) head = head -> next ; ListNode * rest = head ? head -> next : nullptr ; if ( head ) head -> next = nullptr ; return rest ; } pair < ListNode * , ListNode *> merge ( ListNode * l1 , ListNode * l2 ) { ListNode dummy ( 0 ); ListNode * tail = & dummy ; while ( l1 && l2 ) { if ( l1 -> val > l2 -> val ) swap ( l1 , l2 ); tail -> next = l1 ; l1 = l1 -> next ; tail = tail -> next ; } tail -> next = l1 ? l1 : l2 ; while ( tail -> next ) tail = tail -> next ; return { dummy . next , tail }; } }; 149. Max Points on a Line $\\star\\star\\star$ Time: $O(n^2)$ Space: $O(n)$ class Solution { public : int maxPoints ( vector < vector < int >>& points ) { int ans = 0 ; for ( int i = 0 ; i < points . size (); ++ i ) { map < pair < int , int > , int > count ; vector < int > p1 { points [ i ]}; int samePoints = 1 ; int maxPoints = 0 ; for ( int j = i + 1 ; j < points . size (); ++ j ) { vector < int > p2 { points [ j ]}; if ( p1 == p2 ) ++ samePoints ; else maxPoints = max ( maxPoints , ++ count [ getSlope ( p1 , p2 )]); } ans = max ( ans , samePoints + maxPoints ); } return ans ; } private : pair < int , int > getSlope ( vector < int >& p1 , vector < int >& p2 ) { const int dx = p2 [ 0 ] - p1 [ 0 ]; const int dy = p2 [ 1 ] - p1 [ 1 ]; if ( dx == 0 ) return { 0 , p1 [ 0 ]}; if ( dy == 0 ) return { p1 [ 1 ], 0 }; const int d = __gcd ( dx , dy ); return { dx / d , dy / d }; } }; 150. Evaluate Reverse Polish Notation $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : int evalRPN ( vector < string >& tokens ) { stack < int > stack ; const unordered_map < string , function < int ( int , int ) >> op { { \"+\" , plus < int > ()}, { \"-\" , minus < int > ()}, { \"*\" , multiplies < int > ()}, { \"/\" , divides < int > ()}}; for ( const string & token : tokens ) if ( op . count ( token )) { const int b = stack . top (); stack . pop (); const int a = stack . top (); stack . pop (); stack . push ( op . at ( token )( a , b )); } else stack . push ( stoi ( token )); return stack . top (); } };","title":"0141-0150"},{"location":"cpp/0101-0200/0141-0150/#141-linked-list-cycle-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : bool hasCycle ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ) return true ; } return false ; } };","title":"141. Linked List Cycle $\\star$"},{"location":"cpp/0101-0200/0141-0150/#142-linked-list-cycle-ii-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : ListNode * detectCycle ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ) { slow = head ; while ( slow != fast ) { slow = slow -> next ; fast = fast -> next ; } return slow ; } } return nullptr ; } };","title":"142. Linked List Cycle II $\\star\\star$"},{"location":"cpp/0101-0200/0141-0150/#143-reorder-list-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : void reorderList ( ListNode * head ) { if ( ! head || ! head -> next ) return ; ListNode * mid = findMid ( head ); ListNode * reversed = reverse ( mid ); merge ( head , reversed ); } private : ListNode * findMid ( ListNode * head ) { ListNode * prev = nullptr ; ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { prev = slow ; slow = slow -> next ; fast = fast -> next -> next ; } prev -> next = nullptr ; return slow ; } ListNode * reverse ( ListNode * head ) { ListNode * prev = nullptr ; ListNode * curr = head ; while ( curr ) { ListNode * next = curr -> next ; curr -> next = prev ; prev = curr ; curr = next ; } return prev ; } void merge ( ListNode * l1 , ListNode * l2 ) { while ( l2 ) { ListNode * next = l1 -> next ; l1 -> next = l2 ; l1 = l2 ; l2 = next ; } } };","title":"143. Reorder List $\\star\\star$"},{"location":"cpp/0101-0200/0141-0150/#144-binary-tree-preorder-traversal-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : vector < int > preorderTraversal ( TreeNode * root ) { if ( ! root ) return {}; vector < int > ans ; stack < TreeNode *> stack {{ root }}; while ( ! stack . empty ()) { root = stack . top (), stack . pop (); ans . push_back ( root -> val ); if ( root -> right ) stack . push ( root -> right ); if ( root -> left ) stack . push ( root -> left ); } return ans ; } };","title":"144. Binary Tree Preorder Traversal $\\star\\star$"},{"location":"cpp/0101-0200/0141-0150/#145-binary-tree-postorder-traversal-starstarstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : vector < int > postorderTraversal ( TreeNode * root ) { if ( ! root ) return {}; vector < int > ans ; stack < TreeNode *> stack {{ root }}; while ( ! stack . empty ()) { root = stack . top (), stack . pop (); ans . push_back ( root -> val ); if ( root -> left ) stack . push ( root -> left ); if ( root -> right ) stack . push ( root -> right ); } reverse ( begin ( ans ), end ( ans )); return ans ; } };","title":"145. Binary Tree Postorder Traversal $\\star\\star\\star$"},{"location":"cpp/0101-0200/0141-0150/#146-lru-cache-starstar","text":"Time: $O(1)$ Space: $O(capacity)$ class LRUCache { public : LRUCache ( int capacity ) : capacity ( capacity ) {} int get ( int key ) { if ( ! map . count ( key )) return - 1 ; const auto & node = map [ key ]; cache . splice ( begin ( cache ), cache , node ); return node -> value ; } void put ( int key , int value ) { if ( map . count ( key )) { const auto & node = map [ key ]; node -> value = value ; cache . splice ( begin ( cache ), cache , node ); return ; } if ( cache . size () == capacity ) { const Node & lastNode = cache . back (); map . erase ( lastNode . key ); cache . pop_back (); } cache . push_front ( Node ( key , value )); map [ key ] = begin ( cache ); } private : struct Node { int key ; int value ; Node ( int key , int value ) : key ( key ), value ( value ) {} }; int capacity ; list < Node > cache ; unordered_map < int , list < Node >:: iterator > map ; };","title":"146. LRU Cache $\\star\\star$"},{"location":"cpp/0101-0200/0141-0150/#147-insertion-sort-list-starstar","text":"Time: $O(n^2)$ Space: $O(1)$ class Solution { public : ListNode * insertionSortList ( ListNode * head ) { ListNode dummy ( 0 ); ListNode * curr = head ; while ( curr ) { ListNode * prev = & dummy ; while ( prev -> next && prev -> next -> val < curr -> val ) prev = prev -> next ; ListNode * next = curr -> next ; curr -> next = prev -> next ; prev -> next = curr ; curr = next ; } return dummy . next ; } };","title":"147. Insertion Sort List $\\star\\star$"},{"location":"cpp/0101-0200/0141-0150/#148-sort-list-starstar","text":"Time: $O(n\\log n)$ Space: $O(1)$ class Solution { public : ListNode * sortList ( ListNode * head ) { int length = 0 ; for ( ListNode * curr = head ; curr ; curr = curr -> next ) ++ length ; ListNode dummy ( 0 ); dummy . next = head ; for ( int k = 1 ; k < length ; k *= 2 ) { ListNode * curr = dummy . next ; ListNode * tail = & dummy ; while ( curr ) { ListNode * l = curr ; ListNode * r = split ( l , k ); curr = split ( r , k ); auto [ mergedHead , mergedTail ] = merge ( l , r ); tail -> next = mergedHead ; tail = mergedTail ; } } return dummy . next ; } private : ListNode * split ( ListNode * head , int k ) { while ( -- k && head ) head = head -> next ; ListNode * rest = head ? head -> next : nullptr ; if ( head ) head -> next = nullptr ; return rest ; } pair < ListNode * , ListNode *> merge ( ListNode * l1 , ListNode * l2 ) { ListNode dummy ( 0 ); ListNode * tail = & dummy ; while ( l1 && l2 ) { if ( l1 -> val > l2 -> val ) swap ( l1 , l2 ); tail -> next = l1 ; l1 = l1 -> next ; tail = tail -> next ; } tail -> next = l1 ? l1 : l2 ; while ( tail -> next ) tail = tail -> next ; return { dummy . next , tail }; } };","title":"148. Sort List $\\star\\star$"},{"location":"cpp/0101-0200/0141-0150/#149-max-points-on-a-line-starstarstar","text":"Time: $O(n^2)$ Space: $O(n)$ class Solution { public : int maxPoints ( vector < vector < int >>& points ) { int ans = 0 ; for ( int i = 0 ; i < points . size (); ++ i ) { map < pair < int , int > , int > count ; vector < int > p1 { points [ i ]}; int samePoints = 1 ; int maxPoints = 0 ; for ( int j = i + 1 ; j < points . size (); ++ j ) { vector < int > p2 { points [ j ]}; if ( p1 == p2 ) ++ samePoints ; else maxPoints = max ( maxPoints , ++ count [ getSlope ( p1 , p2 )]); } ans = max ( ans , samePoints + maxPoints ); } return ans ; } private : pair < int , int > getSlope ( vector < int >& p1 , vector < int >& p2 ) { const int dx = p2 [ 0 ] - p1 [ 0 ]; const int dy = p2 [ 1 ] - p1 [ 1 ]; if ( dx == 0 ) return { 0 , p1 [ 0 ]}; if ( dy == 0 ) return { p1 [ 1 ], 0 }; const int d = __gcd ( dx , dy ); return { dx / d , dy / d }; } };","title":"149. Max Points on a Line $\\star\\star\\star$"},{"location":"cpp/0101-0200/0141-0150/#150-evaluate-reverse-polish-notation-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : int evalRPN ( vector < string >& tokens ) { stack < int > stack ; const unordered_map < string , function < int ( int , int ) >> op { { \"+\" , plus < int > ()}, { \"-\" , minus < int > ()}, { \"*\" , multiplies < int > ()}, { \"/\" , divides < int > ()}}; for ( const string & token : tokens ) if ( op . count ( token )) { const int b = stack . top (); stack . pop (); const int a = stack . top (); stack . pop (); stack . push ( op . at ( token )( a , b )); } else stack . push ( stoi ( token )); return stack . top (); } };","title":"150. Evaluate Reverse Polish Notation $\\star\\star$"},{"location":"cpp/0101-0200/0151-0160/","text":"151. Reverse Words in a String $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : string reverseWords ( string s ) { reverse ( begin ( s ), end ( s )); reverseWords ( s , 0 , 0 ); return cleanSpaces ( s , 0 , 0 ); } private : void reverseWords ( string & s , int i , int j ) { while ( i < s . length ()) { while ( i < j || i < s . length () && s [ i ] == ' ' ) ++ i ; while ( j < i || j < s . length () && s [ j ] != ' ' ) ++ j ; reverse ( begin ( s ) + i , begin ( s ) + j ); } } string cleanSpaces ( string & s , int i , int j ) { while ( j < s . length ()) { while ( j < s . length () && s [ j ] == ' ' ) ++ j ; while ( j < s . length () && s [ j ] != ' ' ) s [ i ++ ] = s [ j ++ ]; while ( j < s . length () && s [ j ] == ' ' ) ++ j ; if ( j < s . length ()) s [ i ++ ] = ' ' ; } return s . substr ( 0 , i ); } }; 152. Maximum Product Subarray $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : int maxProduct ( vector < int >& nums ) { int ans = nums [ 0 ]; int currMin = nums [ 0 ]; int currMax = nums [ 0 ]; for ( int i = 1 ; i < nums . size (); ++ i ) { const int a = currMin * nums [ i ]; const int b = currMax * nums [ i ]; currMin = min ({ a , b , nums [ i ]}); currMax = max ({ a , b , nums [ i ]}); ans = max ( ans , currMax ); } return ans ; } }; 153. Find Minimum in Rotated Sorted Array $\\star\\star$ Time: $O(\\log n)$ Space: $O(1)$ class Solution { public : int findMin ( vector < int >& nums ) { int l = 0 ; int r = nums . size () - 1 ; while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( nums [ m ] < nums [ r ]) r = m ; else l = m + 1 ; } return nums [ l ]; } }; 154. Find Minimum in Rotated Sorted Array II $\\star\\star\\star$ Time: $O(\\log n) \\to O(n)$ Space: $O(1)$ class Solution { public : int findMin ( vector < int >& nums ) { int l = 0 ; int r = nums . size () - 1 ; while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( nums [ m ] == nums [ r ]) -- r ; else if ( nums [ m ] < nums [ r ]) r = m ; else l = m + 1 ; } return nums [ l ]; } }; 155. Min Stack $\\star$ Time: $O(1)$ Space: $O(n)$ class MinStack { public : void push ( int x ) { int mini = stack . empty () ? x : min ( stack . top (). second , x ); stack . push ({ x , mini }); } void pop () { stack . pop (); } int top () { return stack . top (). first ; } int getMin () { return stack . top (). second ; } private : stack < pair < int , int >> stack ; }; 156. Binary Tree Upside Down $\\star\\star$ \ud83d\udd12 157. Read N Characters Given Read4 $\\star$ \ud83d\udd12 158. Read N Characters Given Read4 II - Call multiple times $\\star\\star\\star$ \ud83d\udd12 159. Longest Substring with At Most Two Distinct Characters $\\star\\star$ \ud83d\udd12 160. Intersection of Two Linked Lists $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : ListNode * getIntersectionNode ( ListNode * headA , ListNode * headB ) { ListNode * a = headA ; ListNode * b = headB ; while ( a != b ) { a = a ? a -> next : headB ; b = b ? b -> next : headA ; } return a ; } };","title":"0151-0160"},{"location":"cpp/0101-0200/0151-0160/#151-reverse-words-in-a-string-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : string reverseWords ( string s ) { reverse ( begin ( s ), end ( s )); reverseWords ( s , 0 , 0 ); return cleanSpaces ( s , 0 , 0 ); } private : void reverseWords ( string & s , int i , int j ) { while ( i < s . length ()) { while ( i < j || i < s . length () && s [ i ] == ' ' ) ++ i ; while ( j < i || j < s . length () && s [ j ] != ' ' ) ++ j ; reverse ( begin ( s ) + i , begin ( s ) + j ); } } string cleanSpaces ( string & s , int i , int j ) { while ( j < s . length ()) { while ( j < s . length () && s [ j ] == ' ' ) ++ j ; while ( j < s . length () && s [ j ] != ' ' ) s [ i ++ ] = s [ j ++ ]; while ( j < s . length () && s [ j ] == ' ' ) ++ j ; if ( j < s . length ()) s [ i ++ ] = ' ' ; } return s . substr ( 0 , i ); } };","title":"151. Reverse Words in a String $\\star\\star$"},{"location":"cpp/0101-0200/0151-0160/#152-maximum-product-subarray-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : int maxProduct ( vector < int >& nums ) { int ans = nums [ 0 ]; int currMin = nums [ 0 ]; int currMax = nums [ 0 ]; for ( int i = 1 ; i < nums . size (); ++ i ) { const int a = currMin * nums [ i ]; const int b = currMax * nums [ i ]; currMin = min ({ a , b , nums [ i ]}); currMax = max ({ a , b , nums [ i ]}); ans = max ( ans , currMax ); } return ans ; } };","title":"152. Maximum Product Subarray $\\star\\star$"},{"location":"cpp/0101-0200/0151-0160/#153-find-minimum-in-rotated-sorted-array-starstar","text":"Time: $O(\\log n)$ Space: $O(1)$ class Solution { public : int findMin ( vector < int >& nums ) { int l = 0 ; int r = nums . size () - 1 ; while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( nums [ m ] < nums [ r ]) r = m ; else l = m + 1 ; } return nums [ l ]; } };","title":"153. Find Minimum in Rotated Sorted Array $\\star\\star$"},{"location":"cpp/0101-0200/0151-0160/#154-find-minimum-in-rotated-sorted-array-ii-starstarstar","text":"Time: $O(\\log n) \\to O(n)$ Space: $O(1)$ class Solution { public : int findMin ( vector < int >& nums ) { int l = 0 ; int r = nums . size () - 1 ; while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( nums [ m ] == nums [ r ]) -- r ; else if ( nums [ m ] < nums [ r ]) r = m ; else l = m + 1 ; } return nums [ l ]; } };","title":"154. Find Minimum in Rotated Sorted Array II $\\star\\star\\star$"},{"location":"cpp/0101-0200/0151-0160/#155-min-stack-star","text":"Time: $O(1)$ Space: $O(n)$ class MinStack { public : void push ( int x ) { int mini = stack . empty () ? x : min ( stack . top (). second , x ); stack . push ({ x , mini }); } void pop () { stack . pop (); } int top () { return stack . top (). first ; } int getMin () { return stack . top (). second ; } private : stack < pair < int , int >> stack ; };","title":"155. Min Stack $\\star$"},{"location":"cpp/0101-0200/0151-0160/#156-binary-tree-upside-down-starstar","text":"","title":"156. Binary Tree Upside Down $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0101-0200/0151-0160/#157-read-n-characters-given-read4-star","text":"","title":"157. Read N Characters Given Read4 $\\star$ \ud83d\udd12"},{"location":"cpp/0101-0200/0151-0160/#158-read-n-characters-given-read4-ii-call-multiple-times-starstarstar","text":"","title":"158. Read N Characters Given Read4 II - Call multiple times $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/0101-0200/0151-0160/#159-longest-substring-with-at-most-two-distinct-characters-starstar","text":"","title":"159. Longest Substring with At Most Two Distinct Characters $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0101-0200/0151-0160/#160-intersection-of-two-linked-lists-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : ListNode * getIntersectionNode ( ListNode * headA , ListNode * headB ) { ListNode * a = headA ; ListNode * b = headB ; while ( a != b ) { a = a ? a -> next : headB ; b = b ? b -> next : headA ; } return a ; } };","title":"160. Intersection of Two Linked Lists $\\star$"},{"location":"cpp/0101-0200/0161-0170/","text":"161. One Edit Distance $\\star\\star$ \ud83d\udd12 162. Find Peak Element $\\star\\star$ Time: $O(n\\log n)$ Space: $O(1)$ class Solution { public : int findPeakElement ( vector < int >& nums ) { int l = 0 ; int r = nums . size () - 1 ; while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( nums [ m ] > nums [ m + 1 ]) r = m ; else l = m + 1 ; } return l ; } }; 163. Missing Ranges $\\star\\star$ \ud83d\udd12 164. Maximum Gap $\\star\\star\\star$ 165. Compare Version Numbers $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : int compareVersion ( string version1 , string version2 ) { istringstream iss1 ( version1 ); istringstream iss2 ( version2 ); int num1 ; int num2 ; char dotChar ; while ( bool ( iss1 >> num1 ) + bool ( iss2 >> num2 )) { if ( num1 < num2 ) return - 1 ; if ( num1 > num2 ) return 1 ; iss1 >> dotChar ; iss2 >> dotChar ; num1 = 0 ; num2 = 0 ; } return 0 ; }; }; 166. Fraction to Recurring Decimal $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : string fractionToDecimal ( int numerator , int denominator ) { if ( numerator == 0 ) return \"0\" ; string ans ; if ( numerator < 0 ^ denominator < 0 ) ans += \"-\" ; long n = labs ( numerator ); long d = labs ( denominator ); ans += to_string ( n / d ); if ( n % d == 0 ) return ans ; ans += '.' ; unordered_map < int , int > seen ; for ( long r = n % d ; r ; r %= d ) { if ( seen . count ( r ) > 0 ) { ans . insert ( seen [ r ], 1 , '(' ); ans += ')' ; break ; } seen [ r ] = ans . size (); r *= 10 ; ans += to_string ( r / d ); } return ans ; } }; 167. Two Sum II - Input array is sorted $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : vector < int > twoSum ( vector < int >& numbers , int target ) { int l = 0 ; int r = numbers . size () - 1 ; while ( numbers [ l ] + numbers [ r ] != target ) if ( numbers [ l ] + numbers [ r ] < target ) ++ l ; else -- r ; return { l + 1 , r + 1 }; } }; 168. Excel Sheet Column Title $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : string convertToTitle ( int n ) { return n == 0 ? \"\" : convertToTitle (( n - 1 ) / 26 ) + ( char )( 'A' + (( n - 1 ) % 26 )); } }; 169. Majority Element $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : int majorityElement ( vector < int >& nums ) { int ans ; int count = 0 ; for ( const int num : nums ) { if ( count == 0 ) ans = num ; count += num == ans ? 1 : - 1 ; } return ans ; } }; 170. Two Sum III - Data structure design $\\star$ \ud83d\udd12","title":"0161-0170"},{"location":"cpp/0101-0200/0161-0170/#161-one-edit-distance-starstar","text":"","title":"161. One Edit Distance $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0101-0200/0161-0170/#162-find-peak-element-starstar","text":"Time: $O(n\\log n)$ Space: $O(1)$ class Solution { public : int findPeakElement ( vector < int >& nums ) { int l = 0 ; int r = nums . size () - 1 ; while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( nums [ m ] > nums [ m + 1 ]) r = m ; else l = m + 1 ; } return l ; } };","title":"162. Find Peak Element $\\star\\star$"},{"location":"cpp/0101-0200/0161-0170/#163-missing-ranges-starstar","text":"","title":"163. Missing Ranges $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0101-0200/0161-0170/#164-maximum-gap-starstarstar","text":"","title":"164. Maximum Gap $\\star\\star\\star$"},{"location":"cpp/0101-0200/0161-0170/#165-compare-version-numbers-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : int compareVersion ( string version1 , string version2 ) { istringstream iss1 ( version1 ); istringstream iss2 ( version2 ); int num1 ; int num2 ; char dotChar ; while ( bool ( iss1 >> num1 ) + bool ( iss2 >> num2 )) { if ( num1 < num2 ) return - 1 ; if ( num1 > num2 ) return 1 ; iss1 >> dotChar ; iss2 >> dotChar ; num1 = 0 ; num2 = 0 ; } return 0 ; }; };","title":"165. Compare Version Numbers $\\star\\star$"},{"location":"cpp/0101-0200/0161-0170/#166-fraction-to-recurring-decimal-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : string fractionToDecimal ( int numerator , int denominator ) { if ( numerator == 0 ) return \"0\" ; string ans ; if ( numerator < 0 ^ denominator < 0 ) ans += \"-\" ; long n = labs ( numerator ); long d = labs ( denominator ); ans += to_string ( n / d ); if ( n % d == 0 ) return ans ; ans += '.' ; unordered_map < int , int > seen ; for ( long r = n % d ; r ; r %= d ) { if ( seen . count ( r ) > 0 ) { ans . insert ( seen [ r ], 1 , '(' ); ans += ')' ; break ; } seen [ r ] = ans . size (); r *= 10 ; ans += to_string ( r / d ); } return ans ; } };","title":"166. Fraction to Recurring Decimal $\\star\\star$"},{"location":"cpp/0101-0200/0161-0170/#167-two-sum-ii-input-array-is-sorted-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : vector < int > twoSum ( vector < int >& numbers , int target ) { int l = 0 ; int r = numbers . size () - 1 ; while ( numbers [ l ] + numbers [ r ] != target ) if ( numbers [ l ] + numbers [ r ] < target ) ++ l ; else -- r ; return { l + 1 , r + 1 }; } };","title":"167. Two Sum II - Input array is sorted $\\star$"},{"location":"cpp/0101-0200/0161-0170/#168-excel-sheet-column-title-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : string convertToTitle ( int n ) { return n == 0 ? \"\" : convertToTitle (( n - 1 ) / 26 ) + ( char )( 'A' + (( n - 1 ) % 26 )); } };","title":"168. Excel Sheet Column Title $\\star$"},{"location":"cpp/0101-0200/0161-0170/#169-majority-element-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : int majorityElement ( vector < int >& nums ) { int ans ; int count = 0 ; for ( const int num : nums ) { if ( count == 0 ) ans = num ; count += num == ans ? 1 : - 1 ; } return ans ; } };","title":"169. Majority Element $\\star$"},{"location":"cpp/0101-0200/0161-0170/#170-two-sum-iii-data-structure-design-star","text":"","title":"170. Two Sum III - Data structure design $\\star$ \ud83d\udd12"},{"location":"cpp/0101-0200/0171-0180/","text":"171. Excel Sheet Column Number $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : int titleToNumber ( string s ) { return accumulate ( begin ( s ), end ( s ), 0 , []( int a , int b ) { return a * 26 + ( b - 'A' + 1 ); }); } }; 172. Factorial Trailing Zeroes $\\star$ Time: $O(\\log_5 n)$ Space: $O(1)$ class Solution { public : int trailingZeroes ( int n ) { return n == 0 ? 0 : n / 5 + trailingZeroes ( n / 5 ); } }; 173. Binary Search Tree Iterator $\\star\\star$ Time: $O(n)$ Space: $O(\\log n)$ class BSTIterator { public : BSTIterator ( TreeNode * root ) { while ( root ) { stack . push ( root ); root = root -> left ; } } int next () { TreeNode * node = stack . top (); stack . pop (); int res = node -> val ; node = node -> right ; while ( node ) { stack . push ( node ); node = node -> left ; } return res ; } bool hasNext () { return ! stack . empty (); } private : stack < TreeNode *> stack ; }; 174. Dungeon Game $\\star\\star\\star$ Time: $O(mn)$ Space: $O(mn) \\to O(n)$ class Solution { public : int calculateMinimumHP ( vector < vector < int >>& dungeon ) { const int m = dungeon . size (); const int n = dungeon [ 0 ]. size (); vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 , INT_MAX )); dp [ m ][ n - 1 ] = 1 ; dp [ m - 1 ][ n ] = 1 ; for ( int i = m - 1 ; i >= 0 ; -- i ) for ( int j = n - 1 ; j >= 0 ; -- j ) { dp [ i ][ j ] = min ( dp [ i + 1 ][ j ], dp [ i ][ j + 1 ]) - dungeon [ i ][ j ]; dp [ i ][ j ] = max ( dp [ i ][ j ], 1 ); } return dp [ 0 ][ 0 ]; } }; 175. Combine Two Tables $\\star$ 176. Second Highest Salary $\\star$ 177. Nth Highest Salary $\\star\\star$ 178. Rank Scores $\\star\\star$ 179. Largest Number $\\star\\star$ Time: $O(n\\log n)$ Space: $O(n)$ class Solution { public : string largestNumber ( vector < int >& nums ) { string ans ; sort ( begin ( nums ), end ( nums ), []( int a , int b ) { return to_string ( a ) + to_string ( b ) > to_string ( b ) + to_string ( a ); }); for ( const int num : nums ) ans += to_string ( num ); return ans [ 0 ] == '0' ? \"0\" : ans ; } }; 180. Consecutive Numbers $\\star\\star$","title":"0171-0180"},{"location":"cpp/0101-0200/0171-0180/#171-excel-sheet-column-number-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : int titleToNumber ( string s ) { return accumulate ( begin ( s ), end ( s ), 0 , []( int a , int b ) { return a * 26 + ( b - 'A' + 1 ); }); } };","title":"171. Excel Sheet Column Number $\\star$"},{"location":"cpp/0101-0200/0171-0180/#172-factorial-trailing-zeroes-star","text":"Time: $O(\\log_5 n)$ Space: $O(1)$ class Solution { public : int trailingZeroes ( int n ) { return n == 0 ? 0 : n / 5 + trailingZeroes ( n / 5 ); } };","title":"172. Factorial Trailing Zeroes $\\star$"},{"location":"cpp/0101-0200/0171-0180/#173-binary-search-tree-iterator-starstar","text":"Time: $O(n)$ Space: $O(\\log n)$ class BSTIterator { public : BSTIterator ( TreeNode * root ) { while ( root ) { stack . push ( root ); root = root -> left ; } } int next () { TreeNode * node = stack . top (); stack . pop (); int res = node -> val ; node = node -> right ; while ( node ) { stack . push ( node ); node = node -> left ; } return res ; } bool hasNext () { return ! stack . empty (); } private : stack < TreeNode *> stack ; };","title":"173. Binary Search Tree Iterator $\\star\\star$"},{"location":"cpp/0101-0200/0171-0180/#174-dungeon-game-starstarstar","text":"Time: $O(mn)$ Space: $O(mn) \\to O(n)$ class Solution { public : int calculateMinimumHP ( vector < vector < int >>& dungeon ) { const int m = dungeon . size (); const int n = dungeon [ 0 ]. size (); vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 , INT_MAX )); dp [ m ][ n - 1 ] = 1 ; dp [ m - 1 ][ n ] = 1 ; for ( int i = m - 1 ; i >= 0 ; -- i ) for ( int j = n - 1 ; j >= 0 ; -- j ) { dp [ i ][ j ] = min ( dp [ i + 1 ][ j ], dp [ i ][ j + 1 ]) - dungeon [ i ][ j ]; dp [ i ][ j ] = max ( dp [ i ][ j ], 1 ); } return dp [ 0 ][ 0 ]; } };","title":"174. Dungeon Game $\\star\\star\\star$"},{"location":"cpp/0101-0200/0171-0180/#175-combine-two-tables-star","text":"","title":"175. Combine Two Tables $\\star$"},{"location":"cpp/0101-0200/0171-0180/#176-second-highest-salary-star","text":"","title":"176. Second Highest Salary $\\star$"},{"location":"cpp/0101-0200/0171-0180/#177-nth-highest-salary-starstar","text":"","title":"177. Nth Highest Salary $\\star\\star$"},{"location":"cpp/0101-0200/0171-0180/#178-rank-scores-starstar","text":"","title":"178. Rank Scores $\\star\\star$"},{"location":"cpp/0101-0200/0171-0180/#179-largest-number-starstar","text":"Time: $O(n\\log n)$ Space: $O(n)$ class Solution { public : string largestNumber ( vector < int >& nums ) { string ans ; sort ( begin ( nums ), end ( nums ), []( int a , int b ) { return to_string ( a ) + to_string ( b ) > to_string ( b ) + to_string ( a ); }); for ( const int num : nums ) ans += to_string ( num ); return ans [ 0 ] == '0' ? \"0\" : ans ; } };","title":"179. Largest Number $\\star\\star$"},{"location":"cpp/0101-0200/0171-0180/#180-consecutive-numbers-starstar","text":"","title":"180. Consecutive Numbers $\\star\\star$"},{"location":"cpp/0101-0200/0181-0190/","text":"181. Employees Earning More Than Their Managers $\\star$ 182. Duplicate Emails $\\star$ 183. Customers Who Never Order $\\star$ 184. Department Highest Salary $\\star\\star$ 185. Department Top Three Salaries $\\star\\star\\star$ 186. Reverse Words in a String II $\\star\\star$ \ud83d\udd12 187. Repeated DNA Sequences $\\star\\star$ Time: $O(10n)$ Space: $O(10n)$ class Solution { public : vector < string > findRepeatedDnaSequences ( string s ) { unordered_set < string > ans ; unordered_set < string_view > seen ; const string_view sv ( s ); for ( int i = 0 ; i + 10 <= s . length (); ++ i ) { if ( seen . count ( sv . substr ( i , 10 ))) ans . insert ( s . substr ( i , 10 )); seen . insert ( sv . substr ( i , 10 )); } return { begin ( ans ), end ( ans )}; } }; 188. Best Time to Buy and Sell Stock IV $\\star\\star\\star$ Time: $O(nk)$ Space: $O(k)$ class Solution { public : int maxProfit ( int k , vector < int >& prices ) { if ( k >= prices . size () / 2 ) { int sell = 0 ; int hold = INT_MIN ; for ( int price : prices ) { sell = max ( sell , hold + price ); hold = max ( hold , sell - price ); } return sell ; } vector < int > sell ( k + 1 ); vector < int > hold ( k + 1 , INT_MIN ); for ( int price : prices ) for ( int i = k ; i > 0 ; -- i ) { sell [ i ] = max ( sell [ i ], hold [ i ] + price ); hold [ i ] = max ( hold [ i ], sell [ i - 1 ] - price ); } return sell [ k ]; } }; 189. Rotate Array $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : void rotate ( vector < int >& nums , int k ) { k %= nums . size (); reverse ( nums , 0 , nums . size () - 1 ); reverse ( nums , 0 , k - 1 ); reverse ( nums , k , nums . size () - 1 ); } private : void reverse ( vector < int >& nums , int l , int r ) { while ( l < r ) swap ( nums [ l ++ ], nums [ r -- ]); } }; 190. Reverse Bits $\\star$ Time: $O(32)$ Space: $O(1)$ class Solution { public : uint32_t reverseBits ( uint32_t num ) { uint32_t ans = 0 ; for ( int i = 0 ; i < 32 ; ++ i ) if (( num >> i ) & 1 ) ans |= ( 1 << ( 31 - i )); return ans ; } };","title":"0181-0190"},{"location":"cpp/0101-0200/0181-0190/#181-employees-earning-more-than-their-managers-star","text":"","title":"181. Employees Earning More Than Their Managers $\\star$"},{"location":"cpp/0101-0200/0181-0190/#182-duplicate-emails-star","text":"","title":"182. Duplicate Emails $\\star$"},{"location":"cpp/0101-0200/0181-0190/#183-customers-who-never-order-star","text":"","title":"183. Customers Who Never Order $\\star$"},{"location":"cpp/0101-0200/0181-0190/#184-department-highest-salary-starstar","text":"","title":"184. Department Highest Salary $\\star\\star$"},{"location":"cpp/0101-0200/0181-0190/#185-department-top-three-salaries-starstarstar","text":"","title":"185. Department Top Three Salaries $\\star\\star\\star$"},{"location":"cpp/0101-0200/0181-0190/#186-reverse-words-in-a-string-ii-starstar","text":"","title":"186. Reverse Words in a String II $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0101-0200/0181-0190/#187-repeated-dna-sequences-starstar","text":"Time: $O(10n)$ Space: $O(10n)$ class Solution { public : vector < string > findRepeatedDnaSequences ( string s ) { unordered_set < string > ans ; unordered_set < string_view > seen ; const string_view sv ( s ); for ( int i = 0 ; i + 10 <= s . length (); ++ i ) { if ( seen . count ( sv . substr ( i , 10 ))) ans . insert ( s . substr ( i , 10 )); seen . insert ( sv . substr ( i , 10 )); } return { begin ( ans ), end ( ans )}; } };","title":"187. Repeated DNA Sequences $\\star\\star$"},{"location":"cpp/0101-0200/0181-0190/#188-best-time-to-buy-and-sell-stock-iv-starstarstar","text":"Time: $O(nk)$ Space: $O(k)$ class Solution { public : int maxProfit ( int k , vector < int >& prices ) { if ( k >= prices . size () / 2 ) { int sell = 0 ; int hold = INT_MIN ; for ( int price : prices ) { sell = max ( sell , hold + price ); hold = max ( hold , sell - price ); } return sell ; } vector < int > sell ( k + 1 ); vector < int > hold ( k + 1 , INT_MIN ); for ( int price : prices ) for ( int i = k ; i > 0 ; -- i ) { sell [ i ] = max ( sell [ i ], hold [ i ] + price ); hold [ i ] = max ( hold [ i ], sell [ i - 1 ] - price ); } return sell [ k ]; } };","title":"188. Best Time to Buy and Sell Stock IV $\\star\\star\\star$"},{"location":"cpp/0101-0200/0181-0190/#189-rotate-array-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : void rotate ( vector < int >& nums , int k ) { k %= nums . size (); reverse ( nums , 0 , nums . size () - 1 ); reverse ( nums , 0 , k - 1 ); reverse ( nums , k , nums . size () - 1 ); } private : void reverse ( vector < int >& nums , int l , int r ) { while ( l < r ) swap ( nums [ l ++ ], nums [ r -- ]); } };","title":"189. Rotate Array $\\star$"},{"location":"cpp/0101-0200/0181-0190/#190-reverse-bits-star","text":"Time: $O(32)$ Space: $O(1)$ class Solution { public : uint32_t reverseBits ( uint32_t num ) { uint32_t ans = 0 ; for ( int i = 0 ; i < 32 ; ++ i ) if (( num >> i ) & 1 ) ans |= ( 1 << ( 31 - i )); return ans ; } };","title":"190. Reverse Bits $\\star$"},{"location":"cpp/0101-0200/0191-0200/","text":"191. Number of 1 Bits $\\star$ Time: $O(32)$ Space: $O(1)$ class Solution { public : int hammingWeight ( uint32_t n ) { int ans = 0 ; for ( int i = 0 ; i < 32 ; ++ i ) if (( n >> i ) & 1 ) ++ ans ; return ans ; } }; 192. Word Frequency $\\star\\star$ 193. Valid Phone Numbers $\\star$ 194. Transpose File $\\star\\star$ 195. Tenth Line $\\star$ 196. Delete Duplicate Emails $\\star$ 197. Rising Temperature $\\star$ 198. House Robber $\\star$ Time: $O(n)$ Space: $O(n) \\to O(1)$ class Solution { public : int rob ( vector < int >& nums ) { int prev1 = 0 ; int prev2 = 0 ; for ( int num : nums ) { const int cache = prev1 ; prev1 = max ( prev1 , prev2 + num ); prev2 = cache ; } return prev1 ; } }; 199. Binary Tree Right Side View $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : vector < int > rightSideView ( TreeNode * root ) { vector < int > ans ; function < void ( TreeNode * , int ) > dfs = [ & ]( TreeNode * root , int depth ) { if ( ! root ) return ; if ( depth == ans . size ()) ans . push_back ( root -> val ); dfs ( root -> right , depth + 1 ); dfs ( root -> left , depth + 1 ); }; dfs ( root , 0 ); return ans ; } }; 200. Number of Islands $\\star\\star$ Time: $O(mn)$ Space: $O(mn)$ class Solution { public : int numIslands ( vector < vector < char >>& grid ) { if ( grid . empty ()) return 0 ; const int m = grid . size (); const int n = grid [ 0 ]. size (); int ans = 0 ; function < void ( int , int ) > dfs = [ & ]( int i , int j ) { if ( i < 0 || i == m || j < 0 || j == n ) return ; if ( grid [ i ][ j ] == '0' ) return ; grid [ i ][ j ] = '0' ; dfs ( i + 1 , j ); dfs ( i - 1 , j ); dfs ( i , j + 1 ); dfs ( i , j - 1 ); }; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ][ j ] == '1' ) { ++ ans ; dfs ( i , j ); } return ans ; } };","title":"0191-0200"},{"location":"cpp/0101-0200/0191-0200/#191-number-of-1-bits-star","text":"Time: $O(32)$ Space: $O(1)$ class Solution { public : int hammingWeight ( uint32_t n ) { int ans = 0 ; for ( int i = 0 ; i < 32 ; ++ i ) if (( n >> i ) & 1 ) ++ ans ; return ans ; } };","title":"191. Number of 1 Bits $\\star$"},{"location":"cpp/0101-0200/0191-0200/#192-word-frequency-starstar","text":"","title":"192. Word Frequency $\\star\\star$"},{"location":"cpp/0101-0200/0191-0200/#193-valid-phone-numbers-star","text":"","title":"193. Valid Phone Numbers $\\star$"},{"location":"cpp/0101-0200/0191-0200/#194-transpose-file-starstar","text":"","title":"194. Transpose File $\\star\\star$"},{"location":"cpp/0101-0200/0191-0200/#195-tenth-line-star","text":"","title":"195. Tenth Line $\\star$"},{"location":"cpp/0101-0200/0191-0200/#196-delete-duplicate-emails-star","text":"","title":"196. Delete Duplicate Emails $\\star$"},{"location":"cpp/0101-0200/0191-0200/#197-rising-temperature-star","text":"","title":"197. Rising Temperature $\\star$"},{"location":"cpp/0101-0200/0191-0200/#198-house-robber-star","text":"Time: $O(n)$ Space: $O(n) \\to O(1)$ class Solution { public : int rob ( vector < int >& nums ) { int prev1 = 0 ; int prev2 = 0 ; for ( int num : nums ) { const int cache = prev1 ; prev1 = max ( prev1 , prev2 + num ); prev2 = cache ; } return prev1 ; } };","title":"198. House Robber $\\star$"},{"location":"cpp/0101-0200/0191-0200/#199-binary-tree-right-side-view-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : vector < int > rightSideView ( TreeNode * root ) { vector < int > ans ; function < void ( TreeNode * , int ) > dfs = [ & ]( TreeNode * root , int depth ) { if ( ! root ) return ; if ( depth == ans . size ()) ans . push_back ( root -> val ); dfs ( root -> right , depth + 1 ); dfs ( root -> left , depth + 1 ); }; dfs ( root , 0 ); return ans ; } };","title":"199. Binary Tree Right Side View $\\star\\star$"},{"location":"cpp/0101-0200/0191-0200/#200-number-of-islands-starstar","text":"Time: $O(mn)$ Space: $O(mn)$ class Solution { public : int numIslands ( vector < vector < char >>& grid ) { if ( grid . empty ()) return 0 ; const int m = grid . size (); const int n = grid [ 0 ]. size (); int ans = 0 ; function < void ( int , int ) > dfs = [ & ]( int i , int j ) { if ( i < 0 || i == m || j < 0 || j == n ) return ; if ( grid [ i ][ j ] == '0' ) return ; grid [ i ][ j ] = '0' ; dfs ( i + 1 , j ); dfs ( i - 1 , j ); dfs ( i , j + 1 ); dfs ( i , j - 1 ); }; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ][ j ] == '1' ) { ++ ans ; dfs ( i , j ); } return ans ; } };","title":"200. Number of Islands $\\star\\star$"},{"location":"cpp/0201-0300/0201-0210/","text":"201. Bitwise AND of Numbers Range $\\star\\star$ Time: $O(32)$ Space: $O(1)$ class Solution { public : int rangeBitwiseAnd ( int m , int n ) { int shiftBits = 0 ; while ( m != n ) { m >>= 1 ; n >>= 1 ; ++ shiftBits ; } return m << shiftBits ; } }; 202. Happy Number $\\star$ Time: $O(\\log n)$ Space: $O(1)$ class Solution { public : bool isHappy ( int n ) { auto helper = [ & ]( int n ) { int sum = 0 ; while ( n ) { sum += pow ( n % 10 , 2 ); n /= 10 ; } return sum ; }; int slow = helper ( n ); int fast = helper ( helper ( n )); while ( slow != fast ) { slow = helper ( slow ); fast = helper ( helper ( fast )); } return slow == 1 ; } }; 203. Remove Linked List Elements $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : ListNode * removeElements ( ListNode * head , int val ) { ListNode dummy ( 0 ); dummy . next = head ; ListNode * prev = & dummy ; for (; head ; head = head -> next ) if ( head -> val != val ) { prev -> next = head ; prev = prev -> next ; } prev -> next = nullptr ; return dummy . next ; } }; 204. Count Primes $\\star$ Time: $O(n\\log\\log n)$ Space: $O(n)$ class Solution { public : int countPrimes ( int n ) { if ( n <= 2 ) return false ; vector < bool > prime ( n , true ); prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int i = 0 ; i < sqrt ( n ); ++ i ) if ( prime [ i ]) for ( int j = i * i ; j < n ; j += i ) prime [ j ] = false ; return count ( begin ( prime ), end ( prime ), true ); } }; 205. Isomorphic Strings $\\star$ Time: $O(n)$ Space: $O(128)$ class Solution { public : bool isIsomorphic ( string s , string t ) { vector < int > charToIndex_s ( 128 ); vector < int > charToIndex_t ( 128 ); for ( int i = 0 ; i < s . length (); ++ i ) { if ( charToIndex_s [ s [ i ]] != charToIndex_t [ t [ i ]]) return false ; charToIndex_s [ s [ i ]] = i + 1 ; charToIndex_t [ t [ i ]] = i + 1 ; } return true ; } }; 206. Reverse Linked List $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : ListNode * reverseList ( ListNode * head ) { ListNode * prev = nullptr ; ListNode * curr = head ; while ( curr ) { ListNode * next = curr -> next ; curr -> next = prev ; prev = curr ; curr = next ; } return prev ; } }; 207. Course Schedule $\\star\\star$ Time: $O(n^2) \\to O(n)$ Space: $O(n)$ class Solution { public : bool canFinish ( int numCourses , vector < vector < int >>& prerequisites ) { vector < vector < int >> graph ( numCourses ); vector < int > state ( numCourses , 0 ); // 0: init, 1: visiting, 2: visited for ( const vector < int >& p : prerequisites ) graph [ p [ 1 ]]. push_back ( p [ 0 ]); function < bool ( int ) > hasCycle = [ & ]( int course ) { if ( state [ course ] == 1 ) return true ; if ( state [ course ] == 2 ) return false ; state [ course ] = 1 ; for ( int neighbor : graph [ course ]) if ( hasCycle ( neighbor )) return true ; state [ course ] = 2 ; return false ; }; for ( int course = 0 ; course < numCourses ; ++ course ) if ( hasCycle ( course )) return false ; return true ; } }; 208. Implement Trie (Prefix Tree) $\\star\\star$ struct TrieNode { TrieNode () : children ( 26 ), isWord ( false ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete child ; } vector < TrieNode *> children ; bool isWord ; }; class Trie { public : void insert ( const string & word ) { TrieNode * node = & root ; for ( const char c : word ) { if ( ! node -> children [ c - 'a' ]) node -> children [ c - 'a' ] = new TrieNode ; node = node -> children [ c - 'a' ]; } node -> isWord = true ; } bool search ( const string & word ) { TrieNode * node = find ( word ); return node && node -> isWord ; } bool startsWith ( const string & prefix ) { return find ( prefix ); } private : TrieNode root ; TrieNode * find ( const string & prefix ) { TrieNode * node = & root ; for ( const char c : prefix ) { if ( ! node -> children [ c - 'a' ]) return nullptr ; node = node -> children [ c - 'a' ]; } return node ; } }; 209. Minimum Size Subarray Sum $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : int minSubArrayLen ( int s , vector < int >& nums ) { int ans = INT_MAX ; int sum = 0 ; for ( int l = 0 , r = 0 ; r < nums . size (); ++ r ) { sum += nums [ r ]; while ( sum >= s ) { ans = min ( ans , r - l + 1 ); sum -= nums [ l ++ ]; } } return ans < INT_MAX ? ans : 0 ; } }; 210. Course Schedule II $\\star\\star$ Time: $O(n^2) \\to O(n)$ Space: $O(n)$ class Solution { public : vector < int > findOrder ( int numCourses , vector < vector < int >>& prerequisites ) { deque < int > ans ; vector < vector < int >> graph ( numCourses ); vector < int > state ( numCourses , 0 ); // 0: init, 1: visiting, 2: visited for ( const vector < int >& p : prerequisites ) graph [ p [ 1 ]]. push_back ( p [ 0 ]); function < bool ( int ) > hasCycle = [ & ]( int course ) { if ( state [ course ] == 1 ) return true ; if ( state [ course ] == 2 ) return false ; state [ course ] = 1 ; for ( int neighbor : graph [ course ]) if ( hasCycle ( neighbor )) return true ; state [ course ] = 2 ; ans . push_front ( course ); return false ; }; for ( int course = 0 ; course < numCourses ; ++ course ) if ( hasCycle ( course )) return {}; return { begin ( ans ), end ( ans )}; } };","title":"0201-0210"},{"location":"cpp/0201-0300/0201-0210/#201-bitwise-and-of-numbers-range-starstar","text":"Time: $O(32)$ Space: $O(1)$ class Solution { public : int rangeBitwiseAnd ( int m , int n ) { int shiftBits = 0 ; while ( m != n ) { m >>= 1 ; n >>= 1 ; ++ shiftBits ; } return m << shiftBits ; } };","title":"201. Bitwise AND of Numbers Range $\\star\\star$"},{"location":"cpp/0201-0300/0201-0210/#202-happy-number-star","text":"Time: $O(\\log n)$ Space: $O(1)$ class Solution { public : bool isHappy ( int n ) { auto helper = [ & ]( int n ) { int sum = 0 ; while ( n ) { sum += pow ( n % 10 , 2 ); n /= 10 ; } return sum ; }; int slow = helper ( n ); int fast = helper ( helper ( n )); while ( slow != fast ) { slow = helper ( slow ); fast = helper ( helper ( fast )); } return slow == 1 ; } };","title":"202. Happy Number $\\star$"},{"location":"cpp/0201-0300/0201-0210/#203-remove-linked-list-elements-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : ListNode * removeElements ( ListNode * head , int val ) { ListNode dummy ( 0 ); dummy . next = head ; ListNode * prev = & dummy ; for (; head ; head = head -> next ) if ( head -> val != val ) { prev -> next = head ; prev = prev -> next ; } prev -> next = nullptr ; return dummy . next ; } };","title":"203. Remove Linked List Elements $\\star$"},{"location":"cpp/0201-0300/0201-0210/#204-count-primes-star","text":"Time: $O(n\\log\\log n)$ Space: $O(n)$ class Solution { public : int countPrimes ( int n ) { if ( n <= 2 ) return false ; vector < bool > prime ( n , true ); prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int i = 0 ; i < sqrt ( n ); ++ i ) if ( prime [ i ]) for ( int j = i * i ; j < n ; j += i ) prime [ j ] = false ; return count ( begin ( prime ), end ( prime ), true ); } };","title":"204. Count Primes $\\star$"},{"location":"cpp/0201-0300/0201-0210/#205-isomorphic-strings-star","text":"Time: $O(n)$ Space: $O(128)$ class Solution { public : bool isIsomorphic ( string s , string t ) { vector < int > charToIndex_s ( 128 ); vector < int > charToIndex_t ( 128 ); for ( int i = 0 ; i < s . length (); ++ i ) { if ( charToIndex_s [ s [ i ]] != charToIndex_t [ t [ i ]]) return false ; charToIndex_s [ s [ i ]] = i + 1 ; charToIndex_t [ t [ i ]] = i + 1 ; } return true ; } };","title":"205. Isomorphic Strings $\\star$"},{"location":"cpp/0201-0300/0201-0210/#206-reverse-linked-list-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : ListNode * reverseList ( ListNode * head ) { ListNode * prev = nullptr ; ListNode * curr = head ; while ( curr ) { ListNode * next = curr -> next ; curr -> next = prev ; prev = curr ; curr = next ; } return prev ; } };","title":"206. Reverse Linked List $\\star$"},{"location":"cpp/0201-0300/0201-0210/#207-course-schedule-starstar","text":"Time: $O(n^2) \\to O(n)$ Space: $O(n)$ class Solution { public : bool canFinish ( int numCourses , vector < vector < int >>& prerequisites ) { vector < vector < int >> graph ( numCourses ); vector < int > state ( numCourses , 0 ); // 0: init, 1: visiting, 2: visited for ( const vector < int >& p : prerequisites ) graph [ p [ 1 ]]. push_back ( p [ 0 ]); function < bool ( int ) > hasCycle = [ & ]( int course ) { if ( state [ course ] == 1 ) return true ; if ( state [ course ] == 2 ) return false ; state [ course ] = 1 ; for ( int neighbor : graph [ course ]) if ( hasCycle ( neighbor )) return true ; state [ course ] = 2 ; return false ; }; for ( int course = 0 ; course < numCourses ; ++ course ) if ( hasCycle ( course )) return false ; return true ; } };","title":"207. Course Schedule $\\star\\star$"},{"location":"cpp/0201-0300/0201-0210/#208-implement-trie-prefix-tree-starstar","text":"struct TrieNode { TrieNode () : children ( 26 ), isWord ( false ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete child ; } vector < TrieNode *> children ; bool isWord ; }; class Trie { public : void insert ( const string & word ) { TrieNode * node = & root ; for ( const char c : word ) { if ( ! node -> children [ c - 'a' ]) node -> children [ c - 'a' ] = new TrieNode ; node = node -> children [ c - 'a' ]; } node -> isWord = true ; } bool search ( const string & word ) { TrieNode * node = find ( word ); return node && node -> isWord ; } bool startsWith ( const string & prefix ) { return find ( prefix ); } private : TrieNode root ; TrieNode * find ( const string & prefix ) { TrieNode * node = & root ; for ( const char c : prefix ) { if ( ! node -> children [ c - 'a' ]) return nullptr ; node = node -> children [ c - 'a' ]; } return node ; } };","title":"208. Implement Trie (Prefix Tree) $\\star\\star$"},{"location":"cpp/0201-0300/0201-0210/#209-minimum-size-subarray-sum-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : int minSubArrayLen ( int s , vector < int >& nums ) { int ans = INT_MAX ; int sum = 0 ; for ( int l = 0 , r = 0 ; r < nums . size (); ++ r ) { sum += nums [ r ]; while ( sum >= s ) { ans = min ( ans , r - l + 1 ); sum -= nums [ l ++ ]; } } return ans < INT_MAX ? ans : 0 ; } };","title":"209. Minimum Size Subarray Sum $\\star\\star$"},{"location":"cpp/0201-0300/0201-0210/#210-course-schedule-ii-starstar","text":"Time: $O(n^2) \\to O(n)$ Space: $O(n)$ class Solution { public : vector < int > findOrder ( int numCourses , vector < vector < int >>& prerequisites ) { deque < int > ans ; vector < vector < int >> graph ( numCourses ); vector < int > state ( numCourses , 0 ); // 0: init, 1: visiting, 2: visited for ( const vector < int >& p : prerequisites ) graph [ p [ 1 ]]. push_back ( p [ 0 ]); function < bool ( int ) > hasCycle = [ & ]( int course ) { if ( state [ course ] == 1 ) return true ; if ( state [ course ] == 2 ) return false ; state [ course ] = 1 ; for ( int neighbor : graph [ course ]) if ( hasCycle ( neighbor )) return true ; state [ course ] = 2 ; ans . push_front ( course ); return false ; }; for ( int course = 0 ; course < numCourses ; ++ course ) if ( hasCycle ( course )) return {}; return { begin ( ans ), end ( ans )}; } };","title":"210. Course Schedule II $\\star\\star$"},{"location":"cpp/0201-0300/0211-0220/","text":"211. Add and Search Word - Data structure design $\\star\\star$ struct TrieNode { TrieNode () : children ( 26 ), isWord ( false ){}; ~ TrieNode () { for ( TrieNode * child : children ) delete child ; } vector < TrieNode *> children ; bool isWord ; }; class WordDictionary { public : void addWord ( const string & word ) { TrieNode * node = & root ; for ( const char c : word ) { if ( ! node -> children [ c - 'a' ]) node -> children [ c - 'a' ] = new TrieNode ; node = node -> children [ c - 'a' ]; } node -> isWord = true ; } bool search ( const string & word ) { return dfs ( word , 0 , & root ); } private : TrieNode root ; bool dfs ( const string & word , int s , TrieNode * node ) { if ( s == word . length ()) return node -> isWord ; if ( word [ s ] != '.' ) { TrieNode * next = node -> children [ word [ s ] - 'a' ]; return next ? dfs ( word , s + 1 , next ) : false ; } // word[s] == '.' -> search all 26 children for ( int i = 0 ; i < 26 ; ++ i ) if ( node -> children [ i ] && dfs ( word , s + 1 , node -> children [ i ])) return true ; return false ; } }; 212. Word Search II $\\star\\star\\star$ struct TrieNode { TrieNode () : children ( 26 ), word ( nullptr ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete child ; } vector < TrieNode *> children ; const string * word ; }; class Solution { public : vector < string > findWords ( vector < vector < char >>& board , vector < string >& words ) { const int m = board . size (); const int n = board [ 0 ]. size (); vector < string > ans ; for ( const string & word : words ) insert ( word ); function < void ( int , int , TrieNode * ) > dfs = [ & ]( int i , int j , TrieNode * node ) { if ( i < 0 || i == m || j < 0 || j == n ) return ; if ( board [ i ][ j ] == '*' ) return ; const char c = board [ i ][ j ]; TrieNode * next = node -> children [ c - 'a' ]; if ( ! next ) return ; if ( next -> word ) { ans . push_back ( * next -> word ); next -> word = nullptr ; } board [ i ][ j ] = '*' ; dfs ( i + 1 , j , next ); dfs ( i - 1 , j , next ); dfs ( i , j + 1 , next ); dfs ( i , j - 1 , next ); board [ i ][ j ] = c ; }; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) dfs ( i , j , & root ); return ans ; } private : TrieNode root ; void insert ( const string & word ) { TrieNode * node = & root ; for ( const char c : word ) { if ( ! node -> children [ c - 'a' ]) node -> children [ c - 'a' ] = new TrieNode ; node = node -> children [ c - 'a' ]; } node -> word = & word ; } }; 213. House Robber II $\\star\\star$ Time: $O(n)$ Space: $O(n) \\to O(1)$ class Solution { public : int rob ( vector < int >& nums ) { if ( nums . empty ()) return 0 ; if ( nums . size () == 1 ) return nums [ 0 ]; auto rob = [ & ]( int l , int r ) { int prev1 = 0 ; int prev2 = 0 ; for ( int i = l ; i <= r ; ++ i ) { const int cache = prev1 ; prev1 = max ( prev1 , prev2 + nums [ i ]); prev2 = cache ; } return prev1 ; }; return max ( rob ( 0 , nums . size () - 2 ), rob ( 1 , nums . size () - 1 )); } }; 214. Shortest Palindrome $\\star\\star\\star$ 215. Kth Largest Element in an Array $\\star\\star$ Time: $O(n\\log k)$ Space: $O(k)$ class Solution { public : int findKthLargest ( vector < int >& nums , int k ) { priority_queue < int , vector < int > , greater <>> pq ; for ( const int num : nums ) { pq . push ( num ); if ( pq . size () > k ) pq . pop (); } return pq . top (); } }; 216. Combination Sum III $\\star\\star$ Time: $O(C(9, k)) = O(9^k)$ Space: $O(n)$ class Solution { public : vector < vector < int >> combinationSum3 ( int k , int n ) { vector < vector < int >> ans ; vector < int > path ; function < void ( int , int , int ) > dfs = [ & ]( int s , int k , int n ) { if ( k == 0 && n == 0 ) { ans . push_back ( path ); return ; } if ( k == 0 || n <= 0 ) return ; for ( int i = s ; i <= 9 ; ++ i ) { path . push_back ( i ); dfs ( i + 1 , k - 1 , n - i ); path . pop_back (); } }; dfs ( 1 , k , n ); return ans ; } }; 217. Contains Duplicate $\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : bool containsDuplicate ( vector < int >& nums ) { unordered_set < int > seen ; for ( const int num : nums ) if ( ! seen . insert ( num ). second ) return true ; return false ; } }; 218. The Skyline Problem $\\star\\star\\star$ class Solution { public : vector < vector < int >> getSkyline ( vector < vector < int >>& buildings ) { vector < vector < int >> ans ; vector < vector < int >> events ; for ( const vector < int >& building : buildings ) { events . push_back ({ building [ 0 ], building [ 2 ]}); events . push_back ({ building [ 1 ], - building [ 2 ]}); } sort ( begin ( events ), end ( events ), []( const vector < int >& e1 , const vector < int >& e2 ) { return e1 [ 0 ] == e2 [ 0 ] ? e1 [ 1 ] > e2 [ 1 ] : e1 [ 0 ] < e2 [ 0 ]; }); for ( const vector < int >& event : events ) { const int x = event [ 0 ]; const int h = abs ( event [ 1 ]); if ( event [ 1 ] > 0 ) { if ( h > maxHeight ()) ans . push_back ({ x , h }); set . insert ( h ); } else { set . erase ( set . equal_range ( h ). first ); if ( h > maxHeight ()) ans . push_back ({ x , maxHeight ()}); } } return ans ; } private : multiset < int > set ; int maxHeight () const { return set . empty () ? 0 : * rbegin ( set ); } }; 219. Contains Duplicate II $\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : bool containsNearbyDuplicate ( vector < int >& nums , int k ) { unordered_set < int > seen ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( ! seen . insert ( nums [ i ]). second ) return true ; if ( i >= k ) seen . erase ( nums [ i - k ]); } return false ; } }; 220. Contains Duplicate III $\\star\\star$ Time: $O(n\\log k)$ Space: $O(k)$ class Solution { public : bool containsNearbyAlmostDuplicate ( vector < int >& nums , int k , int t ) { set < long > window ; for ( int i = 0 ; i < nums . size (); ++ i ) { const auto it = window . lower_bound (( long ) nums [ i ] - t ); if ( it != cend ( window ) && * it - nums [ i ] <= t ) return true ; window . insert ( nums [ i ]); if ( i >= k ) window . erase ( nums [ i - k ]); } return false ; } };","title":"0211-0220"},{"location":"cpp/0201-0300/0211-0220/#211-add-and-search-word-data-structure-design-starstar","text":"struct TrieNode { TrieNode () : children ( 26 ), isWord ( false ){}; ~ TrieNode () { for ( TrieNode * child : children ) delete child ; } vector < TrieNode *> children ; bool isWord ; }; class WordDictionary { public : void addWord ( const string & word ) { TrieNode * node = & root ; for ( const char c : word ) { if ( ! node -> children [ c - 'a' ]) node -> children [ c - 'a' ] = new TrieNode ; node = node -> children [ c - 'a' ]; } node -> isWord = true ; } bool search ( const string & word ) { return dfs ( word , 0 , & root ); } private : TrieNode root ; bool dfs ( const string & word , int s , TrieNode * node ) { if ( s == word . length ()) return node -> isWord ; if ( word [ s ] != '.' ) { TrieNode * next = node -> children [ word [ s ] - 'a' ]; return next ? dfs ( word , s + 1 , next ) : false ; } // word[s] == '.' -> search all 26 children for ( int i = 0 ; i < 26 ; ++ i ) if ( node -> children [ i ] && dfs ( word , s + 1 , node -> children [ i ])) return true ; return false ; } };","title":"211. Add and Search Word - Data structure design $\\star\\star$"},{"location":"cpp/0201-0300/0211-0220/#212-word-search-ii-starstarstar","text":"struct TrieNode { TrieNode () : children ( 26 ), word ( nullptr ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete child ; } vector < TrieNode *> children ; const string * word ; }; class Solution { public : vector < string > findWords ( vector < vector < char >>& board , vector < string >& words ) { const int m = board . size (); const int n = board [ 0 ]. size (); vector < string > ans ; for ( const string & word : words ) insert ( word ); function < void ( int , int , TrieNode * ) > dfs = [ & ]( int i , int j , TrieNode * node ) { if ( i < 0 || i == m || j < 0 || j == n ) return ; if ( board [ i ][ j ] == '*' ) return ; const char c = board [ i ][ j ]; TrieNode * next = node -> children [ c - 'a' ]; if ( ! next ) return ; if ( next -> word ) { ans . push_back ( * next -> word ); next -> word = nullptr ; } board [ i ][ j ] = '*' ; dfs ( i + 1 , j , next ); dfs ( i - 1 , j , next ); dfs ( i , j + 1 , next ); dfs ( i , j - 1 , next ); board [ i ][ j ] = c ; }; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) dfs ( i , j , & root ); return ans ; } private : TrieNode root ; void insert ( const string & word ) { TrieNode * node = & root ; for ( const char c : word ) { if ( ! node -> children [ c - 'a' ]) node -> children [ c - 'a' ] = new TrieNode ; node = node -> children [ c - 'a' ]; } node -> word = & word ; } };","title":"212. Word Search II $\\star\\star\\star$"},{"location":"cpp/0201-0300/0211-0220/#213-house-robber-ii-starstar","text":"Time: $O(n)$ Space: $O(n) \\to O(1)$ class Solution { public : int rob ( vector < int >& nums ) { if ( nums . empty ()) return 0 ; if ( nums . size () == 1 ) return nums [ 0 ]; auto rob = [ & ]( int l , int r ) { int prev1 = 0 ; int prev2 = 0 ; for ( int i = l ; i <= r ; ++ i ) { const int cache = prev1 ; prev1 = max ( prev1 , prev2 + nums [ i ]); prev2 = cache ; } return prev1 ; }; return max ( rob ( 0 , nums . size () - 2 ), rob ( 1 , nums . size () - 1 )); } };","title":"213. House Robber II $\\star\\star$"},{"location":"cpp/0201-0300/0211-0220/#214-shortest-palindrome-starstarstar","text":"","title":"214. Shortest Palindrome $\\star\\star\\star$"},{"location":"cpp/0201-0300/0211-0220/#215-kth-largest-element-in-an-array-starstar","text":"Time: $O(n\\log k)$ Space: $O(k)$ class Solution { public : int findKthLargest ( vector < int >& nums , int k ) { priority_queue < int , vector < int > , greater <>> pq ; for ( const int num : nums ) { pq . push ( num ); if ( pq . size () > k ) pq . pop (); } return pq . top (); } };","title":"215. Kth Largest Element in an Array $\\star\\star$"},{"location":"cpp/0201-0300/0211-0220/#216-combination-sum-iii-starstar","text":"Time: $O(C(9, k)) = O(9^k)$ Space: $O(n)$ class Solution { public : vector < vector < int >> combinationSum3 ( int k , int n ) { vector < vector < int >> ans ; vector < int > path ; function < void ( int , int , int ) > dfs = [ & ]( int s , int k , int n ) { if ( k == 0 && n == 0 ) { ans . push_back ( path ); return ; } if ( k == 0 || n <= 0 ) return ; for ( int i = s ; i <= 9 ; ++ i ) { path . push_back ( i ); dfs ( i + 1 , k - 1 , n - i ); path . pop_back (); } }; dfs ( 1 , k , n ); return ans ; } };","title":"216. Combination Sum III $\\star\\star$"},{"location":"cpp/0201-0300/0211-0220/#217-contains-duplicate-star","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : bool containsDuplicate ( vector < int >& nums ) { unordered_set < int > seen ; for ( const int num : nums ) if ( ! seen . insert ( num ). second ) return true ; return false ; } };","title":"217. Contains Duplicate $\\star$"},{"location":"cpp/0201-0300/0211-0220/#218-the-skyline-problem-starstarstar","text":"class Solution { public : vector < vector < int >> getSkyline ( vector < vector < int >>& buildings ) { vector < vector < int >> ans ; vector < vector < int >> events ; for ( const vector < int >& building : buildings ) { events . push_back ({ building [ 0 ], building [ 2 ]}); events . push_back ({ building [ 1 ], - building [ 2 ]}); } sort ( begin ( events ), end ( events ), []( const vector < int >& e1 , const vector < int >& e2 ) { return e1 [ 0 ] == e2 [ 0 ] ? e1 [ 1 ] > e2 [ 1 ] : e1 [ 0 ] < e2 [ 0 ]; }); for ( const vector < int >& event : events ) { const int x = event [ 0 ]; const int h = abs ( event [ 1 ]); if ( event [ 1 ] > 0 ) { if ( h > maxHeight ()) ans . push_back ({ x , h }); set . insert ( h ); } else { set . erase ( set . equal_range ( h ). first ); if ( h > maxHeight ()) ans . push_back ({ x , maxHeight ()}); } } return ans ; } private : multiset < int > set ; int maxHeight () const { return set . empty () ? 0 : * rbegin ( set ); } };","title":"218. The Skyline Problem $\\star\\star\\star$"},{"location":"cpp/0201-0300/0211-0220/#219-contains-duplicate-ii-star","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : bool containsNearbyDuplicate ( vector < int >& nums , int k ) { unordered_set < int > seen ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( ! seen . insert ( nums [ i ]). second ) return true ; if ( i >= k ) seen . erase ( nums [ i - k ]); } return false ; } };","title":"219. Contains Duplicate II $\\star$"},{"location":"cpp/0201-0300/0211-0220/#220-contains-duplicate-iii-starstar","text":"Time: $O(n\\log k)$ Space: $O(k)$ class Solution { public : bool containsNearbyAlmostDuplicate ( vector < int >& nums , int k , int t ) { set < long > window ; for ( int i = 0 ; i < nums . size (); ++ i ) { const auto it = window . lower_bound (( long ) nums [ i ] - t ); if ( it != cend ( window ) && * it - nums [ i ] <= t ) return true ; window . insert ( nums [ i ]); if ( i >= k ) window . erase ( nums [ i - k ]); } return false ; } };","title":"220. Contains Duplicate III $\\star\\star$"},{"location":"cpp/0201-0300/0221-0230/","text":"221. Maximal Square $\\star\\star$ Time: $O(mn)$ Space: $O(mn) \\to O(n)$ class Solution { public : int maximalSquare ( vector < vector < char >>& matrix ) { if ( matrix . empty ()) return 0 ; int maxLength = 0 ; vector < vector < int >> dp ( matrix . size (), vector < int > ( matrix [ 0 ]. size ())); for ( int i = 0 ; i < matrix . size (); ++ i ) for ( int j = 0 ; j < matrix [ 0 ]. size (); ++ j ) { if ( i == 0 || j == 0 || matrix [ i ][ j ] == '0' ) dp [ i ][ j ] = matrix [ i ][ j ] == '1' ? 1 : 0 ; else dp [ i ][ j ] = min ({ dp [ i - 1 ][ j - 1 ], dp [ i - 1 ][ j ], dp [ i ][ j - 1 ]}) + 1 ; maxLength = max ( maxLength , dp [ i ][ j ]); } return maxLength * maxLength ; } }; 222. Count Complete Tree Nodes $\\star\\star$ Time: $O(\\log^2n)$ Space: $O(1)$ class Solution { public : int countNodes ( TreeNode * root ) { if ( ! root ) return 0 ; TreeNode * l = root ; TreeNode * r = root ; int heightL = 0 ; int heightR = 0 ; while ( l ) { ++ heightL ; l = l -> left ; } while ( r ) { ++ heightR ; r = r -> right ; } if ( heightL == heightR ) return pow ( 2 , heightL ) - 1 ; return 1 + countNodes ( root -> left ) + countNodes ( root -> right ); } }; 223. Rectangle Area $\\star\\star$ Time: $O(1)$ Space: $O(1)$ class Solution { public : int computeArea ( long A , long B , long C , long D , long E , long F , long G , long H ) { const long x = max ( A , E ) < min ( C , G ) ? ( min ( C , G ) - max ( A , E )) : 0 ; const long y = max ( B , F ) < min ( D , H ) ? ( min ( D , H ) - max ( B , F )) : 0 ; return ( C - A ) * ( D - B ) + ( G - E ) * ( H - F ) - x * y ; } }; 224. Basic Calculator $\\star\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : int calculate ( string s ) { int ans = 0 ; int num = 0 ; int sign = 1 ; stack < int > stack {{ sign }}; for ( int i = 0 ; i < s . length (); ++ i ) { const char c = s [ i ]; if ( isdigit ( c )) num = num * 10 + ( c - '0' ); else if ( c == '+' || c == '-' ) { ans += sign * num ; sign = stack . top () * ( c == '+' ? 1 : - 1 ); num = 0 ; } else if ( c == '(' ) stack . push ( sign ); else if ( c == ' ) ' ) stack . pop (); } return ans + sign * num ; } }; 225. Implement Stack using Queues $\\star$ Time: $O(1)$ Space: $O(n)$ class MyStack { public : void push ( int x ) { queue . push ( x ); for ( int i = 0 ; i < queue . size () - 1 ; ++ i ) { queue . push ( queue . front ()); queue . pop (); } } int pop () { int val = queue . front (); queue . pop (); return val ; } int top () { return queue . front (); } bool empty () { return queue . empty (); } private : queue < int > queue ; }; 226. Invert Binary Tree $\\star$ Time: $O(\\log n)$ Space: $O(\\log n)$ class Solution { public : TreeNode * invertTree ( TreeNode * root ) { if ( ! root ) return nullptr ; invertTree ( root -> left ); invertTree ( root -> right ); swap ( root -> left , root -> right ); return root ; } }; 227. Basic Calculator II $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : int calculate ( string s ) { int ans = 0 ; int num = 0 ; char sign = '+' ; stack < int > stack ; for ( int i = 0 ; i < s . length (); ++ i ) { const char c = s [ i ]; if ( isdigit ( c )) num = num * 10 + ( c - '0' ); if ( ! isdigit ( c ) && ! isspace ( c ) || i == s . length () - 1 ) { switch ( sign ) { case '+' : stack . push ( num ); break ; case '-' : stack . push ( - num ); break ; case '*' : num = stack . top () * num , stack . pop (); stack . push ( num ); break ; default : num = stack . top () / num , stack . pop (); stack . push ( num ); } num = 0 ; sign = c ; } } while ( ! stack . empty ()) ans += stack . top (), stack . pop (); return ans ; } }; 228. Summary Ranges $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : vector < string > summaryRanges ( vector < int >& nums ) { vector < string > ans ; for ( int i = 0 ; i < nums . size (); ++ i ) { const int begin = nums [ i ]; while ( i + 1 < nums . size () && nums [ i ] == nums [ i + 1 ] - 1 ) ++ i ; const int end = nums [ i ]; if ( begin == end ) ans . push_back ( to_string ( begin )); else ans . push_back ( to_string ( begin ) + \"->\" + to_string ( end )); } return ans ; } }; 229. Majority Element II $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : vector < int > majorityElement ( vector < int >& nums ) { vector < int > ans ; int ans1 = 0 ; int ans2 = 1 ; int count1 = 0 ; int count2 = 0 ; for ( int num : nums ) if ( num == ans1 ) ++ count1 ; else if ( num == ans2 ) ++ count2 ; else if ( count1 == 0 ) { ans1 = num ; ++ count1 ; } else if ( count2 == 0 ) { ans2 = num ; ++ count2 ; } else { -- count1 ; -- count2 ; } count1 = 0 ; count2 = 0 ; for ( const int num : nums ) if ( num == ans1 ) ++ count1 ; else if ( num == ans2 ) ++ count2 ; if ( count1 > nums . size () / 3 ) ans . push_back ( ans1 ); if ( count2 > nums . size () / 3 ) ans . push_back ( ans2 ); return ans ; } }; 230. Kth Smallest Element in a BST $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : int kthSmallest ( TreeNode * root , int k ) { vector < int > nums ; function < void ( TreeNode * ) > inorder = [ & ]( TreeNode * root ) { if ( ! root ) return ; inorder ( root -> left ); nums . push_back ( root -> val ); inorder ( root -> right ); }; inorder ( root ); return nums [ k - 1 ]; } };","title":"0221-0230"},{"location":"cpp/0201-0300/0221-0230/#221-maximal-square-starstar","text":"Time: $O(mn)$ Space: $O(mn) \\to O(n)$ class Solution { public : int maximalSquare ( vector < vector < char >>& matrix ) { if ( matrix . empty ()) return 0 ; int maxLength = 0 ; vector < vector < int >> dp ( matrix . size (), vector < int > ( matrix [ 0 ]. size ())); for ( int i = 0 ; i < matrix . size (); ++ i ) for ( int j = 0 ; j < matrix [ 0 ]. size (); ++ j ) { if ( i == 0 || j == 0 || matrix [ i ][ j ] == '0' ) dp [ i ][ j ] = matrix [ i ][ j ] == '1' ? 1 : 0 ; else dp [ i ][ j ] = min ({ dp [ i - 1 ][ j - 1 ], dp [ i - 1 ][ j ], dp [ i ][ j - 1 ]}) + 1 ; maxLength = max ( maxLength , dp [ i ][ j ]); } return maxLength * maxLength ; } };","title":"221. Maximal Square $\\star\\star$"},{"location":"cpp/0201-0300/0221-0230/#222-count-complete-tree-nodes-starstar","text":"Time: $O(\\log^2n)$ Space: $O(1)$ class Solution { public : int countNodes ( TreeNode * root ) { if ( ! root ) return 0 ; TreeNode * l = root ; TreeNode * r = root ; int heightL = 0 ; int heightR = 0 ; while ( l ) { ++ heightL ; l = l -> left ; } while ( r ) { ++ heightR ; r = r -> right ; } if ( heightL == heightR ) return pow ( 2 , heightL ) - 1 ; return 1 + countNodes ( root -> left ) + countNodes ( root -> right ); } };","title":"222. Count Complete Tree Nodes $\\star\\star$"},{"location":"cpp/0201-0300/0221-0230/#223-rectangle-area-starstar","text":"Time: $O(1)$ Space: $O(1)$ class Solution { public : int computeArea ( long A , long B , long C , long D , long E , long F , long G , long H ) { const long x = max ( A , E ) < min ( C , G ) ? ( min ( C , G ) - max ( A , E )) : 0 ; const long y = max ( B , F ) < min ( D , H ) ? ( min ( D , H ) - max ( B , F )) : 0 ; return ( C - A ) * ( D - B ) + ( G - E ) * ( H - F ) - x * y ; } };","title":"223. Rectangle Area $\\star\\star$"},{"location":"cpp/0201-0300/0221-0230/#224-basic-calculator-starstarstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : int calculate ( string s ) { int ans = 0 ; int num = 0 ; int sign = 1 ; stack < int > stack {{ sign }}; for ( int i = 0 ; i < s . length (); ++ i ) { const char c = s [ i ]; if ( isdigit ( c )) num = num * 10 + ( c - '0' ); else if ( c == '+' || c == '-' ) { ans += sign * num ; sign = stack . top () * ( c == '+' ? 1 : - 1 ); num = 0 ; } else if ( c == '(' ) stack . push ( sign ); else if ( c == ' ) ' ) stack . pop (); } return ans + sign * num ; } };","title":"224. Basic Calculator $\\star\\star\\star$"},{"location":"cpp/0201-0300/0221-0230/#225-implement-stack-using-queues-star","text":"Time: $O(1)$ Space: $O(n)$ class MyStack { public : void push ( int x ) { queue . push ( x ); for ( int i = 0 ; i < queue . size () - 1 ; ++ i ) { queue . push ( queue . front ()); queue . pop (); } } int pop () { int val = queue . front (); queue . pop (); return val ; } int top () { return queue . front (); } bool empty () { return queue . empty (); } private : queue < int > queue ; };","title":"225. Implement Stack using Queues $\\star$"},{"location":"cpp/0201-0300/0221-0230/#226-invert-binary-tree-star","text":"Time: $O(\\log n)$ Space: $O(\\log n)$ class Solution { public : TreeNode * invertTree ( TreeNode * root ) { if ( ! root ) return nullptr ; invertTree ( root -> left ); invertTree ( root -> right ); swap ( root -> left , root -> right ); return root ; } };","title":"226. Invert Binary Tree $\\star$"},{"location":"cpp/0201-0300/0221-0230/#227-basic-calculator-ii-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : int calculate ( string s ) { int ans = 0 ; int num = 0 ; char sign = '+' ; stack < int > stack ; for ( int i = 0 ; i < s . length (); ++ i ) { const char c = s [ i ]; if ( isdigit ( c )) num = num * 10 + ( c - '0' ); if ( ! isdigit ( c ) && ! isspace ( c ) || i == s . length () - 1 ) { switch ( sign ) { case '+' : stack . push ( num ); break ; case '-' : stack . push ( - num ); break ; case '*' : num = stack . top () * num , stack . pop (); stack . push ( num ); break ; default : num = stack . top () / num , stack . pop (); stack . push ( num ); } num = 0 ; sign = c ; } } while ( ! stack . empty ()) ans += stack . top (), stack . pop (); return ans ; } };","title":"227. Basic Calculator II $\\star\\star$"},{"location":"cpp/0201-0300/0221-0230/#228-summary-ranges-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : vector < string > summaryRanges ( vector < int >& nums ) { vector < string > ans ; for ( int i = 0 ; i < nums . size (); ++ i ) { const int begin = nums [ i ]; while ( i + 1 < nums . size () && nums [ i ] == nums [ i + 1 ] - 1 ) ++ i ; const int end = nums [ i ]; if ( begin == end ) ans . push_back ( to_string ( begin )); else ans . push_back ( to_string ( begin ) + \"->\" + to_string ( end )); } return ans ; } };","title":"228. Summary Ranges $\\star\\star$"},{"location":"cpp/0201-0300/0221-0230/#229-majority-element-ii-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : vector < int > majorityElement ( vector < int >& nums ) { vector < int > ans ; int ans1 = 0 ; int ans2 = 1 ; int count1 = 0 ; int count2 = 0 ; for ( int num : nums ) if ( num == ans1 ) ++ count1 ; else if ( num == ans2 ) ++ count2 ; else if ( count1 == 0 ) { ans1 = num ; ++ count1 ; } else if ( count2 == 0 ) { ans2 = num ; ++ count2 ; } else { -- count1 ; -- count2 ; } count1 = 0 ; count2 = 0 ; for ( const int num : nums ) if ( num == ans1 ) ++ count1 ; else if ( num == ans2 ) ++ count2 ; if ( count1 > nums . size () / 3 ) ans . push_back ( ans1 ); if ( count2 > nums . size () / 3 ) ans . push_back ( ans2 ); return ans ; } };","title":"229. Majority Element II $\\star\\star$"},{"location":"cpp/0201-0300/0221-0230/#230-kth-smallest-element-in-a-bst-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : int kthSmallest ( TreeNode * root , int k ) { vector < int > nums ; function < void ( TreeNode * ) > inorder = [ & ]( TreeNode * root ) { if ( ! root ) return ; inorder ( root -> left ); nums . push_back ( root -> val ); inorder ( root -> right ); }; inorder ( root ); return nums [ k - 1 ]; } };","title":"230. Kth Smallest Element in a BST $\\star\\star$"},{"location":"cpp/0201-0300/0231-0240/","text":"231. Power of Two $\\star$ Time: $O(1)$ Space: $O(1)$ class Solution { public : bool isPowerOfTwo ( int n ) { return n < 0 ? false : __builtin_popcountll ( n ) == 1 ; } }; 232. Implement Queue using Stacks $\\star$ Time: $O(1)$ Space: $O(n)$ class MyQueue { public : void push ( int x ) { input . push ( x ); } int pop () { peek (); int val = output . top (); output . pop (); return val ; } int peek () { if ( output . empty ()) while ( ! input . empty ()) output . push ( input . top ()), input . pop (); return output . top (); } bool empty () { return input . empty () && output . empty (); } private : stack < int > input ; stack < int > output ; }; 233. Number of Digit One $\\star\\star\\star$ Time: $O(\\log n)$ Space: $O(1)$ class Solution { public : int countDigitOne ( int n ) { if ( n < 0 ) return 0 ; int ans = 0 ; int num = n ; for ( long i = 1 ; i <= n ; i *= 10 , num /= 10 ) { const int prefix = n / ( i * 10 ); const int suffix = n % i ; const int currentDigit = num % 10 ; ans += prefix * i ; if ( currentDigit > 1 ) ans += i ; else if ( currentDigit == 1 ) ans += suffix + 1 ; } return ans ; } }; 234. Palindrome Linked List $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : bool isPalindrome ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } if ( fast ) slow = slow -> next ; slow = reverseList ( slow ); while ( slow ) { if ( slow -> val != head -> val ) return false ; slow = slow -> next ; head = head -> next ; } return true ; } private : ListNode * reverseList ( ListNode * head ) { ListNode * prev = nullptr ; ListNode * curr = head ; while ( curr ) { ListNode * next = curr -> next ; curr -> next = prev ; prev = curr ; curr = next ; } return prev ; } }; 235. Lowest Common Ancestor of a Binary Search Tree $\\star$ Time: $O(\\log n)$ Space: $O(\\log n)$ class Solution { public : TreeNode * lowestCommonAncestor ( TreeNode * root , TreeNode * p , TreeNode * q ) { if ( root -> val > max ( p -> val , q -> val )) return lowestCommonAncestor ( root -> left , p , q ); if ( root -> val < min ( p -> val , q -> val )) return lowestCommonAncestor ( root -> right , p , q ); return root ; } }; 236. Lowest Common Ancestor of a Binary Tree $\\star\\star$ Time: $O(\\log n)$ Space: $O(\\log n)$ class Solution { public : TreeNode * lowestCommonAncestor ( TreeNode * root , TreeNode * p , TreeNode * q ) { if ( ! root ) return nullptr ; if ( root == p || root == q ) return root ; TreeNode * left = lowestCommonAncestor ( root -> left , p , q ); TreeNode * right = lowestCommonAncestor ( root -> right , p , q ); if ( ! left ) return right ; if ( ! right ) return left ; return root ; } }; 237. Delete Node in a Linked List $\\star$ Time: $O(1)$ Space: $O(1)$ class Solution { public : void deleteNode ( ListNode * node ) { node -> val = node -> next -> val ; node -> next = node -> next -> next ; } }; 238. Product of Array Except Self $\\star\\star$ Time: $O(n)$ Space: $O(n) \\to O(1)$ class Solution { public : vector < int > productExceptSelf ( vector < int >& nums ) { vector < int > ans ( nums . size ()); ans [ 0 ] = 1 ; int r = 1 ; for ( int i = 1 ; i < nums . size (); ++ i ) ans [ i ] = ans [ i - 1 ] * nums [ i - 1 ]; for ( int i = nums . size () - 1 ; i >= 0 ; -- i ) { ans [ i ] *= r ; r *= nums [ i ]; } return ans ; } }; 239. Sliding Window Maximum $\\star\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : vector < int > maxSlidingWindow ( vector < int >& nums , int k ) { vector < int > ans ; deque < int > maxQueue ; for ( int i = 0 ; i < nums . size (); ++ i ) { while ( ! maxQueue . empty () && maxQueue . back () < nums [ i ]) maxQueue . pop_back (); maxQueue . push_back ( nums [ i ]); if ( i >= k - 1 ) { ans . push_back ( maxQueue . front ()); if ( nums [ i - k + 1 ] == maxQueue . front ()) maxQueue . pop_front (); } } return ans ; } }; 240. Search a 2D Matrix II $\\star\\star$ Time: $O(m + n)$ Space: $O(1)$ class Solution { public : bool searchMatrix ( vector < vector < int >>& matrix , int target ) { if ( matrix . empty ()) return false ; int r = 0 ; int c = matrix [ 0 ]. size () - 1 ; while ( r < matrix . size () && c >= 0 ) { if ( matrix [ r ][ c ] == target ) return true ; target < matrix [ r ][ c ] ? -- c : ++ r ; } return false ; } };","title":"0231-0240"},{"location":"cpp/0201-0300/0231-0240/#231-power-of-two-star","text":"Time: $O(1)$ Space: $O(1)$ class Solution { public : bool isPowerOfTwo ( int n ) { return n < 0 ? false : __builtin_popcountll ( n ) == 1 ; } };","title":"231. Power of Two $\\star$"},{"location":"cpp/0201-0300/0231-0240/#232-implement-queue-using-stacks-star","text":"Time: $O(1)$ Space: $O(n)$ class MyQueue { public : void push ( int x ) { input . push ( x ); } int pop () { peek (); int val = output . top (); output . pop (); return val ; } int peek () { if ( output . empty ()) while ( ! input . empty ()) output . push ( input . top ()), input . pop (); return output . top (); } bool empty () { return input . empty () && output . empty (); } private : stack < int > input ; stack < int > output ; };","title":"232. Implement Queue using Stacks $\\star$"},{"location":"cpp/0201-0300/0231-0240/#233-number-of-digit-one-starstarstar","text":"Time: $O(\\log n)$ Space: $O(1)$ class Solution { public : int countDigitOne ( int n ) { if ( n < 0 ) return 0 ; int ans = 0 ; int num = n ; for ( long i = 1 ; i <= n ; i *= 10 , num /= 10 ) { const int prefix = n / ( i * 10 ); const int suffix = n % i ; const int currentDigit = num % 10 ; ans += prefix * i ; if ( currentDigit > 1 ) ans += i ; else if ( currentDigit == 1 ) ans += suffix + 1 ; } return ans ; } };","title":"233. Number of Digit One $\\star\\star\\star$"},{"location":"cpp/0201-0300/0231-0240/#234-palindrome-linked-list-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : bool isPalindrome ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } if ( fast ) slow = slow -> next ; slow = reverseList ( slow ); while ( slow ) { if ( slow -> val != head -> val ) return false ; slow = slow -> next ; head = head -> next ; } return true ; } private : ListNode * reverseList ( ListNode * head ) { ListNode * prev = nullptr ; ListNode * curr = head ; while ( curr ) { ListNode * next = curr -> next ; curr -> next = prev ; prev = curr ; curr = next ; } return prev ; } };","title":"234. Palindrome Linked List $\\star$"},{"location":"cpp/0201-0300/0231-0240/#235-lowest-common-ancestor-of-a-binary-search-tree-star","text":"Time: $O(\\log n)$ Space: $O(\\log n)$ class Solution { public : TreeNode * lowestCommonAncestor ( TreeNode * root , TreeNode * p , TreeNode * q ) { if ( root -> val > max ( p -> val , q -> val )) return lowestCommonAncestor ( root -> left , p , q ); if ( root -> val < min ( p -> val , q -> val )) return lowestCommonAncestor ( root -> right , p , q ); return root ; } };","title":"235. Lowest Common Ancestor of a Binary Search Tree $\\star$"},{"location":"cpp/0201-0300/0231-0240/#236-lowest-common-ancestor-of-a-binary-tree-starstar","text":"Time: $O(\\log n)$ Space: $O(\\log n)$ class Solution { public : TreeNode * lowestCommonAncestor ( TreeNode * root , TreeNode * p , TreeNode * q ) { if ( ! root ) return nullptr ; if ( root == p || root == q ) return root ; TreeNode * left = lowestCommonAncestor ( root -> left , p , q ); TreeNode * right = lowestCommonAncestor ( root -> right , p , q ); if ( ! left ) return right ; if ( ! right ) return left ; return root ; } };","title":"236. Lowest Common Ancestor of a Binary Tree $\\star\\star$"},{"location":"cpp/0201-0300/0231-0240/#237-delete-node-in-a-linked-list-star","text":"Time: $O(1)$ Space: $O(1)$ class Solution { public : void deleteNode ( ListNode * node ) { node -> val = node -> next -> val ; node -> next = node -> next -> next ; } };","title":"237. Delete Node in a Linked List $\\star$"},{"location":"cpp/0201-0300/0231-0240/#238-product-of-array-except-self-starstar","text":"Time: $O(n)$ Space: $O(n) \\to O(1)$ class Solution { public : vector < int > productExceptSelf ( vector < int >& nums ) { vector < int > ans ( nums . size ()); ans [ 0 ] = 1 ; int r = 1 ; for ( int i = 1 ; i < nums . size (); ++ i ) ans [ i ] = ans [ i - 1 ] * nums [ i - 1 ]; for ( int i = nums . size () - 1 ; i >= 0 ; -- i ) { ans [ i ] *= r ; r *= nums [ i ]; } return ans ; } };","title":"238. Product of Array Except Self $\\star\\star$"},{"location":"cpp/0201-0300/0231-0240/#239-sliding-window-maximum-starstarstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : vector < int > maxSlidingWindow ( vector < int >& nums , int k ) { vector < int > ans ; deque < int > maxQueue ; for ( int i = 0 ; i < nums . size (); ++ i ) { while ( ! maxQueue . empty () && maxQueue . back () < nums [ i ]) maxQueue . pop_back (); maxQueue . push_back ( nums [ i ]); if ( i >= k - 1 ) { ans . push_back ( maxQueue . front ()); if ( nums [ i - k + 1 ] == maxQueue . front ()) maxQueue . pop_front (); } } return ans ; } };","title":"239. Sliding Window Maximum $\\star\\star\\star$"},{"location":"cpp/0201-0300/0231-0240/#240-search-a-2d-matrix-ii-starstar","text":"Time: $O(m + n)$ Space: $O(1)$ class Solution { public : bool searchMatrix ( vector < vector < int >>& matrix , int target ) { if ( matrix . empty ()) return false ; int r = 0 ; int c = matrix [ 0 ]. size () - 1 ; while ( r < matrix . size () && c >= 0 ) { if ( matrix [ r ][ c ] == target ) return true ; target < matrix [ r ][ c ] ? -- c : ++ r ; } return false ; } };","title":"240. Search a 2D Matrix II $\\star\\star$"},{"location":"cpp/0201-0300/0241-0250/","text":"241. Different Ways to Add Parentheses $\\star\\star$ Time: $O(2^n \\to n)$ Space: $O(2^n)$ class Solution { public : vector < int > diffWaysToCompute ( string input ) { unordered_map < string , vector < int >> memo ; function < vector < int > ( const string & ) > ways = [ & ]( const string & s ) { if ( memo . count ( s )) return memo [ s ]; vector < int > ans ; for ( int i = 0 ; i < s . length (); ++ i ) if ( ispunct ( s [ i ])) for ( int a : ways ( s . substr ( 0 , i ))) for ( int b : ways ( s . substr ( i + 1 ))) ans . push_back ( s [ i ] == '+' ? a + b : s [ i ] == '-' ? a - b : a * b ); return memo [ s ] = ans . empty () ? vector < int > { stoi ( s )} : ans ; }; return ways ( input ); } }; 242. Valid Anagram $\\star$ Time: $O(26)$ Space: $O(n)$ class Solution { public : bool isAnagram ( string s , string t ) { if ( s . length () != t . length ()) return false ; vector < int > count ( 26 ); for ( const char c : s ) ++ count [ c - 'a' ]; for ( const char c : t ) if ( -- count [ c - 'a' ] < 0 ) return false ; return true ; } }; 243. Shortest Word Distance $\\star$ \ud83d\udd12 244. Shortest Word Distance II $\\star\\star$ \ud83d\udd12 245. Shortest Word Distance III $\\star\\star$ \ud83d\udd12 246. Strobogrammatic Number $\\star$ \ud83d\udd12 247. Strobogrammatic Number II $\\star\\star$ \ud83d\udd12 248. Strobogrammatic Number III $\\star\\star\\star$ \ud83d\udd12 249. Group Shifted Strings $\\star\\star$ \ud83d\udd12 250. Count Univalue Subtrees $\\star\\star$ \ud83d\udd12","title":"0241-0250"},{"location":"cpp/0201-0300/0241-0250/#241-different-ways-to-add-parentheses-starstar","text":"Time: $O(2^n \\to n)$ Space: $O(2^n)$ class Solution { public : vector < int > diffWaysToCompute ( string input ) { unordered_map < string , vector < int >> memo ; function < vector < int > ( const string & ) > ways = [ & ]( const string & s ) { if ( memo . count ( s )) return memo [ s ]; vector < int > ans ; for ( int i = 0 ; i < s . length (); ++ i ) if ( ispunct ( s [ i ])) for ( int a : ways ( s . substr ( 0 , i ))) for ( int b : ways ( s . substr ( i + 1 ))) ans . push_back ( s [ i ] == '+' ? a + b : s [ i ] == '-' ? a - b : a * b ); return memo [ s ] = ans . empty () ? vector < int > { stoi ( s )} : ans ; }; return ways ( input ); } };","title":"241. Different Ways to Add Parentheses $\\star\\star$"},{"location":"cpp/0201-0300/0241-0250/#242-valid-anagram-star","text":"Time: $O(26)$ Space: $O(n)$ class Solution { public : bool isAnagram ( string s , string t ) { if ( s . length () != t . length ()) return false ; vector < int > count ( 26 ); for ( const char c : s ) ++ count [ c - 'a' ]; for ( const char c : t ) if ( -- count [ c - 'a' ] < 0 ) return false ; return true ; } };","title":"242. Valid Anagram $\\star$"},{"location":"cpp/0201-0300/0241-0250/#243-shortest-word-distance-star","text":"","title":"243. Shortest Word Distance $\\star$ \ud83d\udd12"},{"location":"cpp/0201-0300/0241-0250/#244-shortest-word-distance-ii-starstar","text":"","title":"244. Shortest Word Distance II $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0201-0300/0241-0250/#245-shortest-word-distance-iii-starstar","text":"","title":"245. Shortest Word Distance III $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0201-0300/0241-0250/#246-strobogrammatic-number-star","text":"","title":"246. Strobogrammatic Number $\\star$ \ud83d\udd12"},{"location":"cpp/0201-0300/0241-0250/#247-strobogrammatic-number-ii-starstar","text":"","title":"247. Strobogrammatic Number II $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0201-0300/0241-0250/#248-strobogrammatic-number-iii-starstarstar","text":"","title":"248. Strobogrammatic Number III $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/0201-0300/0241-0250/#249-group-shifted-strings-starstar","text":"","title":"249. Group Shifted Strings $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0201-0300/0241-0250/#250-count-univalue-subtrees-starstar","text":"","title":"250. Count Univalue Subtrees $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0201-0300/0251-0260/","text":"251. Flatten 2D Vector $\\star\\star$ \ud83d\udd12 252. Meeting Rooms $\\star$ \ud83d\udd12 253. Meeting Rooms II $\\star\\star$ \ud83d\udd12 254. Factor Combinations $\\star\\star$ \ud83d\udd12 255. Verify Preorder Sequence in Binary Search Tree $\\star\\star$ \ud83d\udd12 256. Paint House $\\star$ \ud83d\udd12 257. Binary Tree Paths $\\star$ Time: $O(n)$ Space: $O(\\log n)$ class Solution { public : vector < string > binaryTreePaths ( TreeNode * root ) { vector < string > ans ; function < void ( TreeNode * , const string & ) > dfs = [ & ]( TreeNode * root , const string & path ) { if ( ! root ) return ; if ( ! root -> left && ! root -> right ) { ans . push_back ( path + to_string ( root -> val )); return ; } dfs ( root -> left , path + to_string ( root -> val ) + \"->\" ); dfs ( root -> right , path + to_string ( root -> val ) + \"->\" ); }; dfs ( root , \"\" ); return ans ; } }; 258. Add Digits $\\star$ Time: $O(1)$ Space: $O(1)$ class Solution { public : int addDigits ( int num ) { return 1 + ( num - 1 ) % 9 ; } }; 259. 3Sum Smaller $\\star\\star$ \ud83d\udd12 260. Single Number III $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : vector < int > singleNumber ( vector < int >& nums ) { const int xors = accumulate ( begin ( nums ), end ( nums ), 0 , bit_xor <> ()); const int lowbit = xors & - xors ; vector < int > ans ( 2 ); for ( const int num : nums ) if ( num & lowbit ) ans [ 0 ] ^= num ; else ans [ 1 ] ^= num ; return ans ; } };","title":"0251-0260"},{"location":"cpp/0201-0300/0251-0260/#251-flatten-2d-vector-starstar","text":"","title":"251. Flatten 2D Vector $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0201-0300/0251-0260/#252-meeting-rooms-star","text":"","title":"252. Meeting Rooms $\\star$ \ud83d\udd12"},{"location":"cpp/0201-0300/0251-0260/#253-meeting-rooms-ii-starstar","text":"","title":"253. Meeting Rooms II $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0201-0300/0251-0260/#254-factor-combinations-starstar","text":"","title":"254. Factor Combinations $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0201-0300/0251-0260/#255-verify-preorder-sequence-in-binary-search-tree-starstar","text":"","title":"255. Verify Preorder Sequence in Binary Search Tree $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0201-0300/0251-0260/#256-paint-house-star","text":"","title":"256. Paint House $\\star$ \ud83d\udd12"},{"location":"cpp/0201-0300/0251-0260/#257-binary-tree-paths-star","text":"Time: $O(n)$ Space: $O(\\log n)$ class Solution { public : vector < string > binaryTreePaths ( TreeNode * root ) { vector < string > ans ; function < void ( TreeNode * , const string & ) > dfs = [ & ]( TreeNode * root , const string & path ) { if ( ! root ) return ; if ( ! root -> left && ! root -> right ) { ans . push_back ( path + to_string ( root -> val )); return ; } dfs ( root -> left , path + to_string ( root -> val ) + \"->\" ); dfs ( root -> right , path + to_string ( root -> val ) + \"->\" ); }; dfs ( root , \"\" ); return ans ; } };","title":"257. Binary Tree Paths $\\star$"},{"location":"cpp/0201-0300/0251-0260/#258-add-digits-star","text":"Time: $O(1)$ Space: $O(1)$ class Solution { public : int addDigits ( int num ) { return 1 + ( num - 1 ) % 9 ; } };","title":"258. Add Digits $\\star$"},{"location":"cpp/0201-0300/0251-0260/#259-3sum-smaller-starstar","text":"","title":"259. 3Sum Smaller $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0201-0300/0251-0260/#260-single-number-iii-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : vector < int > singleNumber ( vector < int >& nums ) { const int xors = accumulate ( begin ( nums ), end ( nums ), 0 , bit_xor <> ()); const int lowbit = xors & - xors ; vector < int > ans ( 2 ); for ( const int num : nums ) if ( num & lowbit ) ans [ 0 ] ^= num ; else ans [ 1 ] ^= num ; return ans ; } };","title":"260. Single Number III $\\star\\star$"},{"location":"cpp/0201-0300/0261-0270/","text":"261. Graph Valid Tree $\\star\\star$ \ud83d\udd12 262. Trips and Users $\\star\\star\\star$ 263. Ugly Number $\\star$ Time: $O(\\log n)$ Space: $O(1)$ class Solution { public : bool isUgly ( int num ) { if ( num == 0 ) return false ; for ( const int prime : { 2 , 3 , 5 }) while ( num % prime == 0 ) num /= prime ; return num == 1 ; } }; 264. Ugly Number II $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : int nthUglyNumber ( int n ) { vector < int > uglyNums { 1 }; int i2 = 0 ; int i3 = 0 ; int i5 = 0 ; while ( uglyNums . size () < n ) { const int next2 = uglyNums [ i2 ] * 2 ; const int next3 = uglyNums [ i3 ] * 3 ; const int next5 = uglyNums [ i5 ] * 5 ; const int next = min ({ next2 , next3 , next5 }); if ( next == next2 ) ++ i2 ; if ( next == next3 ) ++ i3 ; if ( next == next5 ) ++ i5 ; uglyNums . push_back ( next ); } return uglyNums . back (); } }; 265. Paint House II $\\star\\star\\star$ \ud83d\udd12 266. Palindrome Permutation $\\star$ \ud83d\udd12 267. Palindrome Permutation II $\\star\\star$ \ud83d\udd12 268. Missing Number $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : int missingNumber ( vector < int >& nums ) { int ans = nums . size (); for ( int i = 0 ; i < nums . size (); ++ i ) ans ^= i ^ nums [ i ]; return ans ; } }; 269. Alien Dictionary $\\star\\star\\star$ \ud83d\udd12 270. Closest Binary Search Tree Value $\\star$ \ud83d\udd12","title":"0261-0270"},{"location":"cpp/0201-0300/0261-0270/#261-graph-valid-tree-starstar","text":"","title":"261. Graph Valid Tree $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0201-0300/0261-0270/#262-trips-and-users-starstarstar","text":"","title":"262. Trips and Users $\\star\\star\\star$"},{"location":"cpp/0201-0300/0261-0270/#263-ugly-number-star","text":"Time: $O(\\log n)$ Space: $O(1)$ class Solution { public : bool isUgly ( int num ) { if ( num == 0 ) return false ; for ( const int prime : { 2 , 3 , 5 }) while ( num % prime == 0 ) num /= prime ; return num == 1 ; } };","title":"263. Ugly Number $\\star$"},{"location":"cpp/0201-0300/0261-0270/#264-ugly-number-ii-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : int nthUglyNumber ( int n ) { vector < int > uglyNums { 1 }; int i2 = 0 ; int i3 = 0 ; int i5 = 0 ; while ( uglyNums . size () < n ) { const int next2 = uglyNums [ i2 ] * 2 ; const int next3 = uglyNums [ i3 ] * 3 ; const int next5 = uglyNums [ i5 ] * 5 ; const int next = min ({ next2 , next3 , next5 }); if ( next == next2 ) ++ i2 ; if ( next == next3 ) ++ i3 ; if ( next == next5 ) ++ i5 ; uglyNums . push_back ( next ); } return uglyNums . back (); } };","title":"264. Ugly Number II $\\star\\star$"},{"location":"cpp/0201-0300/0261-0270/#265-paint-house-ii-starstarstar","text":"","title":"265. Paint House II $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/0201-0300/0261-0270/#266-palindrome-permutation-star","text":"","title":"266. Palindrome Permutation $\\star$ \ud83d\udd12"},{"location":"cpp/0201-0300/0261-0270/#267-palindrome-permutation-ii-starstar","text":"","title":"267. Palindrome Permutation II $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0201-0300/0261-0270/#268-missing-number-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : int missingNumber ( vector < int >& nums ) { int ans = nums . size (); for ( int i = 0 ; i < nums . size (); ++ i ) ans ^= i ^ nums [ i ]; return ans ; } };","title":"268. Missing Number $\\star$"},{"location":"cpp/0201-0300/0261-0270/#269-alien-dictionary-starstarstar","text":"","title":"269. Alien Dictionary $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/0201-0300/0261-0270/#270-closest-binary-search-tree-value-star","text":"","title":"270. Closest Binary Search Tree Value $\\star$ \ud83d\udd12"},{"location":"cpp/0201-0300/0271-0280/","text":"271. Encode and Decode Strings $\\star\\star$ \ud83d\udd12 272. Closest Binary Search Tree Value II $\\star\\star\\star$ \ud83d\udd12 273. Integer to English Words $\\star\\star\\star$ class Solution { public : string numberToWords ( int num ) { return num == 0 ? \"Zero\" : helper ( num ); } private : const vector < string > belowTwenty { \"\" , \"One\" , \"Two\" , \"Three\" , \"Four\" , \"Five\" , \"Six\" , \"Seven\" , \"Eight\" , \"Nine\" , \"Ten\" , \"Eleven\" , \"Twelve\" , \"Thirteen\" , \"Fourteen\" , \"Fifteen\" , \"Sixteen\" , \"Seventeen\" , \"Eighteen\" , \"Nineteen\" }; const vector < string > tens { \"\" , \"Ten\" , \"Twenty\" , \"Thirty\" , \"Forty\" , \"Fifty\" , \"Sixty\" , \"Seventy\" , \"Eighty\" , \"Ninety\" }; string helper ( int num ) { string s ; if ( num < 20 ) s = belowTwenty . at ( num ); else if ( num < 100 ) s = tens . at ( num / 10 ) + \" \" + helper ( num % 10 ); else if ( num < 1000 ) s = helper ( num / 100 ) + \" Hundred \" + helper ( num % 100 ); else if ( num < 1000000 ) s = helper ( num / 1000 ) + \" Thousand \" + helper ( num % 1000 ); else if ( num < 1000000000 ) s = helper ( num / 1000000 ) + \" Million \" + helper ( num % 1000000 ); else s = helper ( num / 1000000000 ) + \" Billion \" + helper ( num % 1000000000 ); return trim ( s ); } string trim ( string & s ) { if ( s . empty ()) return s ; s . erase ( 0 , s . find_first_not_of ( ' ' )); s . erase ( s . find_last_not_of ( ' ' ) + 1 ); return s ; } }; 274. H-Index $\\star\\star$ Time: $O(n\\log n)$ Space: $O(n)$ class Solution { public : int hIndex ( vector < int >& citations ) { const int n = citations . size (); int accumulate = 0 ; vector < int > count ( n + 1 ); for ( const int citation : citations ) ++ count [ min ( citation , n )]; for ( int i = n ; i >= 0 ; -- i ) { accumulate += count [ i ]; if ( accumulate >= i ) return i ; } throw ; } }; 275. H-Index II $\\star\\star$ Time: $O(\\log n)$ Space: $O(1)$ class Solution { public : int hIndex ( vector < int >& citations ) { int l = 0 ; int r = citations . size (); while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( citations [ m ] >= citations . size () - m ) r = m ; else l = m + 1 ; } return citations . size () - l ; } }; 276. Paint Fence $\\star$ \ud83d\udd12 277. Find the Celebrity $\\star\\star$ \ud83d\udd12 278. First Bad Version $\\star$ Time: $O(\\log n)$ Space: $O(1)$ bool isBadVersion ( int version ); class Solution { public : int firstBadVersion ( int n ) { int l = 1 ; int r = n ; while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( isBadVersion ( m )) r = m ; else l = m + 1 ; } return l ; } }; 279. Perfect Squares $\\star\\star$ Time: $O(\\log n)$ Space: $O(n\\log n)$ class Solution { public : int numSquares ( int n ) { vector < int > dp ( n + 1 , n ); dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; ++ i ) for ( int j = 1 ; j * j <= i ; ++ j ) dp [ i ] = min ( dp [ i ], dp [ i - j * j ] + 1 ); return dp [ n ]; } }; 280. Wiggle Sort $\\star\\star$ \ud83d\udd12","title":"0271-0280"},{"location":"cpp/0201-0300/0271-0280/#271-encode-and-decode-strings-starstar","text":"","title":"271. Encode and Decode Strings $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0201-0300/0271-0280/#272-closest-binary-search-tree-value-ii-starstarstar","text":"","title":"272. Closest Binary Search Tree Value II $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/0201-0300/0271-0280/#273-integer-to-english-words-starstarstar","text":"class Solution { public : string numberToWords ( int num ) { return num == 0 ? \"Zero\" : helper ( num ); } private : const vector < string > belowTwenty { \"\" , \"One\" , \"Two\" , \"Three\" , \"Four\" , \"Five\" , \"Six\" , \"Seven\" , \"Eight\" , \"Nine\" , \"Ten\" , \"Eleven\" , \"Twelve\" , \"Thirteen\" , \"Fourteen\" , \"Fifteen\" , \"Sixteen\" , \"Seventeen\" , \"Eighteen\" , \"Nineteen\" }; const vector < string > tens { \"\" , \"Ten\" , \"Twenty\" , \"Thirty\" , \"Forty\" , \"Fifty\" , \"Sixty\" , \"Seventy\" , \"Eighty\" , \"Ninety\" }; string helper ( int num ) { string s ; if ( num < 20 ) s = belowTwenty . at ( num ); else if ( num < 100 ) s = tens . at ( num / 10 ) + \" \" + helper ( num % 10 ); else if ( num < 1000 ) s = helper ( num / 100 ) + \" Hundred \" + helper ( num % 100 ); else if ( num < 1000000 ) s = helper ( num / 1000 ) + \" Thousand \" + helper ( num % 1000 ); else if ( num < 1000000000 ) s = helper ( num / 1000000 ) + \" Million \" + helper ( num % 1000000 ); else s = helper ( num / 1000000000 ) + \" Billion \" + helper ( num % 1000000000 ); return trim ( s ); } string trim ( string & s ) { if ( s . empty ()) return s ; s . erase ( 0 , s . find_first_not_of ( ' ' )); s . erase ( s . find_last_not_of ( ' ' ) + 1 ); return s ; } };","title":"273. Integer to English Words $\\star\\star\\star$"},{"location":"cpp/0201-0300/0271-0280/#274-h-index-starstar","text":"Time: $O(n\\log n)$ Space: $O(n)$ class Solution { public : int hIndex ( vector < int >& citations ) { const int n = citations . size (); int accumulate = 0 ; vector < int > count ( n + 1 ); for ( const int citation : citations ) ++ count [ min ( citation , n )]; for ( int i = n ; i >= 0 ; -- i ) { accumulate += count [ i ]; if ( accumulate >= i ) return i ; } throw ; } };","title":"274. H-Index $\\star\\star$"},{"location":"cpp/0201-0300/0271-0280/#275-h-index-ii-starstar","text":"Time: $O(\\log n)$ Space: $O(1)$ class Solution { public : int hIndex ( vector < int >& citations ) { int l = 0 ; int r = citations . size (); while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( citations [ m ] >= citations . size () - m ) r = m ; else l = m + 1 ; } return citations . size () - l ; } };","title":"275. H-Index II $\\star\\star$"},{"location":"cpp/0201-0300/0271-0280/#276-paint-fence-star","text":"","title":"276. Paint Fence $\\star$ \ud83d\udd12"},{"location":"cpp/0201-0300/0271-0280/#277-find-the-celebrity-starstar","text":"","title":"277. Find the Celebrity $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0201-0300/0271-0280/#278-first-bad-version-star","text":"Time: $O(\\log n)$ Space: $O(1)$ bool isBadVersion ( int version ); class Solution { public : int firstBadVersion ( int n ) { int l = 1 ; int r = n ; while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( isBadVersion ( m )) r = m ; else l = m + 1 ; } return l ; } };","title":"278. First Bad Version $\\star$"},{"location":"cpp/0201-0300/0271-0280/#279-perfect-squares-starstar","text":"Time: $O(\\log n)$ Space: $O(n\\log n)$ class Solution { public : int numSquares ( int n ) { vector < int > dp ( n + 1 , n ); dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; ++ i ) for ( int j = 1 ; j * j <= i ; ++ j ) dp [ i ] = min ( dp [ i ], dp [ i - j * j ] + 1 ); return dp [ n ]; } };","title":"279. Perfect Squares $\\star\\star$"},{"location":"cpp/0201-0300/0271-0280/#280-wiggle-sort-starstar","text":"","title":"280. Wiggle Sort $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0201-0300/0281-0290/","text":"281. Zigzag Iterator $\\star\\star$ \ud83d\udd12 282. Expression Add Operators $\\star\\star\\star$ Time: $O(n4^{n - 1})$ Space: $O(n^2)$ class Solution { public : vector < string > addOperators ( string num , int target ) { vector < string > ans ; vector < string > path ; auto join = []( vector < string >& path ) { string joined ; for ( const string & s : path ) joined += s ; return joined ; }; function < void ( int , long , long ) > dfs = [ & ]( int s , long eval , long multiplied ) { if ( s == num . length () && eval == target ) { ans . push_back ( join ( path )); return ; } for ( int i = 1 ; i <= num . length () - s ; ++ i ) { const string t = num . substr ( s , i ); // current substring if ( i > 1 && t [ 0 ] == '0' ) continue ; const long curr = stol ( t ); // current substring's number if ( s == 0 ) { path . push_back ( t ); dfs ( i , curr , curr ); path . pop_back (); continue ; } for ( const string & op : { \"+\" , \"-\" , \"*\" }) { path . push_back ( op ); path . push_back ( t ); if ( op == \"+\" ) dfs ( s + i , eval + curr , curr ); else if ( op == \"-\" ) dfs ( s + i , eval - curr , - curr ); else dfs ( s + i , eval - multiplied + multiplied * curr , multiplied * curr ); path . pop_back (); path . pop_back (); } } }; dfs ( 0 , 0 , 0 ); return ans ; } }; 283. Move Zeroes $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : void moveZeroes ( vector < int >& nums ) { int i = 0 ; for ( const int num : nums ) if ( num != 0 ) nums [ i ++ ] = num ; for (; i < nums . size (); ++ i ) nums [ i ] = 0 ; } }; 284. Peeking Iterator $\\star\\star$ class PeekingIterator : public Iterator { public : PeekingIterator ( const vector < int >& nums ) : Iterator ( nums ) {} int peek () { return Iterator ( * this ). next (); } int next () { return Iterator :: next (); } bool hasNext () const { return Iterator :: hasNext (); } }; 285. Inorder Successor in BST $\\star\\star$ \ud83d\udd12 286. Walls and Gates $\\star\\star$ \ud83d\udd12 287. Find the Duplicate Number $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : int findDuplicate ( vector < int >& nums ) { int slow = nums [ nums [ 0 ]]; int fast = nums [ nums [ nums [ 0 ]]]; while ( slow != fast ) { slow = nums [ slow ]; fast = nums [ nums [ fast ]]; } slow = nums [ 0 ]; while ( slow != fast ) { slow = nums [ slow ]; fast = nums [ fast ]; } return slow ; } }; 288. Unique Word Abbreviation $\\star\\star$ \ud83d\udd12 289. Game of Life $\\star\\star$ Time: $O(mn)$ Space: $O(1)$ class Solution { public : void gameOfLife ( vector < vector < int >>& board ) { const int m = board . size (); const int n = board [ 0 ]. size (); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int ones = 0 ; for ( int y = max ( 0 , i - 1 ); y < min ( m , i + 2 ); ++ y ) for ( int x = max ( 0 , j - 1 ); x < min ( n , j + 2 ); ++ x ) ones += board [ y ][ x ] & 1 ; if (( board [ i ][ j ] == 1 && ( ones == 3 || ones == 4 )) || ( board [ i ][ j ] == 0 && ones == 3 )) board [ i ][ j ] |= 0 b10 ; } for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) board [ i ][ j ] >>= 1 ; } }; 290. Word Pattern $\\star$ class Solution { public : bool wordPattern ( string pattern , string str ) { const int n = pattern . length (); vector < int > charToIndex ( 26 ); unordered_map < string , int > stringToIndex ; istringstream iss ( str ); int i = 0 ; for ( string word ; iss >> word ; ++ i ) { if ( i == n || charToIndex [ pattern [ i ] - 'a' ] != stringToIndex [ word ]) return false ; charToIndex [ pattern [ i ] - 'a' ] = i + 1 ; stringToIndex [ word ] = i + 1 ; } return i == n ; } };","title":"0281-0290"},{"location":"cpp/0201-0300/0281-0290/#281-zigzag-iterator-starstar","text":"","title":"281. Zigzag Iterator $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0201-0300/0281-0290/#282-expression-add-operators-starstarstar","text":"Time: $O(n4^{n - 1})$ Space: $O(n^2)$ class Solution { public : vector < string > addOperators ( string num , int target ) { vector < string > ans ; vector < string > path ; auto join = []( vector < string >& path ) { string joined ; for ( const string & s : path ) joined += s ; return joined ; }; function < void ( int , long , long ) > dfs = [ & ]( int s , long eval , long multiplied ) { if ( s == num . length () && eval == target ) { ans . push_back ( join ( path )); return ; } for ( int i = 1 ; i <= num . length () - s ; ++ i ) { const string t = num . substr ( s , i ); // current substring if ( i > 1 && t [ 0 ] == '0' ) continue ; const long curr = stol ( t ); // current substring's number if ( s == 0 ) { path . push_back ( t ); dfs ( i , curr , curr ); path . pop_back (); continue ; } for ( const string & op : { \"+\" , \"-\" , \"*\" }) { path . push_back ( op ); path . push_back ( t ); if ( op == \"+\" ) dfs ( s + i , eval + curr , curr ); else if ( op == \"-\" ) dfs ( s + i , eval - curr , - curr ); else dfs ( s + i , eval - multiplied + multiplied * curr , multiplied * curr ); path . pop_back (); path . pop_back (); } } }; dfs ( 0 , 0 , 0 ); return ans ; } };","title":"282. Expression Add Operators $\\star\\star\\star$"},{"location":"cpp/0201-0300/0281-0290/#283-move-zeroes-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : void moveZeroes ( vector < int >& nums ) { int i = 0 ; for ( const int num : nums ) if ( num != 0 ) nums [ i ++ ] = num ; for (; i < nums . size (); ++ i ) nums [ i ] = 0 ; } };","title":"283. Move Zeroes $\\star$"},{"location":"cpp/0201-0300/0281-0290/#284-peeking-iterator-starstar","text":"class PeekingIterator : public Iterator { public : PeekingIterator ( const vector < int >& nums ) : Iterator ( nums ) {} int peek () { return Iterator ( * this ). next (); } int next () { return Iterator :: next (); } bool hasNext () const { return Iterator :: hasNext (); } };","title":"284. Peeking Iterator $\\star\\star$"},{"location":"cpp/0201-0300/0281-0290/#285-inorder-successor-in-bst-starstar","text":"","title":"285. Inorder Successor in BST $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0201-0300/0281-0290/#286-walls-and-gates-starstar","text":"","title":"286. Walls and Gates $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0201-0300/0281-0290/#287-find-the-duplicate-number-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : int findDuplicate ( vector < int >& nums ) { int slow = nums [ nums [ 0 ]]; int fast = nums [ nums [ nums [ 0 ]]]; while ( slow != fast ) { slow = nums [ slow ]; fast = nums [ nums [ fast ]]; } slow = nums [ 0 ]; while ( slow != fast ) { slow = nums [ slow ]; fast = nums [ fast ]; } return slow ; } };","title":"287. Find the Duplicate Number $\\star\\star$"},{"location":"cpp/0201-0300/0281-0290/#288-unique-word-abbreviation-starstar","text":"","title":"288. Unique Word Abbreviation $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0201-0300/0281-0290/#289-game-of-life-starstar","text":"Time: $O(mn)$ Space: $O(1)$ class Solution { public : void gameOfLife ( vector < vector < int >>& board ) { const int m = board . size (); const int n = board [ 0 ]. size (); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int ones = 0 ; for ( int y = max ( 0 , i - 1 ); y < min ( m , i + 2 ); ++ y ) for ( int x = max ( 0 , j - 1 ); x < min ( n , j + 2 ); ++ x ) ones += board [ y ][ x ] & 1 ; if (( board [ i ][ j ] == 1 && ( ones == 3 || ones == 4 )) || ( board [ i ][ j ] == 0 && ones == 3 )) board [ i ][ j ] |= 0 b10 ; } for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) board [ i ][ j ] >>= 1 ; } };","title":"289. Game of Life $\\star\\star$"},{"location":"cpp/0201-0300/0281-0290/#290-word-pattern-star","text":"class Solution { public : bool wordPattern ( string pattern , string str ) { const int n = pattern . length (); vector < int > charToIndex ( 26 ); unordered_map < string , int > stringToIndex ; istringstream iss ( str ); int i = 0 ; for ( string word ; iss >> word ; ++ i ) { if ( i == n || charToIndex [ pattern [ i ] - 'a' ] != stringToIndex [ word ]) return false ; charToIndex [ pattern [ i ] - 'a' ] = i + 1 ; stringToIndex [ word ] = i + 1 ; } return i == n ; } };","title":"290. Word Pattern $\\star$"},{"location":"cpp/0201-0300/0291-0300/","text":"291. Word Pattern II $\\star\\star\\star$ \ud83d\udd12 292. Nim Game $\\star$ Time: $O(1)$ Space: $O(1)$ class Solution { public : bool canWinNim ( int n ) { return n % 4 != 0 ; } }; 293. Flip Game $\\star$ \ud83d\udd12 294. Flip Game II $\\star\\star$ \ud83d\udd12 295. Find Median from Data Stream $\\star\\star\\star$ Time: $O(n\\log n)$ Space: $O(n)$ class MedianFinder { public : void addNum ( int num ) { if ( l . empty () || num <= l . top ()) l . push ( num ); else r . push ( num ); // balance two heaps if ( l . size () + 1 == r . size ()) l . push ( r . top ()), r . pop (); else if ( l . size () == r . size () + 2 ) r . push ( l . top ()), l . pop (); } double findMedian () { if ( l . size () == r . size ()) return ( l . top () + r . top ()) / 2.0 ; return l . top (); } private : priority_queue < int , vector < int >> l ; // Max Heap priority_queue < int , vector < int > , greater <>> r ; // Min Heap }; 296. Best Meeting Point $\\star\\star\\star$ \ud83d\udd12 297. Serialize and Deserialize Binary Tree $\\star\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Codec { public : string serialize ( TreeNode * root ) { if ( ! root ) return \"\" ; string ans ; queue < TreeNode *> queue {{ root }}; while ( ! queue . empty ()) { root = queue . front (), queue . pop (); if ( ! root ) { ans += \"n \" ; continue ; } ans += to_string ( root -> val ) + \" \" ; queue . push ( root -> left ); queue . push ( root -> right ); } return ans ; } TreeNode * deserialize ( string data ) { if ( data . empty ()) return nullptr ; istringstream iss ( data ); string val ; iss >> val ; TreeNode * root = new TreeNode ( stoi ( val )); queue < TreeNode *> queue {{ root }}; while ( iss >> val ) { TreeNode * parent = queue . front (); queue . pop (); // left node if ( val != \"n\" ) { parent -> left = new TreeNode ( stoi ( val )); queue . push ( parent -> left ); } // right node iss >> val ; if ( val != \"n\" ) { parent -> right = new TreeNode ( stoi ( val )); queue . push ( parent -> right ); } } return root ; } }; 298. Binary Tree Longest Consecutive Sequence $\\star\\star$ \ud83d\udd12 299. Bulls and Cows $\\star$ Time: $O(n)$ Space: $O(10)$ class Solution { public : string getHint ( string secret , string guess ) { int A = 0 ; int B = 0 ; vector < int > count1 ( 10 ); vector < int > count2 ( 10 ); for ( int i = 0 ; i < secret . length (); ++ i ) if ( secret [ i ] == guess [ i ]) ++ A ; else { ++ count1 [ secret [ i ] - '0' ]; ++ count2 [ guess [ i ] - '0' ]; } for ( int i = 0 ; i <= 9 ; ++ i ) B += min ( count1 [ i ], count2 [ i ]); return to_string ( A ) + \"A\" + to_string ( B ) + \"B\" ; } }; 300. Longest Increasing Subsequence $\\star\\star$ Time: $O(n^2) \\tilde O(n\\log n)$ Space: $O(n)$ class Solution { public : int lengthOfLIS ( vector < int >& nums ) { int ans = 0 ; vector < int > tails ( nums . size ()); for ( const int num : nums ) { int l = 0 ; int r = ans ; while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( tails [ m ] < num ) l = m + 1 ; else r = m ; } tails [ l ] = num ; if ( l == ans ) ++ ans ; } return ans ; } };","title":"0291-0300"},{"location":"cpp/0201-0300/0291-0300/#291-word-pattern-ii-starstarstar","text":"","title":"291. Word Pattern II $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/0201-0300/0291-0300/#292-nim-game-star","text":"Time: $O(1)$ Space: $O(1)$ class Solution { public : bool canWinNim ( int n ) { return n % 4 != 0 ; } };","title":"292. Nim Game $\\star$"},{"location":"cpp/0201-0300/0291-0300/#293-flip-game-star","text":"","title":"293. Flip Game $\\star$ \ud83d\udd12"},{"location":"cpp/0201-0300/0291-0300/#294-flip-game-ii-starstar","text":"","title":"294. Flip Game II $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0201-0300/0291-0300/#295-find-median-from-data-stream-starstarstar","text":"Time: $O(n\\log n)$ Space: $O(n)$ class MedianFinder { public : void addNum ( int num ) { if ( l . empty () || num <= l . top ()) l . push ( num ); else r . push ( num ); // balance two heaps if ( l . size () + 1 == r . size ()) l . push ( r . top ()), r . pop (); else if ( l . size () == r . size () + 2 ) r . push ( l . top ()), l . pop (); } double findMedian () { if ( l . size () == r . size ()) return ( l . top () + r . top ()) / 2.0 ; return l . top (); } private : priority_queue < int , vector < int >> l ; // Max Heap priority_queue < int , vector < int > , greater <>> r ; // Min Heap };","title":"295. Find Median from Data Stream $\\star\\star\\star$"},{"location":"cpp/0201-0300/0291-0300/#296-best-meeting-point-starstarstar","text":"","title":"296. Best Meeting Point $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/0201-0300/0291-0300/#297-serialize-and-deserialize-binary-tree-starstarstar","text":"Time: $O(n)$ Space: $O(n)$ class Codec { public : string serialize ( TreeNode * root ) { if ( ! root ) return \"\" ; string ans ; queue < TreeNode *> queue {{ root }}; while ( ! queue . empty ()) { root = queue . front (), queue . pop (); if ( ! root ) { ans += \"n \" ; continue ; } ans += to_string ( root -> val ) + \" \" ; queue . push ( root -> left ); queue . push ( root -> right ); } return ans ; } TreeNode * deserialize ( string data ) { if ( data . empty ()) return nullptr ; istringstream iss ( data ); string val ; iss >> val ; TreeNode * root = new TreeNode ( stoi ( val )); queue < TreeNode *> queue {{ root }}; while ( iss >> val ) { TreeNode * parent = queue . front (); queue . pop (); // left node if ( val != \"n\" ) { parent -> left = new TreeNode ( stoi ( val )); queue . push ( parent -> left ); } // right node iss >> val ; if ( val != \"n\" ) { parent -> right = new TreeNode ( stoi ( val )); queue . push ( parent -> right ); } } return root ; } };","title":"297. Serialize and Deserialize Binary Tree $\\star\\star\\star$"},{"location":"cpp/0201-0300/0291-0300/#298-binary-tree-longest-consecutive-sequence-starstar","text":"","title":"298. Binary Tree Longest Consecutive Sequence $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0201-0300/0291-0300/#299-bulls-and-cows-star","text":"Time: $O(n)$ Space: $O(10)$ class Solution { public : string getHint ( string secret , string guess ) { int A = 0 ; int B = 0 ; vector < int > count1 ( 10 ); vector < int > count2 ( 10 ); for ( int i = 0 ; i < secret . length (); ++ i ) if ( secret [ i ] == guess [ i ]) ++ A ; else { ++ count1 [ secret [ i ] - '0' ]; ++ count2 [ guess [ i ] - '0' ]; } for ( int i = 0 ; i <= 9 ; ++ i ) B += min ( count1 [ i ], count2 [ i ]); return to_string ( A ) + \"A\" + to_string ( B ) + \"B\" ; } };","title":"299. Bulls and Cows $\\star$"},{"location":"cpp/0201-0300/0291-0300/#300-longest-increasing-subsequence-starstar","text":"Time: $O(n^2) \\tilde O(n\\log n)$ Space: $O(n)$ class Solution { public : int lengthOfLIS ( vector < int >& nums ) { int ans = 0 ; vector < int > tails ( nums . size ()); for ( const int num : nums ) { int l = 0 ; int r = ans ; while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( tails [ m ] < num ) l = m + 1 ; else r = m ; } tails [ l ] = num ; if ( l == ans ) ++ ans ; } return ans ; } };","title":"300. Longest Increasing Subsequence $\\star\\star$"},{"location":"cpp/0301-0400/0301-0310/","text":"301. Remove Invalid Parentheses $\\star\\star\\star$ Time: $O(2^n)$ class Solution { public : vector < string > removeInvalidParentheses ( string s ) { vector < string > ans ; int l = 0 ; int r = 0 ; // calculate how many '(' and ')' we have to delete for ( const char c : s ) if ( c == '(' ) ++ l ; else if ( c == ' ) ' ) { if ( l == 0 ) ++ r ; else -- l ; } dfs ( s , 0 , l , r , ans ); return ans ; } private : // check if `s` is a valid string bool isValid ( const string & s ) { int count = 0 ; // num('(') - num(')') for ( const char c : s ) { if ( c == '(' ) ++ count ; else if ( c == ' ) ' ) -- count ; if ( count < 0 ) return false ; } return true ; // return count == 0 is okay, too; } void dfs ( const string & s , int startIndex , int l , int r , vector < string >& ans ) { if ( l == 0 && r == 0 && isValid ( s )) { ans . push_back ( s ); return ; } for ( int i = startIndex ; i < s . length (); ++ i ) { if ( i > startIndex && s [ i ] == s [ i - 1 ]) continue ; if ( r > 0 && s [ i ] == ')' ) // delete s[i], then do the dfs dfs ( s . substr ( 0 , i ) + s . substr ( i + 1 ), i , l , r - 1 , ans ); else if ( l > 0 && s [ i ] == '(' ) // delete s[i], then do the dfs dfs ( s . substr ( 0 , i ) + s . substr ( i + 1 ), i , l - 1 , r , ans ); } } }; 302. Smallest Rectangle Enclosing Black Pixels $\\star\\star\\star$ \ud83d\udd12 303. Range Sum Query - Immutable $\\star$ Time: $O(n)$ Space: $O(n)$ class NumArray { public : NumArray ( vector < int >& nums ) { prefixSum = vector < int > ( nums . size () + 1 ); for ( int i = 1 ; i <= nums . size (); ++ i ) prefixSum [ i ] += prefixSum [ i - 1 ] + nums [ i - 1 ]; } int sumRange ( int i , int j ) { return prefixSum [ j + 1 ] - prefixSum [ i ]; } private : vector < int > prefixSum ; }; 304. Range Sum Query 2D - Immutable $\\star\\star$ Time: $O(mn)$ Space: $O(n)$ class NumMatrix { public : NumMatrix ( vector < vector < int >>& matrix ) { if ( matrix . empty ()) return ; const int m = matrix . size (); const int n = matrix [ 0 ]. size (); prefixSum = vector < vector < int >> ( m + 1 , vector < int > ( n + 1 )); for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) prefixSum [ i ][ j ] += prefixSum [ i - 1 ][ j ] + prefixSum [ i ][ j - 1 ] + matrix [ i - 1 ][ j - 1 ] - prefixSum [ i - 1 ][ j - 1 ]; } int sumRegion ( int row1 , int col1 , int row2 , int col2 ) { return prefixSum [ row2 + 1 ][ col2 + 1 ] - prefixSum [ row2 + 1 ][ col1 ] - prefixSum [ row1 ][ col2 + 1 ] + prefixSum [ row1 ][ col1 ]; } private : vector < vector < int >> prefixSum ; }; 305. Number of Islands II $\\star\\star\\star$ \ud83d\udd12 306. Additive Number $\\star\\star$ Time: $O(n^2)$ Space: $O(n)$ class Solution { public : bool isAdditiveNumber ( string num ) { const int n = num . length (); function < bool ( long , long , long ) > dfs = [ & ]( long firstNum , long secondNum , long s ) { if ( s == n ) return true ; const long thirdNum = firstNum + secondNum ; const string thirdNumStr = to_string ( thirdNum ); return num . find ( thirdNumStr , s ) == s && dfs ( secondNum , thirdNum , s + thirdNumStr . length ()); }; // num[0..i] = firstNum for ( int i = 0 ; i < n / 2 ; ++ i ) { if ( i > 0 && num [ 0 ] == '0' ) return false ; const long firstNum = stol ( num . substr ( 0 , i + 1 )); // num[i + 1..j] = secondNum // len(thirdNum) >= max(len(firstNum), len(secondNum)) for ( int j = i + 1 ; max ( i , j - i ) < n - j ; ++ j ) { if ( j > i + 1 && num [ i + 1 ] == '0' ) break ; const long secondNum = stol ( num . substr ( i + 1 , j - i )); if ( dfs ( firstNum , secondNum , j + 1 )) return true ; } } return false ; } }; 307. Range Sum Query - Mutable $\\star\\star$ Time: $O(n\\log n)$ Space: $O(n)$ class FenwickTree { public : FenwickTree ( int n ) : sums ( n + 1 , 0 ) {} void update ( int i , int delta ) { while ( i < sums . size ()) { sums [ i ] += delta ; i += i & ( - i ); } } int get ( int i ) { int sum = 0 ; while ( i > 0 ) { sum += sums [ i ]; i -= i & ( - i ); } return sum ; } private : vector < int > sums ; }; class NumArray { public : NumArray ( vector < int >& nums ) : nums ( nums ), tree ( nums . size ()) { for ( int i = 0 ; i < nums . size (); ++ i ) tree . update ( i + 1 , nums [ i ]); } void update ( int i , int val ) { tree . update ( i + 1 , val - nums [ i ]); nums [ i ] = val ; } int sumRange ( int i , int j ) { return tree . get ( j + 1 ) - tree . get ( i ); } private : vector < int > nums ; FenwickTree tree ; }; 308. Range Sum Query 2D - Mutable $\\star\\star\\star$ \ud83d\udd12 309. Best Time to Buy and Sell Stock with Cooldown $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : int maxProfit ( vector < int >& prices ) { int sell = 0 ; int hold = INT_MIN ; int prev = 0 ; for ( const int price : prices ) { const int cache = sell ; sell = max ( sell , hold + price ); hold = max ( hold , prev - price ); prev = cache ; } return sell ; } }; 310. Minimum Height Trees $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : vector < int > findMinHeightTrees ( int n , vector < vector < int >>& edges ) { if ( n == 1 ) return { 0 }; vector < int > ans ; unordered_map < int , unordered_set < int >> graph ; for ( const vector < int >& edge : edges ) { graph [ edge [ 0 ]]. insert ( edge [ 1 ]); graph [ edge [ 1 ]]. insert ( edge [ 0 ]); } for ( const auto & [ label , neighbors ] : graph ) if ( neighbors . size () == 1 ) ans . push_back ( label ); while ( n > 2 ) { n -= ans . size (); vector < int > nextLeaves ; for ( int leaf : ans ) { const int j = * begin ( graph [ leaf ]); graph [ j ]. erase ( leaf ); if ( graph [ j ]. size () == 1 ) nextLeaves . push_back ( j ); } ans = nextLeaves ; } return ans ; } };","title":"0301-0310"},{"location":"cpp/0301-0400/0301-0310/#301-remove-invalid-parentheses-starstarstar","text":"Time: $O(2^n)$ class Solution { public : vector < string > removeInvalidParentheses ( string s ) { vector < string > ans ; int l = 0 ; int r = 0 ; // calculate how many '(' and ')' we have to delete for ( const char c : s ) if ( c == '(' ) ++ l ; else if ( c == ' ) ' ) { if ( l == 0 ) ++ r ; else -- l ; } dfs ( s , 0 , l , r , ans ); return ans ; } private : // check if `s` is a valid string bool isValid ( const string & s ) { int count = 0 ; // num('(') - num(')') for ( const char c : s ) { if ( c == '(' ) ++ count ; else if ( c == ' ) ' ) -- count ; if ( count < 0 ) return false ; } return true ; // return count == 0 is okay, too; } void dfs ( const string & s , int startIndex , int l , int r , vector < string >& ans ) { if ( l == 0 && r == 0 && isValid ( s )) { ans . push_back ( s ); return ; } for ( int i = startIndex ; i < s . length (); ++ i ) { if ( i > startIndex && s [ i ] == s [ i - 1 ]) continue ; if ( r > 0 && s [ i ] == ')' ) // delete s[i], then do the dfs dfs ( s . substr ( 0 , i ) + s . substr ( i + 1 ), i , l , r - 1 , ans ); else if ( l > 0 && s [ i ] == '(' ) // delete s[i], then do the dfs dfs ( s . substr ( 0 , i ) + s . substr ( i + 1 ), i , l - 1 , r , ans ); } } };","title":"301. Remove Invalid Parentheses $\\star\\star\\star$"},{"location":"cpp/0301-0400/0301-0310/#302-smallest-rectangle-enclosing-black-pixels-starstarstar","text":"","title":"302. Smallest Rectangle Enclosing Black Pixels $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/0301-0400/0301-0310/#303-range-sum-query-immutable-star","text":"Time: $O(n)$ Space: $O(n)$ class NumArray { public : NumArray ( vector < int >& nums ) { prefixSum = vector < int > ( nums . size () + 1 ); for ( int i = 1 ; i <= nums . size (); ++ i ) prefixSum [ i ] += prefixSum [ i - 1 ] + nums [ i - 1 ]; } int sumRange ( int i , int j ) { return prefixSum [ j + 1 ] - prefixSum [ i ]; } private : vector < int > prefixSum ; };","title":"303. Range Sum Query - Immutable $\\star$"},{"location":"cpp/0301-0400/0301-0310/#304-range-sum-query-2d-immutable-starstar","text":"Time: $O(mn)$ Space: $O(n)$ class NumMatrix { public : NumMatrix ( vector < vector < int >>& matrix ) { if ( matrix . empty ()) return ; const int m = matrix . size (); const int n = matrix [ 0 ]. size (); prefixSum = vector < vector < int >> ( m + 1 , vector < int > ( n + 1 )); for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) prefixSum [ i ][ j ] += prefixSum [ i - 1 ][ j ] + prefixSum [ i ][ j - 1 ] + matrix [ i - 1 ][ j - 1 ] - prefixSum [ i - 1 ][ j - 1 ]; } int sumRegion ( int row1 , int col1 , int row2 , int col2 ) { return prefixSum [ row2 + 1 ][ col2 + 1 ] - prefixSum [ row2 + 1 ][ col1 ] - prefixSum [ row1 ][ col2 + 1 ] + prefixSum [ row1 ][ col1 ]; } private : vector < vector < int >> prefixSum ; };","title":"304. Range Sum Query 2D - Immutable $\\star\\star$"},{"location":"cpp/0301-0400/0301-0310/#305-number-of-islands-ii-starstarstar","text":"","title":"305. Number of Islands II $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/0301-0400/0301-0310/#306-additive-number-starstar","text":"Time: $O(n^2)$ Space: $O(n)$ class Solution { public : bool isAdditiveNumber ( string num ) { const int n = num . length (); function < bool ( long , long , long ) > dfs = [ & ]( long firstNum , long secondNum , long s ) { if ( s == n ) return true ; const long thirdNum = firstNum + secondNum ; const string thirdNumStr = to_string ( thirdNum ); return num . find ( thirdNumStr , s ) == s && dfs ( secondNum , thirdNum , s + thirdNumStr . length ()); }; // num[0..i] = firstNum for ( int i = 0 ; i < n / 2 ; ++ i ) { if ( i > 0 && num [ 0 ] == '0' ) return false ; const long firstNum = stol ( num . substr ( 0 , i + 1 )); // num[i + 1..j] = secondNum // len(thirdNum) >= max(len(firstNum), len(secondNum)) for ( int j = i + 1 ; max ( i , j - i ) < n - j ; ++ j ) { if ( j > i + 1 && num [ i + 1 ] == '0' ) break ; const long secondNum = stol ( num . substr ( i + 1 , j - i )); if ( dfs ( firstNum , secondNum , j + 1 )) return true ; } } return false ; } };","title":"306. Additive Number $\\star\\star$"},{"location":"cpp/0301-0400/0301-0310/#307-range-sum-query-mutable-starstar","text":"Time: $O(n\\log n)$ Space: $O(n)$ class FenwickTree { public : FenwickTree ( int n ) : sums ( n + 1 , 0 ) {} void update ( int i , int delta ) { while ( i < sums . size ()) { sums [ i ] += delta ; i += i & ( - i ); } } int get ( int i ) { int sum = 0 ; while ( i > 0 ) { sum += sums [ i ]; i -= i & ( - i ); } return sum ; } private : vector < int > sums ; }; class NumArray { public : NumArray ( vector < int >& nums ) : nums ( nums ), tree ( nums . size ()) { for ( int i = 0 ; i < nums . size (); ++ i ) tree . update ( i + 1 , nums [ i ]); } void update ( int i , int val ) { tree . update ( i + 1 , val - nums [ i ]); nums [ i ] = val ; } int sumRange ( int i , int j ) { return tree . get ( j + 1 ) - tree . get ( i ); } private : vector < int > nums ; FenwickTree tree ; };","title":"307. Range Sum Query - Mutable $\\star\\star$"},{"location":"cpp/0301-0400/0301-0310/#308-range-sum-query-2d-mutable-starstarstar","text":"","title":"308. Range Sum Query 2D - Mutable $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/0301-0400/0301-0310/#309-best-time-to-buy-and-sell-stock-with-cooldown-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : int maxProfit ( vector < int >& prices ) { int sell = 0 ; int hold = INT_MIN ; int prev = 0 ; for ( const int price : prices ) { const int cache = sell ; sell = max ( sell , hold + price ); hold = max ( hold , prev - price ); prev = cache ; } return sell ; } };","title":"309. Best Time to Buy and Sell Stock with Cooldown $\\star\\star$"},{"location":"cpp/0301-0400/0301-0310/#310-minimum-height-trees-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : vector < int > findMinHeightTrees ( int n , vector < vector < int >>& edges ) { if ( n == 1 ) return { 0 }; vector < int > ans ; unordered_map < int , unordered_set < int >> graph ; for ( const vector < int >& edge : edges ) { graph [ edge [ 0 ]]. insert ( edge [ 1 ]); graph [ edge [ 1 ]]. insert ( edge [ 0 ]); } for ( const auto & [ label , neighbors ] : graph ) if ( neighbors . size () == 1 ) ans . push_back ( label ); while ( n > 2 ) { n -= ans . size (); vector < int > nextLeaves ; for ( int leaf : ans ) { const int j = * begin ( graph [ leaf ]); graph [ j ]. erase ( leaf ); if ( graph [ j ]. size () == 1 ) nextLeaves . push_back ( j ); } ans = nextLeaves ; } return ans ; } };","title":"310. Minimum Height Trees $\\star\\star$"},{"location":"cpp/0301-0400/0311-0320/","text":"311. Sparse Matrix Multiplication $\\star\\star$ \ud83d\udd12 312. Burst Balloons $\\star\\star\\star$ Time: $O(n^3)$ Space: $O(n^2)$ class Solution { public : int maxCoins ( vector < int >& nums ) { const int n = nums . size (); nums . insert ( begin ( nums ), 1 ); nums . insert ( end ( nums ), 1 ); vector < vector < int >> dp ( n + 2 , vector < int > ( n + 2 )); for ( int length = 1 ; length <= n ; ++ length ) for ( int i = 1 ; i + length - 1 <= n ; ++ i ) { const int j = i + length - 1 ; for ( int k = i ; k <= j ; ++ k ) dp [ i ][ j ] = max ( dp [ i ][ j ], dp [ i ][ k - 1 ] + nums [ i - 1 ] * nums [ k ] * nums [ j + 1 ] + dp [ k + 1 ][ j ]); } return dp [ 1 ][ n ]; } }; 313. Super Ugly Number $\\star\\star$ Time: $O(n\\log k)$ Space: $O(k)$ class Solution { public : int nthSuperUglyNumber ( int n , vector < int >& primes ) { const int k = primes . size (); vector < int > uglyNums { 1 }; vector < int > indices ( k ); while ( uglyNums . size () < n ) { vector < int > nexts ( k ); for ( int i = 0 ; i < k ; ++ i ) nexts [ i ] = uglyNums [ indices [ i ]] * primes [ i ]; const int next = * min_element ( begin ( nexts ), end ( nexts )); for ( int i = 0 ; i < k ; ++ i ) if ( next == nexts [ i ]) ++ indices [ i ]; uglyNums . push_back ( next ); } return uglyNums . back (); } }; 314. Binary Tree Vertical Order Traversal $\\star\\star$ \ud83d\udd12 315. Count of Smaller Numbers After Self $\\star\\star\\star$ Time: $O(n\\log k) \\tidle O(n\\log n)$, where k = unique nums Space: $O(n)$ struct Item { int value = 0 ; int index = 0 ; Item ( int value , int index ) : value ( value ), index ( index ) {} Item () : value ( 0 ), index ( 0 ) {} }; class Solution { public : vector < int > countSmaller ( vector < int >& nums ) { const int n = nums . size (); vector < int > counts ( n ); vector < Item > items ( n ); for ( int i = 0 ; i < n ; ++ i ) items [ i ] = Item ( nums [ i ], i ); function < void ( int , int , int ) > merge = [ & ]( int l , int m , int r ) { vector < Item > sorted ( r - l + 1 ); int k = 0 ; // point to the sorted's beginning int i = l ; // point to the left's beginning int j = m + 1 ; // point to the right's beginning int rightCount = 0 ; while ( i <= m && j <= r ) if ( items [ j ]. value < items [ i ]. value ) { ++ rightCount ; sorted [ k ++ ] = items [ j ++ ]; } else { counts [ items [ i ]. index ] += rightCount ; sorted [ k ++ ] = items [ i ++ ]; } // put possible remaining left part to the sorted array while ( i <= m ) { counts [ items [ i ]. index ] += rightCount ; sorted [ k ++ ] = items [ i ++ ]; } // put possible remaining right part to the sorted array while ( j <= r ) sorted [ k ++ ] = items [ j ++ ]; copy ( begin ( sorted ), end ( sorted ), begin ( items ) + l ); }; function < void ( int , int ) > mergeSort = [ & ]( int l , int r ) { if ( l >= r ) return ; const int m = l + ( r - l ) / 2 ; mergeSort ( l , m ); mergeSort ( m + 1 , r ); merge ( l , m , r ); }; mergeSort ( 0 , n - 1 ); return counts ; } }; 316. Remove Duplicate Letters $\\star\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : string removeDuplicateLetters ( string s ) { string ans ; vector < int > count ( 26 ); vector < bool > used ( 26 ); for ( const char c : s ) ++ count [ c - 'a' ]; for ( const char c : s ) { -- count [ c - 'a' ]; if ( used [ c - 'a' ]) continue ; while ( ! ans . empty () && ans . back () > c && count [ ans . back () - 'a' ] > 0 ) { used [ ans . back () - 'a' ] = false ; ans . pop_back (); } ans += c ; used [ c - 'a' ] = true ; } return ans ; } }; 317. Shortest Distance from All Buildings $\\star\\star\\star$ \ud83d\udd12 318. Maximum Product of Word Lengths $\\star\\star$ Time: $O(n^2)$ Space: $O(n)$ class Solution { public : int maxProduct ( vector < string >& words ) { size_t ans = 0 ; vector < int > bitmasks ; for ( const string & word : words ) { int bitmask = 0 ; for ( int i = 0 ; i < word . length (); ++ i ) bitmask |= 1 << ( word [ i ] - 'a' ); bitmasks . push_back ( bitmask ); } for ( int i = 0 ; i < words . size (); ++ i ) for ( int j = i + 1 ; j < words . size (); ++ j ) if (( bitmasks [ i ] & bitmasks [ j ]) == 0 ) ans = max ( ans , words [ i ]. length () * words [ j ]. length ()); return ans ; } }; 319. Bulb Switcher $\\star\\star$ Time: $O(1)$ Space: $O(1)$ class Solution { public : int bulbSwitch ( int n ) { return sqrt ( n ); } }; 320. Generalized Abbreviation $\\star\\star$ \ud83d\udd12","title":"0311-0320"},{"location":"cpp/0301-0400/0311-0320/#311-sparse-matrix-multiplication-starstar","text":"","title":"311. Sparse Matrix Multiplication $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0301-0400/0311-0320/#312-burst-balloons-starstarstar","text":"Time: $O(n^3)$ Space: $O(n^2)$ class Solution { public : int maxCoins ( vector < int >& nums ) { const int n = nums . size (); nums . insert ( begin ( nums ), 1 ); nums . insert ( end ( nums ), 1 ); vector < vector < int >> dp ( n + 2 , vector < int > ( n + 2 )); for ( int length = 1 ; length <= n ; ++ length ) for ( int i = 1 ; i + length - 1 <= n ; ++ i ) { const int j = i + length - 1 ; for ( int k = i ; k <= j ; ++ k ) dp [ i ][ j ] = max ( dp [ i ][ j ], dp [ i ][ k - 1 ] + nums [ i - 1 ] * nums [ k ] * nums [ j + 1 ] + dp [ k + 1 ][ j ]); } return dp [ 1 ][ n ]; } };","title":"312. Burst Balloons $\\star\\star\\star$"},{"location":"cpp/0301-0400/0311-0320/#313-super-ugly-number-starstar","text":"Time: $O(n\\log k)$ Space: $O(k)$ class Solution { public : int nthSuperUglyNumber ( int n , vector < int >& primes ) { const int k = primes . size (); vector < int > uglyNums { 1 }; vector < int > indices ( k ); while ( uglyNums . size () < n ) { vector < int > nexts ( k ); for ( int i = 0 ; i < k ; ++ i ) nexts [ i ] = uglyNums [ indices [ i ]] * primes [ i ]; const int next = * min_element ( begin ( nexts ), end ( nexts )); for ( int i = 0 ; i < k ; ++ i ) if ( next == nexts [ i ]) ++ indices [ i ]; uglyNums . push_back ( next ); } return uglyNums . back (); } };","title":"313. Super Ugly Number $\\star\\star$"},{"location":"cpp/0301-0400/0311-0320/#314-binary-tree-vertical-order-traversal-starstar","text":"","title":"314. Binary Tree Vertical Order Traversal $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0301-0400/0311-0320/#315-count-of-smaller-numbers-after-self-starstarstar","text":"Time: $O(n\\log k) \\tidle O(n\\log n)$, where k = unique nums Space: $O(n)$ struct Item { int value = 0 ; int index = 0 ; Item ( int value , int index ) : value ( value ), index ( index ) {} Item () : value ( 0 ), index ( 0 ) {} }; class Solution { public : vector < int > countSmaller ( vector < int >& nums ) { const int n = nums . size (); vector < int > counts ( n ); vector < Item > items ( n ); for ( int i = 0 ; i < n ; ++ i ) items [ i ] = Item ( nums [ i ], i ); function < void ( int , int , int ) > merge = [ & ]( int l , int m , int r ) { vector < Item > sorted ( r - l + 1 ); int k = 0 ; // point to the sorted's beginning int i = l ; // point to the left's beginning int j = m + 1 ; // point to the right's beginning int rightCount = 0 ; while ( i <= m && j <= r ) if ( items [ j ]. value < items [ i ]. value ) { ++ rightCount ; sorted [ k ++ ] = items [ j ++ ]; } else { counts [ items [ i ]. index ] += rightCount ; sorted [ k ++ ] = items [ i ++ ]; } // put possible remaining left part to the sorted array while ( i <= m ) { counts [ items [ i ]. index ] += rightCount ; sorted [ k ++ ] = items [ i ++ ]; } // put possible remaining right part to the sorted array while ( j <= r ) sorted [ k ++ ] = items [ j ++ ]; copy ( begin ( sorted ), end ( sorted ), begin ( items ) + l ); }; function < void ( int , int ) > mergeSort = [ & ]( int l , int r ) { if ( l >= r ) return ; const int m = l + ( r - l ) / 2 ; mergeSort ( l , m ); mergeSort ( m + 1 , r ); merge ( l , m , r ); }; mergeSort ( 0 , n - 1 ); return counts ; } };","title":"315. Count of Smaller Numbers After Self $\\star\\star\\star$"},{"location":"cpp/0301-0400/0311-0320/#316-remove-duplicate-letters-starstarstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : string removeDuplicateLetters ( string s ) { string ans ; vector < int > count ( 26 ); vector < bool > used ( 26 ); for ( const char c : s ) ++ count [ c - 'a' ]; for ( const char c : s ) { -- count [ c - 'a' ]; if ( used [ c - 'a' ]) continue ; while ( ! ans . empty () && ans . back () > c && count [ ans . back () - 'a' ] > 0 ) { used [ ans . back () - 'a' ] = false ; ans . pop_back (); } ans += c ; used [ c - 'a' ] = true ; } return ans ; } };","title":"316. Remove Duplicate Letters $\\star\\star\\star$"},{"location":"cpp/0301-0400/0311-0320/#317-shortest-distance-from-all-buildings-starstarstar","text":"","title":"317. Shortest Distance from All Buildings $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/0301-0400/0311-0320/#318-maximum-product-of-word-lengths-starstar","text":"Time: $O(n^2)$ Space: $O(n)$ class Solution { public : int maxProduct ( vector < string >& words ) { size_t ans = 0 ; vector < int > bitmasks ; for ( const string & word : words ) { int bitmask = 0 ; for ( int i = 0 ; i < word . length (); ++ i ) bitmask |= 1 << ( word [ i ] - 'a' ); bitmasks . push_back ( bitmask ); } for ( int i = 0 ; i < words . size (); ++ i ) for ( int j = i + 1 ; j < words . size (); ++ j ) if (( bitmasks [ i ] & bitmasks [ j ]) == 0 ) ans = max ( ans , words [ i ]. length () * words [ j ]. length ()); return ans ; } };","title":"318. Maximum Product of Word Lengths $\\star\\star$"},{"location":"cpp/0301-0400/0311-0320/#319-bulb-switcher-starstar","text":"Time: $O(1)$ Space: $O(1)$ class Solution { public : int bulbSwitch ( int n ) { return sqrt ( n ); } };","title":"319. Bulb Switcher $\\star\\star$"},{"location":"cpp/0301-0400/0311-0320/#320-generalized-abbreviation-starstar","text":"","title":"320. Generalized Abbreviation $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0301-0400/0321-0330/","text":"321. Create Maximum Number $\\star\\star\\star$ Time: $O(k(m + n)^2)$ Space: $O(m + n)$ class Solution { public : vector < int > maxNumber ( vector < int >& nums1 , vector < int >& nums2 , int k ) { vector < int > ans ; for ( int k1 = 0 ; k1 <= k ; ++ k1 ) { const int k2 = k - k1 ; if ( k1 > nums1 . size () || k2 > nums2 . size ()) continue ; ans = max ( ans , maxNumber ( maxNumber ( nums1 , k1 ), maxNumber ( nums2 , k2 ))); } return ans ; } private : vector < int > maxNumber ( const vector < int >& nums , int k ) { if ( k == 0 ) return {}; vector < int > ans ; int toPop = nums . size () - k ; for ( const int num : nums ) { while ( ! ans . empty () && ans . back () < num && toPop -- > 0 ) ans . pop_back (); ans . push_back ( num ); } return { begin ( ans ), begin ( ans ) + k }; } private : vector < int > maxNumber ( const vector < int >& nums1 , const vector < int >& nums2 ) { vector < int > ans ; auto s1 = cbegin ( nums1 ); auto s2 = cbegin ( nums2 ); while ( s1 != cend ( nums1 ) || s2 != cend ( nums2 )) if ( lexicographical_compare ( s1 , cend ( nums1 ), s2 , cend ( nums2 ))) ans . push_back ( * s2 ++ ); else ans . push_back ( * s1 ++ ); return ans ; } }; 322. Coin Change $\\star\\star$ Time: $O(nk)$, where n = len(coins) and k = amount Space: $O(k)$ class Solution { public : int coinChange ( vector < int >& coins , int amount ) { vector < int > dp ( amount + 1 , amount + 1 ); dp [ 0 ] = 0 ; for ( int coin : coins ) for ( int i = coin ; i <= amount ; ++ i ) dp [ i ] = min ( dp [ i ], dp [ i - coin ] + 1 ); return dp . back () < amount + 1 ? dp . back () : - 1 ; } }; 323. Number of Connected Components in an Undirected Graph $\\star\\star$ \ud83d\udd12 324. Wiggle Sort II $\\star\\star$ Time: $O(n) \\tidle O(n^2)$ Space: $O(1)$ class Solution { public : void wiggleSort ( vector < int >& nums ) { const int n = nums . size (); const auto it = begin ( nums ) + n / 2 ; nth_element ( begin ( nums ), it , end ( nums )); const int median = * it ; // index-rewiring #define A(i) nums[(1 + 2 * i) % (n | 1)] for ( int i = 0 , j = 0 , k = n - 1 ; i <= k ;) if ( A ( i ) > median ) swap ( A ( i ++ ), A ( j ++ )); else if ( A ( i ) < median ) swap ( A ( i ), A ( k -- )); else ++ i ; } }; 325. Maximum Size Subarray Sum Equals k $\\star\\star$ \ud83d\udd12 326. Power of Three $\\star$ class Solution { public : bool isPowerOfThree ( int n ) { return n > 0 && ( int ) pow ( 3 , 19 ) % n == 0 ; } }; 327. Count of Range Sum $\\star\\star\\star$ Time: $O(n\\log n)$ Space: $O(n)$ class Solution { public : int countRangeSum ( vector < int >& nums , int lower , int upper ) { const int n = nums . size (); int count = 0 ; vector < long > prefixSum ( n + 1 , 0 ); for ( int i = 1 ; i <= n ; ++ i ) prefixSum [ i ] = prefixSum [ i - 1 ] + ( long ) nums [ i - 1 ]; function < void ( int , int , int ) > merge = [ & ]( int l , int m , int r ) { vector < long > sorted ( r - l + 1 ); int k = 0 ; // point to the sorted's beginning int j = m + 1 ; // point to the right's beginning int lo = m + 1 ; // 1st index that prefixSum[lo] - prefixSum[i] >= lower int hi = m + 1 ; // 1st index that prefixSum[hi] - prefixSum[i] > upper // for each index i in range [l, m], add hi - lo to count for ( int i = l ; i <= m ; ++ i ) { while ( lo <= r && prefixSum [ lo ] - prefixSum [ i ] < lower ) ++ lo ; while ( hi <= r && prefixSum [ hi ] - prefixSum [ i ] <= upper ) ++ hi ; count += hi - lo ; // put right part that is smaller than prefixSum[i] to the sorted array while ( j <= r && prefixSum [ j ] < prefixSum [ i ]) sorted [ k ++ ] = prefixSum [ j ++ ]; sorted [ k ++ ] = prefixSum [ i ]; } // put possible remaining right part to the sorted array while ( j <= r ) sorted [ k ++ ] = prefixSum [ j ++ ]; copy ( begin ( sorted ), end ( sorted ), begin ( prefixSum ) + l ); }; function < void ( int , int ) > mergeSort = [ & ]( int l , int r ) { if ( l >= r ) return ; const int m = l + ( r - l ) / 2 ; mergeSort ( l , m ); mergeSort ( m + 1 , r ); merge ( l , m , r ); }; mergeSort ( 0 , n ); return count ; } }; 328. Odd Even Linked List $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : ListNode * oddEvenList ( ListNode * head ) { ListNode oddHead ( 0 ); ListNode evenHead ( 0 ); ListNode * odd = & oddHead ; ListNode * even = & evenHead ; for ( int isOdd = 0 ; head ; head = head -> next ) if ( isOdd ^= 1 ) { odd -> next = head ; odd = head ; } else { even -> next = head ; even = head ; } even -> next = nullptr ; odd -> next = evenHead . next ; return oddHead . next ; } }; 329. Longest Increasing Path in a Matrix $\\star\\star\\star$ Time: $O(mn)$ Space: $O(mn)$ class Solution { public : int longestIncreasingPath ( vector < vector < int >>& matrix ) { if ( matrix . empty ()) return 0 ; const int m = matrix . size (); const int n = matrix [ 0 ]. size (); int ans = 0 ; vector < vector < int >> memo ( m , vector < int > ( n )); function < int ( int , int , int ) > dfs = [ & ]( int i , int j , int maxi ) { if ( i < 0 || i == m || j < 0 || j == n ) return 0 ; if ( matrix [ i ][ j ] <= maxi ) return 0 ; if ( memo [ i ][ j ]) return memo [ i ][ j ]; return memo [ i ][ j ] = 1 + max ({ dfs ( i + 1 , j , matrix [ i ][ j ]), dfs ( i - 1 , j , matrix [ i ][ j ]), dfs ( i , j + 1 , matrix [ i ][ j ]), dfs ( i , j - 1 , matrix [ i ][ j ])}); }; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) ans = max ( ans , dfs ( i , j , INT_MIN )); return ans ; } }; 330. Patching Array $\\star\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : int minPatches ( vector < int >& nums , int n ) { int ans = 0 ; long minMissNum = 1 ; for ( int i = 0 ; minMissNum <= n ;) if ( i < nums . size () && nums [ i ] <= minMissNum ) minMissNum += nums [ i ++ ]; else { minMissNum += minMissNum ; // greedily add itself ++ ans ; } return ans ; } };","title":"0321-0330"},{"location":"cpp/0301-0400/0321-0330/#321-create-maximum-number-starstarstar","text":"Time: $O(k(m + n)^2)$ Space: $O(m + n)$ class Solution { public : vector < int > maxNumber ( vector < int >& nums1 , vector < int >& nums2 , int k ) { vector < int > ans ; for ( int k1 = 0 ; k1 <= k ; ++ k1 ) { const int k2 = k - k1 ; if ( k1 > nums1 . size () || k2 > nums2 . size ()) continue ; ans = max ( ans , maxNumber ( maxNumber ( nums1 , k1 ), maxNumber ( nums2 , k2 ))); } return ans ; } private : vector < int > maxNumber ( const vector < int >& nums , int k ) { if ( k == 0 ) return {}; vector < int > ans ; int toPop = nums . size () - k ; for ( const int num : nums ) { while ( ! ans . empty () && ans . back () < num && toPop -- > 0 ) ans . pop_back (); ans . push_back ( num ); } return { begin ( ans ), begin ( ans ) + k }; } private : vector < int > maxNumber ( const vector < int >& nums1 , const vector < int >& nums2 ) { vector < int > ans ; auto s1 = cbegin ( nums1 ); auto s2 = cbegin ( nums2 ); while ( s1 != cend ( nums1 ) || s2 != cend ( nums2 )) if ( lexicographical_compare ( s1 , cend ( nums1 ), s2 , cend ( nums2 ))) ans . push_back ( * s2 ++ ); else ans . push_back ( * s1 ++ ); return ans ; } };","title":"321. Create Maximum Number $\\star\\star\\star$"},{"location":"cpp/0301-0400/0321-0330/#322-coin-change-starstar","text":"Time: $O(nk)$, where n = len(coins) and k = amount Space: $O(k)$ class Solution { public : int coinChange ( vector < int >& coins , int amount ) { vector < int > dp ( amount + 1 , amount + 1 ); dp [ 0 ] = 0 ; for ( int coin : coins ) for ( int i = coin ; i <= amount ; ++ i ) dp [ i ] = min ( dp [ i ], dp [ i - coin ] + 1 ); return dp . back () < amount + 1 ? dp . back () : - 1 ; } };","title":"322. Coin Change $\\star\\star$"},{"location":"cpp/0301-0400/0321-0330/#323-number-of-connected-components-in-an-undirected-graph-starstar","text":"","title":"323. Number of Connected Components in an Undirected Graph $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0301-0400/0321-0330/#324-wiggle-sort-ii-starstar","text":"Time: $O(n) \\tidle O(n^2)$ Space: $O(1)$ class Solution { public : void wiggleSort ( vector < int >& nums ) { const int n = nums . size (); const auto it = begin ( nums ) + n / 2 ; nth_element ( begin ( nums ), it , end ( nums )); const int median = * it ; // index-rewiring #define A(i) nums[(1 + 2 * i) % (n | 1)] for ( int i = 0 , j = 0 , k = n - 1 ; i <= k ;) if ( A ( i ) > median ) swap ( A ( i ++ ), A ( j ++ )); else if ( A ( i ) < median ) swap ( A ( i ), A ( k -- )); else ++ i ; } };","title":"324. Wiggle Sort II $\\star\\star$"},{"location":"cpp/0301-0400/0321-0330/#325-maximum-size-subarray-sum-equals-k-starstar","text":"","title":"325. Maximum Size Subarray Sum Equals k $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0301-0400/0321-0330/#326-power-of-three-star","text":"class Solution { public : bool isPowerOfThree ( int n ) { return n > 0 && ( int ) pow ( 3 , 19 ) % n == 0 ; } };","title":"326. Power of Three $\\star$"},{"location":"cpp/0301-0400/0321-0330/#327-count-of-range-sum-starstarstar","text":"Time: $O(n\\log n)$ Space: $O(n)$ class Solution { public : int countRangeSum ( vector < int >& nums , int lower , int upper ) { const int n = nums . size (); int count = 0 ; vector < long > prefixSum ( n + 1 , 0 ); for ( int i = 1 ; i <= n ; ++ i ) prefixSum [ i ] = prefixSum [ i - 1 ] + ( long ) nums [ i - 1 ]; function < void ( int , int , int ) > merge = [ & ]( int l , int m , int r ) { vector < long > sorted ( r - l + 1 ); int k = 0 ; // point to the sorted's beginning int j = m + 1 ; // point to the right's beginning int lo = m + 1 ; // 1st index that prefixSum[lo] - prefixSum[i] >= lower int hi = m + 1 ; // 1st index that prefixSum[hi] - prefixSum[i] > upper // for each index i in range [l, m], add hi - lo to count for ( int i = l ; i <= m ; ++ i ) { while ( lo <= r && prefixSum [ lo ] - prefixSum [ i ] < lower ) ++ lo ; while ( hi <= r && prefixSum [ hi ] - prefixSum [ i ] <= upper ) ++ hi ; count += hi - lo ; // put right part that is smaller than prefixSum[i] to the sorted array while ( j <= r && prefixSum [ j ] < prefixSum [ i ]) sorted [ k ++ ] = prefixSum [ j ++ ]; sorted [ k ++ ] = prefixSum [ i ]; } // put possible remaining right part to the sorted array while ( j <= r ) sorted [ k ++ ] = prefixSum [ j ++ ]; copy ( begin ( sorted ), end ( sorted ), begin ( prefixSum ) + l ); }; function < void ( int , int ) > mergeSort = [ & ]( int l , int r ) { if ( l >= r ) return ; const int m = l + ( r - l ) / 2 ; mergeSort ( l , m ); mergeSort ( m + 1 , r ); merge ( l , m , r ); }; mergeSort ( 0 , n ); return count ; } };","title":"327. Count of Range Sum $\\star\\star\\star$"},{"location":"cpp/0301-0400/0321-0330/#328-odd-even-linked-list-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : ListNode * oddEvenList ( ListNode * head ) { ListNode oddHead ( 0 ); ListNode evenHead ( 0 ); ListNode * odd = & oddHead ; ListNode * even = & evenHead ; for ( int isOdd = 0 ; head ; head = head -> next ) if ( isOdd ^= 1 ) { odd -> next = head ; odd = head ; } else { even -> next = head ; even = head ; } even -> next = nullptr ; odd -> next = evenHead . next ; return oddHead . next ; } };","title":"328. Odd Even Linked List $\\star\\star$"},{"location":"cpp/0301-0400/0321-0330/#329-longest-increasing-path-in-a-matrix-starstarstar","text":"Time: $O(mn)$ Space: $O(mn)$ class Solution { public : int longestIncreasingPath ( vector < vector < int >>& matrix ) { if ( matrix . empty ()) return 0 ; const int m = matrix . size (); const int n = matrix [ 0 ]. size (); int ans = 0 ; vector < vector < int >> memo ( m , vector < int > ( n )); function < int ( int , int , int ) > dfs = [ & ]( int i , int j , int maxi ) { if ( i < 0 || i == m || j < 0 || j == n ) return 0 ; if ( matrix [ i ][ j ] <= maxi ) return 0 ; if ( memo [ i ][ j ]) return memo [ i ][ j ]; return memo [ i ][ j ] = 1 + max ({ dfs ( i + 1 , j , matrix [ i ][ j ]), dfs ( i - 1 , j , matrix [ i ][ j ]), dfs ( i , j + 1 , matrix [ i ][ j ]), dfs ( i , j - 1 , matrix [ i ][ j ])}); }; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) ans = max ( ans , dfs ( i , j , INT_MIN )); return ans ; } };","title":"329. Longest Increasing Path in a Matrix $\\star\\star\\star$"},{"location":"cpp/0301-0400/0321-0330/#330-patching-array-starstarstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : int minPatches ( vector < int >& nums , int n ) { int ans = 0 ; long minMissNum = 1 ; for ( int i = 0 ; minMissNum <= n ;) if ( i < nums . size () && nums [ i ] <= minMissNum ) minMissNum += nums [ i ++ ]; else { minMissNum += minMissNum ; // greedily add itself ++ ans ; } return ans ; } };","title":"330. Patching Array $\\star\\star\\star$"},{"location":"cpp/0301-0400/0331-0340/","text":"331. Verify Preorder Serialization of a Binary Tree $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : bool isValidSerialization ( string preorder ) { int degree = 1 ; // out-degree - in-degree istringstream iss ( preorder ); string token ; while ( getline ( iss , token , ',' )) { if ( -- degree < 0 ) return false ; if ( token != \"#\" ) degree += 2 ; } return degree == 0 ; } }; 332. Reconstruct Itinerary $\\star\\star$ Time: $O(|E|\\log |E|)$ Space: $O(|E|)$ class Solution { public : vector < string > findItinerary ( vector < vector < string >>& tickets ) { deque < string > ans ; map < string , multiset < string >> graph ; for ( const vector < string >& ticket : tickets ) graph [ ticket [ 0 ]]. insert ( ticket [ 1 ]); function < void ( const string & ) > dfs = [ & ]( const string & airport ) { while ( graph . count ( airport ) && ! graph [ airport ]. empty ()) { const string nextAirport = * begin ( graph [ airport ]); graph [ airport ]. erase ( begin ( graph [ airport ])); dfs ( nextAirport ); } ans . push_front ( airport ); }; dfs ( \"JFK\" ); return { begin ( ans ), end ( ans )}; } }; 333. Largest BST Subtree $\\star\\star$ \ud83d\udd12 334. Increasing Triplet Subsequence $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : bool increasingTriplet ( vector < int >& nums ) { int first = INT_MAX ; int second = INT_MAX ; for ( const int num : nums ) if ( num <= first ) first = num ; else if ( num <= second ) second = num ; else return true ; return false ; } }; 335. Self Crossing $\\star\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : bool isSelfCrossing ( vector < int >& x ) { if ( x . size () <= 3 ) return false ; for ( int i = 3 ; i < x . size (); ++ i ) { if ( x [ i - 2 ] <= x [ i ] && x [ i - 1 ] <= x [ i - 3 ]) return true ; if ( i >= 4 && x [ i - 1 ] == x [ i - 3 ] && x [ i - 2 ] <= x [ i ] + x [ i - 4 ]) return true ; if ( i >= 5 && x [ i - 4 ] <= x [ i - 2 ] && x [ i - 2 ] <= x [ i ] + x [ i - 4 ] && x [ i - 1 ] <= x [ i - 3 ] && x [ i - 3 ] <= x [ i - 1 ] + x [ i - 5 ]) return true ; } return false ; } }; 336. Palindrome Pairs $\\star\\star\\star$ Time: $O(nk^2)$, where n = len(words) and k = len(words[i]) Space: $O(nk)$ class Solution { public : vector < vector < int >> palindromePairs ( vector < string >& words ) { vector < vector < int >> ans ; unordered_map < string , int > map ; for ( int i = 0 ; i < words . size (); ++ i ) { string word = words [ i ]; reverse ( begin ( word ), end ( word )); map [ word ] = i ; } for ( int i = 0 ; i < words . size (); ++ i ) { if ( map . count ( \"\" ) && map [ \"\" ] != i && isPalindrome ( words [ i ])) ans . push_back ({ i , map [ \"\" ]}); for ( int j = 1 ; j <= words [ i ]. length (); ++ j ) { const string l = words [ i ]. substr ( 0 , j ); const string r = words [ i ]. substr ( j , words [ i ]. length () - j ); if ( map . count ( l ) && map [ l ] != i && isPalindrome ( r )) ans . push_back ({ i , map [ l ]}); if ( map . count ( r ) && map [ r ] != i && isPalindrome ( l )) ans . push_back ({ map [ r ], i }); } } return ans ; } private : bool isPalindrome ( const string & s ) { int l = 0 ; int r = s . length () - 1 ; while ( l < r ) if ( s [ l ++ ] != s [ r -- ]) return false ; return true ; } }; 337. House Robber III $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : int rob ( TreeNode * root ) { const auto & [ robRoot , notRobRoot ] = robOrNot ( root ); return max ( robRoot , notRobRoot ); } private : pair < int , int > robOrNot ( TreeNode * root ) { if ( ! root ) return { 0 , 0 }; const auto & [ robLeft , notRobLeft ] = robOrNot ( root -> left ); const auto & [ robRight , notRobRight ] = robOrNot ( root -> right ); return { root -> val + notRobLeft + notRobRight , max ( robLeft , notRobLeft ) + max ( robRight , notRobRight )}; } }; 338. Counting Bits $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : vector < int > countBits ( int num ) { vector < int > ans ( num + 1 ); for ( int i = 1 ; i <= num ; ++ i ) ans [ i ] = ans [ i >> 1 ] + ( i & 1 ); return ans ; } }; 339. Nested List Weight Sum $\\star$ \ud83d\udd12 340. Longest Substring with At Most K Distinct Characters $\\star\\star\\star$ \ud83d\udd12","title":"0331-0340"},{"location":"cpp/0301-0400/0331-0340/#331-verify-preorder-serialization-of-a-binary-tree-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : bool isValidSerialization ( string preorder ) { int degree = 1 ; // out-degree - in-degree istringstream iss ( preorder ); string token ; while ( getline ( iss , token , ',' )) { if ( -- degree < 0 ) return false ; if ( token != \"#\" ) degree += 2 ; } return degree == 0 ; } };","title":"331. Verify Preorder Serialization of a Binary Tree $\\star\\star$"},{"location":"cpp/0301-0400/0331-0340/#332-reconstruct-itinerary-starstar","text":"Time: $O(|E|\\log |E|)$ Space: $O(|E|)$ class Solution { public : vector < string > findItinerary ( vector < vector < string >>& tickets ) { deque < string > ans ; map < string , multiset < string >> graph ; for ( const vector < string >& ticket : tickets ) graph [ ticket [ 0 ]]. insert ( ticket [ 1 ]); function < void ( const string & ) > dfs = [ & ]( const string & airport ) { while ( graph . count ( airport ) && ! graph [ airport ]. empty ()) { const string nextAirport = * begin ( graph [ airport ]); graph [ airport ]. erase ( begin ( graph [ airport ])); dfs ( nextAirport ); } ans . push_front ( airport ); }; dfs ( \"JFK\" ); return { begin ( ans ), end ( ans )}; } };","title":"332. Reconstruct Itinerary $\\star\\star$"},{"location":"cpp/0301-0400/0331-0340/#333-largest-bst-subtree-starstar","text":"","title":"333. Largest BST Subtree $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0301-0400/0331-0340/#334-increasing-triplet-subsequence-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : bool increasingTriplet ( vector < int >& nums ) { int first = INT_MAX ; int second = INT_MAX ; for ( const int num : nums ) if ( num <= first ) first = num ; else if ( num <= second ) second = num ; else return true ; return false ; } };","title":"334. Increasing Triplet Subsequence $\\star\\star$"},{"location":"cpp/0301-0400/0331-0340/#335-self-crossing-starstarstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : bool isSelfCrossing ( vector < int >& x ) { if ( x . size () <= 3 ) return false ; for ( int i = 3 ; i < x . size (); ++ i ) { if ( x [ i - 2 ] <= x [ i ] && x [ i - 1 ] <= x [ i - 3 ]) return true ; if ( i >= 4 && x [ i - 1 ] == x [ i - 3 ] && x [ i - 2 ] <= x [ i ] + x [ i - 4 ]) return true ; if ( i >= 5 && x [ i - 4 ] <= x [ i - 2 ] && x [ i - 2 ] <= x [ i ] + x [ i - 4 ] && x [ i - 1 ] <= x [ i - 3 ] && x [ i - 3 ] <= x [ i - 1 ] + x [ i - 5 ]) return true ; } return false ; } };","title":"335. Self Crossing $\\star\\star\\star$"},{"location":"cpp/0301-0400/0331-0340/#336-palindrome-pairs-starstarstar","text":"Time: $O(nk^2)$, where n = len(words) and k = len(words[i]) Space: $O(nk)$ class Solution { public : vector < vector < int >> palindromePairs ( vector < string >& words ) { vector < vector < int >> ans ; unordered_map < string , int > map ; for ( int i = 0 ; i < words . size (); ++ i ) { string word = words [ i ]; reverse ( begin ( word ), end ( word )); map [ word ] = i ; } for ( int i = 0 ; i < words . size (); ++ i ) { if ( map . count ( \"\" ) && map [ \"\" ] != i && isPalindrome ( words [ i ])) ans . push_back ({ i , map [ \"\" ]}); for ( int j = 1 ; j <= words [ i ]. length (); ++ j ) { const string l = words [ i ]. substr ( 0 , j ); const string r = words [ i ]. substr ( j , words [ i ]. length () - j ); if ( map . count ( l ) && map [ l ] != i && isPalindrome ( r )) ans . push_back ({ i , map [ l ]}); if ( map . count ( r ) && map [ r ] != i && isPalindrome ( l )) ans . push_back ({ map [ r ], i }); } } return ans ; } private : bool isPalindrome ( const string & s ) { int l = 0 ; int r = s . length () - 1 ; while ( l < r ) if ( s [ l ++ ] != s [ r -- ]) return false ; return true ; } };","title":"336. Palindrome Pairs $\\star\\star\\star$"},{"location":"cpp/0301-0400/0331-0340/#337-house-robber-iii-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : int rob ( TreeNode * root ) { const auto & [ robRoot , notRobRoot ] = robOrNot ( root ); return max ( robRoot , notRobRoot ); } private : pair < int , int > robOrNot ( TreeNode * root ) { if ( ! root ) return { 0 , 0 }; const auto & [ robLeft , notRobLeft ] = robOrNot ( root -> left ); const auto & [ robRight , notRobRight ] = robOrNot ( root -> right ); return { root -> val + notRobLeft + notRobRight , max ( robLeft , notRobLeft ) + max ( robRight , notRobRight )}; } };","title":"337. House Robber III $\\star\\star$"},{"location":"cpp/0301-0400/0331-0340/#338-counting-bits-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : vector < int > countBits ( int num ) { vector < int > ans ( num + 1 ); for ( int i = 1 ; i <= num ; ++ i ) ans [ i ] = ans [ i >> 1 ] + ( i & 1 ); return ans ; } };","title":"338. Counting Bits $\\star\\star$"},{"location":"cpp/0301-0400/0331-0340/#339-nested-list-weight-sum-star","text":"","title":"339. Nested List Weight Sum $\\star$ \ud83d\udd12"},{"location":"cpp/0301-0400/0331-0340/#340-longest-substring-with-at-most-k-distinct-characters-starstarstar","text":"","title":"340. Longest Substring with At Most K Distinct Characters $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/0301-0400/0341-0350/","text":"341. Flatten Nested List Iterator $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class NestedIterator { public : NestedIterator ( vector < NestedInteger >& nestedList ) { addInteger ( nestedList ); } int next () { int num = queue . front (); queue . pop (); return num ; } bool hasNext () { return ! queue . empty (); } private : queue < int > queue ; void addInteger ( const vector < NestedInteger >& nestedList ) { for ( const NestedInteger ni : nestedList ) if ( ni . isInteger ()) queue . push ( ni . getInteger ()); else addInteger ( ni . getList ()); } }; 342. Power of Four $\\star$ Time: $O(1)$ Space: $O(1)$ class Solution { public : bool isPowerOfFour ( int num ) { return num > 0 && __builtin_popcountll ( num ) == 1 && ( num - 1 ) % 3 == 0 ; } }; 343. Integer Break $\\star\\star$ Time: $O(n / 3)$ Space: $O(1)$ class Solution { public : int integerBreak ( int n ) { if ( n == 2 ) return 1 ; if ( n == 3 ) return 2 ; int ans = 1 ; while ( n > 4 ) { n -= 3 ; ans *= 3 ; } ans *= n ; return ans ; } }; 344. Reverse String $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : void reverseString ( vector < char >& s ) { int l = 0 ; int r = s . size () - 1 ; while ( l < r ) swap ( s [ l ++ ], s [ r -- ]); } }; 345. Reverse Vowels of a String $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : string reverseVowels ( string s ) { const unordered_set < char > vowels { 'a' , 'e' , 'i' , 'o' , 'u' , 'A' , 'E' , 'I' , 'O' , 'U' }; int l = 0 ; int r = s . length () - 1 ; while ( l < r ) { while ( l < r && ! vowels . count ( s [ l ])) ++ l ; while ( l < r && ! vowels . count ( s [ r ])) -- r ; swap ( s [ l ++ ], s [ r -- ]); } return s ; } }; 346. Moving Average from Data Stream $\\star$ \ud83d\udd12 347. Top K Frequent Elements $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : vector < int > topKFrequent ( vector < int >& nums , int k ) { const int n = nums . size (); vector < int > ans ; vector < vector < int >> bucket ( n + 1 ); unordered_map < int , int > count ; for ( const int num : nums ) ++ count [ num ]; for ( const auto & [ num , freq ] : count ) bucket [ freq ]. push_back ( num ); for ( int freq = n ; freq > 0 ; -- freq ) { for ( const int num : bucket [ freq ]) ans . push_back ( num ); if ( ans . size () == k ) return ans ; } throw ; } }; 348. Design Tic-Tac-Toe $\\star\\star$ \ud83d\udd12 349. Intersection of Two Arrays $\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : vector < int > intersection ( vector < int >& nums1 , vector < int >& nums2 ) { vector < int > ans ; unordered_set < int > nums1Set { begin ( nums1 ), end ( nums1 )}; for ( const int num : nums2 ) if ( nums1Set . erase ( num )) ans . push_back ( num ); return ans ; } }; 350. Intersection of Two Arrays II $\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : vector < int > intersect ( vector < int >& nums1 , vector < int >& nums2 ) { vector < int > ans ; unordered_map < int , int > count ; for ( const int num : nums1 ) ++ count [ num ]; for ( const int num : nums2 ) if ( count [ num ] -- > 0 ) ans . push_back ( num ); return ans ; } };","title":"0341-0350"},{"location":"cpp/0301-0400/0341-0350/#341-flatten-nested-list-iterator-starstar","text":"Time: $O(n)$ Space: $O(n)$ class NestedIterator { public : NestedIterator ( vector < NestedInteger >& nestedList ) { addInteger ( nestedList ); } int next () { int num = queue . front (); queue . pop (); return num ; } bool hasNext () { return ! queue . empty (); } private : queue < int > queue ; void addInteger ( const vector < NestedInteger >& nestedList ) { for ( const NestedInteger ni : nestedList ) if ( ni . isInteger ()) queue . push ( ni . getInteger ()); else addInteger ( ni . getList ()); } };","title":"341. Flatten Nested List Iterator $\\star\\star$"},{"location":"cpp/0301-0400/0341-0350/#342-power-of-four-star","text":"Time: $O(1)$ Space: $O(1)$ class Solution { public : bool isPowerOfFour ( int num ) { return num > 0 && __builtin_popcountll ( num ) == 1 && ( num - 1 ) % 3 == 0 ; } };","title":"342. Power of Four $\\star$"},{"location":"cpp/0301-0400/0341-0350/#343-integer-break-starstar","text":"Time: $O(n / 3)$ Space: $O(1)$ class Solution { public : int integerBreak ( int n ) { if ( n == 2 ) return 1 ; if ( n == 3 ) return 2 ; int ans = 1 ; while ( n > 4 ) { n -= 3 ; ans *= 3 ; } ans *= n ; return ans ; } };","title":"343. Integer Break $\\star\\star$"},{"location":"cpp/0301-0400/0341-0350/#344-reverse-string-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : void reverseString ( vector < char >& s ) { int l = 0 ; int r = s . size () - 1 ; while ( l < r ) swap ( s [ l ++ ], s [ r -- ]); } };","title":"344. Reverse String $\\star$"},{"location":"cpp/0301-0400/0341-0350/#345-reverse-vowels-of-a-string-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : string reverseVowels ( string s ) { const unordered_set < char > vowels { 'a' , 'e' , 'i' , 'o' , 'u' , 'A' , 'E' , 'I' , 'O' , 'U' }; int l = 0 ; int r = s . length () - 1 ; while ( l < r ) { while ( l < r && ! vowels . count ( s [ l ])) ++ l ; while ( l < r && ! vowels . count ( s [ r ])) -- r ; swap ( s [ l ++ ], s [ r -- ]); } return s ; } };","title":"345. Reverse Vowels of a String $\\star$"},{"location":"cpp/0301-0400/0341-0350/#346-moving-average-from-data-stream-star","text":"","title":"346. Moving Average from Data Stream $\\star$ \ud83d\udd12"},{"location":"cpp/0301-0400/0341-0350/#347-top-k-frequent-elements-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : vector < int > topKFrequent ( vector < int >& nums , int k ) { const int n = nums . size (); vector < int > ans ; vector < vector < int >> bucket ( n + 1 ); unordered_map < int , int > count ; for ( const int num : nums ) ++ count [ num ]; for ( const auto & [ num , freq ] : count ) bucket [ freq ]. push_back ( num ); for ( int freq = n ; freq > 0 ; -- freq ) { for ( const int num : bucket [ freq ]) ans . push_back ( num ); if ( ans . size () == k ) return ans ; } throw ; } };","title":"347. Top K Frequent Elements $\\star\\star$"},{"location":"cpp/0301-0400/0341-0350/#348-design-tic-tac-toe-starstar","text":"","title":"348. Design Tic-Tac-Toe $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0301-0400/0341-0350/#349-intersection-of-two-arrays-star","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : vector < int > intersection ( vector < int >& nums1 , vector < int >& nums2 ) { vector < int > ans ; unordered_set < int > nums1Set { begin ( nums1 ), end ( nums1 )}; for ( const int num : nums2 ) if ( nums1Set . erase ( num )) ans . push_back ( num ); return ans ; } };","title":"349. Intersection of Two Arrays $\\star$"},{"location":"cpp/0301-0400/0341-0350/#350-intersection-of-two-arrays-ii-star","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : vector < int > intersect ( vector < int >& nums1 , vector < int >& nums2 ) { vector < int > ans ; unordered_map < int , int > count ; for ( const int num : nums1 ) ++ count [ num ]; for ( const int num : nums2 ) if ( count [ num ] -- > 0 ) ans . push_back ( num ); return ans ; } };","title":"350. Intersection of Two Arrays II $\\star$"},{"location":"cpp/0301-0400/0351-0360/","text":"351. Android Unlock Patterns $\\star\\star$ \ud83d\udd12 352. Data Stream as Disjoint Intervals $\\star\\star\\star$ Time: $O(n\\log n)$ Space: $O(n)$ class SummaryRanges { public : void addNum ( int val ) { if ( map . count ( val )) return ; const int lo = lowerKey ( val ); const int hi = higherKey ( val ); if ( lo >= 0 && hi >= 0 && map [ lo ][ 1 ] + 1 == val && hi == val + 1 ) { map [ lo ][ 1 ] = map [ hi ][ 1 ]; map . erase ( hi ); } else if ( lo >= 0 && map [ lo ][ 1 ] + 1 >= val ) { map [ lo ][ 1 ] = max ( map [ lo ][ 1 ], val ); } else if ( hi >= 0 && hi == val + 1 ) { map [ val ] = { val , map [ hi ][ 1 ]}; map . erase ( hi ); } else { map [ val ] = { val , val }; } } vector < vector < int >> getIntervals () { vector < vector < int >> ans ; for ( const auto & [ _ , intervals ] : map ) ans . push_back ( intervals ); return ans ; } private : map < int , vector < int >> map ; int lowerKey ( int key ) { auto it = map . lower_bound ( key ); if ( it == begin ( map )) return - 1 ; return ( -- it ) -> first ; } int higherKey ( int key ) { auto it = map . upper_bound ( key ); if ( it == end ( map )) return - 1 ; return it -> first ; } }; 353. Design Snake Game $\\star\\star$ \ud83d\udd12 354. Russian Doll Envelopes $\\star\\star\\star$ Time: $O(n\\log n)$ Space: $O(n)$ class Solution { public : int maxEnvelopes ( vector < vector < int >>& envelopes ) { int ans = 0 ; vector < int > dp ( envelopes . size ()); sort ( begin ( envelopes ), end ( envelopes ), []( const auto & a , const auto & b ) { return a [ 0 ] == b [ 0 ] ? a [ 1 ] > b [ 1 ] : a [ 0 ] < b [ 0 ]; }); for ( const vector < int >& envelope : envelopes ) { int l = 0 ; int r = ans ; while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( dp [ m ] < envelope [ 1 ]) l = m + 1 ; else r = m ; } dp [ l ] = envelope [ 1 ]; if ( l == ans ) ++ ans ; } return ans ; } }; 355. Design Twitter $\\star\\star$ Time: $O(n + k\\log n)$, where n = len(tweets) and k = min(10, len(tweets)) Space: $O(n)$ struct Tweet { int tweetId ; int time ; Tweet ( int tweetId , int time ) : tweetId ( tweetId ), time ( time ) {} }; class Twitter { public : void postTweet ( int userId , int tweetId ) { tweets [ userId ]. push_back ( Tweet ( tweetId , time ++ )); } vector < int > getNewsFeed ( int userId ) { vector < int > newsFeed ; auto compare = []( const Tweet & a , const Tweet & b ) { return a . time < b . time ; }; priority_queue < Tweet , vector < Tweet > , decltype ( compare ) > pq ( compare ); // push your own tweets for ( const Tweet & tweet : tweets [ userId ]) pq . push ( tweet ); // push your followees' tweets for ( const int followeeId : followees [ userId ]) for ( const Tweet & tweet : tweets [ followeeId ]) pq . push ( tweet ); for ( int i = min ( 10 , ( int ) pq . size ()); i > 0 ; -- i ) newsFeed . push_back ( pq . top (). tweetId ), pq . pop (); return newsFeed ; } void follow ( int followerId , int followeeId ) { if ( followerId == followeeId ) return ; followees [ followerId ]. insert ( followeeId ); } void unfollow ( int followerId , int followeeId ) { if ( followerId == followeeId ) return ; followees [ followerId ]. erase ( followeeId ); } private : int time = 0 ; unordered_map < int , unordered_set < int >> followees ; // {userId: {followeeIds}} unordered_map < int , vector < Tweet >> tweets ; // {userId: {Tweets}} }; 356. Line Reflection $\\star\\star$ \ud83d\udd12 357. Count Numbers with Unique Digits $\\star\\star$ Time: $O(9)$ Space: $O(1)$ class Solution { public : int countNumbersWithUniqueDigits ( int n ) { if ( n == 0 ) return 1 ; int ans = 10 ; int uniqueDigits = 9 ; for ( int availableNum = 9 ; n > 1 && availableNum > 0 ; -- n , -- availableNum ) { uniqueDigits *= availableNum ; ans += uniqueDigits ; } return ans ; } }; 358. Rearrange String k Distance Apart $\\star\\star\\star$ \ud83d\udd12 359. Logger Rate Limiter $\\star$ \ud83d\udd12 360. Sort Transformed Array $\\star\\star$ \ud83d\udd12","title":"0351-0360"},{"location":"cpp/0301-0400/0351-0360/#351-android-unlock-patterns-starstar","text":"","title":"351. Android Unlock Patterns $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0301-0400/0351-0360/#352-data-stream-as-disjoint-intervals-starstarstar","text":"Time: $O(n\\log n)$ Space: $O(n)$ class SummaryRanges { public : void addNum ( int val ) { if ( map . count ( val )) return ; const int lo = lowerKey ( val ); const int hi = higherKey ( val ); if ( lo >= 0 && hi >= 0 && map [ lo ][ 1 ] + 1 == val && hi == val + 1 ) { map [ lo ][ 1 ] = map [ hi ][ 1 ]; map . erase ( hi ); } else if ( lo >= 0 && map [ lo ][ 1 ] + 1 >= val ) { map [ lo ][ 1 ] = max ( map [ lo ][ 1 ], val ); } else if ( hi >= 0 && hi == val + 1 ) { map [ val ] = { val , map [ hi ][ 1 ]}; map . erase ( hi ); } else { map [ val ] = { val , val }; } } vector < vector < int >> getIntervals () { vector < vector < int >> ans ; for ( const auto & [ _ , intervals ] : map ) ans . push_back ( intervals ); return ans ; } private : map < int , vector < int >> map ; int lowerKey ( int key ) { auto it = map . lower_bound ( key ); if ( it == begin ( map )) return - 1 ; return ( -- it ) -> first ; } int higherKey ( int key ) { auto it = map . upper_bound ( key ); if ( it == end ( map )) return - 1 ; return it -> first ; } };","title":"352. Data Stream as Disjoint Intervals $\\star\\star\\star$"},{"location":"cpp/0301-0400/0351-0360/#353-design-snake-game-starstar","text":"","title":"353. Design Snake Game $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0301-0400/0351-0360/#354-russian-doll-envelopes-starstarstar","text":"Time: $O(n\\log n)$ Space: $O(n)$ class Solution { public : int maxEnvelopes ( vector < vector < int >>& envelopes ) { int ans = 0 ; vector < int > dp ( envelopes . size ()); sort ( begin ( envelopes ), end ( envelopes ), []( const auto & a , const auto & b ) { return a [ 0 ] == b [ 0 ] ? a [ 1 ] > b [ 1 ] : a [ 0 ] < b [ 0 ]; }); for ( const vector < int >& envelope : envelopes ) { int l = 0 ; int r = ans ; while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( dp [ m ] < envelope [ 1 ]) l = m + 1 ; else r = m ; } dp [ l ] = envelope [ 1 ]; if ( l == ans ) ++ ans ; } return ans ; } };","title":"354. Russian Doll Envelopes $\\star\\star\\star$"},{"location":"cpp/0301-0400/0351-0360/#355-design-twitter-starstar","text":"Time: $O(n + k\\log n)$, where n = len(tweets) and k = min(10, len(tweets)) Space: $O(n)$ struct Tweet { int tweetId ; int time ; Tweet ( int tweetId , int time ) : tweetId ( tweetId ), time ( time ) {} }; class Twitter { public : void postTweet ( int userId , int tweetId ) { tweets [ userId ]. push_back ( Tweet ( tweetId , time ++ )); } vector < int > getNewsFeed ( int userId ) { vector < int > newsFeed ; auto compare = []( const Tweet & a , const Tweet & b ) { return a . time < b . time ; }; priority_queue < Tweet , vector < Tweet > , decltype ( compare ) > pq ( compare ); // push your own tweets for ( const Tweet & tweet : tweets [ userId ]) pq . push ( tweet ); // push your followees' tweets for ( const int followeeId : followees [ userId ]) for ( const Tweet & tweet : tweets [ followeeId ]) pq . push ( tweet ); for ( int i = min ( 10 , ( int ) pq . size ()); i > 0 ; -- i ) newsFeed . push_back ( pq . top (). tweetId ), pq . pop (); return newsFeed ; } void follow ( int followerId , int followeeId ) { if ( followerId == followeeId ) return ; followees [ followerId ]. insert ( followeeId ); } void unfollow ( int followerId , int followeeId ) { if ( followerId == followeeId ) return ; followees [ followerId ]. erase ( followeeId ); } private : int time = 0 ; unordered_map < int , unordered_set < int >> followees ; // {userId: {followeeIds}} unordered_map < int , vector < Tweet >> tweets ; // {userId: {Tweets}} };","title":"355. Design Twitter $\\star\\star$"},{"location":"cpp/0301-0400/0351-0360/#356-line-reflection-starstar","text":"","title":"356. Line Reflection $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0301-0400/0351-0360/#357-count-numbers-with-unique-digits-starstar","text":"Time: $O(9)$ Space: $O(1)$ class Solution { public : int countNumbersWithUniqueDigits ( int n ) { if ( n == 0 ) return 1 ; int ans = 10 ; int uniqueDigits = 9 ; for ( int availableNum = 9 ; n > 1 && availableNum > 0 ; -- n , -- availableNum ) { uniqueDigits *= availableNum ; ans += uniqueDigits ; } return ans ; } };","title":"357. Count Numbers with Unique Digits $\\star\\star$"},{"location":"cpp/0301-0400/0351-0360/#358-rearrange-string-k-distance-apart-starstarstar","text":"","title":"358. Rearrange String k Distance Apart $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/0301-0400/0351-0360/#359-logger-rate-limiter-star","text":"","title":"359. Logger Rate Limiter $\\star$ \ud83d\udd12"},{"location":"cpp/0301-0400/0351-0360/#360-sort-transformed-array-starstar","text":"","title":"360. Sort Transformed Array $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0301-0400/0361-0370/","text":"361. Bomb Enemy $\\star\\star$ \ud83d\udd12 362. Design Hit Counter $\\star\\star$ \ud83d\udd12 363. Max Sum of Rectangle No Larger Than K $\\star\\star\\star$ Time: $O(\\min(m, n)^2 \\cdot \\max(m, n) \\cdot \\log\\max(m, n))$ Space: $O(\\max(m, n))$ class Solution { public : int maxSumSubmatrix ( vector < vector < int >>& matrix , int k ) { const int m = matrix . size (); const int n = matrix [ 0 ]. size (); int ans = INT_MIN ; for ( int baseCol = 0 ; baseCol < n ; ++ baseCol ) { vector < int > sums ( m , 0 ); for ( int j = baseCol ; j < n ; ++ j ) { for ( int i = 0 ; i < m ; ++ i ) sums [ i ] += matrix [ i ][ j ]; // find the max subarray no more than k set < int > accumulate { 0 }; int prefixSum = 0 ; for ( const int sum : sums ) { prefixSum += sum ; const auto it = accumulate . lower_bound ( prefixSum - k ); if ( it != cend ( accumulate )) ans = max ( ans , prefixSum - * it ); accumulate . insert ( prefixSum ); } } } return ans ; } }; 364. Nested List Weight Sum II $\\star\\star$ \ud83d\udd12 365. Water and Jug Problem $\\star\\star$ Time: $O(1)$ Space: $O(1)$ class Solution { public : bool canMeasureWater ( int x , int y , int z ) { return z == 0 || ( long ) x + y >= z && z % __gcd ( x , y ) == 0 ; } }; 366. Find Leaves of Binary Tree $\\star\\star$ \ud83d\udd12 367. Valid Perfect Square $\\star$ Time: $O(\\log num)$ Space: $O(1)$ class Solution { public : bool isPerfectSquare ( long num ) { long l = 1 ; long r = num + 1 ; while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( m > num / m ) r = m ; else l = m + 1 ; } return ( l - 1 ) * ( l - 1 ) == num ; } }; 368. Largest Divisible Subset $\\star\\star$ Time: $O(n^2)$ Space: $O(n)$ class Solution { public : vector < int > largestDivisibleSubset ( vector < int >& nums ) { const int n = nums . size (); vector < int > ans ; vector < int > lengthEndsAt ( n , 1 ); vector < int > prevIndex ( n , - 1 ); int maxLength = 0 ; int index = - 1 ; sort ( begin ( nums ), end ( nums )); for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i - 1 ; j >= 0 ; -- j ) if ( nums [ i ] % nums [ j ] == 0 && lengthEndsAt [ i ] < lengthEndsAt [ j ] + 1 ) { lengthEndsAt [ i ] = lengthEndsAt [ j ] + 1 ; prevIndex [ i ] = j ; } if ( lengthEndsAt [ i ] > maxLength ) { maxLength = lengthEndsAt [ i ]; index = i ; } } while ( index != - 1 ) { ans . push_back ( nums [ index ]); index = prevIndex [ index ]; } return ans ; } }; 369. Plus One Linked List $\\star\\star$ \ud83d\udd12 370. Range Addition $\\star\\star$ \ud83d\udd12","title":"0361-0370"},{"location":"cpp/0301-0400/0361-0370/#361-bomb-enemy-starstar","text":"","title":"361. Bomb Enemy $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0301-0400/0361-0370/#362-design-hit-counter-starstar","text":"","title":"362. Design Hit Counter $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0301-0400/0361-0370/#363-max-sum-of-rectangle-no-larger-than-k-starstarstar","text":"Time: $O(\\min(m, n)^2 \\cdot \\max(m, n) \\cdot \\log\\max(m, n))$ Space: $O(\\max(m, n))$ class Solution { public : int maxSumSubmatrix ( vector < vector < int >>& matrix , int k ) { const int m = matrix . size (); const int n = matrix [ 0 ]. size (); int ans = INT_MIN ; for ( int baseCol = 0 ; baseCol < n ; ++ baseCol ) { vector < int > sums ( m , 0 ); for ( int j = baseCol ; j < n ; ++ j ) { for ( int i = 0 ; i < m ; ++ i ) sums [ i ] += matrix [ i ][ j ]; // find the max subarray no more than k set < int > accumulate { 0 }; int prefixSum = 0 ; for ( const int sum : sums ) { prefixSum += sum ; const auto it = accumulate . lower_bound ( prefixSum - k ); if ( it != cend ( accumulate )) ans = max ( ans , prefixSum - * it ); accumulate . insert ( prefixSum ); } } } return ans ; } };","title":"363. Max Sum of Rectangle No Larger Than K $\\star\\star\\star$"},{"location":"cpp/0301-0400/0361-0370/#364-nested-list-weight-sum-ii-starstar","text":"","title":"364. Nested List Weight Sum II $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0301-0400/0361-0370/#365-water-and-jug-problem-starstar","text":"Time: $O(1)$ Space: $O(1)$ class Solution { public : bool canMeasureWater ( int x , int y , int z ) { return z == 0 || ( long ) x + y >= z && z % __gcd ( x , y ) == 0 ; } };","title":"365. Water and Jug Problem $\\star\\star$"},{"location":"cpp/0301-0400/0361-0370/#366-find-leaves-of-binary-tree-starstar","text":"","title":"366. Find Leaves of Binary Tree $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0301-0400/0361-0370/#367-valid-perfect-square-star","text":"Time: $O(\\log num)$ Space: $O(1)$ class Solution { public : bool isPerfectSquare ( long num ) { long l = 1 ; long r = num + 1 ; while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( m > num / m ) r = m ; else l = m + 1 ; } return ( l - 1 ) * ( l - 1 ) == num ; } };","title":"367. Valid Perfect Square $\\star$"},{"location":"cpp/0301-0400/0361-0370/#368-largest-divisible-subset-starstar","text":"Time: $O(n^2)$ Space: $O(n)$ class Solution { public : vector < int > largestDivisibleSubset ( vector < int >& nums ) { const int n = nums . size (); vector < int > ans ; vector < int > lengthEndsAt ( n , 1 ); vector < int > prevIndex ( n , - 1 ); int maxLength = 0 ; int index = - 1 ; sort ( begin ( nums ), end ( nums )); for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i - 1 ; j >= 0 ; -- j ) if ( nums [ i ] % nums [ j ] == 0 && lengthEndsAt [ i ] < lengthEndsAt [ j ] + 1 ) { lengthEndsAt [ i ] = lengthEndsAt [ j ] + 1 ; prevIndex [ i ] = j ; } if ( lengthEndsAt [ i ] > maxLength ) { maxLength = lengthEndsAt [ i ]; index = i ; } } while ( index != - 1 ) { ans . push_back ( nums [ index ]); index = prevIndex [ index ]; } return ans ; } };","title":"368. Largest Divisible Subset $\\star\\star$"},{"location":"cpp/0301-0400/0361-0370/#369-plus-one-linked-list-starstar","text":"","title":"369. Plus One Linked List $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0301-0400/0361-0370/#370-range-addition-starstar","text":"","title":"370. Range Addition $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0301-0400/0371-0380/","text":"371. Sum of Two Integers $\\star$ Time: $O(32)$ Space: $O(1)$ class Solution { public : int getSum ( unsigned a , unsigned b ) { while ( b != 0 ) { const unsigned sum = a ^ b ; b = ( a & b ) << 1 ; a = sum ; } return a ; } }; 372. Super Pow $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : int superPow ( int a , vector < int >& b ) { const int k = 1337 ; int ans = 1 ; auto powMod = [ & ]( int x , int y ) { // x^y % k int pow = 1 ; while ( y -- ) pow = ( pow * x ) % k ; return pow ; }; a %= k ; for ( const int i : b ) ans = powMod ( ans , 10 ) * powMod ( a , i ) % k ; return ans ; } }; 373. Find K Pairs with Smallest Sums $\\star\\star$ Time: $O(k\\log k)$ Space: $O(k)$ class Solution { public : vector < vector < int >> kSmallestPairs ( vector < int >& nums1 , vector < int >& nums2 , int k ) { if ( nums2 . empty ()) return {}; vector < vector < int >> ans ; auto compare = [ & ]( const pair < int , int >& a , const pair < int , int >& b ) { return nums1 [ a . first ] + nums2 [ a . second ] > nums1 [ b . first ] + nums2 [ b . second ]; }; priority_queue < pair < int , int > , vector < pair < int , int >> , decltype ( compare ) > pq ( compare ); for ( int i = 0 ; i < nums1 . size () && i < k ; ++ i ) pq . push ({ i , 0 }); while ( ! pq . empty () && ans . size () < k ) { const auto [ index1 , index2 ] = pq . top (); pq . pop (); ans . push_back ({ nums1 [ index1 ], nums2 [ index2 ]}); if ( index2 + 1 < nums2 . size ()) pq . push ({ index1 , index2 + 1 }); } return ans ; } }; 374. Guess Number Higher or Lower $\\star$ Time: $O(\\log n)$ Space: $O(1)$ class Solution { public : int guessNumber ( int n ) { int l = 1 ; int r = n ; while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( guess ( m ) <= 0 ) r = m ; else l = m + 1 ; } return l ; } }; 375. Guess Number Higher or Lower II $\\star\\star$ Time: $O(n^3)$ Space: $O(n^2)$ class Solution { public : int getMoneyAmount ( int n ) { vector < vector < int >> dp ( n + 2 , vector < int > ( n + 2 )); for ( int length = 2 ; length <= n ; ++ length ) for ( int i = 1 ; i + length - 1 <= n ; ++ i ) { const int j = i + length - 1 ; dp [ i ][ j ] = INT_MAX ; for ( int k = i ; k <= j ; ++ k ) dp [ i ][ j ] = min ( dp [ i ][ j ], max ( dp [ i ][ k - 1 ], dp [ k + 1 ][ j ]) + k ); } return dp [ 1 ][ n ]; } }; 376. Wiggle Subsequence $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : int wiggleMaxLength ( vector < int >& nums ) { if ( nums . empty ()) return 0 ; int increasing = 1 ; int decreasing = 1 ; for ( int i = 1 ; i < nums . size (); ++ i ) if ( nums [ i ] > nums [ i - 1 ]) increasing = decreasing + 1 ; else if ( nums [ i ] < nums [ i - 1 ]) decreasing = increasing + 1 ; return max ( increasing , decreasing ); } }; 377. Combination Sum IV $\\star\\star$ Time: $O(nk)$, where n = len(coins) and k = target Space: $O(k)$ class Solution { public : int combinationSum4 ( vector < int >& nums , int target ) { vector < unsigned long long > dp ( target + 1 ); dp [ 0 ] = 1 ; for ( int i = 1 ; i <= target ; ++ i ) for ( const int num : nums ) if ( i >= num ) dp [ i ] += dp [ i - num ]; return dp [ target ]; } }; 378. Kth Smallest Element in a Sorted Matrix $\\star\\star$ class Solution { public : int kthSmallest ( vector < vector < int >>& matrix , int k ) { auto compare = [ & ]( const pair < int , int >& a , const pair < int , int >& b ) { return matrix [ a . first ][ a . second ] > matrix [ b . first ][ b . second ]; }; priority_queue < pair < int , int > , vector < pair < int , int >> , decltype ( compare ) > pq ( compare ); for ( int i = 0 ; i < matrix . size () && i < k ; ++ i ) pq . push ({ i , 0 }); while ( k -- > 1 ) { const auto [ i , j ] = pq . top (); pq . pop (); if ( j + 1 < matrix . size ()) pq . push ({ i , j + 1 }); } return matrix [ pq . top (). first ][ pq . top (). second ]; } }; 379. Design Phone Directory $\\star\\star$ \ud83d\udd12 380. Insert Delete GetRandom O(1) $\\star\\star$ class RandomizedSet { public : bool insert ( int val ) { if ( map . count ( val )) return false ; map [ val ] = vals . size (); vals . push_back ( val ); return true ; } bool remove ( int val ) { if ( ! map . count ( val )) return false ; int index = map [ val ]; map [ vals . back ()] = index ; map . erase ( val ); swap ( vals [ index ], vals . back ()); vals . pop_back (); return true ; } int getRandom () { int index = rand () % vals . size (); return vals [ index ]; } private : vector < int > vals ; unordered_map < int , int > map ; };","title":"0371-0380"},{"location":"cpp/0301-0400/0371-0380/#371-sum-of-two-integers-star","text":"Time: $O(32)$ Space: $O(1)$ class Solution { public : int getSum ( unsigned a , unsigned b ) { while ( b != 0 ) { const unsigned sum = a ^ b ; b = ( a & b ) << 1 ; a = sum ; } return a ; } };","title":"371. Sum of Two Integers $\\star$"},{"location":"cpp/0301-0400/0371-0380/#372-super-pow-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : int superPow ( int a , vector < int >& b ) { const int k = 1337 ; int ans = 1 ; auto powMod = [ & ]( int x , int y ) { // x^y % k int pow = 1 ; while ( y -- ) pow = ( pow * x ) % k ; return pow ; }; a %= k ; for ( const int i : b ) ans = powMod ( ans , 10 ) * powMod ( a , i ) % k ; return ans ; } };","title":"372. Super Pow $\\star\\star$"},{"location":"cpp/0301-0400/0371-0380/#373-find-k-pairs-with-smallest-sums-starstar","text":"Time: $O(k\\log k)$ Space: $O(k)$ class Solution { public : vector < vector < int >> kSmallestPairs ( vector < int >& nums1 , vector < int >& nums2 , int k ) { if ( nums2 . empty ()) return {}; vector < vector < int >> ans ; auto compare = [ & ]( const pair < int , int >& a , const pair < int , int >& b ) { return nums1 [ a . first ] + nums2 [ a . second ] > nums1 [ b . first ] + nums2 [ b . second ]; }; priority_queue < pair < int , int > , vector < pair < int , int >> , decltype ( compare ) > pq ( compare ); for ( int i = 0 ; i < nums1 . size () && i < k ; ++ i ) pq . push ({ i , 0 }); while ( ! pq . empty () && ans . size () < k ) { const auto [ index1 , index2 ] = pq . top (); pq . pop (); ans . push_back ({ nums1 [ index1 ], nums2 [ index2 ]}); if ( index2 + 1 < nums2 . size ()) pq . push ({ index1 , index2 + 1 }); } return ans ; } };","title":"373. Find K Pairs with Smallest Sums $\\star\\star$"},{"location":"cpp/0301-0400/0371-0380/#374-guess-number-higher-or-lower-star","text":"Time: $O(\\log n)$ Space: $O(1)$ class Solution { public : int guessNumber ( int n ) { int l = 1 ; int r = n ; while ( l < r ) { const int m = l + ( r - l ) / 2 ; if ( guess ( m ) <= 0 ) r = m ; else l = m + 1 ; } return l ; } };","title":"374. Guess Number Higher or Lower $\\star$"},{"location":"cpp/0301-0400/0371-0380/#375-guess-number-higher-or-lower-ii-starstar","text":"Time: $O(n^3)$ Space: $O(n^2)$ class Solution { public : int getMoneyAmount ( int n ) { vector < vector < int >> dp ( n + 2 , vector < int > ( n + 2 )); for ( int length = 2 ; length <= n ; ++ length ) for ( int i = 1 ; i + length - 1 <= n ; ++ i ) { const int j = i + length - 1 ; dp [ i ][ j ] = INT_MAX ; for ( int k = i ; k <= j ; ++ k ) dp [ i ][ j ] = min ( dp [ i ][ j ], max ( dp [ i ][ k - 1 ], dp [ k + 1 ][ j ]) + k ); } return dp [ 1 ][ n ]; } };","title":"375. Guess Number Higher or Lower II $\\star\\star$"},{"location":"cpp/0301-0400/0371-0380/#376-wiggle-subsequence-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : int wiggleMaxLength ( vector < int >& nums ) { if ( nums . empty ()) return 0 ; int increasing = 1 ; int decreasing = 1 ; for ( int i = 1 ; i < nums . size (); ++ i ) if ( nums [ i ] > nums [ i - 1 ]) increasing = decreasing + 1 ; else if ( nums [ i ] < nums [ i - 1 ]) decreasing = increasing + 1 ; return max ( increasing , decreasing ); } };","title":"376. Wiggle Subsequence $\\star\\star$"},{"location":"cpp/0301-0400/0371-0380/#377-combination-sum-iv-starstar","text":"Time: $O(nk)$, where n = len(coins) and k = target Space: $O(k)$ class Solution { public : int combinationSum4 ( vector < int >& nums , int target ) { vector < unsigned long long > dp ( target + 1 ); dp [ 0 ] = 1 ; for ( int i = 1 ; i <= target ; ++ i ) for ( const int num : nums ) if ( i >= num ) dp [ i ] += dp [ i - num ]; return dp [ target ]; } };","title":"377. Combination Sum IV $\\star\\star$"},{"location":"cpp/0301-0400/0371-0380/#378-kth-smallest-element-in-a-sorted-matrix-starstar","text":"class Solution { public : int kthSmallest ( vector < vector < int >>& matrix , int k ) { auto compare = [ & ]( const pair < int , int >& a , const pair < int , int >& b ) { return matrix [ a . first ][ a . second ] > matrix [ b . first ][ b . second ]; }; priority_queue < pair < int , int > , vector < pair < int , int >> , decltype ( compare ) > pq ( compare ); for ( int i = 0 ; i < matrix . size () && i < k ; ++ i ) pq . push ({ i , 0 }); while ( k -- > 1 ) { const auto [ i , j ] = pq . top (); pq . pop (); if ( j + 1 < matrix . size ()) pq . push ({ i , j + 1 }); } return matrix [ pq . top (). first ][ pq . top (). second ]; } };","title":"378. Kth Smallest Element in a Sorted Matrix $\\star\\star$"},{"location":"cpp/0301-0400/0371-0380/#379-design-phone-directory-starstar","text":"","title":"379. Design Phone Directory $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0301-0400/0371-0380/#380-insert-delete-getrandom-o1-starstar","text":"class RandomizedSet { public : bool insert ( int val ) { if ( map . count ( val )) return false ; map [ val ] = vals . size (); vals . push_back ( val ); return true ; } bool remove ( int val ) { if ( ! map . count ( val )) return false ; int index = map [ val ]; map [ vals . back ()] = index ; map . erase ( val ); swap ( vals [ index ], vals . back ()); vals . pop_back (); return true ; } int getRandom () { int index = rand () % vals . size (); return vals [ index ]; } private : vector < int > vals ; unordered_map < int , int > map ; };","title":"380. Insert Delete GetRandom O(1) $\\star\\star$"},{"location":"cpp/0301-0400/0381-0390/","text":"381. Insert Delete GetRandom O(1) - Duplicates allowed $\\star\\star\\star$ class RandomizedCollection { public : bool insert ( int val ) { map [ val ]. push_back ( vals . size ()); vals . emplace_back ( val , map [ val ]. size () - 1 ); return map [ val ]. size () == 1 ; } bool remove ( int val ) { if ( ! map . count ( val ) || map [ val ]. empty ()) return false ; int index = map [ val ]. back (); map [ vals . back (). first ][ vals . back (). second ] = index ; map [ val ]. pop_back (); swap ( vals [ index ], vals . back ()); vals . pop_back (); return true ; } int getRandom () { int index = rand () % vals . size (); return vals [ index ]. first ; } private : vector < pair < int , int >> vals ; unordered_map < int , vector < int >> map ; }; 382. Linked List Random Node $\\star\\star$ class Solution { public : Solution ( ListNode * head ) { privateHead = head ; for ( ListNode * curr = head ; curr ; curr = curr -> next ) ++ length ; } int getRandom () { int n = rand () % length ; ListNode * curr = privateHead ; while ( n -- > 0 ) curr = curr -> next ; return curr -> val ; } private : ListNode * privateHead ; int length = 0 ; }; 383. Ransom Note $\\star$ Time: $O(n + m)$, where n = ransomNote and m = magazine Space: $O(26)$ class Solution { public : bool canConstruct ( string ransomNote , string magazine ) { vector < int > count ( 26 ); for ( const char c : magazine ) ++ count [ c - 'a' ]; for ( const char c : ransomNote ) if ( -- count [ c - 'a' ] < 0 ) return false ; return true ; } }; 384. Shuffle an Array $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : Solution ( vector < int >& nums ) : nums ( move ( nums )) { srand ( time ( nullptr )); } vector < int > reset () { return nums ; } vector < int > shuffle () { vector < int > A ( nums ); for ( int i = A . size () - 1 ; i >= 0 ; -- i ) { int j = rand () % ( i + 1 ); swap ( A [ i ], A [ j ]); } return A ; } private : vector < int > nums ; }; 385. Mini Parser $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : NestedInteger deserialize ( string s ) { if ( s [ 0 ] != '[' ) return NestedInteger ( stoi ( s )); stack < NestedInteger > stack ; int start ; // the start index of num for ( int i = 0 ; i < s . length (); ++ i ) { switch ( s [ i ]) { case '[' : stack . push ( NestedInteger ()); start = i + 1 ; break ; case ',' : if ( i > start ) { int num = stoi ( s . substr ( start , i )); stack . top (). add ( NestedInteger ( num )); } start = i + 1 ; break ; case ']' : NestedInteger popped = stack . top (); stack . pop (); if ( i > start ) { int num = stoi ( s . substr ( start , i )); popped . add ( NestedInteger ( num )); } if ( stack . empty ()) return popped ; else stack . top (). add ( popped ); start = i + 1 ; break ; } } throw ; } }; 386. Lexicographical Numbers $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : vector < int > lexicalOrder ( int n ) { vector < int > ans ; int curr = 1 ; while ( ans . size () < n ) { ans . push_back ( curr ); if ( curr * 10 <= n ) curr *= 10 ; else { while ( curr % 10 == 9 || curr == n ) curr /= 10 ; ++ curr ; } } return ans ; } }; 387. First Unique Character in a String $\\star$ Time: $O(n)$ Space: $O(26)$ class Solution { public : int firstUniqChar ( string s ) { vector < int > count ( 26 ); for ( const char c : s ) ++ count [ c - 'a' ]; for ( int i = 0 ; i < s . length (); ++ i ) if ( count [ s [ i ] - 'a' ] == 1 ) return i ; return - 1 ; } }; 388. Longest Absolute File Path $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : int lengthLongestPath ( string input ) { size_t ans = 0 ; stack < pair < int , size_t >> stack {{{ - 1 , 0 }}}; // {depth, currentLength} stringstream ss ( input ); for ( string token ; getline ( ss , token , '\\n' );) { int depth = count_if ( begin ( token ), end ( token ), []( char c ) { return c == '\\t' ; }); token . erase ( remove ( begin ( token ), end ( token ), '\\t' ), end ( token )); while ( depth <= stack . top (). first ) stack . pop (); if ( token . find ( '.' ) != string :: npos ) // file ans = max ( ans , stack . top (). second + token . length ()); else // directory + '/' stack . push ({ depth , stack . top (). second + token . length () + 1 }); } return ans ; } }; 389. Find the Difference $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : char findTheDifference ( string s , string t ) { char ans = 0 ; for ( const char c : s ) ans ^= c ; for ( const char c : t ) ans ^= c ; return ans ; } }; 390. Elimination Game $\\star\\star$ Time: $O(\\log n)$ Space: $O(\\log n)$ class Solution { public : int lastRemaining ( int n ) { return n == 1 ? 1 : 2 * ( 1 + n / 2 - lastRemaining ( n / 2 )); } };","title":"0381-0390"},{"location":"cpp/0301-0400/0381-0390/#381-insert-delete-getrandom-o1-duplicates-allowed-starstarstar","text":"class RandomizedCollection { public : bool insert ( int val ) { map [ val ]. push_back ( vals . size ()); vals . emplace_back ( val , map [ val ]. size () - 1 ); return map [ val ]. size () == 1 ; } bool remove ( int val ) { if ( ! map . count ( val ) || map [ val ]. empty ()) return false ; int index = map [ val ]. back (); map [ vals . back (). first ][ vals . back (). second ] = index ; map [ val ]. pop_back (); swap ( vals [ index ], vals . back ()); vals . pop_back (); return true ; } int getRandom () { int index = rand () % vals . size (); return vals [ index ]. first ; } private : vector < pair < int , int >> vals ; unordered_map < int , vector < int >> map ; };","title":"381. Insert Delete GetRandom O(1) - Duplicates allowed $\\star\\star\\star$"},{"location":"cpp/0301-0400/0381-0390/#382-linked-list-random-node-starstar","text":"class Solution { public : Solution ( ListNode * head ) { privateHead = head ; for ( ListNode * curr = head ; curr ; curr = curr -> next ) ++ length ; } int getRandom () { int n = rand () % length ; ListNode * curr = privateHead ; while ( n -- > 0 ) curr = curr -> next ; return curr -> val ; } private : ListNode * privateHead ; int length = 0 ; };","title":"382. Linked List Random Node $\\star\\star$"},{"location":"cpp/0301-0400/0381-0390/#383-ransom-note-star","text":"Time: $O(n + m)$, where n = ransomNote and m = magazine Space: $O(26)$ class Solution { public : bool canConstruct ( string ransomNote , string magazine ) { vector < int > count ( 26 ); for ( const char c : magazine ) ++ count [ c - 'a' ]; for ( const char c : ransomNote ) if ( -- count [ c - 'a' ] < 0 ) return false ; return true ; } };","title":"383. Ransom Note $\\star$"},{"location":"cpp/0301-0400/0381-0390/#384-shuffle-an-array-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : Solution ( vector < int >& nums ) : nums ( move ( nums )) { srand ( time ( nullptr )); } vector < int > reset () { return nums ; } vector < int > shuffle () { vector < int > A ( nums ); for ( int i = A . size () - 1 ; i >= 0 ; -- i ) { int j = rand () % ( i + 1 ); swap ( A [ i ], A [ j ]); } return A ; } private : vector < int > nums ; };","title":"384. Shuffle an Array $\\star\\star$"},{"location":"cpp/0301-0400/0381-0390/#385-mini-parser-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : NestedInteger deserialize ( string s ) { if ( s [ 0 ] != '[' ) return NestedInteger ( stoi ( s )); stack < NestedInteger > stack ; int start ; // the start index of num for ( int i = 0 ; i < s . length (); ++ i ) { switch ( s [ i ]) { case '[' : stack . push ( NestedInteger ()); start = i + 1 ; break ; case ',' : if ( i > start ) { int num = stoi ( s . substr ( start , i )); stack . top (). add ( NestedInteger ( num )); } start = i + 1 ; break ; case ']' : NestedInteger popped = stack . top (); stack . pop (); if ( i > start ) { int num = stoi ( s . substr ( start , i )); popped . add ( NestedInteger ( num )); } if ( stack . empty ()) return popped ; else stack . top (). add ( popped ); start = i + 1 ; break ; } } throw ; } };","title":"385. Mini Parser $\\star\\star$"},{"location":"cpp/0301-0400/0381-0390/#386-lexicographical-numbers-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : vector < int > lexicalOrder ( int n ) { vector < int > ans ; int curr = 1 ; while ( ans . size () < n ) { ans . push_back ( curr ); if ( curr * 10 <= n ) curr *= 10 ; else { while ( curr % 10 == 9 || curr == n ) curr /= 10 ; ++ curr ; } } return ans ; } };","title":"386. Lexicographical Numbers $\\star\\star$"},{"location":"cpp/0301-0400/0381-0390/#387-first-unique-character-in-a-string-star","text":"Time: $O(n)$ Space: $O(26)$ class Solution { public : int firstUniqChar ( string s ) { vector < int > count ( 26 ); for ( const char c : s ) ++ count [ c - 'a' ]; for ( int i = 0 ; i < s . length (); ++ i ) if ( count [ s [ i ] - 'a' ] == 1 ) return i ; return - 1 ; } };","title":"387. First Unique Character in a String $\\star$"},{"location":"cpp/0301-0400/0381-0390/#388-longest-absolute-file-path-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : int lengthLongestPath ( string input ) { size_t ans = 0 ; stack < pair < int , size_t >> stack {{{ - 1 , 0 }}}; // {depth, currentLength} stringstream ss ( input ); for ( string token ; getline ( ss , token , '\\n' );) { int depth = count_if ( begin ( token ), end ( token ), []( char c ) { return c == '\\t' ; }); token . erase ( remove ( begin ( token ), end ( token ), '\\t' ), end ( token )); while ( depth <= stack . top (). first ) stack . pop (); if ( token . find ( '.' ) != string :: npos ) // file ans = max ( ans , stack . top (). second + token . length ()); else // directory + '/' stack . push ({ depth , stack . top (). second + token . length () + 1 }); } return ans ; } };","title":"388. Longest Absolute File Path $\\star\\star$"},{"location":"cpp/0301-0400/0381-0390/#389-find-the-difference-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : char findTheDifference ( string s , string t ) { char ans = 0 ; for ( const char c : s ) ans ^= c ; for ( const char c : t ) ans ^= c ; return ans ; } };","title":"389. Find the Difference $\\star$"},{"location":"cpp/0301-0400/0381-0390/#390-elimination-game-starstar","text":"Time: $O(\\log n)$ Space: $O(\\log n)$ class Solution { public : int lastRemaining ( int n ) { return n == 1 ? 1 : 2 * ( 1 + n / 2 - lastRemaining ( n / 2 )); } };","title":"390. Elimination Game $\\star\\star$"},{"location":"cpp/0301-0400/0391-0400/","text":"391. Perfect Rectangle $\\star\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : bool isRectangleCover ( vector < vector < int >>& rectangles ) { int area = 0 ; int x1 = INT_MAX ; int y1 = INT_MAX ; int x2 = INT_MIN ; int y2 = INT_MIN ; unordered_set < string > corners ; for ( const vector < int >& r : rectangles ) { area += ( r [ 2 ] - r [ 0 ]) * ( r [ 3 ] - r [ 1 ]); x1 = min ( x1 , r [ 0 ]); y1 = min ( y1 , r [ 1 ]); x2 = max ( x2 , r [ 2 ]); y2 = max ( y2 , r [ 3 ]); // four points of current rectangle const vector < string > points { to_string ( r [ 0 ]) + \" \" + to_string ( r [ 1 ]), to_string ( r [ 0 ]) + \" \" + to_string ( r [ 3 ]), to_string ( r [ 2 ]) + \" \" + to_string ( r [ 1 ]), to_string ( r [ 2 ]) + \" \" + to_string ( r [ 3 ])}; for ( const string & point : points ) if ( ! corners . insert ( point ). second ) corners . erase ( point ); } if ( corners . size () != 4 ) return false ; if ( ! corners . count ( to_string ( x1 ) + \" \" + to_string ( y1 )) || ! corners . count ( to_string ( x1 ) + \" \" + to_string ( y2 )) || ! corners . count ( to_string ( x2 ) + \" \" + to_string ( y1 )) || ! corners . count ( to_string ( x2 ) + \" \" + to_string ( y2 ))) return false ; return area == ( x2 - x1 ) * ( y2 - y1 ); } }; 392. Is Subsequence $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : bool isSubsequence ( string s , string t ) { int i = 0 ; for ( int j = 0 ; i < s . length () && j < t . length (); ++ j ) if ( s [ i ] == t [ j ]) ++ i ; return i == s . length (); } }; 393. UTF-8 Validation $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : bool validUtf8 ( vector < int >& data ) { int leftToCheck = 0 ; for ( const int d : data ) if ( leftToCheck == 0 ) { if (( d >> 3 ) == 0 b11110 ) leftToCheck = 3 ; else if (( d >> 4 ) == 0 b1110 ) leftToCheck = 2 ; else if (( d >> 5 ) == 0 b110 ) leftToCheck = 1 ; else if (( d >> 7 ) == 0 b0 ) leftToCheck = 0 ; else return false ; } else { if (( d >> 6 ) != 0 b10 ) return false ; -- leftToCheck ; } return leftToCheck == 0 ; } }; 394. Decode String $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : string decodeString ( string s ) { stack < string > stack ; string currStr ; int currNum = 0 ; for ( const char c : s ) if ( isdigit ( c )) { currNum = currNum * 10 + c - '0' ; } else if ( c == '[' ) { stack . push ( currStr ); stack . push ( to_string ( currNum )); currStr = \"\" ; currNum = 0 ; } else if ( c == ']' ) { int repeatedTime = stoi ( stack . top ()); stack . pop (); string repeatedStr ; while ( repeatedTime -- ) repeatedStr += currStr ; string prevStr = stack . top (); stack . pop (); currStr = prevStr + repeatedStr ; } else { currStr += c ; } return currStr ; } }; 395. Longest Substring with At Least K Repeating Characters $\\star\\star$ Time: $O(n)$ Space: $O(26)$ class Solution { public : int longestSubstring ( string s , int k ) { int ans = 0 ; for ( int i = 1 ; i <= 26 ; ++ i ) ans = max ( ans , longestSubstringWithNUniqueCharacters ( s , k , i )); return ans ; } private : int longestSubstringWithNUniqueCharacters ( const string & s , int k , int n ) { int ans = 0 ; int uniqueNums = 0 ; int noLessThanK = 0 ; vector < int > count ( 26 ); for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { if ( count [ s [ r ] - 'a' ] == 0 ) ++ uniqueNums ; if ( ++ count [ s [ r ] - 'a' ] == k ) ++ noLessThanK ; while ( uniqueNums > n ) { if ( count [ s [ l ] - 'a' ] == k ) -- noLessThanK ; if ( -- count [ s [ l ++ ] - 'a' ] == 0 ) -- uniqueNums ; } if ( noLessThanK == n ) ans = max ( ans , r - l + 1 ); } return ans ; } }; 396. Rotate Function $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : int maxRotateFunction ( vector < int >& A ) { const int sum = accumulate ( begin ( A ), end ( A ), ( long ) 0 ); int f = 0 ; for ( int i = 0 ; i < A . size (); ++ i ) f += i * A [ i ]; // calculate F(0) first int ans = f ; for ( int i = A . size () - 1 ; i > 0 ; -- i ) { f += sum - A . size () * A [ i ]; ans = max ( ans , f ); } return ans ; } }; 397. Integer Replacement $\\star\\star$ Time: $O(\\log n)$ Space: $O(1)$ class Solution { public : int integerReplacement ( long n ) { int ans = 0 ; for (; n > 1 ; ++ ans ) if (( n & 1 ) == 0 ) // ends w/ 0 n >>= 1 ; else if ( n == 3 || (( n >> 1 ) & 1 ) == 0 ) // n = 3 or ends w/ 01 -- n ; else // ends w/ 11 ++ n ; return ans ; } }; 398. Random Pick Index $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : Solution ( vector < int >& nums ) : nums ( move ( nums )) { srand ( time ( nullptr )); } int pick ( int target ) { int res = - 1 ; int range = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) if ( nums [ i ] == target && rand () % ++ range == 0 ) res = i ; return res ; } private : vector < int > nums ; }; 399. Evaluate Division $\\star\\star$ 400. Nth Digit $\\star\\star$ class Solution { public : int findNthDigit ( int n ) { int digitSize = 1 ; int startNum = 1 ; for ( long count = 9 ; digitSize * count < n ; count *= 10 ) { n -= digitSize * count ; ++ digitSize ; startNum *= 10 ; } int targetNum = startNum + ( n - 1 ) / digitSize ; int pos = n % digitSize ; return getDigit ( targetNum , pos , digitSize ); } private : int getDigit ( int num , int pos , int digitSize ) { if ( pos == 0 ) return num % 10 ; for ( int i = 0 ; i < digitSize - pos ; ++ i ) num /= 10 ; return num % 10 ; } };","title":"0391-0300"},{"location":"cpp/0301-0400/0391-0400/#391-perfect-rectangle-starstarstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : bool isRectangleCover ( vector < vector < int >>& rectangles ) { int area = 0 ; int x1 = INT_MAX ; int y1 = INT_MAX ; int x2 = INT_MIN ; int y2 = INT_MIN ; unordered_set < string > corners ; for ( const vector < int >& r : rectangles ) { area += ( r [ 2 ] - r [ 0 ]) * ( r [ 3 ] - r [ 1 ]); x1 = min ( x1 , r [ 0 ]); y1 = min ( y1 , r [ 1 ]); x2 = max ( x2 , r [ 2 ]); y2 = max ( y2 , r [ 3 ]); // four points of current rectangle const vector < string > points { to_string ( r [ 0 ]) + \" \" + to_string ( r [ 1 ]), to_string ( r [ 0 ]) + \" \" + to_string ( r [ 3 ]), to_string ( r [ 2 ]) + \" \" + to_string ( r [ 1 ]), to_string ( r [ 2 ]) + \" \" + to_string ( r [ 3 ])}; for ( const string & point : points ) if ( ! corners . insert ( point ). second ) corners . erase ( point ); } if ( corners . size () != 4 ) return false ; if ( ! corners . count ( to_string ( x1 ) + \" \" + to_string ( y1 )) || ! corners . count ( to_string ( x1 ) + \" \" + to_string ( y2 )) || ! corners . count ( to_string ( x2 ) + \" \" + to_string ( y1 )) || ! corners . count ( to_string ( x2 ) + \" \" + to_string ( y2 ))) return false ; return area == ( x2 - x1 ) * ( y2 - y1 ); } };","title":"391. Perfect Rectangle $\\star\\star\\star$"},{"location":"cpp/0301-0400/0391-0400/#392-is-subsequence-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : bool isSubsequence ( string s , string t ) { int i = 0 ; for ( int j = 0 ; i < s . length () && j < t . length (); ++ j ) if ( s [ i ] == t [ j ]) ++ i ; return i == s . length (); } };","title":"392. Is Subsequence $\\star$"},{"location":"cpp/0301-0400/0391-0400/#393-utf-8-validation-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : bool validUtf8 ( vector < int >& data ) { int leftToCheck = 0 ; for ( const int d : data ) if ( leftToCheck == 0 ) { if (( d >> 3 ) == 0 b11110 ) leftToCheck = 3 ; else if (( d >> 4 ) == 0 b1110 ) leftToCheck = 2 ; else if (( d >> 5 ) == 0 b110 ) leftToCheck = 1 ; else if (( d >> 7 ) == 0 b0 ) leftToCheck = 0 ; else return false ; } else { if (( d >> 6 ) != 0 b10 ) return false ; -- leftToCheck ; } return leftToCheck == 0 ; } };","title":"393. UTF-8 Validation $\\star\\star$"},{"location":"cpp/0301-0400/0391-0400/#394-decode-string-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : string decodeString ( string s ) { stack < string > stack ; string currStr ; int currNum = 0 ; for ( const char c : s ) if ( isdigit ( c )) { currNum = currNum * 10 + c - '0' ; } else if ( c == '[' ) { stack . push ( currStr ); stack . push ( to_string ( currNum )); currStr = \"\" ; currNum = 0 ; } else if ( c == ']' ) { int repeatedTime = stoi ( stack . top ()); stack . pop (); string repeatedStr ; while ( repeatedTime -- ) repeatedStr += currStr ; string prevStr = stack . top (); stack . pop (); currStr = prevStr + repeatedStr ; } else { currStr += c ; } return currStr ; } };","title":"394. Decode String $\\star\\star$"},{"location":"cpp/0301-0400/0391-0400/#395-longest-substring-with-at-least-k-repeating-characters-starstar","text":"Time: $O(n)$ Space: $O(26)$ class Solution { public : int longestSubstring ( string s , int k ) { int ans = 0 ; for ( int i = 1 ; i <= 26 ; ++ i ) ans = max ( ans , longestSubstringWithNUniqueCharacters ( s , k , i )); return ans ; } private : int longestSubstringWithNUniqueCharacters ( const string & s , int k , int n ) { int ans = 0 ; int uniqueNums = 0 ; int noLessThanK = 0 ; vector < int > count ( 26 ); for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { if ( count [ s [ r ] - 'a' ] == 0 ) ++ uniqueNums ; if ( ++ count [ s [ r ] - 'a' ] == k ) ++ noLessThanK ; while ( uniqueNums > n ) { if ( count [ s [ l ] - 'a' ] == k ) -- noLessThanK ; if ( -- count [ s [ l ++ ] - 'a' ] == 0 ) -- uniqueNums ; } if ( noLessThanK == n ) ans = max ( ans , r - l + 1 ); } return ans ; } };","title":"395. Longest Substring with At Least K Repeating Characters $\\star\\star$"},{"location":"cpp/0301-0400/0391-0400/#396-rotate-function-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : int maxRotateFunction ( vector < int >& A ) { const int sum = accumulate ( begin ( A ), end ( A ), ( long ) 0 ); int f = 0 ; for ( int i = 0 ; i < A . size (); ++ i ) f += i * A [ i ]; // calculate F(0) first int ans = f ; for ( int i = A . size () - 1 ; i > 0 ; -- i ) { f += sum - A . size () * A [ i ]; ans = max ( ans , f ); } return ans ; } };","title":"396. Rotate Function $\\star\\star$"},{"location":"cpp/0301-0400/0391-0400/#397-integer-replacement-starstar","text":"Time: $O(\\log n)$ Space: $O(1)$ class Solution { public : int integerReplacement ( long n ) { int ans = 0 ; for (; n > 1 ; ++ ans ) if (( n & 1 ) == 0 ) // ends w/ 0 n >>= 1 ; else if ( n == 3 || (( n >> 1 ) & 1 ) == 0 ) // n = 3 or ends w/ 01 -- n ; else // ends w/ 11 ++ n ; return ans ; } };","title":"397. Integer Replacement $\\star\\star$"},{"location":"cpp/0301-0400/0391-0400/#398-random-pick-index-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : Solution ( vector < int >& nums ) : nums ( move ( nums )) { srand ( time ( nullptr )); } int pick ( int target ) { int res = - 1 ; int range = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) if ( nums [ i ] == target && rand () % ++ range == 0 ) res = i ; return res ; } private : vector < int > nums ; };","title":"398. Random Pick Index $\\star\\star$"},{"location":"cpp/0301-0400/0391-0400/#399-evaluate-division-starstar","text":"","title":"399. Evaluate Division $\\star\\star$"},{"location":"cpp/0301-0400/0391-0400/#400-nth-digit-starstar","text":"class Solution { public : int findNthDigit ( int n ) { int digitSize = 1 ; int startNum = 1 ; for ( long count = 9 ; digitSize * count < n ; count *= 10 ) { n -= digitSize * count ; ++ digitSize ; startNum *= 10 ; } int targetNum = startNum + ( n - 1 ) / digitSize ; int pos = n % digitSize ; return getDigit ( targetNum , pos , digitSize ); } private : int getDigit ( int num , int pos , int digitSize ) { if ( pos == 0 ) return num % 10 ; for ( int i = 0 ; i < digitSize - pos ; ++ i ) num /= 10 ; return num % 10 ; } };","title":"400. Nth Digit $\\star\\star$"},{"location":"cpp/0401-0500/0401-0410/","text":"401. Binary Watch $\\star$ 402. Remove K Digits $\\star\\star$ 403. Frog Jump $\\star\\star\\star$ 404. Sum of Left Leaves $\\star$ 405. Convert a Number to Hexadecimal $\\star$ 406. Queue Reconstruction by Height $\\star\\star$ 407. Trapping Rain Water II $\\star\\star\\star$ 408. Valid Word Abbreviation $\\star$ \ud83d\udd12 409. Longest Palindrome $\\star$ class Solution { public : int longestPalindrome ( string s ) { int ans = 0 ; vector < int > count ( 128 ); for ( char c : s ) ++ count [ c ]; for ( int c : count ) ans += c % 2 == 0 ? c : c - 1 ; bool hasOddCount = any_of ( begin ( count ), end ( count ), []( int c ) { return c & 1 ; }); return ans + hasOddCount ; } }; 410. Split Array Largest Sum $\\star\\star\\star$","title":"0401-0410"},{"location":"cpp/0401-0500/0401-0410/#401-binary-watch-star","text":"","title":"401. Binary Watch $\\star$"},{"location":"cpp/0401-0500/0401-0410/#402-remove-k-digits-starstar","text":"","title":"402. Remove K Digits $\\star\\star$"},{"location":"cpp/0401-0500/0401-0410/#403-frog-jump-starstarstar","text":"","title":"403. Frog Jump $\\star\\star\\star$"},{"location":"cpp/0401-0500/0401-0410/#404-sum-of-left-leaves-star","text":"","title":"404. Sum of Left Leaves $\\star$"},{"location":"cpp/0401-0500/0401-0410/#405-convert-a-number-to-hexadecimal-star","text":"","title":"405. Convert a Number to Hexadecimal $\\star$"},{"location":"cpp/0401-0500/0401-0410/#406-queue-reconstruction-by-height-starstar","text":"","title":"406. Queue Reconstruction by Height $\\star\\star$"},{"location":"cpp/0401-0500/0401-0410/#407-trapping-rain-water-ii-starstarstar","text":"","title":"407. Trapping Rain Water II $\\star\\star\\star$"},{"location":"cpp/0401-0500/0401-0410/#408-valid-word-abbreviation-star","text":"","title":"408. Valid Word Abbreviation $\\star$ \ud83d\udd12"},{"location":"cpp/0401-0500/0401-0410/#409-longest-palindrome-star","text":"class Solution { public : int longestPalindrome ( string s ) { int ans = 0 ; vector < int > count ( 128 ); for ( char c : s ) ++ count [ c ]; for ( int c : count ) ans += c % 2 == 0 ? c : c - 1 ; bool hasOddCount = any_of ( begin ( count ), end ( count ), []( int c ) { return c & 1 ; }); return ans + hasOddCount ; } };","title":"409. Longest Palindrome $\\star$"},{"location":"cpp/0401-0500/0401-0410/#410-split-array-largest-sum-starstarstar","text":"","title":"410. Split Array Largest Sum $\\star\\star\\star$"},{"location":"cpp/0401-0500/0411-0420/","text":"411. Minimum Unique Word Abbreviation $\\star\\star\\star$ \ud83d\udd12 412. Fizz Buzz $\\star$ 413. Arithmetic Slices $\\star\\star$ class Solution { public : int numberOfArithmeticSlices ( vector < int >& A ) { int ans = 0 ; int dp = 0 ; for ( int i = 2 ; i < A . size (); ++ i ) { if ( A [ i ] - A [ i - 1 ] == A [ i - 1 ] - A [ i - 2 ]) ans += ++ dp ; else dp = 0 ; } return ans ; } }; 414. Third Maximum Number $\\star$ class Solution { public : int thirdMax ( vector < int >& nums ) { priority_queue < int , vector < int > , greater <>> pq ; unordered_set < int > seen ; for ( int num : nums ) if ( ! seen . count ( num )) { seen . insert ( num ); pq . push ( num ); if ( pq . size () > 3 ) pq . pop (); } if ( pq . size () == 2 ) pq . pop (); return pq . top (); } }; 415. Add Strings $\\star$ class Solution { public : string addStrings ( string num1 , string num2 ) { string ans ; int carry = 0 ; int i = num1 . length () - 1 ; int j = num2 . length () - 1 ; while ( i >= 0 || j >= 0 || carry ) { if ( i >= 0 ) carry += num1 [ i ] - '0' ; if ( j >= 0 ) carry += num2 [ j ] - '0' ; ans += to_string ( carry % 10 ); carry /= 10 ; -- i ; -- j ; } reverse ( begin ( ans ), end ( ans )); return ans ; } }; 416. Partition Equal Subset Sum $\\star\\star$ class Solution { public : bool canPartition ( vector < int >& nums ) { const int sum = accumulate ( begin ( nums ), end ( nums ), 0 ); if ( sum & 1 ) return false ; vector < bool > dp ( sum / 2 + 1 ); dp [ 0 ] = true ; for ( int num : nums ) for ( int w = sum / 2 ; w >= num ; -- w ) dp [ w ] = dp [ w ] || dp [ w - num ]; return dp [ sum / 2 ]; } }; 417. Pacific Atlantic Water Flow $\\star\\star$ class Solution { public : vector < vector < int >> pacificAtlantic ( vector < vector < int >>& matrix ) { if ( matrix . empty ()) return {}; const int m = matrix . size (); const int n = matrix [ 0 ]. size (); const vector < int > dirs { 0 , 1 , 0 , - 1 , 0 }; vector < vector < int >> ans ; queue < pair < int , int >> qP ; queue < pair < int , int >> qA ; vector < vector < bool >> seenP ( m , vector < bool > ( n )); vector < vector < bool >> seenA ( m , vector < bool > ( n )); auto bfs = [ & ]( queue < pair < int , int >>& q , vector < vector < bool >>& seen ) { while ( ! q . empty ()) { const auto [ i , j ] = q . front (); q . pop (); const int h = matrix [ i ][ j ]; seen [ i ][ j ] = true ; for ( int k = 0 ; k < 4 ; ++ k ) { int x = i + dirs [ k ]; int y = j + dirs [ k + 1 ]; if ( x < 0 || x >= m || y < 0 || y >= n || seen [ x ][ y ] || matrix [ x ][ y ] < h ) continue ; q . push ({ x , y }); } } }; for ( int i = 0 ; i < m ; ++ i ) { qP . push ({ i , 0 }); qA . push ({ i , n - 1 }); } for ( int j = 0 ; j < n ; ++ j ) { qP . push ({ 0 , j }); qA . push ({ m - 1 , j }); } bfs ( qP , seenP ); bfs ( qA , seenA ); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( seenP [ i ][ j ] && seenA [ i ][ j ]) ans . push_back ({ i , j }); return ans ; } }; 418. Sentence Screen Fitting $\\star\\star$ \ud83d\udd12 419. Battleships in a Board $\\star\\star$ 420. Strong Password Checker $\\star\\star\\star$","title":"0411-0420"},{"location":"cpp/0401-0500/0411-0420/#411-minimum-unique-word-abbreviation-starstarstar","text":"","title":"411. Minimum Unique Word Abbreviation $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/0401-0500/0411-0420/#412-fizz-buzz-star","text":"","title":"412. Fizz Buzz $\\star$"},{"location":"cpp/0401-0500/0411-0420/#413-arithmetic-slices-starstar","text":"class Solution { public : int numberOfArithmeticSlices ( vector < int >& A ) { int ans = 0 ; int dp = 0 ; for ( int i = 2 ; i < A . size (); ++ i ) { if ( A [ i ] - A [ i - 1 ] == A [ i - 1 ] - A [ i - 2 ]) ans += ++ dp ; else dp = 0 ; } return ans ; } };","title":"413. Arithmetic Slices $\\star\\star$"},{"location":"cpp/0401-0500/0411-0420/#414-third-maximum-number-star","text":"class Solution { public : int thirdMax ( vector < int >& nums ) { priority_queue < int , vector < int > , greater <>> pq ; unordered_set < int > seen ; for ( int num : nums ) if ( ! seen . count ( num )) { seen . insert ( num ); pq . push ( num ); if ( pq . size () > 3 ) pq . pop (); } if ( pq . size () == 2 ) pq . pop (); return pq . top (); } };","title":"414. Third Maximum Number $\\star$"},{"location":"cpp/0401-0500/0411-0420/#415-add-strings-star","text":"class Solution { public : string addStrings ( string num1 , string num2 ) { string ans ; int carry = 0 ; int i = num1 . length () - 1 ; int j = num2 . length () - 1 ; while ( i >= 0 || j >= 0 || carry ) { if ( i >= 0 ) carry += num1 [ i ] - '0' ; if ( j >= 0 ) carry += num2 [ j ] - '0' ; ans += to_string ( carry % 10 ); carry /= 10 ; -- i ; -- j ; } reverse ( begin ( ans ), end ( ans )); return ans ; } };","title":"415. Add Strings $\\star$"},{"location":"cpp/0401-0500/0411-0420/#416-partition-equal-subset-sum-starstar","text":"class Solution { public : bool canPartition ( vector < int >& nums ) { const int sum = accumulate ( begin ( nums ), end ( nums ), 0 ); if ( sum & 1 ) return false ; vector < bool > dp ( sum / 2 + 1 ); dp [ 0 ] = true ; for ( int num : nums ) for ( int w = sum / 2 ; w >= num ; -- w ) dp [ w ] = dp [ w ] || dp [ w - num ]; return dp [ sum / 2 ]; } };","title":"416. Partition Equal Subset Sum $\\star\\star$"},{"location":"cpp/0401-0500/0411-0420/#417-pacific-atlantic-water-flow-starstar","text":"class Solution { public : vector < vector < int >> pacificAtlantic ( vector < vector < int >>& matrix ) { if ( matrix . empty ()) return {}; const int m = matrix . size (); const int n = matrix [ 0 ]. size (); const vector < int > dirs { 0 , 1 , 0 , - 1 , 0 }; vector < vector < int >> ans ; queue < pair < int , int >> qP ; queue < pair < int , int >> qA ; vector < vector < bool >> seenP ( m , vector < bool > ( n )); vector < vector < bool >> seenA ( m , vector < bool > ( n )); auto bfs = [ & ]( queue < pair < int , int >>& q , vector < vector < bool >>& seen ) { while ( ! q . empty ()) { const auto [ i , j ] = q . front (); q . pop (); const int h = matrix [ i ][ j ]; seen [ i ][ j ] = true ; for ( int k = 0 ; k < 4 ; ++ k ) { int x = i + dirs [ k ]; int y = j + dirs [ k + 1 ]; if ( x < 0 || x >= m || y < 0 || y >= n || seen [ x ][ y ] || matrix [ x ][ y ] < h ) continue ; q . push ({ x , y }); } } }; for ( int i = 0 ; i < m ; ++ i ) { qP . push ({ i , 0 }); qA . push ({ i , n - 1 }); } for ( int j = 0 ; j < n ; ++ j ) { qP . push ({ 0 , j }); qA . push ({ m - 1 , j }); } bfs ( qP , seenP ); bfs ( qA , seenA ); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( seenP [ i ][ j ] && seenA [ i ][ j ]) ans . push_back ({ i , j }); return ans ; } };","title":"417. Pacific Atlantic Water Flow $\\star\\star$"},{"location":"cpp/0401-0500/0411-0420/#418-sentence-screen-fitting-starstar","text":"","title":"418. Sentence Screen Fitting $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0401-0500/0411-0420/#419-battleships-in-a-board-starstar","text":"","title":"419. Battleships in a Board $\\star\\star$"},{"location":"cpp/0401-0500/0411-0420/#420-strong-password-checker-starstarstar","text":"","title":"420. Strong Password Checker $\\star\\star\\star$"},{"location":"cpp/0401-0500/0421-0430/","text":"421. Maximum XOR of Two Numbers in an Array $\\star\\star$ 422. Valid Word Square $\\star$ \ud83d\udd12 423. Reconstruct Original Digits from English $\\star\\star$ class Solution { public : string originalDigits ( string s ) { string ans ; vector < int > count ( 10 ); for ( char c : s ) { if ( c == 'z' ) ++ count [ 0 ]; if ( c == 'o' ) ++ count [ 1 ]; if ( c == 'w' ) ++ count [ 2 ]; if ( c == 'h' ) ++ count [ 3 ]; if ( c == 'u' ) ++ count [ 4 ]; if ( c == 'f' ) ++ count [ 5 ]; if ( c == 'x' ) ++ count [ 6 ]; if ( c == 's' ) ++ count [ 7 ]; if ( c == 'g' ) ++ count [ 8 ]; if ( c == 'i' ) ++ count [ 9 ]; } count [ 1 ] -= count [ 0 ] + count [ 2 ] + count [ 4 ]; count [ 3 ] -= count [ 8 ]; count [ 5 ] -= count [ 4 ]; count [ 7 ] -= count [ 6 ]; count [ 9 ] -= count [ 5 ] + count [ 6 ] + count [ 8 ]; for ( int i = 0 ; i < 10 ; ++ i ) for ( int j = 0 ; j < count [ i ]; ++ j ) ans += i + '0' ; return ans ; } }; 424. Longest Repeating Character Replacement $\\star\\star$ class Solution { public : int characterReplacement ( string s , int k ) { int ans = 0 ; int maxFreq = 0 ; vector < int > count ( 26 ); for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { ++ count [ s [ r ] - 'A' ]; maxFreq = max ( maxFreq , count [ s [ r ] - 'A' ]); while ( maxFreq + k < r - l + 1 ) -- count [ s [ l ++ ] - 'A' ]; ans = max ( ans , r - l + 1 ); } return ans ; } }; 425. Word Squares $\\star\\star\\star$ \ud83d\udd12 426. Convert Binary Search Tree to Sorted Doubly Linked List $\\star\\star$ \ud83d\udd12 427. Construct Quad Tree $\\star\\star$ 428. Serialize and Deserialize N-ary Tree $\\star\\star\\star$ \ud83d\udd12 429. N-ary Tree Level Order Traversal $\\star\\star$ 430. Flatten a Multilevel Doubly Linked List $\\star\\star$ class Solution { public : Node * flatten ( Node * head ) { for ( Node * curr = head ; curr ; curr = curr -> next ) if ( curr -> child ) { Node * cachedNext = curr -> next ; curr -> next = curr -> child ; curr -> child -> prev = curr ; curr -> child = nullptr ; Node * tail = curr -> next ; while ( tail -> next ) tail = tail -> next ; tail -> next = cachedNext ; if ( cachedNext ) cachedNext -> prev = tail ; } return head ; } };","title":"0421-0430"},{"location":"cpp/0401-0500/0421-0430/#421-maximum-xor-of-two-numbers-in-an-array-starstar","text":"","title":"421. Maximum XOR of Two Numbers in an Array $\\star\\star$"},{"location":"cpp/0401-0500/0421-0430/#422-valid-word-square-star","text":"","title":"422. Valid Word Square $\\star$ \ud83d\udd12"},{"location":"cpp/0401-0500/0421-0430/#423-reconstruct-original-digits-from-english-starstar","text":"class Solution { public : string originalDigits ( string s ) { string ans ; vector < int > count ( 10 ); for ( char c : s ) { if ( c == 'z' ) ++ count [ 0 ]; if ( c == 'o' ) ++ count [ 1 ]; if ( c == 'w' ) ++ count [ 2 ]; if ( c == 'h' ) ++ count [ 3 ]; if ( c == 'u' ) ++ count [ 4 ]; if ( c == 'f' ) ++ count [ 5 ]; if ( c == 'x' ) ++ count [ 6 ]; if ( c == 's' ) ++ count [ 7 ]; if ( c == 'g' ) ++ count [ 8 ]; if ( c == 'i' ) ++ count [ 9 ]; } count [ 1 ] -= count [ 0 ] + count [ 2 ] + count [ 4 ]; count [ 3 ] -= count [ 8 ]; count [ 5 ] -= count [ 4 ]; count [ 7 ] -= count [ 6 ]; count [ 9 ] -= count [ 5 ] + count [ 6 ] + count [ 8 ]; for ( int i = 0 ; i < 10 ; ++ i ) for ( int j = 0 ; j < count [ i ]; ++ j ) ans += i + '0' ; return ans ; } };","title":"423. Reconstruct Original Digits from English $\\star\\star$"},{"location":"cpp/0401-0500/0421-0430/#424-longest-repeating-character-replacement-starstar","text":"class Solution { public : int characterReplacement ( string s , int k ) { int ans = 0 ; int maxFreq = 0 ; vector < int > count ( 26 ); for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { ++ count [ s [ r ] - 'A' ]; maxFreq = max ( maxFreq , count [ s [ r ] - 'A' ]); while ( maxFreq + k < r - l + 1 ) -- count [ s [ l ++ ] - 'A' ]; ans = max ( ans , r - l + 1 ); } return ans ; } };","title":"424. Longest Repeating Character Replacement $\\star\\star$"},{"location":"cpp/0401-0500/0421-0430/#425-word-squares-starstarstar","text":"","title":"425. Word Squares $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/0401-0500/0421-0430/#426-convert-binary-search-tree-to-sorted-doubly-linked-list-starstar","text":"","title":"426. Convert Binary Search Tree to Sorted Doubly Linked List $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0401-0500/0421-0430/#427-construct-quad-tree-starstar","text":"","title":"427. Construct Quad Tree $\\star\\star$"},{"location":"cpp/0401-0500/0421-0430/#428-serialize-and-deserialize-n-ary-tree-starstarstar","text":"","title":"428. Serialize and Deserialize N-ary Tree $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/0401-0500/0421-0430/#429-n-ary-tree-level-order-traversal-starstar","text":"","title":"429. N-ary Tree Level Order Traversal $\\star\\star$"},{"location":"cpp/0401-0500/0421-0430/#430-flatten-a-multilevel-doubly-linked-list-starstar","text":"class Solution { public : Node * flatten ( Node * head ) { for ( Node * curr = head ; curr ; curr = curr -> next ) if ( curr -> child ) { Node * cachedNext = curr -> next ; curr -> next = curr -> child ; curr -> child -> prev = curr ; curr -> child = nullptr ; Node * tail = curr -> next ; while ( tail -> next ) tail = tail -> next ; tail -> next = cachedNext ; if ( cachedNext ) cachedNext -> prev = tail ; } return head ; } };","title":"430. Flatten a Multilevel Doubly Linked List $\\star\\star$"},{"location":"cpp/0401-0500/0431-0440/","text":"431. Encode N-ary Tree to Binary Tree $\\star\\star\\star$ \ud83d\udd12 432. All O`one Data Structure $\\star\\star\\star$ 433. Minimum Genetic Mutation $\\star\\star$ 434. Number of Segments in a String $\\star$ class Solution { public : int countSegments ( string s ) { int ans = 0 ; for ( int i = 0 ; i < s . length (); ++ i ) if ( s [ i ] != ' ' && ( i == 0 || s [ i - 1 ] == ' ' )) ++ ans ; return ans ; } }; 435. Non-overlapping Intervals $\\star\\star$ class Solution { public : int eraseOverlapIntervals ( vector < vector < int >>& intervals ) { int ans = 0 ; int currentEnd = INT_MIN ; sort ( begin ( intervals ), end ( intervals ), []( const auto & a , const auto & b ) { return a [ 1 ] < b [ 1 ]; }); for ( vector < int >& interval : intervals ) { if ( interval [ 0 ] >= currentEnd ) currentEnd = interval [ 1 ]; else ++ ans ; } return ans ; } }; 436. Find Right Interval $\\star\\star$ 437. Path Sum III $\\star$ class Solution { public : int pathSum ( TreeNode * root , int sum ) { if ( ! root ) return 0 ; return helper ( root , sum ) + pathSum ( root -> left , sum ) + pathSum ( root -> right , sum ); } private : int helper ( TreeNode * root , int sum ) { if ( ! root ) return 0 ; return ( sum == root -> val ) + helper ( root -> left , sum - root -> val ) + helper ( root -> right , sum - root -> val ); } }; 438. Find All Anagrams in a String $\\star\\star$ class Solution { public : vector < int > findAnagrams ( string s , string p ) { vector < int > ans ; vector < int > count ( 26 ); int required = p . length (); for ( char c : p ) ++ count [ c - 'a' ]; for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { if ( -- count [ s [ r ] - 'a' ] >= 0 ) -- required ; while ( required == 0 ) { if ( r - l + 1 == p . length ()) ans . push_back ( l ); if ( ++ count [ s [ l ++ ] - 'a' ] > 0 ) ++ required ; } } return ans ; } }; 439. Ternary Expression Parser $\\star\\star$ \ud83d\udd12 440. K-th Smallest in Lexicographical Order $\\star\\star\\star$","title":"0431-0440"},{"location":"cpp/0401-0500/0431-0440/#431-encode-n-ary-tree-to-binary-tree-starstarstar","text":"","title":"431. Encode N-ary Tree to Binary Tree $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/0401-0500/0431-0440/#432-all-oone-data-structure-starstarstar","text":"","title":"432. All O`one Data Structure $\\star\\star\\star$"},{"location":"cpp/0401-0500/0431-0440/#433-minimum-genetic-mutation-starstar","text":"","title":"433. Minimum Genetic Mutation $\\star\\star$"},{"location":"cpp/0401-0500/0431-0440/#434-number-of-segments-in-a-string-star","text":"class Solution { public : int countSegments ( string s ) { int ans = 0 ; for ( int i = 0 ; i < s . length (); ++ i ) if ( s [ i ] != ' ' && ( i == 0 || s [ i - 1 ] == ' ' )) ++ ans ; return ans ; } };","title":"434. Number of Segments in a String $\\star$"},{"location":"cpp/0401-0500/0431-0440/#435-non-overlapping-intervals-starstar","text":"class Solution { public : int eraseOverlapIntervals ( vector < vector < int >>& intervals ) { int ans = 0 ; int currentEnd = INT_MIN ; sort ( begin ( intervals ), end ( intervals ), []( const auto & a , const auto & b ) { return a [ 1 ] < b [ 1 ]; }); for ( vector < int >& interval : intervals ) { if ( interval [ 0 ] >= currentEnd ) currentEnd = interval [ 1 ]; else ++ ans ; } return ans ; } };","title":"435. Non-overlapping Intervals $\\star\\star$"},{"location":"cpp/0401-0500/0431-0440/#436-find-right-interval-starstar","text":"","title":"436. Find Right Interval $\\star\\star$"},{"location":"cpp/0401-0500/0431-0440/#437-path-sum-iii-star","text":"class Solution { public : int pathSum ( TreeNode * root , int sum ) { if ( ! root ) return 0 ; return helper ( root , sum ) + pathSum ( root -> left , sum ) + pathSum ( root -> right , sum ); } private : int helper ( TreeNode * root , int sum ) { if ( ! root ) return 0 ; return ( sum == root -> val ) + helper ( root -> left , sum - root -> val ) + helper ( root -> right , sum - root -> val ); } };","title":"437. Path Sum III $\\star$"},{"location":"cpp/0401-0500/0431-0440/#438-find-all-anagrams-in-a-string-starstar","text":"class Solution { public : vector < int > findAnagrams ( string s , string p ) { vector < int > ans ; vector < int > count ( 26 ); int required = p . length (); for ( char c : p ) ++ count [ c - 'a' ]; for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { if ( -- count [ s [ r ] - 'a' ] >= 0 ) -- required ; while ( required == 0 ) { if ( r - l + 1 == p . length ()) ans . push_back ( l ); if ( ++ count [ s [ l ++ ] - 'a' ] > 0 ) ++ required ; } } return ans ; } };","title":"438. Find All Anagrams in a String $\\star\\star$"},{"location":"cpp/0401-0500/0431-0440/#439-ternary-expression-parser-starstar","text":"","title":"439. Ternary Expression Parser $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0401-0500/0431-0440/#440-k-th-smallest-in-lexicographical-order-starstarstar","text":"","title":"440. K-th Smallest in Lexicographical Order $\\star\\star\\star$"},{"location":"cpp/0401-0500/0441-0450/","text":"441. Arranging Coins $\\star$ class Solution { public : int arrangeCoins ( long n ) { return ( - 1 + sqrt ( 8 * n + 1 )) / 2 ; } }; 442. Find All Duplicates in an Array $\\star\\star$ class Solution { public : vector < int > findDuplicates ( vector < int >& nums ) { vector < int > ans ; for ( int num : nums ) { nums [ abs ( num ) - 1 ] *= - 1 ; if ( nums [ abs ( num ) - 1 ] > 0 ) ans . push_back ( abs ( num )); } return ans ; } }; 443. String Compression $\\star$ class Solution { public : int compress ( vector < char >& chars ) { int ans = 0 ; for ( int i = 0 ; i < chars . size ();) { char letter = chars [ i ]; int count = 0 ; while ( i < chars . size () && chars [ i ] == letter ) { ++ count ; ++ i ; } chars [ ans ++ ] = letter ; if ( count > 1 ) for ( char c : to_string ( count )) chars [ ans ++ ] = c ; } return ans ; } }; 444. Sequence Reconstruction $\\star\\star$ \ud83d\udd12 445. Add Two Numbers II $\\star\\star$ class Solution { public : ListNode * addTwoNumbers ( ListNode * l1 , ListNode * l2 ) { stack < ListNode *> stack1 ; stack < ListNode *> stack2 ; while ( l1 ) { stack1 . push ( l1 ); l1 = l1 -> next ; } while ( l2 ) { stack2 . push ( l2 ); l2 = l2 -> next ; } ListNode * head = nullptr ; int carry = 0 ; while ( carry || ! stack1 . empty () || ! stack2 . empty ()) { if ( ! stack1 . empty ()) carry += stack1 . top () -> val , stack1 . pop (); if ( ! stack2 . empty ()) carry += stack2 . top () -> val , stack2 . pop (); ListNode * node = new ListNode ( carry % 10 ); node -> next = head ; head = node ; carry /= 10 ; } return head ; } }; 446. Arithmetic Slices II - Subsequence $\\star\\star\\star$ 447. Number of Boomerangs $\\star$ class Solution { public : int numberOfBoomerangs ( vector < vector < int >>& points ) { int ans = 0 ; for ( vector < int >& p1 : points ) { unordered_map < int , int > count ; for ( vector < int >& p2 : points ) ans += 2 * count [ pow ( p1 [ 0 ] - p2 [ 0 ], 2 ) + pow ( p1 [ 1 ] - p2 [ 1 ], 2 )] ++ ; } return ans ; } }; 448. Find All Numbers Disappeared in an Array $\\star$ class Solution { public : vector < int > findDisappearedNumbers ( vector < int >& nums ) { vector < int > ans ; for ( int num : nums ) { int index = abs ( num ) - 1 ; nums [ index ] = - abs ( nums [ index ]); } for ( int i = 0 ; i < nums . size (); ++ i ) if ( nums [ i ] > 0 ) ans . push_back ( i + 1 ); return ans ; } }; 449. Serialize and Deserialize BST $\\star\\star$ 450. Delete Node in a BST $\\star\\star$","title":"0441-0450"},{"location":"cpp/0401-0500/0441-0450/#441-arranging-coins-star","text":"class Solution { public : int arrangeCoins ( long n ) { return ( - 1 + sqrt ( 8 * n + 1 )) / 2 ; } };","title":"441. Arranging Coins $\\star$"},{"location":"cpp/0401-0500/0441-0450/#442-find-all-duplicates-in-an-array-starstar","text":"class Solution { public : vector < int > findDuplicates ( vector < int >& nums ) { vector < int > ans ; for ( int num : nums ) { nums [ abs ( num ) - 1 ] *= - 1 ; if ( nums [ abs ( num ) - 1 ] > 0 ) ans . push_back ( abs ( num )); } return ans ; } };","title":"442. Find All Duplicates in an Array $\\star\\star$"},{"location":"cpp/0401-0500/0441-0450/#443-string-compression-star","text":"class Solution { public : int compress ( vector < char >& chars ) { int ans = 0 ; for ( int i = 0 ; i < chars . size ();) { char letter = chars [ i ]; int count = 0 ; while ( i < chars . size () && chars [ i ] == letter ) { ++ count ; ++ i ; } chars [ ans ++ ] = letter ; if ( count > 1 ) for ( char c : to_string ( count )) chars [ ans ++ ] = c ; } return ans ; } };","title":"443. String Compression $\\star$"},{"location":"cpp/0401-0500/0441-0450/#444-sequence-reconstruction-starstar","text":"","title":"444. Sequence Reconstruction $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0401-0500/0441-0450/#445-add-two-numbers-ii-starstar","text":"class Solution { public : ListNode * addTwoNumbers ( ListNode * l1 , ListNode * l2 ) { stack < ListNode *> stack1 ; stack < ListNode *> stack2 ; while ( l1 ) { stack1 . push ( l1 ); l1 = l1 -> next ; } while ( l2 ) { stack2 . push ( l2 ); l2 = l2 -> next ; } ListNode * head = nullptr ; int carry = 0 ; while ( carry || ! stack1 . empty () || ! stack2 . empty ()) { if ( ! stack1 . empty ()) carry += stack1 . top () -> val , stack1 . pop (); if ( ! stack2 . empty ()) carry += stack2 . top () -> val , stack2 . pop (); ListNode * node = new ListNode ( carry % 10 ); node -> next = head ; head = node ; carry /= 10 ; } return head ; } };","title":"445. Add Two Numbers II $\\star\\star$"},{"location":"cpp/0401-0500/0441-0450/#446-arithmetic-slices-ii-subsequence-starstarstar","text":"","title":"446. Arithmetic Slices II - Subsequence $\\star\\star\\star$"},{"location":"cpp/0401-0500/0441-0450/#447-number-of-boomerangs-star","text":"class Solution { public : int numberOfBoomerangs ( vector < vector < int >>& points ) { int ans = 0 ; for ( vector < int >& p1 : points ) { unordered_map < int , int > count ; for ( vector < int >& p2 : points ) ans += 2 * count [ pow ( p1 [ 0 ] - p2 [ 0 ], 2 ) + pow ( p1 [ 1 ] - p2 [ 1 ], 2 )] ++ ; } return ans ; } };","title":"447. Number of Boomerangs $\\star$"},{"location":"cpp/0401-0500/0441-0450/#448-find-all-numbers-disappeared-in-an-array-star","text":"class Solution { public : vector < int > findDisappearedNumbers ( vector < int >& nums ) { vector < int > ans ; for ( int num : nums ) { int index = abs ( num ) - 1 ; nums [ index ] = - abs ( nums [ index ]); } for ( int i = 0 ; i < nums . size (); ++ i ) if ( nums [ i ] > 0 ) ans . push_back ( i + 1 ); return ans ; } };","title":"448. Find All Numbers Disappeared in an Array $\\star$"},{"location":"cpp/0401-0500/0441-0450/#449-serialize-and-deserialize-bst-starstar","text":"","title":"449. Serialize and Deserialize BST $\\star\\star$"},{"location":"cpp/0401-0500/0441-0450/#450-delete-node-in-a-bst-starstar","text":"","title":"450. Delete Node in a BST $\\star\\star$"},{"location":"cpp/0401-0500/0451-0460/","text":"451. Sort Characters By Frequency $\\star\\star$ class Solution { public : string frequencySort ( string s ) { string ans ; vector < vector < char >> bucket ( s . length () + 1 ); vector < int > count ( 128 ); for ( char c : s ) ++ count [ c ]; for ( int i = 0 ; i < count . size (); ++ i ) { int freq = count [ i ]; if ( freq > 0 ) bucket [ freq ]. push_back (( char ) i ); } for ( int freq = bucket . size () - 1 ; freq >= 0 ; -- freq ) for ( char c : bucket [ freq ]) for ( int i = 0 ; i < freq ; ++ i ) ans += c ; return ans ; } }; 452. Minimum Number of Arrows to Burst Balloons $\\star\\star$ class Solution { public : int findMinArrowShots ( vector < vector < int >>& points ) { int ans = 0 ; long arrowX = ( long ) INT_MIN - 1 ; sort ( begin ( points ), end ( points ), []( const auto & a , const auto & b ) { return a [ 1 ] < b [ 1 ]; }); for ( vector < int >& point : points ) if ( point [ 0 ] > arrowX ) { ++ ans ; arrowX = point [ 1 ]; } return ans ; } }; 453. Minimum Moves to Equal Array Elements $\\star$ class Solution { public : int minMoves ( vector < int >& nums ) { const int min = * min_element ( begin ( nums ), end ( nums )); return accumulate ( begin ( nums ), end ( nums ), 0 , [ & ]( int a , int b ) { return a + ( b - min ); }); } }; 454. 4Sum II $\\star\\star$ class Solution { public : int fourSumCount ( vector < int >& A , vector < int >& B , vector < int >& C , vector < int >& D ) { int ans = 0 ; unordered_map < int , int > count ; for ( int a : A ) for ( int b : B ) ++ count [ a + b ]; for ( int c : C ) for ( int d : D ) if ( count . count ( - c - d )) ans += count [ - c - d ]; return ans ; } }; 455. Assign Cookies $\\star$ 456. 132 Pattern $\\star\\star$ 457. Circular Array Loop $\\star\\star$ class Solution { public : bool circularArrayLoop ( vector < int >& nums ) { if ( nums . size () < 2 ) return false ; function < int ( int ) > advance = [ & ]( int i ) { const int n = nums . size (); int val = ( i + nums [ i ]) % n ; return i + nums [ i ] >= 0 ? val : n + val ; }; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( nums [ i ] == 0 ) continue ; int slow = i ; int fast = advance ( slow ); while ( nums [ i ] * nums [ fast ] > 0 && nums [ i ] * nums [ advance ( fast )] > 0 ) { if ( slow == fast ) { if ( slow == advance ( slow )) break ; return true ; } slow = advance ( slow ); fast = advance ( advance ( fast )); } slow = i ; int sign = nums [ i ]; while ( sign * nums [ slow ] > 0 ) { int next = advance ( slow ); nums [ slow ] = 0 ; slow = next ; } } return false ; } }; 458. Poor Pigs $\\star\\star\\star$ class Solution { public : int poorPigs ( int buckets , int minutesToDie , int minutesToTest ) { return ceil ( log ( buckets ) / log ( minutesToTest / minutesToDie + 1 )); } }; 459. Repeated Substring Pattern $\\star$ class Solution { public : bool repeatedSubstringPattern ( string s ) { string ss = s + s ; return ss . substr ( 1 , ss . length () - 2 ). find ( s ) != string :: npos ; } }; 460. LFU Cache $\\star\\star\\star$","title":"0451-0460"},{"location":"cpp/0401-0500/0451-0460/#451-sort-characters-by-frequency-starstar","text":"class Solution { public : string frequencySort ( string s ) { string ans ; vector < vector < char >> bucket ( s . length () + 1 ); vector < int > count ( 128 ); for ( char c : s ) ++ count [ c ]; for ( int i = 0 ; i < count . size (); ++ i ) { int freq = count [ i ]; if ( freq > 0 ) bucket [ freq ]. push_back (( char ) i ); } for ( int freq = bucket . size () - 1 ; freq >= 0 ; -- freq ) for ( char c : bucket [ freq ]) for ( int i = 0 ; i < freq ; ++ i ) ans += c ; return ans ; } };","title":"451. Sort Characters By Frequency $\\star\\star$"},{"location":"cpp/0401-0500/0451-0460/#452-minimum-number-of-arrows-to-burst-balloons-starstar","text":"class Solution { public : int findMinArrowShots ( vector < vector < int >>& points ) { int ans = 0 ; long arrowX = ( long ) INT_MIN - 1 ; sort ( begin ( points ), end ( points ), []( const auto & a , const auto & b ) { return a [ 1 ] < b [ 1 ]; }); for ( vector < int >& point : points ) if ( point [ 0 ] > arrowX ) { ++ ans ; arrowX = point [ 1 ]; } return ans ; } };","title":"452. Minimum Number of Arrows to Burst Balloons $\\star\\star$"},{"location":"cpp/0401-0500/0451-0460/#453-minimum-moves-to-equal-array-elements-star","text":"class Solution { public : int minMoves ( vector < int >& nums ) { const int min = * min_element ( begin ( nums ), end ( nums )); return accumulate ( begin ( nums ), end ( nums ), 0 , [ & ]( int a , int b ) { return a + ( b - min ); }); } };","title":"453. Minimum Moves to Equal Array Elements $\\star$"},{"location":"cpp/0401-0500/0451-0460/#454-4sum-ii-starstar","text":"class Solution { public : int fourSumCount ( vector < int >& A , vector < int >& B , vector < int >& C , vector < int >& D ) { int ans = 0 ; unordered_map < int , int > count ; for ( int a : A ) for ( int b : B ) ++ count [ a + b ]; for ( int c : C ) for ( int d : D ) if ( count . count ( - c - d )) ans += count [ - c - d ]; return ans ; } };","title":"454. 4Sum II $\\star\\star$"},{"location":"cpp/0401-0500/0451-0460/#455-assign-cookies-star","text":"","title":"455. Assign Cookies $\\star$"},{"location":"cpp/0401-0500/0451-0460/#456-132-pattern-starstar","text":"","title":"456. 132 Pattern $\\star\\star$"},{"location":"cpp/0401-0500/0451-0460/#457-circular-array-loop-starstar","text":"class Solution { public : bool circularArrayLoop ( vector < int >& nums ) { if ( nums . size () < 2 ) return false ; function < int ( int ) > advance = [ & ]( int i ) { const int n = nums . size (); int val = ( i + nums [ i ]) % n ; return i + nums [ i ] >= 0 ? val : n + val ; }; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( nums [ i ] == 0 ) continue ; int slow = i ; int fast = advance ( slow ); while ( nums [ i ] * nums [ fast ] > 0 && nums [ i ] * nums [ advance ( fast )] > 0 ) { if ( slow == fast ) { if ( slow == advance ( slow )) break ; return true ; } slow = advance ( slow ); fast = advance ( advance ( fast )); } slow = i ; int sign = nums [ i ]; while ( sign * nums [ slow ] > 0 ) { int next = advance ( slow ); nums [ slow ] = 0 ; slow = next ; } } return false ; } };","title":"457. Circular Array Loop $\\star\\star$"},{"location":"cpp/0401-0500/0451-0460/#458-poor-pigs-starstarstar","text":"class Solution { public : int poorPigs ( int buckets , int minutesToDie , int minutesToTest ) { return ceil ( log ( buckets ) / log ( minutesToTest / minutesToDie + 1 )); } };","title":"458. Poor Pigs $\\star\\star\\star$"},{"location":"cpp/0401-0500/0451-0460/#459-repeated-substring-pattern-star","text":"class Solution { public : bool repeatedSubstringPattern ( string s ) { string ss = s + s ; return ss . substr ( 1 , ss . length () - 2 ). find ( s ) != string :: npos ; } };","title":"459. Repeated Substring Pattern $\\star$"},{"location":"cpp/0401-0500/0451-0460/#460-lfu-cache-starstarstar","text":"","title":"460. LFU Cache $\\star\\star\\star$"},{"location":"cpp/0401-0500/0461-0470/","text":"461. Hamming Distance $\\star$ class Solution { public : int hammingDistance ( int x , int y ) { int ans = 0 ; while ( x || y ) { ans += ( x % 2 ) ^ ( y % 2 ); x /= 2 ; y /= 2 ; } return ans ; } }; 462. Minimum Moves to Equal Array Elements II $\\star\\star$ class Solution { public : int minMoves2 ( vector < int >& nums ) { const int n = nums . size (); nth_element ( begin ( nums ), begin ( nums ) + n / 2 , end ( nums )); int median = nums [ n / 2 ]; return accumulate ( begin ( nums ), end ( nums ), 0 , [ & ]( int a , int b ) { return a + abs ( b - median ); }); } }; 463. Island Perimeter $\\star$ class Solution { public : int islandPerimeter ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); int islands = 0 ; int neighbors = 0 ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ][ j ]) { ++ islands ; if ( i + 1 < m && grid [ i + 1 ][ j ]) ++ neighbors ; if ( j + 1 < n && grid [ i ][ j + 1 ]) ++ neighbors ; } return islands * 4 - neighbors * 2 ; } }; 464. Can I Win $\\star\\star$ 465. Optimal Account Balancing $\\star\\star\\star$ \ud83d\udd12 466. Count The Repetitions $\\star\\star\\star$ 467. Unique Substrings in Wraparound String $\\star\\star$ 468. Validate IP Address $\\star\\star$ 469. Convex Polygon $\\star\\star$ \ud83d\udd12 470. Implement Rand10() Using Rand7() $\\star\\star$","title":"0461-0470"},{"location":"cpp/0401-0500/0461-0470/#461-hamming-distance-star","text":"class Solution { public : int hammingDistance ( int x , int y ) { int ans = 0 ; while ( x || y ) { ans += ( x % 2 ) ^ ( y % 2 ); x /= 2 ; y /= 2 ; } return ans ; } };","title":"461. Hamming Distance $\\star$"},{"location":"cpp/0401-0500/0461-0470/#462-minimum-moves-to-equal-array-elements-ii-starstar","text":"class Solution { public : int minMoves2 ( vector < int >& nums ) { const int n = nums . size (); nth_element ( begin ( nums ), begin ( nums ) + n / 2 , end ( nums )); int median = nums [ n / 2 ]; return accumulate ( begin ( nums ), end ( nums ), 0 , [ & ]( int a , int b ) { return a + abs ( b - median ); }); } };","title":"462. Minimum Moves to Equal Array Elements II $\\star\\star$"},{"location":"cpp/0401-0500/0461-0470/#463-island-perimeter-star","text":"class Solution { public : int islandPerimeter ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); int islands = 0 ; int neighbors = 0 ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ][ j ]) { ++ islands ; if ( i + 1 < m && grid [ i + 1 ][ j ]) ++ neighbors ; if ( j + 1 < n && grid [ i ][ j + 1 ]) ++ neighbors ; } return islands * 4 - neighbors * 2 ; } };","title":"463. Island Perimeter $\\star$"},{"location":"cpp/0401-0500/0461-0470/#464-can-i-win-starstar","text":"","title":"464. Can I Win $\\star\\star$"},{"location":"cpp/0401-0500/0461-0470/#465-optimal-account-balancing-starstarstar","text":"","title":"465. Optimal Account Balancing $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/0401-0500/0461-0470/#466-count-the-repetitions-starstarstar","text":"","title":"466. Count The Repetitions $\\star\\star\\star$"},{"location":"cpp/0401-0500/0461-0470/#467-unique-substrings-in-wraparound-string-starstar","text":"","title":"467. Unique Substrings in Wraparound String $\\star\\star$"},{"location":"cpp/0401-0500/0461-0470/#468-validate-ip-address-starstar","text":"","title":"468. Validate IP Address $\\star\\star$"},{"location":"cpp/0401-0500/0461-0470/#469-convex-polygon-starstar","text":"","title":"469. Convex Polygon $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0401-0500/0461-0470/#470-implement-rand10-using-rand7-starstar","text":"","title":"470. Implement Rand10() Using Rand7() $\\star\\star$"},{"location":"cpp/0401-0500/0471-0480/","text":"471. Encode String with Shortest Length $\\star\\star\\star$ \ud83d\udd12 472. Concatenated Words $\\star\\star\\star$ class Solution { public : vector < string > findAllConcatenatedWordsInADict ( vector < string >& words ) { vector < string > ans ; unordered_set < string > wordSet { begin ( words ), end ( words )}; for ( const string & word : words ) if ( isConcat ( word , wordSet )) ans . push_back ( word ); return ans ; } private : unordered_map < string , bool > memo ; bool isConcat ( const string & word , unordered_set < string >& wordSet ) { if ( memo . count ( word )) return memo [ word ]; for ( int i = 1 ; i < word . length (); ++ i ) { string prefix = word . substr ( 0 , i ); string suffix = word . substr ( i ); if ( wordSet . count ( prefix ) && ( wordSet . count ( suffix ) || isConcat ( suffix , wordSet ))) { memo [ word ] = true ; return true ; } } memo [ word ] = false ; return false ; } }; 473. Matchsticks to Square $\\star\\star$ class Solution { public : bool makesquare ( vector < int >& nums ) { if ( nums . size () < 4 ) return false ; int perimeter = accumulate ( begin ( nums ), end ( nums ), 0 ); if ( perimeter % 4 != 0 ) return false ; vector < int > edges ( 4 , perimeter / 4 ); sort ( begin ( nums ), end ( nums ), greater < int > ()); return dfs ( nums , 0 , edges ); } private : bool dfs ( vector < int >& nums , int selected , vector < int >& edges ) { if ( selected == nums . size ()) return all_of ( begin ( edges ), end ( edges ), [ & edges ]( int edge ) { return edge == edges [ 0 ]; }); for ( int i = 0 ; i < edges . size (); ++ i ) { if ( nums [ selected ] > edges [ i ]) continue ; edges [ i ] -= nums [ selected ]; if ( dfs ( nums , selected + 1 , edges )) return true ; edges [ i ] += nums [ selected ]; } return false ; } }; 474. Ones and Zeroes $\\star\\star$ class Solution { public : int findMaxForm ( vector < string >& strs , int m , int n ) { vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 , 0 )); for ( const string s : strs ) { int count0 = count ( begin ( s ), end ( s ), '0' ); int count1 = s . length () - count0 ; for ( int i = m ; i >= count0 ; -- i ) for ( int j = n ; j >= count1 ; -- j ) dp [ i ][ j ] = max ( dp [ i ][ j ], dp [ i - count0 ][ j - count1 ] + 1 ); } return dp [ m ][ n ]; } }; 475. Heaters $\\star$ 476. Number Complement $\\star$ class Solution { public : int findComplement ( int num ) { unsigned int mask = ~ 0 ; while ( num & mask ) mask <<= 1 ; return ~ num ^ mask ; } }; 477. Total Hamming Distance $\\star\\star$ class Solution { public : int totalHammingDistance ( vector < int >& nums ) { int ans = 0 ; int mask = 1 ; for ( int i = 0 ; i < 30 ; ++ i ) { int onesCount = 0 ; for ( int num : nums ) if ( num & mask ) ++ onesCount ; ans += ( nums . size () - onesCount ) * onesCount ; mask = mask << 1 ; } return ans ; } }; 478. Generate Random Point in a Circle $\\star\\star$ class Solution { public : Solution ( double radius , double x_center , double y_center ) { this -> radius = radius ; this -> x_center = x_center ; this -> y_center = y_center ; distribution = uniform_real_distribution < double > ( 0.0 , 1.0 ); } vector < double > randPoint () { double length = sqrt ( distribution ( generator )) * radius ; double degree = distribution ( generator ) * 2 * M_PI ; double x = x_center + length * cos ( degree ); double y = y_center + length * sin ( degree ); return { x , y }; } private : double radius ; double x_center ; double y_center ; default_random_engine generator ; uniform_real_distribution < double > distribution ; }; 479. Largest Palindrome Product $\\star\\star\\star$ 480. Sliding Window Median $\\star\\star\\star$","title":"0471-0480"},{"location":"cpp/0401-0500/0471-0480/#471-encode-string-with-shortest-length-starstarstar","text":"","title":"471. Encode String with Shortest Length $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/0401-0500/0471-0480/#472-concatenated-words-starstarstar","text":"class Solution { public : vector < string > findAllConcatenatedWordsInADict ( vector < string >& words ) { vector < string > ans ; unordered_set < string > wordSet { begin ( words ), end ( words )}; for ( const string & word : words ) if ( isConcat ( word , wordSet )) ans . push_back ( word ); return ans ; } private : unordered_map < string , bool > memo ; bool isConcat ( const string & word , unordered_set < string >& wordSet ) { if ( memo . count ( word )) return memo [ word ]; for ( int i = 1 ; i < word . length (); ++ i ) { string prefix = word . substr ( 0 , i ); string suffix = word . substr ( i ); if ( wordSet . count ( prefix ) && ( wordSet . count ( suffix ) || isConcat ( suffix , wordSet ))) { memo [ word ] = true ; return true ; } } memo [ word ] = false ; return false ; } };","title":"472. Concatenated Words $\\star\\star\\star$"},{"location":"cpp/0401-0500/0471-0480/#473-matchsticks-to-square-starstar","text":"class Solution { public : bool makesquare ( vector < int >& nums ) { if ( nums . size () < 4 ) return false ; int perimeter = accumulate ( begin ( nums ), end ( nums ), 0 ); if ( perimeter % 4 != 0 ) return false ; vector < int > edges ( 4 , perimeter / 4 ); sort ( begin ( nums ), end ( nums ), greater < int > ()); return dfs ( nums , 0 , edges ); } private : bool dfs ( vector < int >& nums , int selected , vector < int >& edges ) { if ( selected == nums . size ()) return all_of ( begin ( edges ), end ( edges ), [ & edges ]( int edge ) { return edge == edges [ 0 ]; }); for ( int i = 0 ; i < edges . size (); ++ i ) { if ( nums [ selected ] > edges [ i ]) continue ; edges [ i ] -= nums [ selected ]; if ( dfs ( nums , selected + 1 , edges )) return true ; edges [ i ] += nums [ selected ]; } return false ; } };","title":"473. Matchsticks to Square $\\star\\star$"},{"location":"cpp/0401-0500/0471-0480/#474-ones-and-zeroes-starstar","text":"class Solution { public : int findMaxForm ( vector < string >& strs , int m , int n ) { vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 , 0 )); for ( const string s : strs ) { int count0 = count ( begin ( s ), end ( s ), '0' ); int count1 = s . length () - count0 ; for ( int i = m ; i >= count0 ; -- i ) for ( int j = n ; j >= count1 ; -- j ) dp [ i ][ j ] = max ( dp [ i ][ j ], dp [ i - count0 ][ j - count1 ] + 1 ); } return dp [ m ][ n ]; } };","title":"474. Ones and Zeroes $\\star\\star$"},{"location":"cpp/0401-0500/0471-0480/#475-heaters-star","text":"","title":"475. Heaters $\\star$"},{"location":"cpp/0401-0500/0471-0480/#476-number-complement-star","text":"class Solution { public : int findComplement ( int num ) { unsigned int mask = ~ 0 ; while ( num & mask ) mask <<= 1 ; return ~ num ^ mask ; } };","title":"476. Number Complement $\\star$"},{"location":"cpp/0401-0500/0471-0480/#477-total-hamming-distance-starstar","text":"class Solution { public : int totalHammingDistance ( vector < int >& nums ) { int ans = 0 ; int mask = 1 ; for ( int i = 0 ; i < 30 ; ++ i ) { int onesCount = 0 ; for ( int num : nums ) if ( num & mask ) ++ onesCount ; ans += ( nums . size () - onesCount ) * onesCount ; mask = mask << 1 ; } return ans ; } };","title":"477. Total Hamming Distance $\\star\\star$"},{"location":"cpp/0401-0500/0471-0480/#478-generate-random-point-in-a-circle-starstar","text":"class Solution { public : Solution ( double radius , double x_center , double y_center ) { this -> radius = radius ; this -> x_center = x_center ; this -> y_center = y_center ; distribution = uniform_real_distribution < double > ( 0.0 , 1.0 ); } vector < double > randPoint () { double length = sqrt ( distribution ( generator )) * radius ; double degree = distribution ( generator ) * 2 * M_PI ; double x = x_center + length * cos ( degree ); double y = y_center + length * sin ( degree ); return { x , y }; } private : double radius ; double x_center ; double y_center ; default_random_engine generator ; uniform_real_distribution < double > distribution ; };","title":"478. Generate Random Point in a Circle $\\star\\star$"},{"location":"cpp/0401-0500/0471-0480/#479-largest-palindrome-product-starstarstar","text":"","title":"479. Largest Palindrome Product $\\star\\star\\star$"},{"location":"cpp/0401-0500/0471-0480/#480-sliding-window-median-starstarstar","text":"","title":"480. Sliding Window Median $\\star\\star\\star$"},{"location":"cpp/0401-0500/0481-0490/","text":"481. Magical String $\\star\\star$ 482. License Key Formatting $\\star$ 483. Smallest Good Base $\\star\\star\\star$ class Solution { public : string smallestGoodBase ( string n ) { unsigned long long num = stoll ( n ); for ( int m = log2 ( num ); m >= 2 ; -- m ) { int k = pow ( num , 1.0 / m ); unsigned long long sum = 1 ; unsigned long long prod = 1 ; for ( int i = 0 ; i < m ; ++ i ) { prod *= k ; sum += prod ; } if ( sum == num ) return to_string ( k ); } return to_string ( num - 1 ); } }; 484. Find Permutation $\\star\\star$ \ud83d\udd12 485. Max Consecutive Ones $\\star$ class Solution { public : int findMaxConsecutiveOnes ( vector < int >& nums ) { int ans = 0 ; int sum = 0 ; for ( int num : nums ) { if ( num == 0 ) sum = 0 ; else { sum += num ; ans = max ( ans , sum ); } } return ans ; } }; 486. Predict the Winner $\\star\\star$ 487. Max Consecutive Ones II $\\star\\star$ \ud83d\udd12 488. Zuma Game $\\star\\star\\star$ 489. Robot Room Cleaner $\\star\\star\\star$ \ud83d\udd12 490. The Maze $\\star\\star$ \ud83d\udd12","title":"0481-0490"},{"location":"cpp/0401-0500/0481-0490/#481-magical-string-starstar","text":"","title":"481. Magical String $\\star\\star$"},{"location":"cpp/0401-0500/0481-0490/#482-license-key-formatting-star","text":"","title":"482. License Key Formatting $\\star$"},{"location":"cpp/0401-0500/0481-0490/#483-smallest-good-base-starstarstar","text":"class Solution { public : string smallestGoodBase ( string n ) { unsigned long long num = stoll ( n ); for ( int m = log2 ( num ); m >= 2 ; -- m ) { int k = pow ( num , 1.0 / m ); unsigned long long sum = 1 ; unsigned long long prod = 1 ; for ( int i = 0 ; i < m ; ++ i ) { prod *= k ; sum += prod ; } if ( sum == num ) return to_string ( k ); } return to_string ( num - 1 ); } };","title":"483. Smallest Good Base $\\star\\star\\star$"},{"location":"cpp/0401-0500/0481-0490/#484-find-permutation-starstar","text":"","title":"484. Find Permutation $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0401-0500/0481-0490/#485-max-consecutive-ones-star","text":"class Solution { public : int findMaxConsecutiveOnes ( vector < int >& nums ) { int ans = 0 ; int sum = 0 ; for ( int num : nums ) { if ( num == 0 ) sum = 0 ; else { sum += num ; ans = max ( ans , sum ); } } return ans ; } };","title":"485. Max Consecutive Ones $\\star$"},{"location":"cpp/0401-0500/0481-0490/#486-predict-the-winner-starstar","text":"","title":"486. Predict the Winner $\\star\\star$"},{"location":"cpp/0401-0500/0481-0490/#487-max-consecutive-ones-ii-starstar","text":"","title":"487. Max Consecutive Ones II $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0401-0500/0481-0490/#488-zuma-game-starstarstar","text":"","title":"488. Zuma Game $\\star\\star\\star$"},{"location":"cpp/0401-0500/0481-0490/#489-robot-room-cleaner-starstarstar","text":"","title":"489. Robot Room Cleaner $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/0401-0500/0481-0490/#490-the-maze-starstar","text":"","title":"490. The Maze $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0401-0500/0491-0500/","text":"491. Increasing Subsequences $\\star\\star$ class Solution { public : vector < vector < int >> findSubsequences ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; dfs ( nums , 0 , path , ans ); return ans ; } private : void dfs ( vector < int >& nums , int s , vector < int >& path , vector < vector < int >>& ans ) { if ( path . size () > 1 ) ans . push_back ( path ); unordered_set < int > used ; for ( int i = s ; i < nums . size (); ++ i ) { if ( used . count ( nums [ i ])) continue ; if ( path . empty () || nums [ i ] >= path . back ()) { used . insert ( nums [ i ]); path . push_back ( nums [ i ]); dfs ( nums , i + 1 , path , ans ); path . pop_back (); } } } }; 492. Construct the Rectangle $\\star$ 493. Reverse Pairs $\\star\\star\\star$ 494. Target Sum $\\star\\star$ class Solution { public : int findTargetSumWays ( vector < int >& nums , int S ) { const int sum = accumulate ( begin ( nums ), end ( nums ), 0 ); if ( sum < S || ( sum + S ) & 1 ) return 0 ; return subsetSum ( nums , ( sum + S ) / 2 ); } private : int subsetSum ( vector < int >& nums , int s ) { vector < int > dp ( s + 1 ); dp [ 0 ] = 1 ; for ( int num : nums ) for ( int w = s ; w >= num ; -- w ) dp [ w ] += dp [ w - num ]; return dp [ s ]; } }; 495. Teemo Attacking $\\star\\star$ class Solution { public : int findPoisonedDuration ( vector < int >& timeSeries , int duration ) { if ( timeSeries . empty () || duration == 0 ) return 0 ; int ans = 0 ; for ( int i = 0 ; i + 1 < timeSeries . size (); ++ i ) ans += min ( timeSeries [ i + 1 ] - timeSeries [ i ], duration ); return ans + duration ; } }; 496. Next Greater Element I $\\star$ 497. Random Point in Non-overlapping Rectangles $\\star\\star$ 498. Diagonal Traverse $\\star\\star$ 499. The Maze III $\\star\\star\\star$ \ud83d\udd12 500. Keyboard Row $\\star$ class Solution { public : vector < string > findWords ( vector < string >& words ) { vector < string > ans ; vector < int > rows { 2 , 3 , 3 , 2 , 1 , 2 , 2 , 2 , 1 , 2 , 2 , 2 , 3 , 3 , 1 , 1 , 1 , 1 , 2 , 1 , 1 , 3 , 1 , 3 , 1 , 3 }; for ( const string & word : words ) { string lowerWord = word ; transform ( begin ( lowerWord ), end ( lowerWord ), begin ( lowerWord ), []( char c ) { return tolower ( c ); }); int row = rows [ lowerWord [ 0 ] - 'a' ]; bool isValid = true ; for ( int i = 1 ; i < lowerWord . length (); ++ i ) if ( rows [ lowerWord [ i ] - 'a' ] != row ) { isValid = false ; break ; } if ( isValid ) ans . push_back ( word ); } return ans ; } };","title":"0491-0500"},{"location":"cpp/0401-0500/0491-0500/#491-increasing-subsequences-starstar","text":"class Solution { public : vector < vector < int >> findSubsequences ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; dfs ( nums , 0 , path , ans ); return ans ; } private : void dfs ( vector < int >& nums , int s , vector < int >& path , vector < vector < int >>& ans ) { if ( path . size () > 1 ) ans . push_back ( path ); unordered_set < int > used ; for ( int i = s ; i < nums . size (); ++ i ) { if ( used . count ( nums [ i ])) continue ; if ( path . empty () || nums [ i ] >= path . back ()) { used . insert ( nums [ i ]); path . push_back ( nums [ i ]); dfs ( nums , i + 1 , path , ans ); path . pop_back (); } } } };","title":"491. Increasing Subsequences $\\star\\star$"},{"location":"cpp/0401-0500/0491-0500/#492-construct-the-rectangle-star","text":"","title":"492. Construct the Rectangle $\\star$"},{"location":"cpp/0401-0500/0491-0500/#493-reverse-pairs-starstarstar","text":"","title":"493. Reverse Pairs $\\star\\star\\star$"},{"location":"cpp/0401-0500/0491-0500/#494-target-sum-starstar","text":"class Solution { public : int findTargetSumWays ( vector < int >& nums , int S ) { const int sum = accumulate ( begin ( nums ), end ( nums ), 0 ); if ( sum < S || ( sum + S ) & 1 ) return 0 ; return subsetSum ( nums , ( sum + S ) / 2 ); } private : int subsetSum ( vector < int >& nums , int s ) { vector < int > dp ( s + 1 ); dp [ 0 ] = 1 ; for ( int num : nums ) for ( int w = s ; w >= num ; -- w ) dp [ w ] += dp [ w - num ]; return dp [ s ]; } };","title":"494. Target Sum $\\star\\star$"},{"location":"cpp/0401-0500/0491-0500/#495-teemo-attacking-starstar","text":"class Solution { public : int findPoisonedDuration ( vector < int >& timeSeries , int duration ) { if ( timeSeries . empty () || duration == 0 ) return 0 ; int ans = 0 ; for ( int i = 0 ; i + 1 < timeSeries . size (); ++ i ) ans += min ( timeSeries [ i + 1 ] - timeSeries [ i ], duration ); return ans + duration ; } };","title":"495. Teemo Attacking $\\star\\star$"},{"location":"cpp/0401-0500/0491-0500/#496-next-greater-element-i-star","text":"","title":"496. Next Greater Element I $\\star$"},{"location":"cpp/0401-0500/0491-0500/#497-random-point-in-non-overlapping-rectangles-starstar","text":"","title":"497. Random Point in Non-overlapping Rectangles $\\star\\star$"},{"location":"cpp/0401-0500/0491-0500/#498-diagonal-traverse-starstar","text":"","title":"498. Diagonal Traverse $\\star\\star$"},{"location":"cpp/0401-0500/0491-0500/#499-the-maze-iii-starstarstar","text":"","title":"499. The Maze III $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/0401-0500/0491-0500/#500-keyboard-row-star","text":"class Solution { public : vector < string > findWords ( vector < string >& words ) { vector < string > ans ; vector < int > rows { 2 , 3 , 3 , 2 , 1 , 2 , 2 , 2 , 1 , 2 , 2 , 2 , 3 , 3 , 1 , 1 , 1 , 1 , 2 , 1 , 1 , 3 , 1 , 3 , 1 , 3 }; for ( const string & word : words ) { string lowerWord = word ; transform ( begin ( lowerWord ), end ( lowerWord ), begin ( lowerWord ), []( char c ) { return tolower ( c ); }); int row = rows [ lowerWord [ 0 ] - 'a' ]; bool isValid = true ; for ( int i = 1 ; i < lowerWord . length (); ++ i ) if ( rows [ lowerWord [ i ] - 'a' ] != row ) { isValid = false ; break ; } if ( isValid ) ans . push_back ( word ); } return ans ; } };","title":"500. Keyboard Row $\\star$"},{"location":"cpp/0501-0600/0501-0510/","text":"501. Find Mode in Binary Search Tree $\\star$ 502. IPO $\\star\\star\\star$ 503. Next Greater Element II $\\star\\star$ class Solution { public : vector < int > nextGreaterElements ( vector < int >& nums ) { vector < int > ans ( nums . size (), - 1 ); stack < int > stack ; for ( int i = 0 ; i < nums . size () * 2 ; ++ i ) { int num = nums [ i % nums . size ()]; while ( ! stack . empty () && nums [ stack . top ()] < num ) { int index = stack . top (); stack . pop (); ans [ index ] = num ; } if ( i < nums . size ()) stack . push ( i ); } return ans ; } }; 504. Base 7 $\\star$ 505. The Maze II $\\star\\star$ \ud83d\udd12 506. Relative Ranks $\\star$ 507. Perfect Number $\\star$ class Solution { public : bool checkPerfectNumber ( int num ) { if ( num == 1 ) return false ; int sum = 1 ; for ( int i = 2 ; i <= sqrt ( num ); ++ i ) if ( num % i == 0 ) sum += i + num / i ; return sum == num ; } }; 508. Most Frequent Subtree Sum $\\star\\star$ class Solution { public : vector < int > findFrequentTreeSum ( TreeNode * root ) { vector < int > ans ; unordered_map < int , int > count ; int maxFreq = 0 ; dfs ( root , count ); for ( auto && [ _ , freq ] : count ) maxFreq = max ( maxFreq , freq ); for ( auto && [ sum , freq ] : count ) if ( freq == maxFreq ) ans . push_back ( sum ); return ans ; } private : int dfs ( TreeNode * root , unordered_map < int , int >& count ) { if ( ! root ) return 0 ; int sum = root -> val + dfs ( root -> left , count ) + dfs ( root -> right , count ); ++ count [ sum ]; return sum ; } }; 509. Fibonacci Number $\\star$ class Solution { public : int fib ( int N ) { if ( N < 2 ) return N ; int dp [] = { 0 , 0 , 1 }; for ( int i = 2 ; i <= N ; ++ i ) { dp [ 0 ] = dp [ 1 ]; dp [ 1 ] = dp [ 2 ]; dp [ 2 ] = dp [ 0 ] + dp [ 1 ]; } return dp [ 2 ]; } }; 510. Inorder Successor in BST II $\\star\\star$ \ud83d\udd12","title":"0501-0510"},{"location":"cpp/0501-0600/0501-0510/#501-find-mode-in-binary-search-tree-star","text":"","title":"501. Find Mode in Binary Search Tree $\\star$"},{"location":"cpp/0501-0600/0501-0510/#502-ipo-starstarstar","text":"","title":"502. IPO $\\star\\star\\star$"},{"location":"cpp/0501-0600/0501-0510/#503-next-greater-element-ii-starstar","text":"class Solution { public : vector < int > nextGreaterElements ( vector < int >& nums ) { vector < int > ans ( nums . size (), - 1 ); stack < int > stack ; for ( int i = 0 ; i < nums . size () * 2 ; ++ i ) { int num = nums [ i % nums . size ()]; while ( ! stack . empty () && nums [ stack . top ()] < num ) { int index = stack . top (); stack . pop (); ans [ index ] = num ; } if ( i < nums . size ()) stack . push ( i ); } return ans ; } };","title":"503. Next Greater Element II $\\star\\star$"},{"location":"cpp/0501-0600/0501-0510/#504-base-7-star","text":"","title":"504. Base 7 $\\star$"},{"location":"cpp/0501-0600/0501-0510/#505-the-maze-ii-starstar","text":"","title":"505. The Maze II $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0501-0600/0501-0510/#506-relative-ranks-star","text":"","title":"506. Relative Ranks $\\star$"},{"location":"cpp/0501-0600/0501-0510/#507-perfect-number-star","text":"class Solution { public : bool checkPerfectNumber ( int num ) { if ( num == 1 ) return false ; int sum = 1 ; for ( int i = 2 ; i <= sqrt ( num ); ++ i ) if ( num % i == 0 ) sum += i + num / i ; return sum == num ; } };","title":"507. Perfect Number $\\star$"},{"location":"cpp/0501-0600/0501-0510/#508-most-frequent-subtree-sum-starstar","text":"class Solution { public : vector < int > findFrequentTreeSum ( TreeNode * root ) { vector < int > ans ; unordered_map < int , int > count ; int maxFreq = 0 ; dfs ( root , count ); for ( auto && [ _ , freq ] : count ) maxFreq = max ( maxFreq , freq ); for ( auto && [ sum , freq ] : count ) if ( freq == maxFreq ) ans . push_back ( sum ); return ans ; } private : int dfs ( TreeNode * root , unordered_map < int , int >& count ) { if ( ! root ) return 0 ; int sum = root -> val + dfs ( root -> left , count ) + dfs ( root -> right , count ); ++ count [ sum ]; return sum ; } };","title":"508. Most Frequent Subtree Sum $\\star\\star$"},{"location":"cpp/0501-0600/0501-0510/#509-fibonacci-number-star","text":"class Solution { public : int fib ( int N ) { if ( N < 2 ) return N ; int dp [] = { 0 , 0 , 1 }; for ( int i = 2 ; i <= N ; ++ i ) { dp [ 0 ] = dp [ 1 ]; dp [ 1 ] = dp [ 2 ]; dp [ 2 ] = dp [ 0 ] + dp [ 1 ]; } return dp [ 2 ]; } };","title":"509. Fibonacci Number $\\star$"},{"location":"cpp/0501-0600/0501-0510/#510-inorder-successor-in-bst-ii-starstar","text":"","title":"510. Inorder Successor in BST II $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0501-0600/0511-0520/","text":"511. Game Play Analysis I $\\star$ \ud83d\udd12 512. Game Play Analysis II $\\star$ \ud83d\udd12 513. Find Bottom Left Tree Value $\\star\\star$ class Solution { public : int findBottomLeftValue ( TreeNode * root ) { queue < TreeNode *> queue {{ root }}; while ( ! queue . empty ()) { root = queue . front (), queue . pop (); if ( root -> right ) queue . push ( root -> right ); if ( root -> left ) queue . push ( root -> left ); } return root -> val ; } }; 514. Freedom Trail $\\star\\star\\star$ class Solution { public : int findRotateSteps ( string ring , string key ) { unordered_map < string , int > memo ; return dfs ( ring , key , 0 , memo ) + key . length (); } private : int dfs ( const string & ring , const string & key , int index , unordered_map < string , int >& memo ) { if ( index == key . length ()) return 0 ; const string hashKey = ring + to_string ( index ); if ( memo . count ( hashKey )) return memo [ hashKey ]; int ans = INT_MAX ; for ( int i = 0 ; i < ring . length (); ++ i ) if ( ring [ i ] == key [ index ]) { int diff = min ( i , ( int ) ring . length () - i ); int step = dfs ( ring . substr ( i ) + ring . substr ( 0 , i ), key , index + 1 , memo ); ans = min ( ans , diff + step ); } return memo [ hashKey ] = ans ; } }; 515. Find Largest Value in Each Tree Row $\\star\\star$ class Solution { public : vector < int > largestValues ( TreeNode * root ) { if ( ! root ) return {}; vector < int > ans ; queue < TreeNode *> queue {{ root }}; while ( ! queue . empty ()) { int max = INT_MIN ; for ( int i = queue . size (); i > 0 ; -- i ) { root = queue . front (), queue . pop (); max = std :: max ( max , root -> val ); if ( root -> left ) queue . push ( root -> left ); if ( root -> right ) queue . push ( root -> right ); } ans . push_back ( max ); } return ans ; } }; 516. Longest Palindromic Subsequence $\\star\\star$ 517. Super Washing Machines $\\star\\star\\star$ class Solution { public : int findMinMoves ( vector < int >& machines ) { int dresses = accumulate ( begin ( machines ), end ( machines ), 0 ); if ( dresses % machines . size () != 0 ) return - 1 ; int ans = 0 ; int average = dresses / machines . size (); int inout = 0 ; for ( int dress : machines ) { inout += dress - average ; ans = max ( ans , max ( abs ( inout ), dress - average )); } return ans ; } }; 518. Coin Change 2 $\\star\\star$ Time: $O(nk)$, where n = len(coins) and k = target Space: $O(k)$ class Solution { public : int change ( int amount , vector < int >& coins ) { vector < int > dp ( amount + 1 ); dp [ 0 ] = 1 ; for ( int coin : coins ) for ( int i = coin ; i <= amount ; ++ i ) dp [ i ] += dp [ i - coin ]; return dp [ amount ]; } }; 519. Random Flip Matrix $\\star\\star$ 520. Detect Capital $\\star$ class Solution { public : bool detectCapitalUse ( string word ) { for ( int i = 1 ; i < word . length (); ++ i ) if ( isupper ( word [ 1 ]) != isupper ( word [ i ]) || islower ( word [ 0 ]) && isupper ( word [ i ])) return false ; return true ; } };","title":"0511-0520"},{"location":"cpp/0501-0600/0511-0520/#511-game-play-analysis-i-star","text":"","title":"511. Game Play Analysis I $\\star$ \ud83d\udd12"},{"location":"cpp/0501-0600/0511-0520/#512-game-play-analysis-ii-star","text":"","title":"512. Game Play Analysis II $\\star$ \ud83d\udd12"},{"location":"cpp/0501-0600/0511-0520/#513-find-bottom-left-tree-value-starstar","text":"class Solution { public : int findBottomLeftValue ( TreeNode * root ) { queue < TreeNode *> queue {{ root }}; while ( ! queue . empty ()) { root = queue . front (), queue . pop (); if ( root -> right ) queue . push ( root -> right ); if ( root -> left ) queue . push ( root -> left ); } return root -> val ; } };","title":"513. Find Bottom Left Tree Value $\\star\\star$"},{"location":"cpp/0501-0600/0511-0520/#514-freedom-trail-starstarstar","text":"class Solution { public : int findRotateSteps ( string ring , string key ) { unordered_map < string , int > memo ; return dfs ( ring , key , 0 , memo ) + key . length (); } private : int dfs ( const string & ring , const string & key , int index , unordered_map < string , int >& memo ) { if ( index == key . length ()) return 0 ; const string hashKey = ring + to_string ( index ); if ( memo . count ( hashKey )) return memo [ hashKey ]; int ans = INT_MAX ; for ( int i = 0 ; i < ring . length (); ++ i ) if ( ring [ i ] == key [ index ]) { int diff = min ( i , ( int ) ring . length () - i ); int step = dfs ( ring . substr ( i ) + ring . substr ( 0 , i ), key , index + 1 , memo ); ans = min ( ans , diff + step ); } return memo [ hashKey ] = ans ; } };","title":"514. Freedom Trail $\\star\\star\\star$"},{"location":"cpp/0501-0600/0511-0520/#515-find-largest-value-in-each-tree-row-starstar","text":"class Solution { public : vector < int > largestValues ( TreeNode * root ) { if ( ! root ) return {}; vector < int > ans ; queue < TreeNode *> queue {{ root }}; while ( ! queue . empty ()) { int max = INT_MIN ; for ( int i = queue . size (); i > 0 ; -- i ) { root = queue . front (), queue . pop (); max = std :: max ( max , root -> val ); if ( root -> left ) queue . push ( root -> left ); if ( root -> right ) queue . push ( root -> right ); } ans . push_back ( max ); } return ans ; } };","title":"515. Find Largest Value in Each Tree Row $\\star\\star$"},{"location":"cpp/0501-0600/0511-0520/#516-longest-palindromic-subsequence-starstar","text":"","title":"516. Longest Palindromic Subsequence $\\star\\star$"},{"location":"cpp/0501-0600/0511-0520/#517-super-washing-machines-starstarstar","text":"class Solution { public : int findMinMoves ( vector < int >& machines ) { int dresses = accumulate ( begin ( machines ), end ( machines ), 0 ); if ( dresses % machines . size () != 0 ) return - 1 ; int ans = 0 ; int average = dresses / machines . size (); int inout = 0 ; for ( int dress : machines ) { inout += dress - average ; ans = max ( ans , max ( abs ( inout ), dress - average )); } return ans ; } };","title":"517. Super Washing Machines $\\star\\star\\star$"},{"location":"cpp/0501-0600/0511-0520/#518-coin-change-2-starstar","text":"Time: $O(nk)$, where n = len(coins) and k = target Space: $O(k)$ class Solution { public : int change ( int amount , vector < int >& coins ) { vector < int > dp ( amount + 1 ); dp [ 0 ] = 1 ; for ( int coin : coins ) for ( int i = coin ; i <= amount ; ++ i ) dp [ i ] += dp [ i - coin ]; return dp [ amount ]; } };","title":"518. Coin Change 2 $\\star\\star$"},{"location":"cpp/0501-0600/0511-0520/#519-random-flip-matrix-starstar","text":"","title":"519. Random Flip Matrix $\\star\\star$"},{"location":"cpp/0501-0600/0511-0520/#520-detect-capital-star","text":"class Solution { public : bool detectCapitalUse ( string word ) { for ( int i = 1 ; i < word . length (); ++ i ) if ( isupper ( word [ 1 ]) != isupper ( word [ i ]) || islower ( word [ 0 ]) && isupper ( word [ i ])) return false ; return true ; } };","title":"520. Detect Capital $\\star$"},{"location":"cpp/0501-0600/0521-0530/","text":"521. Longest Uncommon Subsequence I $\\star$ class Solution { public : int findLUSlength ( string a , string b ) { return a == b ? - 1 : max ( a . length (), b . length ()); } }; 522. Longest Uncommon Subsequence II $\\star\\star$ class Solution { public : int findLUSlength ( vector < string >& strs ) { unordered_set < string > seen ; unordered_set < string > duplicates ; for ( const string & str : strs ) { if ( seen . count ( str )) duplicates . insert ( str ); seen . insert ( str ); } sort ( begin ( strs ), end ( strs ), []( const auto & a , const auto & b ) { return a . length () > b . length (); }); for ( int i = 0 ; i < strs . size (); ++ i ) { if ( duplicates . count ( strs [ i ])) continue ; bool isASubsequence = false ; for ( int j = 0 ; j < i ; ++ j ) isASubsequence |= isSubsequence ( strs [ i ], strs [ j ]); if ( ! isASubsequence ) return strs [ i ]. length (); } return - 1 ; } private : bool isSubsequence ( const string & a , const string & b ) { int i = 0 ; for ( int j = 0 ; i < a . length () && j < b . length (); ++ j ) if ( a [ i ] == b [ j ]) ++ i ; return i == a . length (); } }; 523. Continuous Subarray Sum $\\star\\star$ class Solution { public : bool checkSubarraySum ( vector < int >& nums , int k ) { int prefixSum = 0 ; unordered_map < int , int > prefixSumToIndex {{ 0 , - 1 }}; for ( int i = 0 ; i < nums . size (); ++ i ) { prefixSum += nums [ i ]; if ( k != 0 ) prefixSum %= k ; if ( prefixSumToIndex . count ( prefixSum )) { if ( i - prefixSumToIndex [ prefixSum ] > 1 ) return true ; } else prefixSumToIndex [ prefixSum ] = i ; } return false ; } }; 524. Longest Word in Dictionary through Deleting $\\star\\star$ class Solution { public : string findLongestWord ( string s , vector < string >& d ) { string ans ; for ( const string & word : d ) { int i = 0 ; for ( char c : s ) if ( i < word . length () && c == word [ i ]) ++ i ; if ( i == word . length ()) if ( word . length () > ans . length () || word . length () == ans . length () && word . compare ( ans ) < 0 ) ans = word ; } return ans ; } }; 525. Contiguous Array $\\star\\star$ class Solution { public : int findMaxLength ( vector < int >& nums ) { int ans = 0 ; int prefixSum = 0 ; unordered_map < int , int > prefixSumToIndex {{ 0 , - 1 }}; for ( int i = 0 ; i < nums . size (); ++ i ) { prefixSum += nums [ i ] ? 1 : - 1 ; if ( prefixSumToIndex . count ( prefixSum )) ans = max ( ans , i - prefixSumToIndex [ prefixSum ]); else prefixSumToIndex [ prefixSum ] = i ; } return ans ; } }; 526. Beautiful Arrangement $\\star\\star$ 527. Word Abbreviation $\\star\\star\\star$ \ud83d\udd12 528. Random Pick with Weight $\\star\\star$ 529. Minesweeper $\\star\\star$ class Solution { public : vector < vector < char >> updateBoard ( vector < vector < char >>& board , vector < int >& click ) { if ( board [ click [ 0 ]][ click [ 1 ]] == 'M' ) { board [ click [ 0 ]][ click [ 1 ]] = 'X' ; return board ; } dfs ( board , click [ 0 ], click [ 1 ]); return board ; } private : vector < pair < int , int >> dirs {{ - 1 , - 1 }, { - 1 , 0 }, { - 1 , 1 }, { 0 , - 1 }, { 0 , 1 }, { 1 , - 1 }, { 1 , 0 }, { 1 , 1 }}; void dfs ( vector < vector < char >>& board , int i , int j ) { if ( i < 0 || i >= board . size () || j < 0 || j >= board [ 0 ]. size () || board [ i ][ j ] != 'E' ) return ; int minesCount = 0 ; for ( const auto & [ dx , dy ] : dirs ) { int x = i + dx ; int y = j + dy ; if ( 0 <= x && x < board . size () && 0 <= y && y < board [ 0 ]. size () && board [ x ][ y ] == 'M' ) ++ minesCount ; } board [ i ][ j ] = minesCount ? '0' + minesCount : 'B' ; if ( minesCount == 0 ) for ( const auto & [ dx , dy ] : dirs ) dfs ( board , i + dx , j + dy ); } }; 530. Minimum Absolute Difference in BST $\\star$","title":"0521-0530"},{"location":"cpp/0501-0600/0521-0530/#521-longest-uncommon-subsequence-i-star","text":"class Solution { public : int findLUSlength ( string a , string b ) { return a == b ? - 1 : max ( a . length (), b . length ()); } };","title":"521. Longest Uncommon Subsequence I  $\\star$"},{"location":"cpp/0501-0600/0521-0530/#522-longest-uncommon-subsequence-ii-starstar","text":"class Solution { public : int findLUSlength ( vector < string >& strs ) { unordered_set < string > seen ; unordered_set < string > duplicates ; for ( const string & str : strs ) { if ( seen . count ( str )) duplicates . insert ( str ); seen . insert ( str ); } sort ( begin ( strs ), end ( strs ), []( const auto & a , const auto & b ) { return a . length () > b . length (); }); for ( int i = 0 ; i < strs . size (); ++ i ) { if ( duplicates . count ( strs [ i ])) continue ; bool isASubsequence = false ; for ( int j = 0 ; j < i ; ++ j ) isASubsequence |= isSubsequence ( strs [ i ], strs [ j ]); if ( ! isASubsequence ) return strs [ i ]. length (); } return - 1 ; } private : bool isSubsequence ( const string & a , const string & b ) { int i = 0 ; for ( int j = 0 ; i < a . length () && j < b . length (); ++ j ) if ( a [ i ] == b [ j ]) ++ i ; return i == a . length (); } };","title":"522. Longest Uncommon Subsequence II $\\star\\star$"},{"location":"cpp/0501-0600/0521-0530/#523-continuous-subarray-sum-starstar","text":"class Solution { public : bool checkSubarraySum ( vector < int >& nums , int k ) { int prefixSum = 0 ; unordered_map < int , int > prefixSumToIndex {{ 0 , - 1 }}; for ( int i = 0 ; i < nums . size (); ++ i ) { prefixSum += nums [ i ]; if ( k != 0 ) prefixSum %= k ; if ( prefixSumToIndex . count ( prefixSum )) { if ( i - prefixSumToIndex [ prefixSum ] > 1 ) return true ; } else prefixSumToIndex [ prefixSum ] = i ; } return false ; } };","title":"523. Continuous Subarray Sum $\\star\\star$"},{"location":"cpp/0501-0600/0521-0530/#524-longest-word-in-dictionary-through-deleting-starstar","text":"class Solution { public : string findLongestWord ( string s , vector < string >& d ) { string ans ; for ( const string & word : d ) { int i = 0 ; for ( char c : s ) if ( i < word . length () && c == word [ i ]) ++ i ; if ( i == word . length ()) if ( word . length () > ans . length () || word . length () == ans . length () && word . compare ( ans ) < 0 ) ans = word ; } return ans ; } };","title":"524. Longest Word in Dictionary through Deleting $\\star\\star$"},{"location":"cpp/0501-0600/0521-0530/#525-contiguous-array-starstar","text":"class Solution { public : int findMaxLength ( vector < int >& nums ) { int ans = 0 ; int prefixSum = 0 ; unordered_map < int , int > prefixSumToIndex {{ 0 , - 1 }}; for ( int i = 0 ; i < nums . size (); ++ i ) { prefixSum += nums [ i ] ? 1 : - 1 ; if ( prefixSumToIndex . count ( prefixSum )) ans = max ( ans , i - prefixSumToIndex [ prefixSum ]); else prefixSumToIndex [ prefixSum ] = i ; } return ans ; } };","title":"525. Contiguous Array $\\star\\star$"},{"location":"cpp/0501-0600/0521-0530/#526-beautiful-arrangement-starstar","text":"","title":"526. Beautiful Arrangement $\\star\\star$"},{"location":"cpp/0501-0600/0521-0530/#527-word-abbreviation-starstarstar","text":"","title":"527. Word Abbreviation $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/0501-0600/0521-0530/#528-random-pick-with-weight-starstar","text":"","title":"528. Random Pick with Weight $\\star\\star$"},{"location":"cpp/0501-0600/0521-0530/#529-minesweeper-starstar","text":"class Solution { public : vector < vector < char >> updateBoard ( vector < vector < char >>& board , vector < int >& click ) { if ( board [ click [ 0 ]][ click [ 1 ]] == 'M' ) { board [ click [ 0 ]][ click [ 1 ]] = 'X' ; return board ; } dfs ( board , click [ 0 ], click [ 1 ]); return board ; } private : vector < pair < int , int >> dirs {{ - 1 , - 1 }, { - 1 , 0 }, { - 1 , 1 }, { 0 , - 1 }, { 0 , 1 }, { 1 , - 1 }, { 1 , 0 }, { 1 , 1 }}; void dfs ( vector < vector < char >>& board , int i , int j ) { if ( i < 0 || i >= board . size () || j < 0 || j >= board [ 0 ]. size () || board [ i ][ j ] != 'E' ) return ; int minesCount = 0 ; for ( const auto & [ dx , dy ] : dirs ) { int x = i + dx ; int y = j + dy ; if ( 0 <= x && x < board . size () && 0 <= y && y < board [ 0 ]. size () && board [ x ][ y ] == 'M' ) ++ minesCount ; } board [ i ][ j ] = minesCount ? '0' + minesCount : 'B' ; if ( minesCount == 0 ) for ( const auto & [ dx , dy ] : dirs ) dfs ( board , i + dx , j + dy ); } };","title":"529. Minesweeper $\\star\\star$"},{"location":"cpp/0501-0600/0521-0530/#530-minimum-absolute-difference-in-bst-star","text":"","title":"530. Minimum Absolute Difference in BST $\\star$"},{"location":"cpp/0501-0600/0531-0540/","text":"531. Lonely Pixel I $\\star\\star$ \ud83d\udd12 532. K-diff Pairs in an Array $\\star$ class Solution { public : int findPairs ( vector < int >& nums , int k ) { if ( k < 0 ) return 0 ; int ans = 0 ; unordered_map < int , int > map ; for ( int i = 0 ; i < nums . size (); ++ i ) map [ nums [ i ]] = i ; for ( int i = 0 ; i < nums . size (); ++ i ) { int target = nums [ i ] + k ; if ( map . count ( target ) && map [ target ] != i ) { ++ ans ; map . erase ( target ); } } return ans ; } }; 533. Lonely Pixel II $\\star\\star$ \ud83d\udd12 534. Game Play Analysis III $\\star\\star$ \ud83d\udd12 535. Encode and Decode TinyURL $\\star\\star$ class Solution { public : string encode ( string longUrl ) { while ( ! urlToCode . count ( longUrl )) { string code ; for ( int i = 0 ; i < 6 ; ++ i ) code += alphabets [ rand () % alphabets . size ()]; if ( ! codeToUrl . count ( code )) { codeToUrl [ code ] = longUrl ; urlToCode [ longUrl ] = code ; return \"http://tinyurl.com/\" + code ; } } throw ; } string decode ( string shortUrl ) { return codeToUrl [ shortUrl . substr ( 19 )]; } private : const string alphabets = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\" ; unordered_map < string , string > urlToCode ; unordered_map < string , string > codeToUrl ; }; 536. Construct Binary Tree from String $\\star\\star$ \ud83d\udd12 537. Complex Number Multiplication $\\star\\star$ class Solution { public : string complexNumberMultiply ( string a , string b ) { const auto & [ A , B ] = getRealAndImag ( a ); const auto & [ C , D ] = getRealAndImag ( b ); return to_string ( A * C - B * D ) + \"+\" + to_string ( A * D + B * C ) + \"i\" ; } private : pair < int , int > getRealAndImag ( const string & s ) { string real = s . substr ( 0 , s . find_first_of ( '+' )); string imag = s . substr ( s . find_first_of ( '+' ) + 1 ); return make_pair ( stoi ( real ), stoi ( imag )); } }; 538. Convert BST to Greater Tree $\\star$ 539. Minimum Time Difference $\\star\\star$ class Solution { public : int findMinDifference ( vector < string >& timePoints ) { int ans = 24 * 60 ; int first = 24 * 60 ; vector < bool > bucket ( 24 * 60 , false ); for ( const string & timePoint : timePoints ) { int num = stoi ( timePoint . substr ( 0 , 2 )) * 60 + stoi ( timePoint . substr ( 3 )); first = min ( first , num ); if ( bucket [ num ]) return 0 ; bucket [ num ] = true ; } int prev = first ; for ( int i = first + 1 ; i < bucket . size (); ++ i ) if ( bucket [ i ]) { ans = min ( ans , i - prev ); prev = i ; } return min ( ans , 24 * 60 - prev + first ); } }; 540. Single Element in a Sorted Array $\\star\\star$ class Solution { public : int singleNonDuplicate ( vector < int >& nums ) { int l = 0 ; int r = nums . size () - 1 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( m & 1 ) -- m ; if ( nums [ m ] == nums [ m + 1 ]) l = m + 2 ; else r = m ; } return nums [ l ]; } };","title":"0531-0540"},{"location":"cpp/0501-0600/0531-0540/#531-lonely-pixel-i-starstar","text":"","title":"531. Lonely Pixel I $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0501-0600/0531-0540/#532-k-diff-pairs-in-an-array-star","text":"class Solution { public : int findPairs ( vector < int >& nums , int k ) { if ( k < 0 ) return 0 ; int ans = 0 ; unordered_map < int , int > map ; for ( int i = 0 ; i < nums . size (); ++ i ) map [ nums [ i ]] = i ; for ( int i = 0 ; i < nums . size (); ++ i ) { int target = nums [ i ] + k ; if ( map . count ( target ) && map [ target ] != i ) { ++ ans ; map . erase ( target ); } } return ans ; } };","title":"532. K-diff Pairs in an Array $\\star$"},{"location":"cpp/0501-0600/0531-0540/#533-lonely-pixel-ii-starstar","text":"","title":"533. Lonely Pixel II $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0501-0600/0531-0540/#534-game-play-analysis-iii-starstar","text":"","title":"534. Game Play Analysis III $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0501-0600/0531-0540/#535-encode-and-decode-tinyurl-starstar","text":"class Solution { public : string encode ( string longUrl ) { while ( ! urlToCode . count ( longUrl )) { string code ; for ( int i = 0 ; i < 6 ; ++ i ) code += alphabets [ rand () % alphabets . size ()]; if ( ! codeToUrl . count ( code )) { codeToUrl [ code ] = longUrl ; urlToCode [ longUrl ] = code ; return \"http://tinyurl.com/\" + code ; } } throw ; } string decode ( string shortUrl ) { return codeToUrl [ shortUrl . substr ( 19 )]; } private : const string alphabets = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\" ; unordered_map < string , string > urlToCode ; unordered_map < string , string > codeToUrl ; };","title":"535. Encode and Decode TinyURL $\\star\\star$"},{"location":"cpp/0501-0600/0531-0540/#536-construct-binary-tree-from-string-starstar","text":"","title":"536. Construct Binary Tree from String $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0501-0600/0531-0540/#537-complex-number-multiplication-starstar","text":"class Solution { public : string complexNumberMultiply ( string a , string b ) { const auto & [ A , B ] = getRealAndImag ( a ); const auto & [ C , D ] = getRealAndImag ( b ); return to_string ( A * C - B * D ) + \"+\" + to_string ( A * D + B * C ) + \"i\" ; } private : pair < int , int > getRealAndImag ( const string & s ) { string real = s . substr ( 0 , s . find_first_of ( '+' )); string imag = s . substr ( s . find_first_of ( '+' ) + 1 ); return make_pair ( stoi ( real ), stoi ( imag )); } };","title":"537. Complex Number Multiplication $\\star\\star$"},{"location":"cpp/0501-0600/0531-0540/#538-convert-bst-to-greater-tree-star","text":"","title":"538. Convert BST to Greater Tree $\\star$"},{"location":"cpp/0501-0600/0531-0540/#539-minimum-time-difference-starstar","text":"class Solution { public : int findMinDifference ( vector < string >& timePoints ) { int ans = 24 * 60 ; int first = 24 * 60 ; vector < bool > bucket ( 24 * 60 , false ); for ( const string & timePoint : timePoints ) { int num = stoi ( timePoint . substr ( 0 , 2 )) * 60 + stoi ( timePoint . substr ( 3 )); first = min ( first , num ); if ( bucket [ num ]) return 0 ; bucket [ num ] = true ; } int prev = first ; for ( int i = first + 1 ; i < bucket . size (); ++ i ) if ( bucket [ i ]) { ans = min ( ans , i - prev ); prev = i ; } return min ( ans , 24 * 60 - prev + first ); } };","title":"539. Minimum Time Difference $\\star\\star$"},{"location":"cpp/0501-0600/0531-0540/#540-single-element-in-a-sorted-array-starstar","text":"class Solution { public : int singleNonDuplicate ( vector < int >& nums ) { int l = 0 ; int r = nums . size () - 1 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( m & 1 ) -- m ; if ( nums [ m ] == nums [ m + 1 ]) l = m + 2 ; else r = m ; } return nums [ l ]; } };","title":"540. Single Element in a Sorted Array $\\star\\star$"},{"location":"cpp/0501-0600/0541-0550/","text":"541. Reverse String II $\\star$ class Solution { public : string reverseStr ( string s , int k ) { for ( int i = 0 ; i < s . length (); i += 2 * k ) { int l = i ; int r = min ( i + k - 1 , ( int ) s . length () - 1 ); while ( l < r ) swap ( s [ l ++ ], s [ r -- ]); } return s ; } }; 542. 01 Matrix $\\star\\star$ class Solution { public : vector < vector < int >> updateMatrix ( vector < vector < int >>& matrix ) { const vector < int > dirs { 0 , 1 , 0 , - 1 , 0 }; queue < pair < int , int >> queue ; for ( int i = 0 ; i < matrix . size (); ++ i ) for ( int j = 0 ; j < matrix [ 0 ]. size (); ++ j ) if ( matrix [ i ][ j ] == 0 ) queue . push ({ i , j }); else matrix [ i ][ j ] = INT_MAX ; while ( ! queue . empty ()) { const auto [ i , j ] = queue . front (); queue . pop (); for ( int k = 0 ; k < 4 ; ++ k ) { int x = i + dirs [ k ]; int y = j + dirs [ k + 1 ]; if ( x < 0 || x >= matrix . size () || y < 0 || y >= matrix [ 0 ]. size () || matrix [ x ][ y ] <= matrix [ i ][ j ] + 1 ) continue ; queue . push ({ x , y }); matrix [ x ][ y ] = matrix [ i ][ j ] + 1 ; } } return matrix ; } }; 543. Diameter of Binary Tree $\\star$ 544. Output Contest Matches $\\star\\star$ \ud83d\udd12 545. Boundary of Binary Tree $\\star\\star$ \ud83d\udd12 546. Remove Boxes $\\star\\star\\star$ 547. Friend Circles $\\star\\star$ class UF { public : UF ( int n ) : rank ( n ), parent ( n ) { for ( int i = 0 ; i < parent . size (); ++ i ) parent [ i ] = i ; } void union_ ( int u , int v ) { int pu = find ( u ); int pv = find ( v ); if ( pu == pv ) return ; if ( rank [ pu ] < rank [ pv ]) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ]) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ]; } } int find ( int u ) { if ( u != parent [ u ]) parent [ u ] = find ( parent [ u ]); return parent [ u ]; } private : vector < int > rank ; vector < int > parent ; }; class Solution { public : int findCircleNum ( vector < vector < int >>& M ) { const int n = M . size (); UF uf ( n ); unordered_set < int > friendCircles ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = i ; j < n ; ++ j ) if ( M [ i ][ j ] == 1 ) uf . union_ ( i , j ); for ( int i = 0 ; i < n ; ++ i ) friendCircles . insert ( uf . find ( i )); return friendCircles . size (); } }; 548. Split Array with Equal Sum $\\star\\star$ \ud83d\udd12 549. Binary Tree Longest Consecutive Sequence II $\\star\\star$ \ud83d\udd12 550. Game Play Analysis IV $\\star\\star$ \ud83d\udd12","title":"0541-0550"},{"location":"cpp/0501-0600/0541-0550/#541-reverse-string-ii-star","text":"class Solution { public : string reverseStr ( string s , int k ) { for ( int i = 0 ; i < s . length (); i += 2 * k ) { int l = i ; int r = min ( i + k - 1 , ( int ) s . length () - 1 ); while ( l < r ) swap ( s [ l ++ ], s [ r -- ]); } return s ; } };","title":"541. Reverse String II $\\star$"},{"location":"cpp/0501-0600/0541-0550/#542-01-matrix-starstar","text":"class Solution { public : vector < vector < int >> updateMatrix ( vector < vector < int >>& matrix ) { const vector < int > dirs { 0 , 1 , 0 , - 1 , 0 }; queue < pair < int , int >> queue ; for ( int i = 0 ; i < matrix . size (); ++ i ) for ( int j = 0 ; j < matrix [ 0 ]. size (); ++ j ) if ( matrix [ i ][ j ] == 0 ) queue . push ({ i , j }); else matrix [ i ][ j ] = INT_MAX ; while ( ! queue . empty ()) { const auto [ i , j ] = queue . front (); queue . pop (); for ( int k = 0 ; k < 4 ; ++ k ) { int x = i + dirs [ k ]; int y = j + dirs [ k + 1 ]; if ( x < 0 || x >= matrix . size () || y < 0 || y >= matrix [ 0 ]. size () || matrix [ x ][ y ] <= matrix [ i ][ j ] + 1 ) continue ; queue . push ({ x , y }); matrix [ x ][ y ] = matrix [ i ][ j ] + 1 ; } } return matrix ; } };","title":"542. 01 Matrix $\\star\\star$"},{"location":"cpp/0501-0600/0541-0550/#543-diameter-of-binary-tree-star","text":"","title":"543. Diameter of Binary Tree $\\star$"},{"location":"cpp/0501-0600/0541-0550/#544-output-contest-matches-starstar","text":"","title":"544. Output Contest Matches $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0501-0600/0541-0550/#545-boundary-of-binary-tree-starstar","text":"","title":"545. Boundary of Binary Tree $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0501-0600/0541-0550/#546-remove-boxes-starstarstar","text":"","title":"546. Remove Boxes $\\star\\star\\star$"},{"location":"cpp/0501-0600/0541-0550/#547-friend-circles-starstar","text":"class UF { public : UF ( int n ) : rank ( n ), parent ( n ) { for ( int i = 0 ; i < parent . size (); ++ i ) parent [ i ] = i ; } void union_ ( int u , int v ) { int pu = find ( u ); int pv = find ( v ); if ( pu == pv ) return ; if ( rank [ pu ] < rank [ pv ]) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ]) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ]; } } int find ( int u ) { if ( u != parent [ u ]) parent [ u ] = find ( parent [ u ]); return parent [ u ]; } private : vector < int > rank ; vector < int > parent ; }; class Solution { public : int findCircleNum ( vector < vector < int >>& M ) { const int n = M . size (); UF uf ( n ); unordered_set < int > friendCircles ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = i ; j < n ; ++ j ) if ( M [ i ][ j ] == 1 ) uf . union_ ( i , j ); for ( int i = 0 ; i < n ; ++ i ) friendCircles . insert ( uf . find ( i )); return friendCircles . size (); } };","title":"547. Friend Circles $\\star\\star$"},{"location":"cpp/0501-0600/0541-0550/#548-split-array-with-equal-sum-starstar","text":"","title":"548. Split Array with Equal Sum $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0501-0600/0541-0550/#549-binary-tree-longest-consecutive-sequence-ii-starstar","text":"","title":"549. Binary Tree Longest Consecutive Sequence II $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0501-0600/0541-0550/#550-game-play-analysis-iv-starstar","text":"","title":"550. Game Play Analysis IV $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0501-0600/0551-0560/","text":"551. Student Attendance Record I $\\star$ class Solution { public : bool checkRecord ( string s ) { int countA = 0 ; int countL = 0 ; for ( char c : s ) { if ( c == 'A' && ++ countA > 1 ) return false ; if ( c != 'L' ) countL = 0 ; else if ( ++ countL > 2 ) return false ; } return true ; } }; 552. Student Attendance Record II $\\star\\star\\star$ 553. Optimal Division $\\star\\star$ class Solution { public : string optimalDivision ( vector < int >& nums ) { string ans = to_string ( nums [ 0 ]); if ( nums . size () == 1 ) return ans ; if ( nums . size () == 2 ) return ans + \"/\" + to_string ( nums [ 1 ]); ans += \"/(\" + to_string ( nums [ 1 ]); for ( int i = 2 ; i < nums . size (); ++ i ) ans += \"/\" + to_string ( nums [ i ]); ans += \")\" ; return ans ; } }; 554. Brick Wall $\\star\\star$ class Solution { public : int leastBricks ( vector < vector < int >>& wall ) { int maxFreq = 0 ; unordered_map < int , int > count ; for ( vector < int >& row : wall ) { int prefixSum = 0 ; for ( int i = 0 ; i < row . size () - 1 ; ++ i ) { prefixSum += row [ i ]; maxFreq = max ( maxFreq , ++ count [ prefixSum ]); } } return wall . size () - maxFreq ; } }; 555. Split Concatenated Strings $\\star\\star$ \ud83d\udd12 556. Next Greater Element III $\\star\\star$ class Solution { public : int nextGreaterElement ( int n ) { string s = nextPermutation ( to_string ( n )); long ans = stol ( s ); return ans > INT_MAX || ans <= n ? - 1 : ans ; } private : string nextPermutation ( string s ) { int i ; for ( i = s . length () - 2 ; i >= 0 ; -- i ) if ( s [ i ] < s [ i + 1 ]) break ; if ( i >= 0 ) { int j ; for ( j = s . length () - 1 ; j > i ; -- j ) if ( s [ j ] > s [ i ]) break ; swap ( s [ i ], s [ j ]); } reverse ( s , i + 1 , s . length () - 1 ); return s ; } void reverse ( string & s , int l , int r ) { while ( l < r ) swap ( s [ l ++ ], s [ r -- ]); } }; 557. Reverse Words in a String III $\\star$ class Solution { public : string reverseWords ( string s ) { int i = 0 ; int j = 0 ; while ( i < s . length ()) { while ( i < j || i < s . length () && s [ i ] == ' ' ) ++ i ; while ( j < i || j < s . length () && s [ j ] != ' ' ) ++ j ; reverse ( begin ( s ) + i , begin ( s ) + j ); } return s ; } }; 558. Logical OR of Two Binary Grids Represented as Quad-Trees $\\star\\star$ 559. Maximum Depth of N-ary Tree $\\star$ class Solution { public : int maxDepth ( Node * root ) { if ( ! root ) return 0 ; int ans = 0 ; for ( Node * child : root -> children ) ans = max ( ans , maxDepth ( child )); return 1 + ans ; } }; 560. Subarray Sum Equals K $\\star\\star$ class Solution { public : int subarraySum ( vector < int >& nums , int k ) { int ans = 0 ; int sum = 0 ; unordered_map < int , int > count {{ 0 , 1 }}; for ( int num : nums ) { sum += num ; if ( count . count ( sum - k )) ans += count [ sum - k ]; ++ count [ sum ]; } return ans ; } };","title":"0551-0560"},{"location":"cpp/0501-0600/0551-0560/#551-student-attendance-record-i-star","text":"class Solution { public : bool checkRecord ( string s ) { int countA = 0 ; int countL = 0 ; for ( char c : s ) { if ( c == 'A' && ++ countA > 1 ) return false ; if ( c != 'L' ) countL = 0 ; else if ( ++ countL > 2 ) return false ; } return true ; } };","title":"551. Student Attendance Record I $\\star$"},{"location":"cpp/0501-0600/0551-0560/#552-student-attendance-record-ii-starstarstar","text":"","title":"552. Student Attendance Record II $\\star\\star\\star$"},{"location":"cpp/0501-0600/0551-0560/#553-optimal-division-starstar","text":"class Solution { public : string optimalDivision ( vector < int >& nums ) { string ans = to_string ( nums [ 0 ]); if ( nums . size () == 1 ) return ans ; if ( nums . size () == 2 ) return ans + \"/\" + to_string ( nums [ 1 ]); ans += \"/(\" + to_string ( nums [ 1 ]); for ( int i = 2 ; i < nums . size (); ++ i ) ans += \"/\" + to_string ( nums [ i ]); ans += \")\" ; return ans ; } };","title":"553. Optimal Division $\\star\\star$"},{"location":"cpp/0501-0600/0551-0560/#554-brick-wall-starstar","text":"class Solution { public : int leastBricks ( vector < vector < int >>& wall ) { int maxFreq = 0 ; unordered_map < int , int > count ; for ( vector < int >& row : wall ) { int prefixSum = 0 ; for ( int i = 0 ; i < row . size () - 1 ; ++ i ) { prefixSum += row [ i ]; maxFreq = max ( maxFreq , ++ count [ prefixSum ]); } } return wall . size () - maxFreq ; } };","title":"554. Brick Wall $\\star\\star$"},{"location":"cpp/0501-0600/0551-0560/#555-split-concatenated-strings-starstar","text":"","title":"555. Split Concatenated Strings $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0501-0600/0551-0560/#556-next-greater-element-iii-starstar","text":"class Solution { public : int nextGreaterElement ( int n ) { string s = nextPermutation ( to_string ( n )); long ans = stol ( s ); return ans > INT_MAX || ans <= n ? - 1 : ans ; } private : string nextPermutation ( string s ) { int i ; for ( i = s . length () - 2 ; i >= 0 ; -- i ) if ( s [ i ] < s [ i + 1 ]) break ; if ( i >= 0 ) { int j ; for ( j = s . length () - 1 ; j > i ; -- j ) if ( s [ j ] > s [ i ]) break ; swap ( s [ i ], s [ j ]); } reverse ( s , i + 1 , s . length () - 1 ); return s ; } void reverse ( string & s , int l , int r ) { while ( l < r ) swap ( s [ l ++ ], s [ r -- ]); } };","title":"556. Next Greater Element III $\\star\\star$"},{"location":"cpp/0501-0600/0551-0560/#557-reverse-words-in-a-string-iii-star","text":"class Solution { public : string reverseWords ( string s ) { int i = 0 ; int j = 0 ; while ( i < s . length ()) { while ( i < j || i < s . length () && s [ i ] == ' ' ) ++ i ; while ( j < i || j < s . length () && s [ j ] != ' ' ) ++ j ; reverse ( begin ( s ) + i , begin ( s ) + j ); } return s ; } };","title":"557. Reverse Words in a String III $\\star$"},{"location":"cpp/0501-0600/0551-0560/#558-logical-or-of-two-binary-grids-represented-as-quad-trees-starstar","text":"","title":"558. Logical OR of Two Binary Grids Represented as Quad-Trees $\\star\\star$"},{"location":"cpp/0501-0600/0551-0560/#559-maximum-depth-of-n-ary-tree-star","text":"class Solution { public : int maxDepth ( Node * root ) { if ( ! root ) return 0 ; int ans = 0 ; for ( Node * child : root -> children ) ans = max ( ans , maxDepth ( child )); return 1 + ans ; } };","title":"559. Maximum Depth of N-ary Tree $\\star$"},{"location":"cpp/0501-0600/0551-0560/#560-subarray-sum-equals-k-starstar","text":"class Solution { public : int subarraySum ( vector < int >& nums , int k ) { int ans = 0 ; int sum = 0 ; unordered_map < int , int > count {{ 0 , 1 }}; for ( int num : nums ) { sum += num ; if ( count . count ( sum - k )) ans += count [ sum - k ]; ++ count [ sum ]; } return ans ; } };","title":"560. Subarray Sum Equals K $\\star\\star$"},{"location":"cpp/0501-0600/0561-0570/","text":"561. Array Partition I $\\star$ class Solution { public : int arrayPairSum ( vector < int >& nums ) { int ans = 0 ; sort ( begin ( nums ), end ( nums )); for ( int i = 0 ; i < nums . size (); i += 2 ) ans += nums [ i ]; return ans ; } }; 562. Longest Line of Consecutive One in Matrix $\\star\\star$ \ud83d\udd12 563. Binary Tree Tilt $\\star$ 564. Find the Closest Palindrome $\\star\\star\\star$ class Solution { public : string nearestPalindromic ( string n ) { const auto & [ prevPalindrome , nextPalindrome ] = getPalindromes ( n ); return abs ( prevPalindrome - stoll ( n )) <= abs ( nextPalindrome - stoll ( n )) ? to_string ( prevPalindrome ) : to_string ( nextPalindrome ); } private : pair < long long , long long > getPalindromes ( const string & s ) { const long long num = stoll ( s ); const int n = s . length (); pair < long long , long long > palindromes ; string half = s . substr ( 0 , ( n + 1 ) / 2 ); string reversedHalf = reversed ( half . substr ( 0 , n / 2 )); long long candidate = stoll ( half + reversedHalf ); if ( candidate < num ) palindromes . first = candidate ; else { string prevHalf = to_string ( stoll ( half ) - 1 ); string reversedPrevHalf = reversed ( prevHalf . substr ( 0 , n / 2 )); if ( n % 2 == 0 && stoll ( prevHalf ) == 0 ) palindromes . first = 9 ; else if ( n % 2 == 0 && ( stoll ( prevHalf ) + 1 ) % 10 == 0 ) palindromes . first = stoll ( prevHalf + '9' + reversedPrevHalf ); else palindromes . first = stoll ( prevHalf + reversedPrevHalf ); } if ( candidate > num ) palindromes . second = candidate ; else { string nextHalf = to_string ( stoll ( half ) + 1 ); string reversedNextHalf = reversed ( nextHalf . substr ( 0 , n / 2 )); palindromes . second = stoll ( nextHalf + reversedNextHalf ); } return palindromes ; } string reversed ( const string & s ) { string r = s ; reverse ( begin ( r ), end ( r )); return r ; } }; 565. Array Nesting $\\star\\star$ class Solution { public : int arrayNesting ( vector < int >& nums ) { int ans = 0 ; for ( int num : nums ) { if ( num == - 1 ) continue ; int index = num ; int count = 0 ; while ( nums [ index ] != - 1 ) { int temp = index ; index = nums [ index ]; nums [ temp ] = - 1 ; ++ count ; } ans = max ( ans , count ); } return ans ; } }; 566. Reshape the Matrix $\\star$ class Solution { public : vector < vector < int >> matrixReshape ( vector < vector < int >>& nums , int r , int c ) { if ( nums . empty () || r * c != nums . size () * nums [ 0 ]. size ()) return nums ; vector < vector < int >> ans ( r , vector < int > ( c )); int k = 0 ; for ( vector < int >& row : nums ) for ( int num : row ) { ans [ k / c ][ k % c ] = num ; ++ k ; } return ans ; } }; 567. Permutation in String $\\star\\star$ class Solution { public : bool checkInclusion ( string s1 , string s2 ) { vector < int > count1 ( 26 ); int required = s1 . length (); for ( char c : s1 ) ++ count1 [ c - 'a' ]; for ( int r = 0 ; r < s2 . length (); ++ r ) { if ( -- count1 [ s2 [ r ] - 'a' ] >= 0 ) -- required ; if ( r >= s1 . length ()) if ( ++ count1 [ s2 [ r - s1 . length ()] - 'a' ] > 0 ) ++ required ; if ( required == 0 ) return true ; } return false ; } }; 568. Maximum Vacation Days $\\star\\star\\star$ \ud83d\udd12 569. Median Employee Salary $\\star\\star\\star$ \ud83d\udd12 570. Managers with at Least 5 Direct Reports $\\star\\star$ \ud83d\udd12","title":"0561-0570"},{"location":"cpp/0501-0600/0561-0570/#561-array-partition-i-star","text":"class Solution { public : int arrayPairSum ( vector < int >& nums ) { int ans = 0 ; sort ( begin ( nums ), end ( nums )); for ( int i = 0 ; i < nums . size (); i += 2 ) ans += nums [ i ]; return ans ; } };","title":"561. Array Partition I $\\star$"},{"location":"cpp/0501-0600/0561-0570/#562-longest-line-of-consecutive-one-in-matrix-starstar","text":"","title":"562. Longest Line of Consecutive One in Matrix $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0501-0600/0561-0570/#563-binary-tree-tilt-star","text":"","title":"563. Binary Tree Tilt $\\star$"},{"location":"cpp/0501-0600/0561-0570/#564-find-the-closest-palindrome-starstarstar","text":"class Solution { public : string nearestPalindromic ( string n ) { const auto & [ prevPalindrome , nextPalindrome ] = getPalindromes ( n ); return abs ( prevPalindrome - stoll ( n )) <= abs ( nextPalindrome - stoll ( n )) ? to_string ( prevPalindrome ) : to_string ( nextPalindrome ); } private : pair < long long , long long > getPalindromes ( const string & s ) { const long long num = stoll ( s ); const int n = s . length (); pair < long long , long long > palindromes ; string half = s . substr ( 0 , ( n + 1 ) / 2 ); string reversedHalf = reversed ( half . substr ( 0 , n / 2 )); long long candidate = stoll ( half + reversedHalf ); if ( candidate < num ) palindromes . first = candidate ; else { string prevHalf = to_string ( stoll ( half ) - 1 ); string reversedPrevHalf = reversed ( prevHalf . substr ( 0 , n / 2 )); if ( n % 2 == 0 && stoll ( prevHalf ) == 0 ) palindromes . first = 9 ; else if ( n % 2 == 0 && ( stoll ( prevHalf ) + 1 ) % 10 == 0 ) palindromes . first = stoll ( prevHalf + '9' + reversedPrevHalf ); else palindromes . first = stoll ( prevHalf + reversedPrevHalf ); } if ( candidate > num ) palindromes . second = candidate ; else { string nextHalf = to_string ( stoll ( half ) + 1 ); string reversedNextHalf = reversed ( nextHalf . substr ( 0 , n / 2 )); palindromes . second = stoll ( nextHalf + reversedNextHalf ); } return palindromes ; } string reversed ( const string & s ) { string r = s ; reverse ( begin ( r ), end ( r )); return r ; } };","title":"564. Find the Closest Palindrome $\\star\\star\\star$"},{"location":"cpp/0501-0600/0561-0570/#565-array-nesting-starstar","text":"class Solution { public : int arrayNesting ( vector < int >& nums ) { int ans = 0 ; for ( int num : nums ) { if ( num == - 1 ) continue ; int index = num ; int count = 0 ; while ( nums [ index ] != - 1 ) { int temp = index ; index = nums [ index ]; nums [ temp ] = - 1 ; ++ count ; } ans = max ( ans , count ); } return ans ; } };","title":"565. Array Nesting $\\star\\star$"},{"location":"cpp/0501-0600/0561-0570/#566-reshape-the-matrix-star","text":"class Solution { public : vector < vector < int >> matrixReshape ( vector < vector < int >>& nums , int r , int c ) { if ( nums . empty () || r * c != nums . size () * nums [ 0 ]. size ()) return nums ; vector < vector < int >> ans ( r , vector < int > ( c )); int k = 0 ; for ( vector < int >& row : nums ) for ( int num : row ) { ans [ k / c ][ k % c ] = num ; ++ k ; } return ans ; } };","title":"566. Reshape the Matrix $\\star$"},{"location":"cpp/0501-0600/0561-0570/#567-permutation-in-string-starstar","text":"class Solution { public : bool checkInclusion ( string s1 , string s2 ) { vector < int > count1 ( 26 ); int required = s1 . length (); for ( char c : s1 ) ++ count1 [ c - 'a' ]; for ( int r = 0 ; r < s2 . length (); ++ r ) { if ( -- count1 [ s2 [ r ] - 'a' ] >= 0 ) -- required ; if ( r >= s1 . length ()) if ( ++ count1 [ s2 [ r - s1 . length ()] - 'a' ] > 0 ) ++ required ; if ( required == 0 ) return true ; } return false ; } };","title":"567. Permutation in String $\\star\\star$"},{"location":"cpp/0501-0600/0561-0570/#568-maximum-vacation-days-starstarstar","text":"","title":"568. Maximum Vacation Days $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/0501-0600/0561-0570/#569-median-employee-salary-starstarstar","text":"","title":"569. Median Employee Salary $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/0501-0600/0561-0570/#570-managers-with-at-least-5-direct-reports-starstar","text":"","title":"570. Managers with at Least 5 Direct Reports $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0501-0600/0571-0580/","text":"571. Find Median Given Frequency of Numbers $\\star\\star\\star$ \ud83d\udd12 572. Subtree of Another Tree $\\star$ 573. Squirrel Simulation $\\star\\star$ \ud83d\udd12 574. Winning Candidate $\\star\\star$ \ud83d\udd12 575. Distribute Candies $\\star$ class Solution { public : int distributeCandies ( vector < int >& candies ) { bitset < 200001 > bitset ; for ( int candy : candies ) bitset . set ( candy + 100000 ); return min ( candies . size () / 2 , bitset . count ()); } }; 576. Out of Boundary Paths $\\star\\star$ 577. Employee Bonus $\\star$ \ud83d\udd12 578. Get Highest Answer Rate Question $\\star\\star$ \ud83d\udd12 579. Find Cumulative Salary of an Employee $\\star\\star\\star$ \ud83d\udd12 580. Count Student Number in Departments $\\star\\star$ \ud83d\udd12","title":"0571-0580"},{"location":"cpp/0501-0600/0571-0580/#571-find-median-given-frequency-of-numbers-starstarstar","text":"","title":"571. Find Median Given Frequency of Numbers $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/0501-0600/0571-0580/#572-subtree-of-another-tree-star","text":"","title":"572. Subtree of Another Tree $\\star$"},{"location":"cpp/0501-0600/0571-0580/#573-squirrel-simulation-starstar","text":"","title":"573. Squirrel Simulation $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0501-0600/0571-0580/#574-winning-candidate-starstar","text":"","title":"574. Winning Candidate $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0501-0600/0571-0580/#575-distribute-candies-star","text":"class Solution { public : int distributeCandies ( vector < int >& candies ) { bitset < 200001 > bitset ; for ( int candy : candies ) bitset . set ( candy + 100000 ); return min ( candies . size () / 2 , bitset . count ()); } };","title":"575. Distribute Candies $\\star$"},{"location":"cpp/0501-0600/0571-0580/#576-out-of-boundary-paths-starstar","text":"","title":"576. Out of Boundary Paths $\\star\\star$"},{"location":"cpp/0501-0600/0571-0580/#577-employee-bonus-star","text":"","title":"577. Employee Bonus $\\star$ \ud83d\udd12"},{"location":"cpp/0501-0600/0571-0580/#578-get-highest-answer-rate-question-starstar","text":"","title":"578. Get Highest Answer Rate Question $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0501-0600/0571-0580/#579-find-cumulative-salary-of-an-employee-starstarstar","text":"","title":"579. Find Cumulative Salary of an Employee $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/0501-0600/0571-0580/#580-count-student-number-in-departments-starstar","text":"","title":"580. Count Student Number in Departments $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0501-0600/0581-0590/","text":"581. Shortest Unsorted Continuous Subarray $\\star$ class Solution { public : int findUnsortedSubarray ( vector < int >& nums ) { int min = INT_MAX ; int max = INT_MIN ; bool flag = false ; for ( int i = 1 ; i < nums . size (); ++ i ) { if ( nums [ i ] < nums [ i - 1 ]) flag = true ; if ( flag ) min = std :: min ( min , nums [ i ]); } flag = false ; for ( int i = nums . size () - 2 ; i >= 0 ; -- i ) { if ( nums [ i ] > nums [ i + 1 ]) flag = true ; if ( flag ) max = std :: max ( max , nums [ i ]); } int l ; for ( l = 0 ; l < nums . size (); ++ l ) if ( nums [ l ] > min ) break ; int r ; for ( r = nums . size () - 1 ; r >= 0 ; -- r ) if ( nums [ r ] < max ) break ; return l > r ? 0 : r - l + 1 ; } }; 582. Kill Process $\\star\\star$ \ud83d\udd12 583. Delete Operation for Two Strings $\\star\\star$ 584. Find Customer Referee $\\star$ \ud83d\udd12 585. Investments in 2016 $\\star\\star$ \ud83d\udd12 586. Customer Placing the Largest Number of Orders $\\star$ \ud83d\udd12 587. Erect the Fence $\\star\\star\\star$ 588. Design In-Memory File System $\\star\\star\\star$ \ud83d\udd12 589. N-ary Tree Preorder Traversal $\\star$ 590. N-ary Tree Postorder Traversal $\\star$","title":"0581-0590"},{"location":"cpp/0501-0600/0581-0590/#581-shortest-unsorted-continuous-subarray-star","text":"class Solution { public : int findUnsortedSubarray ( vector < int >& nums ) { int min = INT_MAX ; int max = INT_MIN ; bool flag = false ; for ( int i = 1 ; i < nums . size (); ++ i ) { if ( nums [ i ] < nums [ i - 1 ]) flag = true ; if ( flag ) min = std :: min ( min , nums [ i ]); } flag = false ; for ( int i = nums . size () - 2 ; i >= 0 ; -- i ) { if ( nums [ i ] > nums [ i + 1 ]) flag = true ; if ( flag ) max = std :: max ( max , nums [ i ]); } int l ; for ( l = 0 ; l < nums . size (); ++ l ) if ( nums [ l ] > min ) break ; int r ; for ( r = nums . size () - 1 ; r >= 0 ; -- r ) if ( nums [ r ] < max ) break ; return l > r ? 0 : r - l + 1 ; } };","title":"581. Shortest Unsorted Continuous Subarray $\\star$"},{"location":"cpp/0501-0600/0581-0590/#582-kill-process-starstar","text":"","title":"582. Kill Process $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0501-0600/0581-0590/#583-delete-operation-for-two-strings-starstar","text":"","title":"583. Delete Operation for Two Strings $\\star\\star$"},{"location":"cpp/0501-0600/0581-0590/#584-find-customer-referee-star","text":"","title":"584. Find Customer Referee $\\star$ \ud83d\udd12"},{"location":"cpp/0501-0600/0581-0590/#585-investments-in-2016-starstar","text":"","title":"585. Investments in 2016 $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0501-0600/0581-0590/#586-customer-placing-the-largest-number-of-orders-star","text":"","title":"586. Customer Placing the Largest Number of Orders $\\star$ \ud83d\udd12"},{"location":"cpp/0501-0600/0581-0590/#587-erect-the-fence-starstarstar","text":"","title":"587. Erect the Fence $\\star\\star\\star$"},{"location":"cpp/0501-0600/0581-0590/#588-design-in-memory-file-system-starstarstar","text":"","title":"588. Design In-Memory File System $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/0501-0600/0581-0590/#589-n-ary-tree-preorder-traversal-star","text":"","title":"589. N-ary Tree Preorder Traversal $\\star$"},{"location":"cpp/0501-0600/0581-0590/#590-n-ary-tree-postorder-traversal-star","text":"","title":"590. N-ary Tree Postorder Traversal $\\star$"},{"location":"cpp/0501-0600/0591-0600/","text":"591. Tag Validator $\\star\\star\\star$ 592. Fraction Addition and Subtraction $\\star\\star$ class Solution { public : string fractionAddition ( string expression ) { istringstream iss ( expression ); char _ ; int a ; int b ; int A = 0 ; int B = 1 ; while ( iss >> a >> _ >> b ) { A = A * b + a * B ; B *= b ; int g = abs ( __gcd ( A , B )); A /= g ; B /= g ; } return to_string ( A ) + \"/\" + to_string ( B ); } }; 593. Valid Square $\\star\\star$ class Solution { public : bool validSquare ( vector < int >& p1 , vector < int >& p2 , vector < int >& p3 , vector < int >& p4 ) { set < int > distSet ; vector < vector < int >> points { p1 , p2 , p3 , p4 }; for ( int i = 0 ; i < 4 ; ++ i ) for ( int j = i + 1 ; j < 4 ; ++ j ) distSet . insert ( dist ( points [ i ], points [ j ])); return ! distSet . count ( 0 ) && distSet . size () == 2 ; } private : int dist ( vector < int >& p1 , vector < int >& p2 ) { return ( p1 [ 0 ] - p2 [ 0 ]) * ( p1 [ 0 ] - p2 [ 0 ]) + ( p1 [ 1 ] - p2 [ 1 ]) * ( p1 [ 1 ] - p2 [ 1 ]); } }; 594. Longest Harmonious Subsequence $\\star$ class Solution { public : int findLHS ( vector < int >& nums ) { int ans = 0 ; unordered_map < int , int > count ; for ( int num : nums ) ++ count [ num ]; for ( const auto & [ num , freq ] : count ) if ( count . count ( num + 1 )) ans = max ( ans , freq + count [ num + 1 ]); return ans ; } }; 595. Big Countries $\\star$ 596. Classes More Than 5 Students $\\star$ 597. Friend Requests I: Overall Acceptance Rate $\\star$ \ud83d\udd12 598. Range Addition II $\\star$ class Solution { public : int maxCount ( int m , int n , vector < vector < int >>& ops ) { int minY = m ; int minX = n ; for ( vector < int >& op : ops ) { minY = min ( minY , op [ 0 ]); minX = min ( minX , op [ 1 ]); } return minX * minY ; } }; 599. Minimum Index Sum of Two Lists $\\star$ class Solution { public : vector < string > findRestaurant ( vector < string >& list1 , vector < string >& list2 ) { vector < string > ans ; unordered_map < string , int > restaurantToIndex ; int minSum = INT_MAX ; for ( int i = 0 ; i < list1 . size (); ++ i ) restaurantToIndex [ list1 [ i ]] = i ; for ( int i = 0 ; i < list2 . size (); ++ i ) { if ( restaurantToIndex . count ( list2 [ i ])) { int sum = restaurantToIndex [ list2 [ i ]] + i ; if ( sum < minSum ) ans . clear (); if ( sum <= minSum ) { ans . push_back ( list2 [ i ]); minSum = sum ; } } } return ans ; } }; 600. Non-negative Integers without Consecutive Ones $\\star\\star\\star$","title":"0591-0600"},{"location":"cpp/0501-0600/0591-0600/#591-tag-validator-starstarstar","text":"","title":"591. Tag Validator $\\star\\star\\star$"},{"location":"cpp/0501-0600/0591-0600/#592-fraction-addition-and-subtraction-starstar","text":"class Solution { public : string fractionAddition ( string expression ) { istringstream iss ( expression ); char _ ; int a ; int b ; int A = 0 ; int B = 1 ; while ( iss >> a >> _ >> b ) { A = A * b + a * B ; B *= b ; int g = abs ( __gcd ( A , B )); A /= g ; B /= g ; } return to_string ( A ) + \"/\" + to_string ( B ); } };","title":"592. Fraction Addition and Subtraction $\\star\\star$"},{"location":"cpp/0501-0600/0591-0600/#593-valid-square-starstar","text":"class Solution { public : bool validSquare ( vector < int >& p1 , vector < int >& p2 , vector < int >& p3 , vector < int >& p4 ) { set < int > distSet ; vector < vector < int >> points { p1 , p2 , p3 , p4 }; for ( int i = 0 ; i < 4 ; ++ i ) for ( int j = i + 1 ; j < 4 ; ++ j ) distSet . insert ( dist ( points [ i ], points [ j ])); return ! distSet . count ( 0 ) && distSet . size () == 2 ; } private : int dist ( vector < int >& p1 , vector < int >& p2 ) { return ( p1 [ 0 ] - p2 [ 0 ]) * ( p1 [ 0 ] - p2 [ 0 ]) + ( p1 [ 1 ] - p2 [ 1 ]) * ( p1 [ 1 ] - p2 [ 1 ]); } };","title":"593. Valid Square $\\star\\star$"},{"location":"cpp/0501-0600/0591-0600/#594-longest-harmonious-subsequence-star","text":"class Solution { public : int findLHS ( vector < int >& nums ) { int ans = 0 ; unordered_map < int , int > count ; for ( int num : nums ) ++ count [ num ]; for ( const auto & [ num , freq ] : count ) if ( count . count ( num + 1 )) ans = max ( ans , freq + count [ num + 1 ]); return ans ; } };","title":"594. Longest Harmonious Subsequence $\\star$"},{"location":"cpp/0501-0600/0591-0600/#595-big-countries-star","text":"","title":"595. Big Countries $\\star$"},{"location":"cpp/0501-0600/0591-0600/#596-classes-more-than-5-students-star","text":"","title":"596. Classes More Than 5 Students $\\star$"},{"location":"cpp/0501-0600/0591-0600/#597-friend-requests-i-overall-acceptance-rate-star","text":"","title":"597. Friend Requests I: Overall Acceptance Rate $\\star$ \ud83d\udd12"},{"location":"cpp/0501-0600/0591-0600/#598-range-addition-ii-star","text":"class Solution { public : int maxCount ( int m , int n , vector < vector < int >>& ops ) { int minY = m ; int minX = n ; for ( vector < int >& op : ops ) { minY = min ( minY , op [ 0 ]); minX = min ( minX , op [ 1 ]); } return minX * minY ; } };","title":"598. Range Addition II $\\star$"},{"location":"cpp/0501-0600/0591-0600/#599-minimum-index-sum-of-two-lists-star","text":"class Solution { public : vector < string > findRestaurant ( vector < string >& list1 , vector < string >& list2 ) { vector < string > ans ; unordered_map < string , int > restaurantToIndex ; int minSum = INT_MAX ; for ( int i = 0 ; i < list1 . size (); ++ i ) restaurantToIndex [ list1 [ i ]] = i ; for ( int i = 0 ; i < list2 . size (); ++ i ) { if ( restaurantToIndex . count ( list2 [ i ])) { int sum = restaurantToIndex [ list2 [ i ]] + i ; if ( sum < minSum ) ans . clear (); if ( sum <= minSum ) { ans . push_back ( list2 [ i ]); minSum = sum ; } } } return ans ; } };","title":"599. Minimum Index Sum of Two Lists $\\star$"},{"location":"cpp/0501-0600/0591-0600/#600-non-negative-integers-without-consecutive-ones-starstarstar","text":"","title":"600. Non-negative Integers without Consecutive Ones $\\star\\star\\star$"},{"location":"cpp/0601-0700/0601-0610/","text":"601. Human Traffic of Stadium $\\star\\star\\star$ 602. Friend Requests II: Who Has the Most Friends $\\star\\star$ \ud83d\udd12 603. Consecutive Available Seats $\\star$ \ud83d\udd12 604. Design Compressed String Iterator $\\star$ \ud83d\udd12 605. Can Place Flowers $\\star$ class Solution { public : bool canPlaceFlowers ( vector < int >& flowerbed , int n ) { for ( int i = 0 ; i < flowerbed . size (); ++ i ) { if ( flowerbed [ i ] == 0 && ( i == 0 || flowerbed [ i - 1 ] == 0 ) && ( i == flowerbed . size () - 1 || flowerbed [ i + 1 ] == 0 )) { flowerbed [ i ] = 1 ; -- n ; } if ( n <= 0 ) return true ; } return false ; } }; 606. Construct String from Binary Tree $\\star$ class Solution { public : string tree2str ( TreeNode * t ) { return dfs ( t ); } private : string dfs ( TreeNode * root ) { if ( ! root ) return \"\" ; if ( root -> right ) return to_string ( root -> val ) + \"(\" + dfs ( root -> left ) + \")(\" + dfs ( root -> right ) + \")\" ; if ( root -> left ) return to_string ( root -> val ) + \"(\" + dfs ( root -> left ) + \")\" ; return to_string ( root -> val ); } }; 607. Sales Person $\\star$ \ud83d\udd12 608. Tree Node $\\star\\star$ \ud83d\udd12 609. Find Duplicate File in System $\\star\\star$ class Solution { public : vector < vector < string >> findDuplicate ( vector < string >& paths ) { vector < vector < string >> ans ; unordered_map < string , vector < string >> files ; for ( const string & path : paths ) { stringstream ss ( path ); string root ; string s ; getline ( ss , root , ' ' ); while ( getline ( ss , s , ' ' )) { string filePath = root + '/' + s . substr ( 0 , s . find ( '(' )); string fileContent = s . substr ( s . find ( '(' ) + 1 , s . find ( ')' ) - s . find ( '(' ) - 1 ); files [ fileContent ]. push_back ( filePath ); } } for ( const auto & [ _ , filePath ] : files ) if ( filePath . size () > 1 ) ans . push_back ( filePath ); return ans ; } }; 610. Triangle Judgement $\\star$ \ud83d\udd12","title":"0601-0610"},{"location":"cpp/0601-0700/0601-0610/#601-human-traffic-of-stadium-starstarstar","text":"","title":"601. Human Traffic of Stadium $\\star\\star\\star$"},{"location":"cpp/0601-0700/0601-0610/#602-friend-requests-ii-who-has-the-most-friends-starstar","text":"","title":"602. Friend Requests II: Who Has the Most Friends $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0601-0700/0601-0610/#603-consecutive-available-seats-star","text":"","title":"603. Consecutive Available Seats $\\star$ \ud83d\udd12"},{"location":"cpp/0601-0700/0601-0610/#604-design-compressed-string-iterator-star","text":"","title":"604. Design Compressed String Iterator $\\star$ \ud83d\udd12"},{"location":"cpp/0601-0700/0601-0610/#605-can-place-flowers-star","text":"class Solution { public : bool canPlaceFlowers ( vector < int >& flowerbed , int n ) { for ( int i = 0 ; i < flowerbed . size (); ++ i ) { if ( flowerbed [ i ] == 0 && ( i == 0 || flowerbed [ i - 1 ] == 0 ) && ( i == flowerbed . size () - 1 || flowerbed [ i + 1 ] == 0 )) { flowerbed [ i ] = 1 ; -- n ; } if ( n <= 0 ) return true ; } return false ; } };","title":"605. Can Place Flowers $\\star$"},{"location":"cpp/0601-0700/0601-0610/#606-construct-string-from-binary-tree-star","text":"class Solution { public : string tree2str ( TreeNode * t ) { return dfs ( t ); } private : string dfs ( TreeNode * root ) { if ( ! root ) return \"\" ; if ( root -> right ) return to_string ( root -> val ) + \"(\" + dfs ( root -> left ) + \")(\" + dfs ( root -> right ) + \")\" ; if ( root -> left ) return to_string ( root -> val ) + \"(\" + dfs ( root -> left ) + \")\" ; return to_string ( root -> val ); } };","title":"606. Construct String from Binary Tree $\\star$"},{"location":"cpp/0601-0700/0601-0610/#607-sales-person-star","text":"","title":"607. Sales Person $\\star$ \ud83d\udd12"},{"location":"cpp/0601-0700/0601-0610/#608-tree-node-starstar","text":"","title":"608. Tree Node $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0601-0700/0601-0610/#609-find-duplicate-file-in-system-starstar","text":"class Solution { public : vector < vector < string >> findDuplicate ( vector < string >& paths ) { vector < vector < string >> ans ; unordered_map < string , vector < string >> files ; for ( const string & path : paths ) { stringstream ss ( path ); string root ; string s ; getline ( ss , root , ' ' ); while ( getline ( ss , s , ' ' )) { string filePath = root + '/' + s . substr ( 0 , s . find ( '(' )); string fileContent = s . substr ( s . find ( '(' ) + 1 , s . find ( ')' ) - s . find ( '(' ) - 1 ); files [ fileContent ]. push_back ( filePath ); } } for ( const auto & [ _ , filePath ] : files ) if ( filePath . size () > 1 ) ans . push_back ( filePath ); return ans ; } };","title":"609. Find Duplicate File in System $\\star\\star$"},{"location":"cpp/0601-0700/0601-0610/#610-triangle-judgement-star","text":"","title":"610. Triangle Judgement $\\star$ \ud83d\udd12"},{"location":"cpp/0601-0700/0611-0620/","text":"611. Valid Triangle Number $\\star\\star$ class Solution { public : int triangleNumber ( vector < int >& nums ) { int ans = 0 ; sort ( begin ( nums ), end ( nums )); for ( int k = nums . size () - 1 ; k > 1 ; -- k ) for ( int i = 0 , j = k - 1 ; i < j ;) { if ( nums [ i ] + nums [ j ] > nums [ k ]) { ans += j - i ; -- j ; } else ++ i ; } return ans ; } }; 612. Shortest Distance in a Plane $\\star\\star$ \ud83d\udd12 613. Shortest Distance in a Line $\\star$ \ud83d\udd12 614. Second Degree Follower $\\star\\star$ \ud83d\udd12 615. Average Salary: Departments VS Company $\\star\\star\\star$ \ud83d\udd12 616. Add Bold Tag in String $\\star\\star$ \ud83d\udd12 617. Merge Two Binary Trees $\\star$ 618. Students Report By Geography $\\star\\star\\star$ \ud83d\udd12 619. Biggest Single Number $\\star$ \ud83d\udd12 620. Not Boring Movies $\\star$","title":"0611-0620"},{"location":"cpp/0601-0700/0611-0620/#611-valid-triangle-number-starstar","text":"class Solution { public : int triangleNumber ( vector < int >& nums ) { int ans = 0 ; sort ( begin ( nums ), end ( nums )); for ( int k = nums . size () - 1 ; k > 1 ; -- k ) for ( int i = 0 , j = k - 1 ; i < j ;) { if ( nums [ i ] + nums [ j ] > nums [ k ]) { ans += j - i ; -- j ; } else ++ i ; } return ans ; } };","title":"611. Valid Triangle Number $\\star\\star$"},{"location":"cpp/0601-0700/0611-0620/#612-shortest-distance-in-a-plane-starstar","text":"","title":"612. Shortest Distance in a Plane $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0601-0700/0611-0620/#613-shortest-distance-in-a-line-star","text":"","title":"613. Shortest Distance in a Line $\\star$ \ud83d\udd12"},{"location":"cpp/0601-0700/0611-0620/#614-second-degree-follower-starstar","text":"","title":"614. Second Degree Follower $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0601-0700/0611-0620/#615-average-salary-departments-vs-company-starstarstar","text":"","title":"615. Average Salary: Departments VS Company $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/0601-0700/0611-0620/#616-add-bold-tag-in-string-starstar","text":"","title":"616. Add Bold Tag in String $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0601-0700/0611-0620/#617-merge-two-binary-trees-star","text":"","title":"617. Merge Two Binary Trees $\\star$"},{"location":"cpp/0601-0700/0611-0620/#618-students-report-by-geography-starstarstar","text":"","title":"618. Students Report By Geography $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/0601-0700/0611-0620/#619-biggest-single-number-star","text":"","title":"619. Biggest Single Number $\\star$ \ud83d\udd12"},{"location":"cpp/0601-0700/0611-0620/#620-not-boring-movies-star","text":"","title":"620. Not Boring Movies $\\star$"},{"location":"cpp/0601-0700/0621-0630/","text":"621. Task Scheduler $\\star\\star$ class Solution { public : int leastInterval ( vector < char >& tasks , int n ) { vector < int > count ( 26 , 0 ); for ( char task : tasks ) ++ count [ task - 'A' ]; const int maxFreq = * max_element ( begin ( count ), end ( count )); int ans = ( maxFreq - 1 ) * ( n + 1 ); ans += count_if ( begin ( count ), end ( count ), [ maxFreq ]( int freq ) { return freq == maxFreq ; }); return max ( ans , ( int ) tasks . size ()); } }; 622. Design Circular Queue $\\star\\star$ 623. Add One Row to Tree $\\star\\star$ 624. Maximum Distance in Arrays $\\star$ \ud83d\udd12 625. Minimum Factorization $\\star\\star$ \ud83d\udd12 626. Exchange Seats $\\star\\star$ 627. Swap Salary $\\star$ 628. Maximum Product of Three Numbers $\\star$ class Solution { public : int maximumProduct ( vector < int >& nums ) { int min = INT_MAX ; int secondMin = INT_MAX ; int max = INT_MIN ; int secondMax = INT_MIN ; int thirdMax = INT_MIN ; for ( int num : nums ) { if ( num <= min ) { secondMin = min ; min = num ; } else if ( num <= secondMin ) secondMin = num ; if ( num >= max ) { thirdMax = secondMax ; secondMax = max ; max = num ; } else if ( num >= secondMax ) { thirdMax = secondMax ; secondMax = num ; } else if ( num >= thirdMax ) thirdMax = num ; } return std :: max ( min * secondMin * max , max * secondMax * thirdMax ); } }; 629. K Inverse Pairs Array $\\star\\star\\star$ 630. Course Schedule III $\\star\\star\\star$","title":"0621-0630"},{"location":"cpp/0601-0700/0621-0630/#621-task-scheduler-starstar","text":"class Solution { public : int leastInterval ( vector < char >& tasks , int n ) { vector < int > count ( 26 , 0 ); for ( char task : tasks ) ++ count [ task - 'A' ]; const int maxFreq = * max_element ( begin ( count ), end ( count )); int ans = ( maxFreq - 1 ) * ( n + 1 ); ans += count_if ( begin ( count ), end ( count ), [ maxFreq ]( int freq ) { return freq == maxFreq ; }); return max ( ans , ( int ) tasks . size ()); } };","title":"621. Task Scheduler $\\star\\star$"},{"location":"cpp/0601-0700/0621-0630/#622-design-circular-queue-starstar","text":"","title":"622. Design Circular Queue $\\star\\star$"},{"location":"cpp/0601-0700/0621-0630/#623-add-one-row-to-tree-starstar","text":"","title":"623. Add One Row to Tree $\\star\\star$"},{"location":"cpp/0601-0700/0621-0630/#624-maximum-distance-in-arrays-star","text":"","title":"624. Maximum Distance in Arrays $\\star$ \ud83d\udd12"},{"location":"cpp/0601-0700/0621-0630/#625-minimum-factorization-starstar","text":"","title":"625. Minimum Factorization $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0601-0700/0621-0630/#626-exchange-seats-starstar","text":"","title":"626. Exchange Seats $\\star\\star$"},{"location":"cpp/0601-0700/0621-0630/#627-swap-salary-star","text":"","title":"627. Swap Salary $\\star$"},{"location":"cpp/0601-0700/0621-0630/#628-maximum-product-of-three-numbers-star","text":"class Solution { public : int maximumProduct ( vector < int >& nums ) { int min = INT_MAX ; int secondMin = INT_MAX ; int max = INT_MIN ; int secondMax = INT_MIN ; int thirdMax = INT_MIN ; for ( int num : nums ) { if ( num <= min ) { secondMin = min ; min = num ; } else if ( num <= secondMin ) secondMin = num ; if ( num >= max ) { thirdMax = secondMax ; secondMax = max ; max = num ; } else if ( num >= secondMax ) { thirdMax = secondMax ; secondMax = num ; } else if ( num >= thirdMax ) thirdMax = num ; } return std :: max ( min * secondMin * max , max * secondMax * thirdMax ); } };","title":"628. Maximum Product of Three Numbers $\\star$"},{"location":"cpp/0601-0700/0621-0630/#629-k-inverse-pairs-array-starstarstar","text":"","title":"629. K Inverse Pairs Array $\\star\\star\\star$"},{"location":"cpp/0601-0700/0621-0630/#630-course-schedule-iii-starstarstar","text":"","title":"630. Course Schedule III $\\star\\star\\star$"},{"location":"cpp/0601-0700/0631-0640/","text":"631. Design Excel Sum Formula $\\star\\star\\star$ \ud83d\udd12 632. Smallest Range Covering Elements from K Lists $\\star\\star\\star$ class Solution { public : vector < int > smallestRange ( vector < vector < int >>& nums ) { auto compare = []( const Elem & a , const Elem & b ) { return a . value > b . value ; }; priority_queue < Elem , vector < Elem > , decltype ( compare ) > pq ( compare ); int maxRange = INT_MIN ; for ( int i = 0 ; i < nums . size (); ++ i ) { pq . push ( Elem ( nums [ i ][ 0 ], i , 0 )); maxRange = max ( maxRange , nums [ i ][ 0 ]); } int minRange = pq . top (). value ; vector < int > ans { minRange , maxRange }; while ( pq . size () == nums . size ()) { auto [ value , r , c ] = pq . top (); pq . pop (); if ( c + 1 < nums [ r ]. size ()) { pq . push ( Elem ( nums [ r ][ c + 1 ], r , c + 1 )); maxRange = max ( maxRange , nums [ r ][ c + 1 ]); minRange = pq . top (). value ; if ( maxRange - minRange < ans [ 1 ] - ans [ 0 ]) { ans [ 0 ] = minRange ; ans [ 1 ] = maxRange ; } } } return ans ; } private : struct Elem { int value ; int r ; int c ; Elem ( int value , int r , int c ) : value ( value ), r ( r ), c ( c ) {} }; }; 633. Sum of Square Numbers $\\star$ class Solution { public : bool judgeSquareSum ( int c ) { long l = 0 ; long r = sqrt ( c ); while ( l <= r ) { long sum = l * l + r * r ; if ( sum == c ) return true ; if ( sum < c ) ++ l ; else -- r ; } return false ; } }; 634. Find the Derangement of An Array $\\star\\star$ \ud83d\udd12 635. Design Log Storage System $\\star\\star$ \ud83d\udd12 636. Exclusive Time of Functions $\\star\\star$ 637. Average of Levels in Binary Tree $\\star$ 638. Shopping Offers $\\star\\star$ class Solution { public : int shoppingOffers ( vector < int >& price , vector < vector < int >>& special , vector < int >& needs ) { function < int ( int ) > dfs = [ & ]( int s ) { int ans = 0 ; for ( int i = 0 ; i < needs . size (); ++ i ) ans += needs [ i ] * price [ i ]; for ( int i = s ; i < special . size (); ++ i ) if ( isValid ( special [ i ], needs )) { for ( int j = 0 ; j < needs . size (); ++ j ) needs [ j ] -= special [ i ][ j ]; ans = min ( ans , special [ i ]. back () + dfs ( i )); for ( int j = 0 ; j < needs . size (); ++ j ) needs [ j ] += special [ i ][ j ]; } return ans ; }; return dfs ( 0 ); } private : bool isValid ( vector < int >& offer , vector < int >& needs ) { for ( int i = 0 ; i < needs . size (); ++ i ) if ( offer [ i ] > needs [ i ]) return false ; return true ; } }; 639. Decode Ways II $\\star\\star\\star$ class Solution { public : int numDecodings ( string s ) { if ( s . empty ()) return 0 ; const int kMod = 1e9 + 7 ; long dp1 = count ( s [ 0 ]); long dp2 = 1 ; for ( int i = 1 ; i < s . length (); ++ i ) { long dp = count ( s [ i ]) * dp1 + count ( s [ i - 1 ], s [ i ]) * dp2 ; dp %= kMod ; dp2 = dp1 ; dp1 = dp ; } return dp1 ; } private : int count ( char c ) { if ( c == '*' ) return 9 ; return c != '0' ; } int count ( char c1 , char c2 ) { if ( c1 == '*' && c2 == '*' ) return 15 ; if ( c1 == '*' ) return ( c2 >= '0' && c2 <= '6' ) ? 2 : 1 ; if ( c2 == '*' ) { if ( c1 == '1' ) return 9 ; if ( c1 == '2' ) return 6 ; return 0 ; } return c1 == '1' || ( c1 == '2' && c2 <= '6' ); } }; 640. Solve the Equation $\\star\\star$ class Solution { public : string solveEquation ( string equation ) { string lhsEquation = equation . substr ( 0 , equation . find_first_of ( '=' )); string rhsEquation = equation . substr ( equation . find_first_of ( '=' ) + 1 ); const auto & [ lhsCoefficient , lhsConstant ] = calculate ( lhsEquation ); const auto & [ rhsCoefficient , rhsConstant ] = calculate ( rhsEquation ); int coefficient = lhsCoefficient - rhsCoefficient ; int constant = rhsConstant - lhsConstant ; if ( coefficient == 0 && constant == 0 ) return \"Infinite solutions\" ; if ( coefficient == 0 && constant != 0 ) return \"No solution\" ; return \"x=\" + to_string ( constant / coefficient ); } private : pair < int , int > calculate ( const string & s ) { int coefficient = 0 ; int constant = 0 ; int num = 0 ; int sign = 1 ; for ( int i = 0 ; i < s . length (); ++ i ) { char c = s [ i ]; if ( isdigit ( c )) num = num * 10 + ( c - '0' ); else if ( c == '+' || c == '-' ) { constant += sign * num ; sign = c == '+' ? 1 : - 1 ; num = 0 ; } else { if ( i > 0 && num == 0 && s [ i - 1 ] == '0' ) continue ; coefficient += num == 0 ? sign : sign * num ; num = 0 ; } } return { coefficient , constant + sign * num }; } };","title":"0631-0640"},{"location":"cpp/0601-0700/0631-0640/#631-design-excel-sum-formula-starstarstar","text":"","title":"631. Design Excel Sum Formula $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/0601-0700/0631-0640/#632-smallest-range-covering-elements-from-k-lists-starstarstar","text":"class Solution { public : vector < int > smallestRange ( vector < vector < int >>& nums ) { auto compare = []( const Elem & a , const Elem & b ) { return a . value > b . value ; }; priority_queue < Elem , vector < Elem > , decltype ( compare ) > pq ( compare ); int maxRange = INT_MIN ; for ( int i = 0 ; i < nums . size (); ++ i ) { pq . push ( Elem ( nums [ i ][ 0 ], i , 0 )); maxRange = max ( maxRange , nums [ i ][ 0 ]); } int minRange = pq . top (). value ; vector < int > ans { minRange , maxRange }; while ( pq . size () == nums . size ()) { auto [ value , r , c ] = pq . top (); pq . pop (); if ( c + 1 < nums [ r ]. size ()) { pq . push ( Elem ( nums [ r ][ c + 1 ], r , c + 1 )); maxRange = max ( maxRange , nums [ r ][ c + 1 ]); minRange = pq . top (). value ; if ( maxRange - minRange < ans [ 1 ] - ans [ 0 ]) { ans [ 0 ] = minRange ; ans [ 1 ] = maxRange ; } } } return ans ; } private : struct Elem { int value ; int r ; int c ; Elem ( int value , int r , int c ) : value ( value ), r ( r ), c ( c ) {} }; };","title":"632. Smallest Range Covering Elements from K Lists $\\star\\star\\star$"},{"location":"cpp/0601-0700/0631-0640/#633-sum-of-square-numbers-star","text":"class Solution { public : bool judgeSquareSum ( int c ) { long l = 0 ; long r = sqrt ( c ); while ( l <= r ) { long sum = l * l + r * r ; if ( sum == c ) return true ; if ( sum < c ) ++ l ; else -- r ; } return false ; } };","title":"633. Sum of Square Numbers $\\star$"},{"location":"cpp/0601-0700/0631-0640/#634-find-the-derangement-of-an-array-starstar","text":"","title":"634. Find the Derangement of An Array $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0601-0700/0631-0640/#635-design-log-storage-system-starstar","text":"","title":"635. Design Log Storage System $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0601-0700/0631-0640/#636-exclusive-time-of-functions-starstar","text":"","title":"636. Exclusive Time of Functions $\\star\\star$"},{"location":"cpp/0601-0700/0631-0640/#637-average-of-levels-in-binary-tree-star","text":"","title":"637. Average of Levels in Binary Tree $\\star$"},{"location":"cpp/0601-0700/0631-0640/#638-shopping-offers-starstar","text":"class Solution { public : int shoppingOffers ( vector < int >& price , vector < vector < int >>& special , vector < int >& needs ) { function < int ( int ) > dfs = [ & ]( int s ) { int ans = 0 ; for ( int i = 0 ; i < needs . size (); ++ i ) ans += needs [ i ] * price [ i ]; for ( int i = s ; i < special . size (); ++ i ) if ( isValid ( special [ i ], needs )) { for ( int j = 0 ; j < needs . size (); ++ j ) needs [ j ] -= special [ i ][ j ]; ans = min ( ans , special [ i ]. back () + dfs ( i )); for ( int j = 0 ; j < needs . size (); ++ j ) needs [ j ] += special [ i ][ j ]; } return ans ; }; return dfs ( 0 ); } private : bool isValid ( vector < int >& offer , vector < int >& needs ) { for ( int i = 0 ; i < needs . size (); ++ i ) if ( offer [ i ] > needs [ i ]) return false ; return true ; } };","title":"638. Shopping Offers $\\star\\star$"},{"location":"cpp/0601-0700/0631-0640/#639-decode-ways-ii-starstarstar","text":"class Solution { public : int numDecodings ( string s ) { if ( s . empty ()) return 0 ; const int kMod = 1e9 + 7 ; long dp1 = count ( s [ 0 ]); long dp2 = 1 ; for ( int i = 1 ; i < s . length (); ++ i ) { long dp = count ( s [ i ]) * dp1 + count ( s [ i - 1 ], s [ i ]) * dp2 ; dp %= kMod ; dp2 = dp1 ; dp1 = dp ; } return dp1 ; } private : int count ( char c ) { if ( c == '*' ) return 9 ; return c != '0' ; } int count ( char c1 , char c2 ) { if ( c1 == '*' && c2 == '*' ) return 15 ; if ( c1 == '*' ) return ( c2 >= '0' && c2 <= '6' ) ? 2 : 1 ; if ( c2 == '*' ) { if ( c1 == '1' ) return 9 ; if ( c1 == '2' ) return 6 ; return 0 ; } return c1 == '1' || ( c1 == '2' && c2 <= '6' ); } };","title":"639. Decode Ways II $\\star\\star\\star$"},{"location":"cpp/0601-0700/0631-0640/#640-solve-the-equation-starstar","text":"class Solution { public : string solveEquation ( string equation ) { string lhsEquation = equation . substr ( 0 , equation . find_first_of ( '=' )); string rhsEquation = equation . substr ( equation . find_first_of ( '=' ) + 1 ); const auto & [ lhsCoefficient , lhsConstant ] = calculate ( lhsEquation ); const auto & [ rhsCoefficient , rhsConstant ] = calculate ( rhsEquation ); int coefficient = lhsCoefficient - rhsCoefficient ; int constant = rhsConstant - lhsConstant ; if ( coefficient == 0 && constant == 0 ) return \"Infinite solutions\" ; if ( coefficient == 0 && constant != 0 ) return \"No solution\" ; return \"x=\" + to_string ( constant / coefficient ); } private : pair < int , int > calculate ( const string & s ) { int coefficient = 0 ; int constant = 0 ; int num = 0 ; int sign = 1 ; for ( int i = 0 ; i < s . length (); ++ i ) { char c = s [ i ]; if ( isdigit ( c )) num = num * 10 + ( c - '0' ); else if ( c == '+' || c == '-' ) { constant += sign * num ; sign = c == '+' ? 1 : - 1 ; num = 0 ; } else { if ( i > 0 && num == 0 && s [ i - 1 ] == '0' ) continue ; coefficient += num == 0 ? sign : sign * num ; num = 0 ; } } return { coefficient , constant + sign * num }; } };","title":"640. Solve the Equation $\\star\\star$"},{"location":"cpp/0601-0700/0641-0650/","text":"641. Design Circular Deque $\\star\\star$ 642. Design Search Autocomplete System $\\star\\star\\star$ \ud83d\udd12 643. Maximum Average Subarray I $\\star$ class Solution { public : double findMaxAverage ( vector < int >& nums , int k ) { double sum = accumulate ( begin ( nums ), begin ( nums ) + k , 0 ); double ans = sum ; for ( int i = k ; i < nums . size (); ++ i ) { sum += nums [ i ] - nums [ i - k ]; ans = max ( ans , sum ); } return ans / k ; } }; 644. Maximum Average Subarray II $\\star\\star\\star$ \ud83d\udd12 645. Set Mismatch $\\star$ class Solution { public : vector < int > findErrorNums ( vector < int >& nums ) { int duplicate ; for ( int num : nums ) { if ( nums [ abs ( num ) - 1 ] < 0 ) duplicate = abs ( num ); else nums [ abs ( num ) - 1 ] *= - 1 ; } for ( int i = 0 ; i < nums . size (); ++ i ) if ( nums [ i ] > 0 ) return { duplicate , i + 1 }; throw ; } }; 646. Maximum Length of Pair Chain $\\star\\star$ 647. Palindromic Substrings $\\star\\star$ class Solution { public : int countSubstrings ( string s ) { int ans = 0 ; for ( int i = 0 ; i < s . length (); ++ i ) { ans += extendPalindromes ( s , i , i ); ans += extendPalindromes ( s , i , i + 1 ); } return ans ; } private : int extendPalindromes ( const string & s , int l , int r ) { int count = 0 ; while ( l >= 0 && r < s . length () && s [ l ] == s [ r ]) { ++ count ; -- l ; ++ r ; } return count ; } }; 648. Replace Words $\\star\\star$ class Solution { public : string replaceWords ( vector < string >& dict , string sentence ) { string ans ; for ( const string & word : dict ) insert ( word ); stringstream ss ( sentence ); string s ; while ( getline ( ss , s , ' ' )) ans += ' ' + search ( s ); return ans . substr ( 1 ); } private : struct TrieNode { TrieNode () : children ( 26 ), word ( nullptr ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete ( child ); } vector < TrieNode *> children ; const string * word ; }; TrieNode root ; void insert ( const string & word ) { TrieNode * node = & root ; for ( char c : word ) { TrieNode *& next = node -> children [ c - 'a' ]; if ( ! next ) next = new TrieNode ; node = next ; } node -> word = & word ; } string search ( const string & word ) { TrieNode * node = & root ; for ( char c : word ) { if ( node -> word ) return * node -> word ; TrieNode * next = node -> children [ c - 'a' ]; if ( ! next ) return word ; node = next ; } return word ; } }; 649. Dota2 Senate $\\star\\star$ 650. 2 Keys Keyboard $\\star\\star$ class Solution { public : int minSteps ( int n ) { vector < int > dp ( n + 1 ); for ( int i = 2 ; i <= n ; ++ i ) { dp [ i ] = i ; for ( int j = i / 2 ; i > 1 ; -- j ) if ( i % j == 0 ) { dp [ i ] = dp [ j ] + i / j ; break ; } } return dp [ n ]; } };","title":"0641-0650"},{"location":"cpp/0601-0700/0641-0650/#641-design-circular-deque-starstar","text":"","title":"641. Design Circular Deque $\\star\\star$"},{"location":"cpp/0601-0700/0641-0650/#642-design-search-autocomplete-system-starstarstar","text":"","title":"642. Design Search Autocomplete System $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/0601-0700/0641-0650/#643-maximum-average-subarray-i-star","text":"class Solution { public : double findMaxAverage ( vector < int >& nums , int k ) { double sum = accumulate ( begin ( nums ), begin ( nums ) + k , 0 ); double ans = sum ; for ( int i = k ; i < nums . size (); ++ i ) { sum += nums [ i ] - nums [ i - k ]; ans = max ( ans , sum ); } return ans / k ; } };","title":"643. Maximum Average Subarray I $\\star$"},{"location":"cpp/0601-0700/0641-0650/#644-maximum-average-subarray-ii-starstarstar","text":"","title":"644. Maximum Average Subarray II $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/0601-0700/0641-0650/#645-set-mismatch-star","text":"class Solution { public : vector < int > findErrorNums ( vector < int >& nums ) { int duplicate ; for ( int num : nums ) { if ( nums [ abs ( num ) - 1 ] < 0 ) duplicate = abs ( num ); else nums [ abs ( num ) - 1 ] *= - 1 ; } for ( int i = 0 ; i < nums . size (); ++ i ) if ( nums [ i ] > 0 ) return { duplicate , i + 1 }; throw ; } };","title":"645. Set Mismatch $\\star$"},{"location":"cpp/0601-0700/0641-0650/#646-maximum-length-of-pair-chain-starstar","text":"","title":"646. Maximum Length of Pair Chain $\\star\\star$"},{"location":"cpp/0601-0700/0641-0650/#647-palindromic-substrings-starstar","text":"class Solution { public : int countSubstrings ( string s ) { int ans = 0 ; for ( int i = 0 ; i < s . length (); ++ i ) { ans += extendPalindromes ( s , i , i ); ans += extendPalindromes ( s , i , i + 1 ); } return ans ; } private : int extendPalindromes ( const string & s , int l , int r ) { int count = 0 ; while ( l >= 0 && r < s . length () && s [ l ] == s [ r ]) { ++ count ; -- l ; ++ r ; } return count ; } };","title":"647. Palindromic Substrings $\\star\\star$"},{"location":"cpp/0601-0700/0641-0650/#648-replace-words-starstar","text":"class Solution { public : string replaceWords ( vector < string >& dict , string sentence ) { string ans ; for ( const string & word : dict ) insert ( word ); stringstream ss ( sentence ); string s ; while ( getline ( ss , s , ' ' )) ans += ' ' + search ( s ); return ans . substr ( 1 ); } private : struct TrieNode { TrieNode () : children ( 26 ), word ( nullptr ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete ( child ); } vector < TrieNode *> children ; const string * word ; }; TrieNode root ; void insert ( const string & word ) { TrieNode * node = & root ; for ( char c : word ) { TrieNode *& next = node -> children [ c - 'a' ]; if ( ! next ) next = new TrieNode ; node = next ; } node -> word = & word ; } string search ( const string & word ) { TrieNode * node = & root ; for ( char c : word ) { if ( node -> word ) return * node -> word ; TrieNode * next = node -> children [ c - 'a' ]; if ( ! next ) return word ; node = next ; } return word ; } };","title":"648. Replace Words $\\star\\star$"},{"location":"cpp/0601-0700/0641-0650/#649-dota2-senate-starstar","text":"","title":"649. Dota2 Senate $\\star\\star$"},{"location":"cpp/0601-0700/0641-0650/#650-2-keys-keyboard-starstar","text":"class Solution { public : int minSteps ( int n ) { vector < int > dp ( n + 1 ); for ( int i = 2 ; i <= n ; ++ i ) { dp [ i ] = i ; for ( int j = i / 2 ; i > 1 ; -- j ) if ( i % j == 0 ) { dp [ i ] = dp [ j ] + i / j ; break ; } } return dp [ n ]; } };","title":"650. 2 Keys Keyboard $\\star\\star$"},{"location":"cpp/0601-0700/0651-0660/","text":"651. 4 Keys Keyboard $\\star\\star$ \ud83d\udd12 652. Find Duplicate Subtrees $\\star\\star$ 653. Two Sum IV - Input is a BST $\\star$ class Solution { public : bool findTarget ( TreeNode * root , int k ) { vector < int > nums ; inorder ( root , nums ); int l = 0 ; int r = nums . size () - 1 ; while ( l < r ) { int sum = nums [ l ] + nums [ r ]; if ( sum == k ) return true ; if ( sum < k ) ++ l ; else -- r ; } return false ; } void inorder ( TreeNode * root , vector < int >& nums ) { if ( ! root ) return ; inorder ( root -> left , nums ); nums . push_back ( root -> val ); inorder ( root -> right , nums ); } }; 654. Maximum Binary Tree $\\star\\star$ 655. Print Binary Tree $\\star\\star$ 656. Coin Path $\\star\\star\\star$ \ud83d\udd12 657. Robot Return to Origin $\\star$ class Solution { public : bool judgeCircle ( string moves ) { int right = 0 ; int up = 0 ; for ( char move : moves ) { switch ( move ) { case 'R' : ++ right ; break ; case 'L' : -- right ; break ; case 'U' : ++ up ; break ; case 'D' : -- up ; break ; } } return right == 0 && up == 0 ; } }; 658. Find K Closest Elements $\\star\\star$ 659. Split Array into Consecutive Subsequences $\\star\\star$ 660. Remove 9 $\\star\\star\\star$ \ud83d\udd12","title":"0651-0660"},{"location":"cpp/0601-0700/0651-0660/#651-4-keys-keyboard-starstar","text":"","title":"651. 4 Keys Keyboard $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0601-0700/0651-0660/#652-find-duplicate-subtrees-starstar","text":"","title":"652. Find Duplicate Subtrees $\\star\\star$"},{"location":"cpp/0601-0700/0651-0660/#653-two-sum-iv-input-is-a-bst-star","text":"class Solution { public : bool findTarget ( TreeNode * root , int k ) { vector < int > nums ; inorder ( root , nums ); int l = 0 ; int r = nums . size () - 1 ; while ( l < r ) { int sum = nums [ l ] + nums [ r ]; if ( sum == k ) return true ; if ( sum < k ) ++ l ; else -- r ; } return false ; } void inorder ( TreeNode * root , vector < int >& nums ) { if ( ! root ) return ; inorder ( root -> left , nums ); nums . push_back ( root -> val ); inorder ( root -> right , nums ); } };","title":"653. Two Sum IV - Input is a BST $\\star$"},{"location":"cpp/0601-0700/0651-0660/#654-maximum-binary-tree-starstar","text":"","title":"654. Maximum Binary Tree $\\star\\star$"},{"location":"cpp/0601-0700/0651-0660/#655-print-binary-tree-starstar","text":"","title":"655. Print Binary Tree $\\star\\star$"},{"location":"cpp/0601-0700/0651-0660/#656-coin-path-starstarstar","text":"","title":"656. Coin Path $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/0601-0700/0651-0660/#657-robot-return-to-origin-star","text":"class Solution { public : bool judgeCircle ( string moves ) { int right = 0 ; int up = 0 ; for ( char move : moves ) { switch ( move ) { case 'R' : ++ right ; break ; case 'L' : -- right ; break ; case 'U' : ++ up ; break ; case 'D' : -- up ; break ; } } return right == 0 && up == 0 ; } };","title":"657. Robot Return to Origin $\\star$"},{"location":"cpp/0601-0700/0651-0660/#658-find-k-closest-elements-starstar","text":"","title":"658. Find K Closest Elements $\\star\\star$"},{"location":"cpp/0601-0700/0651-0660/#659-split-array-into-consecutive-subsequences-starstar","text":"","title":"659. Split Array into Consecutive Subsequences $\\star\\star$"},{"location":"cpp/0601-0700/0651-0660/#660-remove-9-starstarstar","text":"","title":"660. Remove 9 $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/0601-0700/0661-0670/","text":"661. Image Smoother $\\star$ class Solution { public : vector < vector < int >> imageSmoother ( vector < vector < int >>& M ) { const int m = M . size (); const int n = M [ 0 ]. size (); vector < vector < int >> ans ( m , vector < int > ( n )); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int ones = 0 ; int count = 0 ; for ( int y = max ( 0 , i - 1 ); y < min ( m , i + 2 ); ++ y ) for ( int x = max ( 0 , j - 1 ); x < min ( n , j + 2 ); ++ x ) { ones += M [ y ][ x ]; ++ count ; } ans [ i ][ j ] = ones / count ; } return ans ; } }; 662. Maximum Width of Binary Tree $\\star\\star$ 663. Equal Tree Partition $\\star\\star$ \ud83d\udd12 664. Strange Printer $\\star\\star\\star$ 665. Non-decreasing Array $\\star$ class Solution { public : bool checkPossibility ( vector < int >& nums ) { int j = - 1 ; for ( int i = 0 ; i + 1 < nums . size (); ++ i ) if ( nums [ i ] > nums [ i + 1 ]) { if ( j != - 1 ) return false ; j = i ; } return j == - 1 || j == 0 || j == nums . size () - 2 || nums [ j - 1 ] <= nums [ j + 1 ] || nums [ j ] <= nums [ j + 2 ]; } }; 666. Path Sum IV $\\star\\star$ \ud83d\udd12 667. Beautiful Arrangement II $\\star\\star$ class Solution { public : vector < int > constructArray ( int n , int k ) { vector < int > ans ; for ( int i = 0 ; i < n - k ; ++ i ) ans . push_back ( i + 1 ); for ( int i = 0 ; i < k ; ++ i ) { if ( i % 2 == 0 ) ans . push_back ( n - i / 2 ); else ans . push_back ( n - k + ( i + 1 ) / 2 ); } return ans ; } }; 668. Kth Smallest Number in Multiplication Table $\\star\\star\\star$ 669. Trim a Binary Search Tree $\\star$ 670. Maximum Swap $\\star\\star$ class Solution { public : int maximumSwap ( int num ) { string s = to_string ( num ); unordered_map < char , int > map ; for ( int i = 0 ; i < s . length (); ++ i ) map [ s [ i ]] = i ; for ( int i = 0 ; i < s . length (); ++ i ) for ( char digit = '9' ; digit > s [ i ]; -- digit ) if ( map [ digit ] > i ) { s [ map [ digit ]] = s [ i ]; s [ i ] = digit ; return stoi ( s ); } return num ; } };","title":"0661-0670"},{"location":"cpp/0601-0700/0661-0670/#661-image-smoother-star","text":"class Solution { public : vector < vector < int >> imageSmoother ( vector < vector < int >>& M ) { const int m = M . size (); const int n = M [ 0 ]. size (); vector < vector < int >> ans ( m , vector < int > ( n )); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int ones = 0 ; int count = 0 ; for ( int y = max ( 0 , i - 1 ); y < min ( m , i + 2 ); ++ y ) for ( int x = max ( 0 , j - 1 ); x < min ( n , j + 2 ); ++ x ) { ones += M [ y ][ x ]; ++ count ; } ans [ i ][ j ] = ones / count ; } return ans ; } };","title":"661. Image Smoother $\\star$"},{"location":"cpp/0601-0700/0661-0670/#662-maximum-width-of-binary-tree-starstar","text":"","title":"662. Maximum Width of Binary Tree $\\star\\star$"},{"location":"cpp/0601-0700/0661-0670/#663-equal-tree-partition-starstar","text":"","title":"663. Equal Tree Partition $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0601-0700/0661-0670/#664-strange-printer-starstarstar","text":"","title":"664. Strange Printer $\\star\\star\\star$"},{"location":"cpp/0601-0700/0661-0670/#665-non-decreasing-array-star","text":"class Solution { public : bool checkPossibility ( vector < int >& nums ) { int j = - 1 ; for ( int i = 0 ; i + 1 < nums . size (); ++ i ) if ( nums [ i ] > nums [ i + 1 ]) { if ( j != - 1 ) return false ; j = i ; } return j == - 1 || j == 0 || j == nums . size () - 2 || nums [ j - 1 ] <= nums [ j + 1 ] || nums [ j ] <= nums [ j + 2 ]; } };","title":"665. Non-decreasing Array $\\star$"},{"location":"cpp/0601-0700/0661-0670/#666-path-sum-iv-starstar","text":"","title":"666. Path Sum IV $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0601-0700/0661-0670/#667-beautiful-arrangement-ii-starstar","text":"class Solution { public : vector < int > constructArray ( int n , int k ) { vector < int > ans ; for ( int i = 0 ; i < n - k ; ++ i ) ans . push_back ( i + 1 ); for ( int i = 0 ; i < k ; ++ i ) { if ( i % 2 == 0 ) ans . push_back ( n - i / 2 ); else ans . push_back ( n - k + ( i + 1 ) / 2 ); } return ans ; } };","title":"667. Beautiful Arrangement II $\\star\\star$"},{"location":"cpp/0601-0700/0661-0670/#668-kth-smallest-number-in-multiplication-table-starstarstar","text":"","title":"668. Kth Smallest Number in Multiplication Table $\\star\\star\\star$"},{"location":"cpp/0601-0700/0661-0670/#669-trim-a-binary-search-tree-star","text":"","title":"669. Trim a Binary Search Tree $\\star$"},{"location":"cpp/0601-0700/0661-0670/#670-maximum-swap-starstar","text":"class Solution { public : int maximumSwap ( int num ) { string s = to_string ( num ); unordered_map < char , int > map ; for ( int i = 0 ; i < s . length (); ++ i ) map [ s [ i ]] = i ; for ( int i = 0 ; i < s . length (); ++ i ) for ( char digit = '9' ; digit > s [ i ]; -- digit ) if ( map [ digit ] > i ) { s [ map [ digit ]] = s [ i ]; s [ i ] = digit ; return stoi ( s ); } return num ; } };","title":"670. Maximum Swap $\\star\\star$"},{"location":"cpp/0601-0700/0671-0680/","text":"671. Second Minimum Node In a Binary Tree $\\star$ 672. Bulb Switcher II $\\star\\star$ class Solution { public : int flipLights ( int n , int m ) { n = min ( n , 3 ); if ( m == 0 ) return 1 ; if ( m == 1 ) return vector < int > { 2 , 3 , 4 }[ n - 1 ]; if ( m == 2 ) return vector < int > { 2 , 4 , 7 }[ n - 1 ]; return pow ( 2 , n ); } }; 673. Number of Longest Increasing Subsequence $\\star\\star$ class Solution { public : int findNumberOfLIS ( vector < int >& nums ) { int ans = 0 ; int maxLength = 0 ; vector < int > length ( nums . size (), 1 ); vector < int > count ( nums . size (), 1 ); for ( int i = 0 ; i < nums . size (); ++ i ) { for ( int j = 0 ; j < i ; ++ j ) if ( nums [ j ] < nums [ i ]) { if ( length [ i ] == length [ j ] + 1 ) count [ i ] += count [ j ]; else if ( length [ i ] < length [ j ] + 1 ) { length [ i ] = length [ j ] + 1 ; count [ i ] = count [ j ]; } } if ( maxLength == length [ i ]) ans += count [ i ]; else if ( maxLength < length [ i ]) { maxLength = length [ i ]; ans = count [ i ]; } } return ans ; } }; 674. Longest Continuous Increasing Subsequence $\\star$ class Solution { public : int findLengthOfLCIS ( vector < int >& nums ) { int ans = 0 ; for ( int i = 0 , j = 0 ; i < nums . size (); ++ i ) { if ( i > 0 && nums [ i ] <= nums [ i - 1 ]) j = i ; ans = max ( ans , i - j + 1 ); } return ans ; } }; 675. Cut Off Trees for Golf Event $\\star\\star\\star$ 676. Implement Magic Dictionary $\\star\\star$ class MagicDictionary { public : void buildDict ( vector < string > dict ) { for ( const string & word : dict ) for ( int i = 0 ; i < word . length (); ++ i ) { string modifiedWord = word . substr ( 0 , i ) + '*' + word . substr ( i + 1 ); if ( ! map . count ( modifiedWord )) map [ modifiedWord ] = word [ i ]; else if ( map [ modifiedWord ] != word [ i ]) map [ modifiedWord ] = '*' ; } } bool search ( string word ) { for ( int i = 0 ; i < word . length (); ++ i ) { string modifiedWord = word . substr ( 0 , i ) + '*' + word . substr ( i + 1 ); if ( map . count ( modifiedWord ) && map [ modifiedWord ] != word [ i ]) return true ; } return false ; } private : unordered_map < string , char > map ; }; 677. Map Sum Pairs $\\star\\star$ 678. Valid Parenthesis String $\\star\\star$ class Solution { public : bool checkValidString ( string s ) { int low = 0 ; int high = 0 ; for ( char c : s ) { switch ( c ) { case '(' : ++ low ; ++ high ; break ; case ')' : low = max ( 0 , -- low ); -- high ; break ; case '*' : low = max ( 0 , -- low ); ++ high ; break ; } if ( high < 0 ) return false ; } return low == 0 ; } }; 679. 24 Game $\\star\\star\\star$ class Solution { public : bool judgePoint24 ( vector < int >& nums ) { vector < double > doubleNums ; for ( int num : nums ) doubleNums . push_back ( num ); return dfs ( doubleNums ); } private : bool dfs ( vector < double >& nums ) { if ( nums . size () == 1 ) return abs ( nums [ 0 ] - 24.0 ) < 0.001 ; for ( int i = 0 ; i < nums . size (); ++ i ) for ( int j = i + 1 ; j < nums . size (); ++ j ) for ( double num : generate ( nums [ i ], nums [ j ])) { vector < double > nextRound { num }; for ( int k = 0 ; k < nums . size (); ++ k ) { if ( k == i || k == j ) continue ; nextRound . push_back ( nums [ k ]); } if ( dfs ( nextRound )) return true ; } return false ; } vector < double > generate ( double a , double b ) { return { a * b , a / b , b / a , a + b , a - b , b - a }; } }; 680. Valid Palindrome II $\\star$ class Solution { public : bool validPalindrome ( string s ) { const int n = s . length (); for ( int i = 0 ; i < n / 2 ; ++ i ) if ( s [ i ] != s [ n - 1 - i ]) return validPalindrome ( s , i + 1 , n - 1 - i ) || validPalindrome ( s , i , n - 2 - i ); return true ; } private : bool validPalindrome ( string & s , int l , int r ) { for ( int i = l ; i <= l + ( r - l ) / 2 ; ++ i ) if ( s [ i ] != s [ r - i + l ]) return false ; return true ; } };","title":"0671-0680"},{"location":"cpp/0601-0700/0671-0680/#671-second-minimum-node-in-a-binary-tree-star","text":"","title":"671. Second Minimum Node In a Binary Tree $\\star$"},{"location":"cpp/0601-0700/0671-0680/#672-bulb-switcher-ii-starstar","text":"class Solution { public : int flipLights ( int n , int m ) { n = min ( n , 3 ); if ( m == 0 ) return 1 ; if ( m == 1 ) return vector < int > { 2 , 3 , 4 }[ n - 1 ]; if ( m == 2 ) return vector < int > { 2 , 4 , 7 }[ n - 1 ]; return pow ( 2 , n ); } };","title":"672. Bulb Switcher II $\\star\\star$"},{"location":"cpp/0601-0700/0671-0680/#673-number-of-longest-increasing-subsequence-starstar","text":"class Solution { public : int findNumberOfLIS ( vector < int >& nums ) { int ans = 0 ; int maxLength = 0 ; vector < int > length ( nums . size (), 1 ); vector < int > count ( nums . size (), 1 ); for ( int i = 0 ; i < nums . size (); ++ i ) { for ( int j = 0 ; j < i ; ++ j ) if ( nums [ j ] < nums [ i ]) { if ( length [ i ] == length [ j ] + 1 ) count [ i ] += count [ j ]; else if ( length [ i ] < length [ j ] + 1 ) { length [ i ] = length [ j ] + 1 ; count [ i ] = count [ j ]; } } if ( maxLength == length [ i ]) ans += count [ i ]; else if ( maxLength < length [ i ]) { maxLength = length [ i ]; ans = count [ i ]; } } return ans ; } };","title":"673. Number of Longest Increasing Subsequence $\\star\\star$"},{"location":"cpp/0601-0700/0671-0680/#674-longest-continuous-increasing-subsequence-star","text":"class Solution { public : int findLengthOfLCIS ( vector < int >& nums ) { int ans = 0 ; for ( int i = 0 , j = 0 ; i < nums . size (); ++ i ) { if ( i > 0 && nums [ i ] <= nums [ i - 1 ]) j = i ; ans = max ( ans , i - j + 1 ); } return ans ; } };","title":"674. Longest Continuous Increasing Subsequence $\\star$"},{"location":"cpp/0601-0700/0671-0680/#675-cut-off-trees-for-golf-event-starstarstar","text":"","title":"675. Cut Off Trees for Golf Event $\\star\\star\\star$"},{"location":"cpp/0601-0700/0671-0680/#676-implement-magic-dictionary-starstar","text":"class MagicDictionary { public : void buildDict ( vector < string > dict ) { for ( const string & word : dict ) for ( int i = 0 ; i < word . length (); ++ i ) { string modifiedWord = word . substr ( 0 , i ) + '*' + word . substr ( i + 1 ); if ( ! map . count ( modifiedWord )) map [ modifiedWord ] = word [ i ]; else if ( map [ modifiedWord ] != word [ i ]) map [ modifiedWord ] = '*' ; } } bool search ( string word ) { for ( int i = 0 ; i < word . length (); ++ i ) { string modifiedWord = word . substr ( 0 , i ) + '*' + word . substr ( i + 1 ); if ( map . count ( modifiedWord ) && map [ modifiedWord ] != word [ i ]) return true ; } return false ; } private : unordered_map < string , char > map ; };","title":"676. Implement Magic Dictionary $\\star\\star$"},{"location":"cpp/0601-0700/0671-0680/#677-map-sum-pairs-starstar","text":"","title":"677. Map Sum Pairs $\\star\\star$"},{"location":"cpp/0601-0700/0671-0680/#678-valid-parenthesis-string-starstar","text":"class Solution { public : bool checkValidString ( string s ) { int low = 0 ; int high = 0 ; for ( char c : s ) { switch ( c ) { case '(' : ++ low ; ++ high ; break ; case ')' : low = max ( 0 , -- low ); -- high ; break ; case '*' : low = max ( 0 , -- low ); ++ high ; break ; } if ( high < 0 ) return false ; } return low == 0 ; } };","title":"678. Valid Parenthesis String $\\star\\star$"},{"location":"cpp/0601-0700/0671-0680/#679-24-game-starstarstar","text":"class Solution { public : bool judgePoint24 ( vector < int >& nums ) { vector < double > doubleNums ; for ( int num : nums ) doubleNums . push_back ( num ); return dfs ( doubleNums ); } private : bool dfs ( vector < double >& nums ) { if ( nums . size () == 1 ) return abs ( nums [ 0 ] - 24.0 ) < 0.001 ; for ( int i = 0 ; i < nums . size (); ++ i ) for ( int j = i + 1 ; j < nums . size (); ++ j ) for ( double num : generate ( nums [ i ], nums [ j ])) { vector < double > nextRound { num }; for ( int k = 0 ; k < nums . size (); ++ k ) { if ( k == i || k == j ) continue ; nextRound . push_back ( nums [ k ]); } if ( dfs ( nextRound )) return true ; } return false ; } vector < double > generate ( double a , double b ) { return { a * b , a / b , b / a , a + b , a - b , b - a }; } };","title":"679. 24 Game $\\star\\star\\star$"},{"location":"cpp/0601-0700/0671-0680/#680-valid-palindrome-ii-star","text":"class Solution { public : bool validPalindrome ( string s ) { const int n = s . length (); for ( int i = 0 ; i < n / 2 ; ++ i ) if ( s [ i ] != s [ n - 1 - i ]) return validPalindrome ( s , i + 1 , n - 1 - i ) || validPalindrome ( s , i , n - 2 - i ); return true ; } private : bool validPalindrome ( string & s , int l , int r ) { for ( int i = l ; i <= l + ( r - l ) / 2 ; ++ i ) if ( s [ i ] != s [ r - i + l ]) return false ; return true ; } };","title":"680. Valid Palindrome II $\\star$"},{"location":"cpp/0601-0700/0681-0690/","text":"681. Next Closest Time $\\star\\star$ \ud83d\udd12 682. Baseball Game $\\star$ 683. K Empty Slots $\\star\\star\\star$ \ud83d\udd12 684. Redundant Connection $\\star\\star$ class UF { public : UF ( int n ) : rank ( n + 1 ), parent ( n + 1 ) { for ( int i = 0 ; i < parent . size (); ++ i ) parent [ i ] = i ; } bool union_ ( int u , int v ) { int pu = find ( u ); int pv = find ( v ); if ( pu == pv ) return false ; if ( rank [ pu ] < rank [ pv ]) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ]) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ]; } return true ; } int find ( int u ) { if ( u != parent [ u ]) parent [ u ] = find ( parent [ u ]); return parent [ u ]; } private : vector < int > rank ; vector < int > parent ; }; class Solution { public : vector < int > findRedundantConnection ( vector < vector < int >>& edges ) { UF uf ( edges . size ()); for ( vector < int >& edge : edges ) if ( ! uf . union_ ( edge [ 0 ], edge [ 1 ])) return edge ; throw ; } }; 685. Redundant Connection II $\\star\\star\\star$ class UF { public : UF ( int n ) : rank ( n + 1 ), parent ( n + 1 ) { for ( int i = 0 ; i < parent . size (); ++ i ) parent [ i ] = i ; } bool union_ ( int u , int v ) { int pu = find ( u ); int pv = find ( v ); if ( pu == pv ) return false ; if ( rank [ pu ] < rank [ pv ]) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ]) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ]; } return true ; } int find ( int u ) { if ( u != parent [ u ]) parent [ u ] = find ( parent [ u ]); return parent [ u ]; } private : vector < int > rank ; vector < int > parent ; }; class Solution { public : vector < int > findRedundantDirectedConnection ( vector < vector < int >>& edges ) { vector < int > parents ( edges . size () + 1 ); int nodeWithTwoParents = 0 ; for ( vector < int >& edge : edges ) { int u = edge [ 0 ]; int v = edge [ 1 ]; if ( ++ parents [ v ] == 2 ) nodeWithTwoParents = v ; } if ( ! nodeWithTwoParents ) return findRedundantDirectedConnection ( edges , - 1 ); for ( int i = edges . size () - 1 ; i >= 0 ; -- i ) { int u = edges [ i ][ 0 ]; int v = edges [ i ][ 1 ]; if ( v == nodeWithTwoParents ) if ( findRedundantDirectedConnection ( edges , i ). empty ()) return edges [ i ]; } throw ; } private : vector < int > findRedundantDirectedConnection ( vector < vector < int >>& edges , int skippedEdgeIndex ) { UF uf ( edges . size ()); for ( int i = 0 ; i < edges . size (); ++ i ) { if ( i == skippedEdgeIndex ) continue ; if ( ! uf . union_ ( edges [ i ][ 0 ], edges [ i ][ 1 ])) return edges [ i ]; } return {}; } }; 686. Repeated String Match $\\star$ class Solution { public : int repeatedStringMatch ( string A , string B ) { const int n = ceil (( double ) B . length () / A . length ()); string s ; for ( int i = 0 ; i < n ; ++ i ) s += A ; if ( s . find ( B ) != string :: npos ) return n ; if (( s + A ). find ( B ) != string :: npos ) return n + 1 ; return - 1 ; } }; 687. Longest Univalue Path $\\star$ 688. Knight Probability in Chessboard $\\star\\star$ 689. Maximum Sum of 3 Non-Overlapping Subarrays $\\star\\star\\star$ class Solution { public : vector < int > maxSumOfThreeSubarrays ( vector < int >& nums , int k ) { vector < int > ans = { - 1 , - 1 , - 1 }; int subarrayCount = nums . size () - k + 1 ; vector < int > dp ( subarrayCount ); int sum = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) { sum += nums [ i ]; if ( i >= k ) sum -= nums [ i - k ]; if ( i >= k - 1 ) dp [ i - k + 1 ] = sum ; } vector < int > left ( subarrayCount ); int maxIndex = 0 ; for ( int i = 0 ; i < subarrayCount ; ++ i ) { if ( dp [ i ] > dp [ maxIndex ]) maxIndex = i ; left [ i ] = maxIndex ; } vector < int > right ( subarrayCount ); maxIndex = subarrayCount - 1 ; for ( int i = subarrayCount - 1 ; i >= 0 ; -- i ) { if ( dp [ i ] >= dp [ maxIndex ]) maxIndex = i ; right [ i ] = maxIndex ; } for ( int i = k ; i < subarrayCount - k ; ++ i ) if ( ans [ 0 ] == - 1 || dp [ left [ i - k ]] + dp [ i ] + dp [ right [ i + k ]] > dp [ ans [ 0 ]] + dp [ ans [ 1 ]] + dp [ ans [ 2 ]]) ans = { left [ i - k ], i , right [ i + k ]}; return ans ; } }; 690. Employee Importance $\\star$ class Solution { public : int getImportance ( vector < Employee *> employees , int id ) { unordered_map < int , Employee *> idToEmployee ; for ( Employee * employee : employees ) idToEmployee [ employee -> id ] = employee ; return dfs ( idToEmployee , id ); } private : int dfs ( unordered_map < int , Employee *>& idToEmployee , int id ) { int subordinatesImportance = 0 ; for ( int subordinate : idToEmployee [ id ] -> subordinates ) subordinatesImportance += dfs ( idToEmployee , subordinate ); return idToEmployee [ id ] -> importance + subordinatesImportance ; } };","title":"0681-0690"},{"location":"cpp/0601-0700/0681-0690/#681-next-closest-time-starstar","text":"","title":"681. Next Closest Time $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0601-0700/0681-0690/#682-baseball-game-star","text":"","title":"682. Baseball Game $\\star$"},{"location":"cpp/0601-0700/0681-0690/#683-k-empty-slots-starstarstar","text":"","title":"683. K Empty Slots $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/0601-0700/0681-0690/#684-redundant-connection-starstar","text":"class UF { public : UF ( int n ) : rank ( n + 1 ), parent ( n + 1 ) { for ( int i = 0 ; i < parent . size (); ++ i ) parent [ i ] = i ; } bool union_ ( int u , int v ) { int pu = find ( u ); int pv = find ( v ); if ( pu == pv ) return false ; if ( rank [ pu ] < rank [ pv ]) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ]) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ]; } return true ; } int find ( int u ) { if ( u != parent [ u ]) parent [ u ] = find ( parent [ u ]); return parent [ u ]; } private : vector < int > rank ; vector < int > parent ; }; class Solution { public : vector < int > findRedundantConnection ( vector < vector < int >>& edges ) { UF uf ( edges . size ()); for ( vector < int >& edge : edges ) if ( ! uf . union_ ( edge [ 0 ], edge [ 1 ])) return edge ; throw ; } };","title":"684. Redundant Connection $\\star\\star$"},{"location":"cpp/0601-0700/0681-0690/#685-redundant-connection-ii-starstarstar","text":"class UF { public : UF ( int n ) : rank ( n + 1 ), parent ( n + 1 ) { for ( int i = 0 ; i < parent . size (); ++ i ) parent [ i ] = i ; } bool union_ ( int u , int v ) { int pu = find ( u ); int pv = find ( v ); if ( pu == pv ) return false ; if ( rank [ pu ] < rank [ pv ]) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ]) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ]; } return true ; } int find ( int u ) { if ( u != parent [ u ]) parent [ u ] = find ( parent [ u ]); return parent [ u ]; } private : vector < int > rank ; vector < int > parent ; }; class Solution { public : vector < int > findRedundantDirectedConnection ( vector < vector < int >>& edges ) { vector < int > parents ( edges . size () + 1 ); int nodeWithTwoParents = 0 ; for ( vector < int >& edge : edges ) { int u = edge [ 0 ]; int v = edge [ 1 ]; if ( ++ parents [ v ] == 2 ) nodeWithTwoParents = v ; } if ( ! nodeWithTwoParents ) return findRedundantDirectedConnection ( edges , - 1 ); for ( int i = edges . size () - 1 ; i >= 0 ; -- i ) { int u = edges [ i ][ 0 ]; int v = edges [ i ][ 1 ]; if ( v == nodeWithTwoParents ) if ( findRedundantDirectedConnection ( edges , i ). empty ()) return edges [ i ]; } throw ; } private : vector < int > findRedundantDirectedConnection ( vector < vector < int >>& edges , int skippedEdgeIndex ) { UF uf ( edges . size ()); for ( int i = 0 ; i < edges . size (); ++ i ) { if ( i == skippedEdgeIndex ) continue ; if ( ! uf . union_ ( edges [ i ][ 0 ], edges [ i ][ 1 ])) return edges [ i ]; } return {}; } };","title":"685. Redundant Connection II $\\star\\star\\star$"},{"location":"cpp/0601-0700/0681-0690/#686-repeated-string-match-star","text":"class Solution { public : int repeatedStringMatch ( string A , string B ) { const int n = ceil (( double ) B . length () / A . length ()); string s ; for ( int i = 0 ; i < n ; ++ i ) s += A ; if ( s . find ( B ) != string :: npos ) return n ; if (( s + A ). find ( B ) != string :: npos ) return n + 1 ; return - 1 ; } };","title":"686. Repeated String Match $\\star$"},{"location":"cpp/0601-0700/0681-0690/#687-longest-univalue-path-star","text":"","title":"687. Longest Univalue Path $\\star$"},{"location":"cpp/0601-0700/0681-0690/#688-knight-probability-in-chessboard-starstar","text":"","title":"688. Knight Probability in Chessboard $\\star\\star$"},{"location":"cpp/0601-0700/0681-0690/#689-maximum-sum-of-3-non-overlapping-subarrays-starstarstar","text":"class Solution { public : vector < int > maxSumOfThreeSubarrays ( vector < int >& nums , int k ) { vector < int > ans = { - 1 , - 1 , - 1 }; int subarrayCount = nums . size () - k + 1 ; vector < int > dp ( subarrayCount ); int sum = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) { sum += nums [ i ]; if ( i >= k ) sum -= nums [ i - k ]; if ( i >= k - 1 ) dp [ i - k + 1 ] = sum ; } vector < int > left ( subarrayCount ); int maxIndex = 0 ; for ( int i = 0 ; i < subarrayCount ; ++ i ) { if ( dp [ i ] > dp [ maxIndex ]) maxIndex = i ; left [ i ] = maxIndex ; } vector < int > right ( subarrayCount ); maxIndex = subarrayCount - 1 ; for ( int i = subarrayCount - 1 ; i >= 0 ; -- i ) { if ( dp [ i ] >= dp [ maxIndex ]) maxIndex = i ; right [ i ] = maxIndex ; } for ( int i = k ; i < subarrayCount - k ; ++ i ) if ( ans [ 0 ] == - 1 || dp [ left [ i - k ]] + dp [ i ] + dp [ right [ i + k ]] > dp [ ans [ 0 ]] + dp [ ans [ 1 ]] + dp [ ans [ 2 ]]) ans = { left [ i - k ], i , right [ i + k ]}; return ans ; } };","title":"689. Maximum Sum of 3 Non-Overlapping Subarrays $\\star\\star\\star$"},{"location":"cpp/0601-0700/0681-0690/#690-employee-importance-star","text":"class Solution { public : int getImportance ( vector < Employee *> employees , int id ) { unordered_map < int , Employee *> idToEmployee ; for ( Employee * employee : employees ) idToEmployee [ employee -> id ] = employee ; return dfs ( idToEmployee , id ); } private : int dfs ( unordered_map < int , Employee *>& idToEmployee , int id ) { int subordinatesImportance = 0 ; for ( int subordinate : idToEmployee [ id ] -> subordinates ) subordinatesImportance += dfs ( idToEmployee , subordinate ); return idToEmployee [ id ] -> importance + subordinatesImportance ; } };","title":"690. Employee Importance $\\star$"},{"location":"cpp/0601-0700/0691-0700/","text":"691. Stickers to Spell Word $\\star\\star\\star$ 692. Top K Frequent Words $\\star\\star$ class Solution { public : vector < string > topKFrequent ( vector < string >& words , int k ) { vector < string > ans ; vector < vector < string >> bucket ( words . size () + 1 ); unordered_map < string , int > count ; for ( const string & word : words ) ++ count [ word ]; for ( const auto & [ word , freq ] : count ) bucket [ freq ]. push_back ( word ); for ( int freq = bucket . size () - 1 ; freq >= 0 ; -- freq ) { sort ( begin ( bucket [ freq ]), end ( bucket [ freq ])); for ( const string & word : bucket [ freq ]) { ans . push_back ( word ); if ( ans . size () == k ) return ans ; } } throw ; } }; 693. Binary Number with Alternating Bits $\\star$ 694. Number of Distinct Islands $\\star\\star$ \ud83d\udd12 695. Max Area of Island $\\star\\star$ class Solution { public : int maxAreaOfIsland ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); int ans = 0 ; vector < vector < bool >> seen ( m , vector < bool > ( n )); function < int ( int , int ) > dfs = [ & ]( int i , int j ) { if ( i < 0 || i >= m || j < 0 || j >= n ) return 0 ; if ( grid [ i ][ j ] == 0 || seen [ i ][ j ]) return 0 ; seen [ i ][ j ] = true ; return 1 + dfs ( i + 1 , j ) + dfs ( i - 1 , j ) + dfs ( i , j + 1 ) + dfs ( i , j - 1 ); }; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) ans = max ( ans , dfs ( i , j )); return ans ; } }; 696. Count Binary Substrings $\\star$ class Solution { public : int countBinarySubstrings ( string s ) { int ans = 0 ; int prevCount = 0 ; int equals = 1 ; for ( int i = 0 ; i + 1 < s . length (); ++ i ) if ( s [ i ] == s [ i + 1 ]) ++ equals ; else { ans += min ( prevCount , equals ); prevCount = equals ; equals = 1 ; } return ans + min ( prevCount , equals ); } }; 697. Degree of an Array $\\star$ class Solution { public : int findShortestSubArray ( vector < int >& nums ) { int ans = 0 ; int degree = 0 ; unordered_map < int , int > firstSeen ; unordered_map < int , int > numCounts ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( ! firstSeen . count ( nums [ i ])) firstSeen [ nums [ i ]] = i ; ++ numCounts [ nums [ i ]]; if ( numCounts [ nums [ i ]] > degree ) { degree = numCounts [ nums [ i ]]; ans = i - firstSeen [ nums [ i ]] + 1 ; } else if ( numCounts [ nums [ i ]] == degree ) ans = min ( ans , i - firstSeen [ nums [ i ]] + 1 ); } return ans ; } }; 698. Partition to K Equal Sum Subsets $\\star\\star$ 699. Falling Squares $\\star\\star\\star$ 700. Search in a Binary Search Tree $\\star$","title":"0691-0700"},{"location":"cpp/0601-0700/0691-0700/#691-stickers-to-spell-word-starstarstar","text":"","title":"691. Stickers to Spell Word $\\star\\star\\star$"},{"location":"cpp/0601-0700/0691-0700/#692-top-k-frequent-words-starstar","text":"class Solution { public : vector < string > topKFrequent ( vector < string >& words , int k ) { vector < string > ans ; vector < vector < string >> bucket ( words . size () + 1 ); unordered_map < string , int > count ; for ( const string & word : words ) ++ count [ word ]; for ( const auto & [ word , freq ] : count ) bucket [ freq ]. push_back ( word ); for ( int freq = bucket . size () - 1 ; freq >= 0 ; -- freq ) { sort ( begin ( bucket [ freq ]), end ( bucket [ freq ])); for ( const string & word : bucket [ freq ]) { ans . push_back ( word ); if ( ans . size () == k ) return ans ; } } throw ; } };","title":"692. Top K Frequent Words $\\star\\star$"},{"location":"cpp/0601-0700/0691-0700/#693-binary-number-with-alternating-bits-star","text":"","title":"693. Binary Number with Alternating Bits $\\star$"},{"location":"cpp/0601-0700/0691-0700/#694-number-of-distinct-islands-starstar","text":"","title":"694. Number of Distinct Islands $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0601-0700/0691-0700/#695-max-area-of-island-starstar","text":"class Solution { public : int maxAreaOfIsland ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); int ans = 0 ; vector < vector < bool >> seen ( m , vector < bool > ( n )); function < int ( int , int ) > dfs = [ & ]( int i , int j ) { if ( i < 0 || i >= m || j < 0 || j >= n ) return 0 ; if ( grid [ i ][ j ] == 0 || seen [ i ][ j ]) return 0 ; seen [ i ][ j ] = true ; return 1 + dfs ( i + 1 , j ) + dfs ( i - 1 , j ) + dfs ( i , j + 1 ) + dfs ( i , j - 1 ); }; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) ans = max ( ans , dfs ( i , j )); return ans ; } };","title":"695. Max Area of Island $\\star\\star$"},{"location":"cpp/0601-0700/0691-0700/#696-count-binary-substrings-star","text":"class Solution { public : int countBinarySubstrings ( string s ) { int ans = 0 ; int prevCount = 0 ; int equals = 1 ; for ( int i = 0 ; i + 1 < s . length (); ++ i ) if ( s [ i ] == s [ i + 1 ]) ++ equals ; else { ans += min ( prevCount , equals ); prevCount = equals ; equals = 1 ; } return ans + min ( prevCount , equals ); } };","title":"696. Count Binary Substrings $\\star$"},{"location":"cpp/0601-0700/0691-0700/#697-degree-of-an-array-star","text":"class Solution { public : int findShortestSubArray ( vector < int >& nums ) { int ans = 0 ; int degree = 0 ; unordered_map < int , int > firstSeen ; unordered_map < int , int > numCounts ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( ! firstSeen . count ( nums [ i ])) firstSeen [ nums [ i ]] = i ; ++ numCounts [ nums [ i ]]; if ( numCounts [ nums [ i ]] > degree ) { degree = numCounts [ nums [ i ]]; ans = i - firstSeen [ nums [ i ]] + 1 ; } else if ( numCounts [ nums [ i ]] == degree ) ans = min ( ans , i - firstSeen [ nums [ i ]] + 1 ); } return ans ; } };","title":"697. Degree of an Array $\\star$"},{"location":"cpp/0601-0700/0691-0700/#698-partition-to-k-equal-sum-subsets-starstar","text":"","title":"698. Partition to K Equal Sum Subsets $\\star\\star$"},{"location":"cpp/0601-0700/0691-0700/#699-falling-squares-starstarstar","text":"","title":"699. Falling Squares $\\star\\star\\star$"},{"location":"cpp/0601-0700/0691-0700/#700-search-in-a-binary-search-tree-star","text":"","title":"700. Search in a Binary Search Tree $\\star$"},{"location":"cpp/0701-0800/0701-0710/","text":"701. Insert into a Binary Search Tree $\\star\\star$ 702. Search in a Sorted Array of Unknown Size $\\star\\star$ \ud83d\udd12 703. Kth Largest Element in a Stream $\\star$ 704. Binary Search $\\star$ 705. Design HashSet $\\star$ class MyHashSet { public : MyHashSet () { set = vector < bool > ( 1000001 ); } void add ( int key ) { set [ key ] = true ; } void remove ( int key ) { set [ key ] = false ; } bool contains ( int key ) { return set [ key ]; } private : vector < bool > set ; }; 706. Design HashMap $\\star$ 707. Design Linked List $\\star\\star$ class MyLinkedList { public : int get ( int index ) { if ( index < 0 || index >= length ) return - 1 ; ListNode * curr = dummy . next ; for ( int i = 0 ; i < index ; ++ i ) curr = curr -> next ; return curr -> val ; } void addAtHead ( int val ) { ListNode * curr = dummy . next ; dummy . next = new ListNode ( val ); dummy . next -> next = curr ; ++ length ; } void addAtTail ( int val ) { ListNode * curr = & dummy ; while ( curr -> next ) curr = curr -> next ; curr -> next = new ListNode ( val ); ++ length ; } void addAtIndex ( int index , int val ) { if ( index > length ) return ; ListNode * curr = & dummy ; for ( int i = 0 ; i < index ; ++ i ) curr = curr -> next ; ListNode * temp = curr -> next ; curr -> next = new ListNode ( val ); curr -> next -> next = temp ; ++ length ; } void deleteAtIndex ( int index ) { if ( index < 0 || index >= length ) return ; ListNode * curr = & dummy ; for ( int i = 0 ; i < index ; ++ i ) curr = curr -> next ; ListNode * temp = curr -> next ; curr -> next = temp -> next ; -- length ; delete temp ; } private : struct ListNode { int val ; ListNode * next ; ListNode ( int x ) : val ( x ), next ( nullptr ) {} }; int length = 0 ; ListNode dummy = ListNode ( 0 ); }; 708. Insert into a Sorted Circular Linked List $\\star\\star$ \ud83d\udd12 709. To Lower Case $\\star$ 710. Random Pick with Blacklist $\\star\\star\\star$ class Solution { public : Solution ( int N , vector < int >& blacklist ) { validRange = N - blacklist . size (); for ( int b : blacklist ) map [ b ] = - 1 ; for ( int b : blacklist ) if ( b < validRange ) { while ( map . count ( N - 1 )) -- N ; map [ b ] = -- N ; } } int pick () { int value = rand () % validRange ; if ( map . count ( value )) return map [ value ]; return value ; } private : int validRange ; unordered_map < int , int > map ; };","title":"0701-0710"},{"location":"cpp/0701-0800/0701-0710/#701-insert-into-a-binary-search-tree-starstar","text":"","title":"701. Insert into a Binary Search Tree $\\star\\star$"},{"location":"cpp/0701-0800/0701-0710/#702-search-in-a-sorted-array-of-unknown-size-starstar","text":"","title":"702. Search in a Sorted Array of Unknown Size $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0701-0800/0701-0710/#703-kth-largest-element-in-a-stream-star","text":"","title":"703. Kth Largest Element in a Stream $\\star$"},{"location":"cpp/0701-0800/0701-0710/#704-binary-search-star","text":"","title":"704. Binary Search $\\star$"},{"location":"cpp/0701-0800/0701-0710/#705-design-hashset-star","text":"class MyHashSet { public : MyHashSet () { set = vector < bool > ( 1000001 ); } void add ( int key ) { set [ key ] = true ; } void remove ( int key ) { set [ key ] = false ; } bool contains ( int key ) { return set [ key ]; } private : vector < bool > set ; };","title":"705. Design HashSet $\\star$"},{"location":"cpp/0701-0800/0701-0710/#706-design-hashmap-star","text":"","title":"706. Design HashMap $\\star$"},{"location":"cpp/0701-0800/0701-0710/#707-design-linked-list-starstar","text":"class MyLinkedList { public : int get ( int index ) { if ( index < 0 || index >= length ) return - 1 ; ListNode * curr = dummy . next ; for ( int i = 0 ; i < index ; ++ i ) curr = curr -> next ; return curr -> val ; } void addAtHead ( int val ) { ListNode * curr = dummy . next ; dummy . next = new ListNode ( val ); dummy . next -> next = curr ; ++ length ; } void addAtTail ( int val ) { ListNode * curr = & dummy ; while ( curr -> next ) curr = curr -> next ; curr -> next = new ListNode ( val ); ++ length ; } void addAtIndex ( int index , int val ) { if ( index > length ) return ; ListNode * curr = & dummy ; for ( int i = 0 ; i < index ; ++ i ) curr = curr -> next ; ListNode * temp = curr -> next ; curr -> next = new ListNode ( val ); curr -> next -> next = temp ; ++ length ; } void deleteAtIndex ( int index ) { if ( index < 0 || index >= length ) return ; ListNode * curr = & dummy ; for ( int i = 0 ; i < index ; ++ i ) curr = curr -> next ; ListNode * temp = curr -> next ; curr -> next = temp -> next ; -- length ; delete temp ; } private : struct ListNode { int val ; ListNode * next ; ListNode ( int x ) : val ( x ), next ( nullptr ) {} }; int length = 0 ; ListNode dummy = ListNode ( 0 ); };","title":"707. Design Linked List $\\star\\star$"},{"location":"cpp/0701-0800/0701-0710/#708-insert-into-a-sorted-circular-linked-list-starstar","text":"","title":"708. Insert into a Sorted Circular Linked List $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0701-0800/0701-0710/#709-to-lower-case-star","text":"","title":"709. To Lower Case $\\star$"},{"location":"cpp/0701-0800/0701-0710/#710-random-pick-with-blacklist-starstarstar","text":"class Solution { public : Solution ( int N , vector < int >& blacklist ) { validRange = N - blacklist . size (); for ( int b : blacklist ) map [ b ] = - 1 ; for ( int b : blacklist ) if ( b < validRange ) { while ( map . count ( N - 1 )) -- N ; map [ b ] = -- N ; } } int pick () { int value = rand () % validRange ; if ( map . count ( value )) return map [ value ]; return value ; } private : int validRange ; unordered_map < int , int > map ; };","title":"710. Random Pick with Blacklist $\\star\\star\\star$"},{"location":"cpp/0701-0800/0711-0720/","text":"711. Number of Distinct Islands II $\\star\\star\\star$ \ud83d\udd12 712. Minimum ASCII Delete Sum for Two Strings $\\star\\star$ 713. Subarray Product Less Than K $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public : int numSubarrayProductLessThanK ( vector < int >& nums , int k ) { if ( k <= 1 ) return 0 ; int ans = 0 ; int prod = 1 ; for ( int l = 0 , r = 0 ; r < nums . size (); ++ r ) { prod *= nums [ r ]; while ( prod >= k ) prod /= nums [ l ++ ]; ans += r - l + 1 ; } return ans ; } }; 714. Best Time to Buy and Sell Stock with Transaction Fee $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : int maxProfit ( vector < int >& prices , int fee ) { int sell = 0 ; int hold = INT_MIN ; for ( int price : prices ) { sell = max ( sell , hold + price ); hold = max ( hold , sell - price - fee ); } return sell ; } }; 715. Range Module $\\star\\star\\star$ 716. Max Stack $\\star$ \ud83d\udd12 717. 1-bit and 2-bit Characters $\\star$ class Solution { public : bool isOneBitCharacter ( vector < int >& bits ) { int i = 0 ; while ( i < bits . size () - 1 ) i += bits [ i ] + 1 ; return i == bits . size () - 1 ; } }; 718. Maximum Length of Repeated Subarray $\\star\\star$ class Solution { public : int findLength ( vector < int >& A , vector < int >& B ) { int ans = 0 ; vector < int > dp ( B . size () + 1 ); for ( int i = A . size () - 1 ; i >= 0 ; -- i ) for ( int j = 0 ; j < B . size (); ++ j ) { dp [ j ] = A [ i ] == B [ j ] ? dp [ j + 1 ] + 1 : 0 ; ans = max ( ans , dp [ j ]); } return ans ; } }; 719. Find K-th Smallest Pair Distance $\\star\\star\\star$ class Solution { public : int smallestDistancePair ( vector < int >& nums , int k ) { sort ( begin ( nums ), end ( nums )); int l = 0 ; int r = nums . back () - nums . front (); while ( l < r ) { int m = l + ( r - l ) / 2 ; int count = 0 ; for ( int i = 0 , j = 0 ; i < nums . size (); ++ i ) { while ( j < nums . size () && nums [ j ] <= nums [ i ] + m ) ++ j ; count += j - i - 1 ; } if ( count < k ) l = m + 1 ; else r = m ; } return l ; } }; 720. Longest Word in Dictionary $\\star$ class Solution { public : string longestWord ( vector < string >& words ) { for ( const string & word : words ) insert ( word ); return dfs ( & root ); } private : struct TrieNode { TrieNode () : children ( 26 ), word ( nullptr ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete ( child ); } vector < TrieNode *> children ; const string * word ; }; TrieNode root ; void insert ( const string & word ) { TrieNode * node = & root ; for ( char c : word ) { TrieNode *& next = node -> children [ c - 'a' ]; if ( ! next ) next = new TrieNode ; node = next ; } node -> word = & word ; } string dfs ( TrieNode * node ) { string ans = node -> word ? * node -> word : \"\" ; for ( TrieNode * child : node -> children ) if ( child && child -> word && child -> word -> length () > 0 ) { string childWord = dfs ( child ); if ( childWord . length () > ans . length ()) ans = childWord ; } return ans ; } };","title":"0711-0720"},{"location":"cpp/0701-0800/0711-0720/#711-number-of-distinct-islands-ii-starstarstar","text":"","title":"711. Number of Distinct Islands II $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/0701-0800/0711-0720/#712-minimum-ascii-delete-sum-for-two-strings-starstar","text":"","title":"712. Minimum ASCII Delete Sum for Two Strings $\\star\\star$"},{"location":"cpp/0701-0800/0711-0720/#713-subarray-product-less-than-k-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public : int numSubarrayProductLessThanK ( vector < int >& nums , int k ) { if ( k <= 1 ) return 0 ; int ans = 0 ; int prod = 1 ; for ( int l = 0 , r = 0 ; r < nums . size (); ++ r ) { prod *= nums [ r ]; while ( prod >= k ) prod /= nums [ l ++ ]; ans += r - l + 1 ; } return ans ; } };","title":"713. Subarray Product Less Than K $\\star\\star$"},{"location":"cpp/0701-0800/0711-0720/#714-best-time-to-buy-and-sell-stock-with-transaction-fee-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : int maxProfit ( vector < int >& prices , int fee ) { int sell = 0 ; int hold = INT_MIN ; for ( int price : prices ) { sell = max ( sell , hold + price ); hold = max ( hold , sell - price - fee ); } return sell ; } };","title":"714. Best Time to Buy and Sell Stock with Transaction Fee $\\star\\star$"},{"location":"cpp/0701-0800/0711-0720/#715-range-module-starstarstar","text":"","title":"715. Range Module $\\star\\star\\star$"},{"location":"cpp/0701-0800/0711-0720/#716-max-stack-star","text":"","title":"716. Max Stack $\\star$ \ud83d\udd12"},{"location":"cpp/0701-0800/0711-0720/#717-1-bit-and-2-bit-characters-star","text":"class Solution { public : bool isOneBitCharacter ( vector < int >& bits ) { int i = 0 ; while ( i < bits . size () - 1 ) i += bits [ i ] + 1 ; return i == bits . size () - 1 ; } };","title":"717. 1-bit and 2-bit Characters $\\star$"},{"location":"cpp/0701-0800/0711-0720/#718-maximum-length-of-repeated-subarray-starstar","text":"class Solution { public : int findLength ( vector < int >& A , vector < int >& B ) { int ans = 0 ; vector < int > dp ( B . size () + 1 ); for ( int i = A . size () - 1 ; i >= 0 ; -- i ) for ( int j = 0 ; j < B . size (); ++ j ) { dp [ j ] = A [ i ] == B [ j ] ? dp [ j + 1 ] + 1 : 0 ; ans = max ( ans , dp [ j ]); } return ans ; } };","title":"718. Maximum Length of Repeated Subarray $\\star\\star$"},{"location":"cpp/0701-0800/0711-0720/#719-find-k-th-smallest-pair-distance-starstarstar","text":"class Solution { public : int smallestDistancePair ( vector < int >& nums , int k ) { sort ( begin ( nums ), end ( nums )); int l = 0 ; int r = nums . back () - nums . front (); while ( l < r ) { int m = l + ( r - l ) / 2 ; int count = 0 ; for ( int i = 0 , j = 0 ; i < nums . size (); ++ i ) { while ( j < nums . size () && nums [ j ] <= nums [ i ] + m ) ++ j ; count += j - i - 1 ; } if ( count < k ) l = m + 1 ; else r = m ; } return l ; } };","title":"719. Find K-th Smallest Pair Distance $\\star\\star\\star$"},{"location":"cpp/0701-0800/0711-0720/#720-longest-word-in-dictionary-star","text":"class Solution { public : string longestWord ( vector < string >& words ) { for ( const string & word : words ) insert ( word ); return dfs ( & root ); } private : struct TrieNode { TrieNode () : children ( 26 ), word ( nullptr ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete ( child ); } vector < TrieNode *> children ; const string * word ; }; TrieNode root ; void insert ( const string & word ) { TrieNode * node = & root ; for ( char c : word ) { TrieNode *& next = node -> children [ c - 'a' ]; if ( ! next ) next = new TrieNode ; node = next ; } node -> word = & word ; } string dfs ( TrieNode * node ) { string ans = node -> word ? * node -> word : \"\" ; for ( TrieNode * child : node -> children ) if ( child && child -> word && child -> word -> length () > 0 ) { string childWord = dfs ( child ); if ( childWord . length () > ans . length ()) ans = childWord ; } return ans ; } };","title":"720. Longest Word in Dictionary $\\star$"},{"location":"cpp/0701-0800/0721-0730/","text":"721. Accounts Merge $\\star\\star$ 722. Remove Comments $\\star\\star$ class Solution { public : vector < string > removeComments ( vector < string >& source ) { vector < string > ans ; bool commenting = false ; string modified ; for ( const string & line : source ) { for ( int i = 0 ; i < line . length ();) { if ( i + 1 == line . length ()) { if ( ! commenting ) modified += line [ i ]; ++ i ; break ; } string twoChars = line . substr ( i , 2 ); if ( twoChars == \"/*\" && ! commenting ) { commenting = true ; i += 2 ; } else if ( twoChars == \"*/\" && commenting ) { commenting = false ; i += 2 ; } else if ( twoChars == \"//\" ) { if ( ! commenting ) break ; else i += 2 ; } else { if ( ! commenting ) modified += line [ i ]; ++ i ; } } if ( modified . length () > 0 && ! commenting ) { ans . push_back ( modified ); modified = \"\" ; } } return ans ; } }; 723. Candy Crush $\\star\\star$ \ud83d\udd12 724. Find Pivot Index $\\star$ class Solution { public : int pivotIndex ( vector < int >& nums ) { int sum = accumulate ( begin ( nums ), end ( nums ), 0 ); int prefixSum = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( prefixSum == sum - prefixSum - nums [ i ]) return i ; prefixSum += nums [ i ]; } return - 1 ; } }; 725. Split Linked List in Parts $\\star\\star$ class Solution { public : vector < ListNode *> splitListToParts ( ListNode * root , int k ) { vector < ListNode *> ans ( k ); int length = 0 ; for ( ListNode * curr = root ; curr ; curr = curr -> next ) ++ length ; int subLength = length / k ; int remainder = length % k ; ListNode * prev = nullptr ; ListNode * head = root ; for ( int i = 0 ; i < k ; ++ i , -- remainder ) { ans [ i ] = head ; for ( int j = 0 ; j < subLength + ( remainder > 0 ); ++ j ) { prev = head ; head = head -> next ; } if ( prev ) prev -> next = nullptr ; } return ans ; } }; 726. Number of Atoms $\\star\\star\\star$ class Solution { public : string countOfAtoms ( string formula ) { string ans ; int i = 0 ; for ( const auto & [ elem , freq ] : parse ( formula , i )) ans += elem + ( freq == 1 ? \"\" : to_string ( freq )); return ans ; } map < string , int > parse ( string & s , int & i ) { const int n = s . length (); map < string , int > count ; while ( i < n ) { if ( s [ i ] == '(' ) { ++ i ; for ( const auto & [ elem , freq ] : parse ( s , i )) count [ elem ] += freq ; } else if ( s [ i ] == ')' ) { int numStart = ++ i ; while ( i < n && isdigit ( s [ i ])) ++ i ; int factor = stoi ( s . substr ( numStart , i - numStart )); for ( auto && [ _ , freq ] : count ) freq *= factor ; return count ; } else if ( isupper ( s [ i ])) { int elemStart = i ++ ; while ( i < n && islower ( s [ i ])) ++ i ; string elem = s . substr ( elemStart , i - elemStart ); int numStart = i ; while ( i < n && isdigit ( s [ i ])) ++ i ; string num = s . substr ( numStart , i - numStart ); count [ elem ] += num . empty () ? 1 : stoi ( num ); } } return count ; } }; 727. Minimum Window Subsequence $\\star\\star\\star$ \ud83d\udd12 728. Self Dividing Numbers $\\star$ class Solution { public : vector < int > selfDividingNumbers ( int left , int right ) { vector < int > ans ; for ( int num = left ; num <= right ; ++ num ) if ( dividingNumber ( num )) ans . push_back ( num ); return ans ; } private : bool dividingNumber ( int num ) { for ( int n = num ; n > 0 ; n /= 10 ) if ( n % 10 == 0 || num % ( n % 10 ) != 0 ) return false ; return true ; } }; 729. My Calendar I $\\star\\star$ class MyCalendar { public : bool book ( int start , int end ) { for ( pair < int , int >& book : books ) if ( max ( book . first , start ) < min ( book . second , end )) return false ; books . push_back ({ start , end }); return true ; } private : vector < pair < int , int >> books ; }; 730. Count Different Palindromic Subsequences $\\star\\star\\star$ class Solution { public : int countPalindromicSubsequences ( string S ) { const int n = S . length (); const int kMod = 1e9 + 7 ; vector < vector < int >> dp ( n , vector < int > ( n , 0 )); for ( int i = 0 ; i < n ; ++ i ) dp [ i ][ i ] = 1 ; for ( int length = 2 ; length <= n ; ++ length ) for ( int i = 0 ; i <= n - length ; ++ i ) { const int j = i + length - 1 ; if ( S [ i ] == S [ j ]) { int lo = i + 1 ; int hi = j - 1 ; while ( lo <= hi && S [ lo ] != S [ i ]) ++ lo ; while ( lo <= hi && S [ hi ] != S [ i ]) -- hi ; if ( lo > hi ) dp [ i ][ j ] = dp [ i + 1 ][ j - 1 ] * 2 + 2 ; else if ( lo == hi ) dp [ i ][ j ] = dp [ i + 1 ][ j - 1 ] * 2 + 1 ; else dp [ i ][ j ] = dp [ i + 1 ][ j - 1 ] * 2 - dp [ lo + 1 ][ hi - 1 ]; } else dp [ i ][ j ] = dp [ i ][ j - 1 ] + dp [ i + 1 ][ j ] - dp [ i + 1 ][ j - 1 ]; dp [ i ][ j ] = ( dp [ i ][ j ] + ( long ) kMod ) % kMod ; } return dp [ 0 ][ n - 1 ]; } };","title":"0721-0730"},{"location":"cpp/0701-0800/0721-0730/#721-accounts-merge-starstar","text":"","title":"721. Accounts Merge $\\star\\star$"},{"location":"cpp/0701-0800/0721-0730/#722-remove-comments-starstar","text":"class Solution { public : vector < string > removeComments ( vector < string >& source ) { vector < string > ans ; bool commenting = false ; string modified ; for ( const string & line : source ) { for ( int i = 0 ; i < line . length ();) { if ( i + 1 == line . length ()) { if ( ! commenting ) modified += line [ i ]; ++ i ; break ; } string twoChars = line . substr ( i , 2 ); if ( twoChars == \"/*\" && ! commenting ) { commenting = true ; i += 2 ; } else if ( twoChars == \"*/\" && commenting ) { commenting = false ; i += 2 ; } else if ( twoChars == \"//\" ) { if ( ! commenting ) break ; else i += 2 ; } else { if ( ! commenting ) modified += line [ i ]; ++ i ; } } if ( modified . length () > 0 && ! commenting ) { ans . push_back ( modified ); modified = \"\" ; } } return ans ; } };","title":"722. Remove Comments $\\star\\star$"},{"location":"cpp/0701-0800/0721-0730/#723-candy-crush-starstar","text":"","title":"723. Candy Crush $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0701-0800/0721-0730/#724-find-pivot-index-star","text":"class Solution { public : int pivotIndex ( vector < int >& nums ) { int sum = accumulate ( begin ( nums ), end ( nums ), 0 ); int prefixSum = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( prefixSum == sum - prefixSum - nums [ i ]) return i ; prefixSum += nums [ i ]; } return - 1 ; } };","title":"724. Find Pivot Index $\\star$"},{"location":"cpp/0701-0800/0721-0730/#725-split-linked-list-in-parts-starstar","text":"class Solution { public : vector < ListNode *> splitListToParts ( ListNode * root , int k ) { vector < ListNode *> ans ( k ); int length = 0 ; for ( ListNode * curr = root ; curr ; curr = curr -> next ) ++ length ; int subLength = length / k ; int remainder = length % k ; ListNode * prev = nullptr ; ListNode * head = root ; for ( int i = 0 ; i < k ; ++ i , -- remainder ) { ans [ i ] = head ; for ( int j = 0 ; j < subLength + ( remainder > 0 ); ++ j ) { prev = head ; head = head -> next ; } if ( prev ) prev -> next = nullptr ; } return ans ; } };","title":"725. Split Linked List in Parts $\\star\\star$"},{"location":"cpp/0701-0800/0721-0730/#726-number-of-atoms-starstarstar","text":"class Solution { public : string countOfAtoms ( string formula ) { string ans ; int i = 0 ; for ( const auto & [ elem , freq ] : parse ( formula , i )) ans += elem + ( freq == 1 ? \"\" : to_string ( freq )); return ans ; } map < string , int > parse ( string & s , int & i ) { const int n = s . length (); map < string , int > count ; while ( i < n ) { if ( s [ i ] == '(' ) { ++ i ; for ( const auto & [ elem , freq ] : parse ( s , i )) count [ elem ] += freq ; } else if ( s [ i ] == ')' ) { int numStart = ++ i ; while ( i < n && isdigit ( s [ i ])) ++ i ; int factor = stoi ( s . substr ( numStart , i - numStart )); for ( auto && [ _ , freq ] : count ) freq *= factor ; return count ; } else if ( isupper ( s [ i ])) { int elemStart = i ++ ; while ( i < n && islower ( s [ i ])) ++ i ; string elem = s . substr ( elemStart , i - elemStart ); int numStart = i ; while ( i < n && isdigit ( s [ i ])) ++ i ; string num = s . substr ( numStart , i - numStart ); count [ elem ] += num . empty () ? 1 : stoi ( num ); } } return count ; } };","title":"726. Number of Atoms $\\star\\star\\star$"},{"location":"cpp/0701-0800/0721-0730/#727-minimum-window-subsequence-starstarstar","text":"","title":"727. Minimum Window Subsequence $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/0701-0800/0721-0730/#728-self-dividing-numbers-star","text":"class Solution { public : vector < int > selfDividingNumbers ( int left , int right ) { vector < int > ans ; for ( int num = left ; num <= right ; ++ num ) if ( dividingNumber ( num )) ans . push_back ( num ); return ans ; } private : bool dividingNumber ( int num ) { for ( int n = num ; n > 0 ; n /= 10 ) if ( n % 10 == 0 || num % ( n % 10 ) != 0 ) return false ; return true ; } };","title":"728. Self Dividing Numbers $\\star$"},{"location":"cpp/0701-0800/0721-0730/#729-my-calendar-i-starstar","text":"class MyCalendar { public : bool book ( int start , int end ) { for ( pair < int , int >& book : books ) if ( max ( book . first , start ) < min ( book . second , end )) return false ; books . push_back ({ start , end }); return true ; } private : vector < pair < int , int >> books ; };","title":"729. My Calendar I $\\star\\star$"},{"location":"cpp/0701-0800/0721-0730/#730-count-different-palindromic-subsequences-starstarstar","text":"class Solution { public : int countPalindromicSubsequences ( string S ) { const int n = S . length (); const int kMod = 1e9 + 7 ; vector < vector < int >> dp ( n , vector < int > ( n , 0 )); for ( int i = 0 ; i < n ; ++ i ) dp [ i ][ i ] = 1 ; for ( int length = 2 ; length <= n ; ++ length ) for ( int i = 0 ; i <= n - length ; ++ i ) { const int j = i + length - 1 ; if ( S [ i ] == S [ j ]) { int lo = i + 1 ; int hi = j - 1 ; while ( lo <= hi && S [ lo ] != S [ i ]) ++ lo ; while ( lo <= hi && S [ hi ] != S [ i ]) -- hi ; if ( lo > hi ) dp [ i ][ j ] = dp [ i + 1 ][ j - 1 ] * 2 + 2 ; else if ( lo == hi ) dp [ i ][ j ] = dp [ i + 1 ][ j - 1 ] * 2 + 1 ; else dp [ i ][ j ] = dp [ i + 1 ][ j - 1 ] * 2 - dp [ lo + 1 ][ hi - 1 ]; } else dp [ i ][ j ] = dp [ i ][ j - 1 ] + dp [ i + 1 ][ j ] - dp [ i + 1 ][ j - 1 ]; dp [ i ][ j ] = ( dp [ i ][ j ] + ( long ) kMod ) % kMod ; } return dp [ 0 ][ n - 1 ]; } };","title":"730. Count Different Palindromic Subsequences $\\star\\star\\star$"},{"location":"cpp/0701-0800/0731-0740/","text":"731. My Calendar II $\\star\\star$ class MyCalendarTwo { public : MyCalendarTwo () {} bool book ( int start , int end ) { for ( const auto & [ first , second ] : overlaps ) if ( max ( start , first ) < min ( end , second )) return false ; for ( const auto & [ first , second ] : booked ) { int s = max ( start , first ); int e = min ( end , second ); if ( s < e ) overlaps . emplace_back ( s , e ); } booked . emplace_back ( start , end ); return true ; } private : vector < pair < int , int >> booked ; vector < pair < int , int >> overlaps ; }; 732. My Calendar III $\\star\\star\\star$ 733. Flood Fill $\\star$ class Solution { public : vector < vector < int >> floodFill ( vector < vector < int >>& image , int sr , int sc , int newColor ) { int startColor = image [ sr ][ sc ]; vector < vector < bool >> seen ( image . size (), vector < bool > ( image [ 0 ]. size ())); function < void ( int , int ) > dfs = [ & ]( int i , int j ) { if ( i < 0 || i >= image . size () || j < 0 || j >= image [ 0 ]. size ()) return ; if ( image [ i ][ j ] != startColor || seen [ i ][ j ]) return ; image [ i ][ j ] = newColor ; seen [ i ][ j ] = true ; dfs ( i + 1 , j ); dfs ( i - 1 , j ); dfs ( i , j + 1 ); dfs ( i , j - 1 ); }; dfs ( sr , sc ); return image ; } }; 734. Sentence Similarity $\\star$ \ud83d\udd12 735. Asteroid Collision $\\star\\star$ 736. Parse Lisp Expression $\\star\\star\\star$ class Solution { public : int evaluate ( string expression ) { return evaluate ( expression , unordered_map < string , int > ()); } private : int evaluate ( const string & e , unordered_map < string , int > prevScope ) { if ( isdigit ( e [ 0 ]) || e [ 0 ] == '-' ) return stoi ( e ); if ( prevScope . count ( e )) return prevScope [ e ]; unordered_map < string , int > scope = prevScope ; int spaceIndex = e . find_first_of ( ' ' ); string nextExpression = e . substr ( spaceIndex + 1 , e . length () - spaceIndex - 2 ); vector < string > tokens = parse ( nextExpression ); if ( e [ 1 ] == 'a' ) return evaluate ( tokens [ 0 ], scope ) + evaluate ( tokens [ 1 ], scope ); if ( e [ 1 ] == 'm' ) return evaluate ( tokens [ 0 ], scope ) * evaluate ( tokens [ 1 ], scope ); for ( int i = 0 ; i < tokens . size () - 2 ; i += 2 ) scope [ tokens [ i ]] = evaluate ( tokens [ i + 1 ], scope ); return evaluate ( tokens . back (), scope ); } vector < string > parse ( const string & e ) { vector < string > tokens ; string s ; int parenthesis = 0 ; for ( char c : e ) { if ( c == '(' ) ++ parenthesis ; else if ( c == ' ) ' ) -- parenthesis ; if ( parenthesis == 0 && c == ' ' ) { tokens . push_back ( s ); s = \"\" ; } else s += c ; } if ( s . length () > 0 ) tokens . push_back ( s ); return tokens ; } }; 737. Sentence Similarity II $\\star\\star$ \ud83d\udd12 738. Monotone Increasing Digits $\\star\\star$ 739. Daily Temperatures $\\star\\star$ class Solution { public : vector < int > dailyTemperatures ( vector < int >& T ) { vector < int > ans ( T . size ()); stack < int > stack ; for ( int i = 0 ; i < T . size (); ++ i ) { while ( ! stack . empty () && T [ i ] > T [ stack . top ()]) { int index = stack . top (); stack . pop (); ans [ index ] = i - index ; } stack . push ( i ); } return ans ; } }; 740. Delete and Earn $\\star\\star$","title":"0731-0740"},{"location":"cpp/0701-0800/0731-0740/#731-my-calendar-ii-starstar","text":"class MyCalendarTwo { public : MyCalendarTwo () {} bool book ( int start , int end ) { for ( const auto & [ first , second ] : overlaps ) if ( max ( start , first ) < min ( end , second )) return false ; for ( const auto & [ first , second ] : booked ) { int s = max ( start , first ); int e = min ( end , second ); if ( s < e ) overlaps . emplace_back ( s , e ); } booked . emplace_back ( start , end ); return true ; } private : vector < pair < int , int >> booked ; vector < pair < int , int >> overlaps ; };","title":"731. My Calendar II $\\star\\star$"},{"location":"cpp/0701-0800/0731-0740/#732-my-calendar-iii-starstarstar","text":"","title":"732. My Calendar III $\\star\\star\\star$"},{"location":"cpp/0701-0800/0731-0740/#733-flood-fill-star","text":"class Solution { public : vector < vector < int >> floodFill ( vector < vector < int >>& image , int sr , int sc , int newColor ) { int startColor = image [ sr ][ sc ]; vector < vector < bool >> seen ( image . size (), vector < bool > ( image [ 0 ]. size ())); function < void ( int , int ) > dfs = [ & ]( int i , int j ) { if ( i < 0 || i >= image . size () || j < 0 || j >= image [ 0 ]. size ()) return ; if ( image [ i ][ j ] != startColor || seen [ i ][ j ]) return ; image [ i ][ j ] = newColor ; seen [ i ][ j ] = true ; dfs ( i + 1 , j ); dfs ( i - 1 , j ); dfs ( i , j + 1 ); dfs ( i , j - 1 ); }; dfs ( sr , sc ); return image ; } };","title":"733. Flood Fill $\\star$"},{"location":"cpp/0701-0800/0731-0740/#734-sentence-similarity-star","text":"","title":"734. Sentence Similarity $\\star$ \ud83d\udd12"},{"location":"cpp/0701-0800/0731-0740/#735-asteroid-collision-starstar","text":"","title":"735. Asteroid Collision $\\star\\star$"},{"location":"cpp/0701-0800/0731-0740/#736-parse-lisp-expression-starstarstar","text":"class Solution { public : int evaluate ( string expression ) { return evaluate ( expression , unordered_map < string , int > ()); } private : int evaluate ( const string & e , unordered_map < string , int > prevScope ) { if ( isdigit ( e [ 0 ]) || e [ 0 ] == '-' ) return stoi ( e ); if ( prevScope . count ( e )) return prevScope [ e ]; unordered_map < string , int > scope = prevScope ; int spaceIndex = e . find_first_of ( ' ' ); string nextExpression = e . substr ( spaceIndex + 1 , e . length () - spaceIndex - 2 ); vector < string > tokens = parse ( nextExpression ); if ( e [ 1 ] == 'a' ) return evaluate ( tokens [ 0 ], scope ) + evaluate ( tokens [ 1 ], scope ); if ( e [ 1 ] == 'm' ) return evaluate ( tokens [ 0 ], scope ) * evaluate ( tokens [ 1 ], scope ); for ( int i = 0 ; i < tokens . size () - 2 ; i += 2 ) scope [ tokens [ i ]] = evaluate ( tokens [ i + 1 ], scope ); return evaluate ( tokens . back (), scope ); } vector < string > parse ( const string & e ) { vector < string > tokens ; string s ; int parenthesis = 0 ; for ( char c : e ) { if ( c == '(' ) ++ parenthesis ; else if ( c == ' ) ' ) -- parenthesis ; if ( parenthesis == 0 && c == ' ' ) { tokens . push_back ( s ); s = \"\" ; } else s += c ; } if ( s . length () > 0 ) tokens . push_back ( s ); return tokens ; } };","title":"736. Parse Lisp Expression $\\star\\star\\star$"},{"location":"cpp/0701-0800/0731-0740/#737-sentence-similarity-ii-starstar","text":"","title":"737. Sentence Similarity II $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0701-0800/0731-0740/#738-monotone-increasing-digits-starstar","text":"","title":"738. Monotone Increasing Digits $\\star\\star$"},{"location":"cpp/0701-0800/0731-0740/#739-daily-temperatures-starstar","text":"class Solution { public : vector < int > dailyTemperatures ( vector < int >& T ) { vector < int > ans ( T . size ()); stack < int > stack ; for ( int i = 0 ; i < T . size (); ++ i ) { while ( ! stack . empty () && T [ i ] > T [ stack . top ()]) { int index = stack . top (); stack . pop (); ans [ index ] = i - index ; } stack . push ( i ); } return ans ; } };","title":"739. Daily Temperatures $\\star\\star$"},{"location":"cpp/0701-0800/0731-0740/#740-delete-and-earn-starstar","text":"","title":"740. Delete and Earn $\\star\\star$"},{"location":"cpp/0701-0800/0741-0750/","text":"741. Cherry Pickup $\\star\\star\\star$ 742. Closest Leaf in a Binary Tree $\\star\\star$ \ud83d\udd12 743. Network Delay Time $\\star\\star$ 744. Find Smallest Letter Greater Than Target $\\star$ class Solution { public : char nextGreatestLetter ( vector < char >& letters , char target ) { int l = 0 ; int r = letters . size (); while ( l < r ) { int m = ( l + r ) >> 1 ; if ( letters [ m ] <= target ) l = m + 1 ; else r = m ; } return letters [ l % letters . size ()]; } }; 745. Prefix and Suffix Search $\\star\\star\\star$ 746. Min Cost Climbing Stairs $\\star$ class Solution { public : int minCostClimbingStairs ( vector < int >& cost ) { const int n = cost . size (); for ( int i = 2 ; i < n ; ++ i ) cost [ i ] += min ( cost [ i - 1 ], cost [ i - 2 ]); return min ( cost [ n - 1 ], cost [ n - 2 ]); } }; 747. Largest Number At Least Twice of Others $\\star$ class Solution { public : int dominantIndex ( vector < int >& nums ) { int ans ; int max = 0 ; int secondMax = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( nums [ i ] > max ) { secondMax = max ; max = nums [ i ]; ans = i ; } else if ( nums [ i ] > secondMax ) secondMax = nums [ i ]; } return max >= 2 * secondMax ? ans : - 1 ; } }; 748. Shortest Completing Word $\\star$ class Solution { public : string shortestCompletingWord ( string licensePlate , vector < string >& words ) { string ans = \"****************\" ; vector < int > count ( 26 ); for ( char c : licensePlate ) if ( isalpha ( c )) ++ count [ tolower ( c ) - 'a' ]; for ( const string & word : words ) if ( word . length () < ans . length () && isMatch ( word , count )) ans = word ; return ans ; } private : bool isMatch ( const string & word , vector < int >& count ) { vector < int > wordCount ( 26 ); for ( char c : word ) ++ wordCount [ c - 'a' ]; for ( int i = 0 ; i < 26 ; ++ i ) if ( wordCount [ i ] < count [ i ]) return false ; return true ; } }; 749. Contain Virus $\\star\\star\\star$ 750. Number Of Corner Rectangles $\\star\\star$ \ud83d\udd12","title":"0741-0750"},{"location":"cpp/0701-0800/0741-0750/#741-cherry-pickup-starstarstar","text":"","title":"741. Cherry Pickup $\\star\\star\\star$"},{"location":"cpp/0701-0800/0741-0750/#742-closest-leaf-in-a-binary-tree-starstar","text":"","title":"742. Closest Leaf in a Binary Tree $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0701-0800/0741-0750/#743-network-delay-time-starstar","text":"","title":"743. Network Delay Time $\\star\\star$"},{"location":"cpp/0701-0800/0741-0750/#744-find-smallest-letter-greater-than-target-star","text":"class Solution { public : char nextGreatestLetter ( vector < char >& letters , char target ) { int l = 0 ; int r = letters . size (); while ( l < r ) { int m = ( l + r ) >> 1 ; if ( letters [ m ] <= target ) l = m + 1 ; else r = m ; } return letters [ l % letters . size ()]; } };","title":"744. Find Smallest Letter Greater Than Target $\\star$"},{"location":"cpp/0701-0800/0741-0750/#745-prefix-and-suffix-search-starstarstar","text":"","title":"745. Prefix and Suffix Search $\\star\\star\\star$"},{"location":"cpp/0701-0800/0741-0750/#746-min-cost-climbing-stairs-star","text":"class Solution { public : int minCostClimbingStairs ( vector < int >& cost ) { const int n = cost . size (); for ( int i = 2 ; i < n ; ++ i ) cost [ i ] += min ( cost [ i - 1 ], cost [ i - 2 ]); return min ( cost [ n - 1 ], cost [ n - 2 ]); } };","title":"746. Min Cost Climbing Stairs $\\star$"},{"location":"cpp/0701-0800/0741-0750/#747-largest-number-at-least-twice-of-others-star","text":"class Solution { public : int dominantIndex ( vector < int >& nums ) { int ans ; int max = 0 ; int secondMax = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( nums [ i ] > max ) { secondMax = max ; max = nums [ i ]; ans = i ; } else if ( nums [ i ] > secondMax ) secondMax = nums [ i ]; } return max >= 2 * secondMax ? ans : - 1 ; } };","title":"747. Largest Number At Least Twice of Others $\\star$"},{"location":"cpp/0701-0800/0741-0750/#748-shortest-completing-word-star","text":"class Solution { public : string shortestCompletingWord ( string licensePlate , vector < string >& words ) { string ans = \"****************\" ; vector < int > count ( 26 ); for ( char c : licensePlate ) if ( isalpha ( c )) ++ count [ tolower ( c ) - 'a' ]; for ( const string & word : words ) if ( word . length () < ans . length () && isMatch ( word , count )) ans = word ; return ans ; } private : bool isMatch ( const string & word , vector < int >& count ) { vector < int > wordCount ( 26 ); for ( char c : word ) ++ wordCount [ c - 'a' ]; for ( int i = 0 ; i < 26 ; ++ i ) if ( wordCount [ i ] < count [ i ]) return false ; return true ; } };","title":"748. Shortest Completing Word $\\star$"},{"location":"cpp/0701-0800/0741-0750/#749-contain-virus-starstarstar","text":"","title":"749. Contain Virus $\\star\\star\\star$"},{"location":"cpp/0701-0800/0741-0750/#750-number-of-corner-rectangles-starstar","text":"","title":"750. Number Of Corner Rectangles $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0701-0800/0751-0760/","text":"751. IP to CIDR $\\star$ \ud83d\udd12 752. Open the Lock $\\star\\star$ 753. Cracking the Safe $\\star\\star\\star$ class Solution { public : string crackSafe ( int n , int k ) { string ans ( n , '0' ); const int passwordSize = pow ( k , n ); unordered_set < string > seen { ans }; function < bool () > dfs = [ & ]() { if ( seen . size () == passwordSize ) return true ; string prefix = ans . substr ( ans . length () - n + 1 ); for ( char c = '0' ; c < '0' + k ; ++ c ) { prefix . push_back ( c ); if ( ! seen . count ( prefix )) { seen . insert ( prefix ); ans . push_back ( c ); if ( dfs ()) return true ; ans . pop_back (); seen . erase ( prefix ); } prefix . pop_back (); } return false ; }; dfs (); return ans ; } }; 754. Reach a Number $\\star\\star$ class Solution { public : int reachNumber ( int target ) { int ans = 0 ; int pos = 0 ; target = abs ( target ); while ( pos < target ) pos += ++ ans ; while (( pos - target ) & 1 ) pos += ++ ans ; return ans ; } }; 755. Pour Water $\\star\\star$ \ud83d\udd12 756. Pyramid Transition Matrix $\\star\\star$ class Solution { public : bool pyramidTransition ( string bottom , vector < string >& allowed ) { unordered_map < string , vector < char >> prefixToBlocks ; for ( const string & a : allowed ) prefixToBlocks [ a . substr ( 0 , 2 )]. push_back ( a [ 2 ]); return dfs ( bottom , \"\" , prefixToBlocks , 0 ); } private : bool dfs ( const string & row , const string & nextRow , unordered_map < string , vector < char >>& prefixToBlocks , int i ) { if ( row . length () == 1 ) return true ; if ( nextRow . length () + 1 == row . length ()) return dfs ( nextRow , \"\" , prefixToBlocks , 0 ); for ( char c : prefixToBlocks [ row . substr ( i , 2 )]) if ( dfs ( row , nextRow + c , prefixToBlocks , i + 1 )) return true ; return false ; } }; 757. Set Intersection Size At Least Two $\\star\\star\\star$ 758. Bold Words in String $\\star$ \ud83d\udd12 759. Employee Free Time $\\star\\star\\star$ \ud83d\udd12 760. Find Anagram Mappings $\\star$ \ud83d\udd12","title":"0751-0760"},{"location":"cpp/0701-0800/0751-0760/#751-ip-to-cidr-star","text":"","title":"751. IP to CIDR $\\star$ \ud83d\udd12"},{"location":"cpp/0701-0800/0751-0760/#752-open-the-lock-starstar","text":"","title":"752. Open the Lock $\\star\\star$"},{"location":"cpp/0701-0800/0751-0760/#753-cracking-the-safe-starstarstar","text":"class Solution { public : string crackSafe ( int n , int k ) { string ans ( n , '0' ); const int passwordSize = pow ( k , n ); unordered_set < string > seen { ans }; function < bool () > dfs = [ & ]() { if ( seen . size () == passwordSize ) return true ; string prefix = ans . substr ( ans . length () - n + 1 ); for ( char c = '0' ; c < '0' + k ; ++ c ) { prefix . push_back ( c ); if ( ! seen . count ( prefix )) { seen . insert ( prefix ); ans . push_back ( c ); if ( dfs ()) return true ; ans . pop_back (); seen . erase ( prefix ); } prefix . pop_back (); } return false ; }; dfs (); return ans ; } };","title":"753. Cracking the Safe $\\star\\star\\star$"},{"location":"cpp/0701-0800/0751-0760/#754-reach-a-number-starstar","text":"class Solution { public : int reachNumber ( int target ) { int ans = 0 ; int pos = 0 ; target = abs ( target ); while ( pos < target ) pos += ++ ans ; while (( pos - target ) & 1 ) pos += ++ ans ; return ans ; } };","title":"754. Reach a Number $\\star\\star$"},{"location":"cpp/0701-0800/0751-0760/#755-pour-water-starstar","text":"","title":"755. Pour Water $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0701-0800/0751-0760/#756-pyramid-transition-matrix-starstar","text":"class Solution { public : bool pyramidTransition ( string bottom , vector < string >& allowed ) { unordered_map < string , vector < char >> prefixToBlocks ; for ( const string & a : allowed ) prefixToBlocks [ a . substr ( 0 , 2 )]. push_back ( a [ 2 ]); return dfs ( bottom , \"\" , prefixToBlocks , 0 ); } private : bool dfs ( const string & row , const string & nextRow , unordered_map < string , vector < char >>& prefixToBlocks , int i ) { if ( row . length () == 1 ) return true ; if ( nextRow . length () + 1 == row . length ()) return dfs ( nextRow , \"\" , prefixToBlocks , 0 ); for ( char c : prefixToBlocks [ row . substr ( i , 2 )]) if ( dfs ( row , nextRow + c , prefixToBlocks , i + 1 )) return true ; return false ; } };","title":"756. Pyramid Transition Matrix $\\star\\star$"},{"location":"cpp/0701-0800/0751-0760/#757-set-intersection-size-at-least-two-starstarstar","text":"","title":"757. Set Intersection Size At Least Two $\\star\\star\\star$"},{"location":"cpp/0701-0800/0751-0760/#758-bold-words-in-string-star","text":"","title":"758. Bold Words in String $\\star$ \ud83d\udd12"},{"location":"cpp/0701-0800/0751-0760/#759-employee-free-time-starstarstar","text":"","title":"759. Employee Free Time $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/0701-0800/0751-0760/#760-find-anagram-mappings-star","text":"","title":"760. Find Anagram Mappings $\\star$ \ud83d\udd12"},{"location":"cpp/0701-0800/0761-0770/","text":"761. Special Binary String $\\star\\star\\star$ class Solution { public : string makeLargestSpecial ( string S ) { vector < string > specials ; int count = 0 ; for ( int i = 0 , j = 0 ; j < S . length (); ++ j ) { count += S [ j ] == '1' ? 1 : - 1 ; if ( count == 0 ) { specials . push_back ( '1' + makeLargestSpecial ( S . substr ( i + 1 , j - i - 1 )) + '0' ); i = j + 1 ; } } sort ( begin ( specials ), end ( specials ), greater < string > ()); string merged ; for ( const string & special : specials ) merged += special ; return merged ; } }; 762. Prime Number of Set Bits in Binary Representation $\\star$ class Solution { public : int countPrimeSetBits ( int L , int R ) { // (10100010100010101100)2 = (665772)10 constexpr int magic = 665772 ; int ans = 0 ; for ( int n = L ; n <= R ; ++ n ) if ( magic & ( 1 << __builtin_popcountll ( n ))) ++ ans ; return ans ; } }; 763. Partition Labels $\\star\\star$ Time: $O(n)$ Space: $O(26)$ class Solution { public : vector < int > partitionLabels ( string S ) { vector < int > ans ; vector < int > letterToRightMostIndex ( 26 ); for ( int i = 0 ; i < S . length (); ++ i ) letterToRightMostIndex [ S [ i ] - 'a' ] = i ; int l = 0 ; int r = 0 ; for ( int i = 0 ; i < S . length (); ++ i ) { r = max ( r , letterToRightMostIndex [ S [ i ] - 'a' ]); if ( i == r ) { ans . push_back ( r - l + 1 ); l = r + 1 ; } } return ans ; } }; 764. Largest Plus Sign $\\star\\star$ 765. Couples Holding Hands $\\star\\star\\star$ 766. Toeplitz Matrix $\\star$ class Solution { public : bool isToeplitzMatrix ( vector < vector < int >>& matrix ) { for ( int i = 0 ; i + 1 < matrix . size (); ++ i ) for ( int j = 0 ; j + 1 < matrix [ 0 ]. size (); ++ j ) if ( matrix [ i ][ j ] != matrix [ i + 1 ][ j + 1 ]) return false ; return true ; } }; 767. Reorganize String $\\star\\star$ class Solution { public : string reorganizeString ( string S ) { const int n = S . length (); vector < int > count ( 26 ); for ( char c : S ) ++ count [ c - 'a' ]; int maxCount = * max_element ( begin ( count ), end ( count )); if ( maxCount > ( n + 1 ) / 2 ) return \"\" ; string ans ( n , ' ' ); if ( maxCount == ( n + 1 ) / 2 ) for ( char c = 'a' ; c <= 'z' ; ++ c ) if ( count [ c - 'a' ] == maxCount ) { for ( int i = 0 ; i < n ; i += 2 ) ans [ i ] = c ; count [ c - 'a' ] = 0 ; break ; } int i = maxCount == ( n + 1 ) / 2 ; for ( char c = 'a' ; c <= 'z' ; ++ c ) while ( count [ c - 'a' ] -- ) { ans [ i ] = c ; i += 2 ; if ( i >= n ) i = 1 ; } return ans ; } }; 768. Max Chunks To Make Sorted II $\\star\\star\\star$ class Solution { public : int maxChunksToSorted ( vector < int >& arr ) { const int n = arr . size (); int ans = 0 ; int max = INT_MIN ; vector < int > min ( n , arr . back ()); for ( int i = n - 2 ; i >= 0 ; -- i ) min [ i ] = std :: min ( min [ i + 1 ], arr [ i ]); for ( int i = 0 ; i < n - 1 ; ++ i ) { max = std :: max ( max , arr [ i ]); if ( max <= min [ i + 1 ]) ++ ans ; } return ans + 1 ; } }; 769. Max Chunks To Make Sorted $\\star\\star$ class Solution { public : int maxChunksToSorted ( vector < int >& arr ) { int ans = 0 ; int max = INT_MIN ; for ( int i = 0 ; i < arr . size (); ++ i ) { max = std :: max ( max , arr [ i ]); if ( max == i ) ++ ans ; } return ans ; } }; 770. Basic Calculator IV $\\star\\star\\star$","title":"0761-0770"},{"location":"cpp/0701-0800/0761-0770/#761-special-binary-string-starstarstar","text":"class Solution { public : string makeLargestSpecial ( string S ) { vector < string > specials ; int count = 0 ; for ( int i = 0 , j = 0 ; j < S . length (); ++ j ) { count += S [ j ] == '1' ? 1 : - 1 ; if ( count == 0 ) { specials . push_back ( '1' + makeLargestSpecial ( S . substr ( i + 1 , j - i - 1 )) + '0' ); i = j + 1 ; } } sort ( begin ( specials ), end ( specials ), greater < string > ()); string merged ; for ( const string & special : specials ) merged += special ; return merged ; } };","title":"761. Special Binary String $\\star\\star\\star$"},{"location":"cpp/0701-0800/0761-0770/#762-prime-number-of-set-bits-in-binary-representation-star","text":"class Solution { public : int countPrimeSetBits ( int L , int R ) { // (10100010100010101100)2 = (665772)10 constexpr int magic = 665772 ; int ans = 0 ; for ( int n = L ; n <= R ; ++ n ) if ( magic & ( 1 << __builtin_popcountll ( n ))) ++ ans ; return ans ; } };","title":"762. Prime Number of Set Bits in Binary Representation $\\star$"},{"location":"cpp/0701-0800/0761-0770/#763-partition-labels-starstar","text":"Time: $O(n)$ Space: $O(26)$ class Solution { public : vector < int > partitionLabels ( string S ) { vector < int > ans ; vector < int > letterToRightMostIndex ( 26 ); for ( int i = 0 ; i < S . length (); ++ i ) letterToRightMostIndex [ S [ i ] - 'a' ] = i ; int l = 0 ; int r = 0 ; for ( int i = 0 ; i < S . length (); ++ i ) { r = max ( r , letterToRightMostIndex [ S [ i ] - 'a' ]); if ( i == r ) { ans . push_back ( r - l + 1 ); l = r + 1 ; } } return ans ; } };","title":"763. Partition Labels $\\star\\star$"},{"location":"cpp/0701-0800/0761-0770/#764-largest-plus-sign-starstar","text":"","title":"764. Largest Plus Sign $\\star\\star$"},{"location":"cpp/0701-0800/0761-0770/#765-couples-holding-hands-starstarstar","text":"","title":"765. Couples Holding Hands $\\star\\star\\star$"},{"location":"cpp/0701-0800/0761-0770/#766-toeplitz-matrix-star","text":"class Solution { public : bool isToeplitzMatrix ( vector < vector < int >>& matrix ) { for ( int i = 0 ; i + 1 < matrix . size (); ++ i ) for ( int j = 0 ; j + 1 < matrix [ 0 ]. size (); ++ j ) if ( matrix [ i ][ j ] != matrix [ i + 1 ][ j + 1 ]) return false ; return true ; } };","title":"766. Toeplitz Matrix $\\star$"},{"location":"cpp/0701-0800/0761-0770/#767-reorganize-string-starstar","text":"class Solution { public : string reorganizeString ( string S ) { const int n = S . length (); vector < int > count ( 26 ); for ( char c : S ) ++ count [ c - 'a' ]; int maxCount = * max_element ( begin ( count ), end ( count )); if ( maxCount > ( n + 1 ) / 2 ) return \"\" ; string ans ( n , ' ' ); if ( maxCount == ( n + 1 ) / 2 ) for ( char c = 'a' ; c <= 'z' ; ++ c ) if ( count [ c - 'a' ] == maxCount ) { for ( int i = 0 ; i < n ; i += 2 ) ans [ i ] = c ; count [ c - 'a' ] = 0 ; break ; } int i = maxCount == ( n + 1 ) / 2 ; for ( char c = 'a' ; c <= 'z' ; ++ c ) while ( count [ c - 'a' ] -- ) { ans [ i ] = c ; i += 2 ; if ( i >= n ) i = 1 ; } return ans ; } };","title":"767. Reorganize String $\\star\\star$"},{"location":"cpp/0701-0800/0761-0770/#768-max-chunks-to-make-sorted-ii-starstarstar","text":"class Solution { public : int maxChunksToSorted ( vector < int >& arr ) { const int n = arr . size (); int ans = 0 ; int max = INT_MIN ; vector < int > min ( n , arr . back ()); for ( int i = n - 2 ; i >= 0 ; -- i ) min [ i ] = std :: min ( min [ i + 1 ], arr [ i ]); for ( int i = 0 ; i < n - 1 ; ++ i ) { max = std :: max ( max , arr [ i ]); if ( max <= min [ i + 1 ]) ++ ans ; } return ans + 1 ; } };","title":"768. Max Chunks To Make Sorted II $\\star\\star\\star$"},{"location":"cpp/0701-0800/0761-0770/#769-max-chunks-to-make-sorted-starstar","text":"class Solution { public : int maxChunksToSorted ( vector < int >& arr ) { int ans = 0 ; int max = INT_MIN ; for ( int i = 0 ; i < arr . size (); ++ i ) { max = std :: max ( max , arr [ i ]); if ( max == i ) ++ ans ; } return ans ; } };","title":"769. Max Chunks To Make Sorted $\\star\\star$"},{"location":"cpp/0701-0800/0761-0770/#770-basic-calculator-iv-starstarstar","text":"","title":"770. Basic Calculator IV $\\star\\star\\star$"},{"location":"cpp/0701-0800/0771-0780/","text":"771. Jewels and Stones $\\star$ class Solution { public : int numJewelsInStones ( string J , string S ) { int ans = 0 ; unordered_set < char > jewels ; for ( char j : J ) jewels . insert ( j ); for ( char s : S ) if ( jewels . count ( s )) ++ ans ; return ans ; } }; 772. Basic Calculator III $\\star\\star\\star$ \ud83d\udd12 773. Sliding Puzzle $\\star\\star\\star$ 774. Minimize Max Distance to Gas Station $\\star\\star\\star$ \ud83d\udd12 775. Global and Local Inversions $\\star\\star$ class Solution { public : bool isIdealPermutation ( vector < int >& A ) { for ( int i = 0 ; i < A . size (); ++ i ) if ( abs ( A [ i ] - i ) > 1 ) return false ; return true ; } }; 776. Split BST $\\star\\star$ \ud83d\udd12 777. Swap Adjacent in LR String $\\star\\star$ 778. Swim in Rising Water $\\star\\star\\star$ 779. K-th Symbol in Grammar $\\star\\star$ 780. Reaching Points $\\star\\star\\star$ class Solution { public : bool reachingPoints ( int sx , int sy , int tx , int ty ) { while ( sx < tx && sy < ty ) if ( tx > ty ) tx %= ty ; else ty %= tx ; return sx == tx && sy <= ty && ( ty - sy ) % tx == 0 || sy == ty && sx <= tx && ( tx - sx ) % ty == 0 ; } };","title":"0771-0780"},{"location":"cpp/0701-0800/0771-0780/#771-jewels-and-stones-star","text":"class Solution { public : int numJewelsInStones ( string J , string S ) { int ans = 0 ; unordered_set < char > jewels ; for ( char j : J ) jewels . insert ( j ); for ( char s : S ) if ( jewels . count ( s )) ++ ans ; return ans ; } };","title":"771. Jewels and Stones $\\star$"},{"location":"cpp/0701-0800/0771-0780/#772-basic-calculator-iii-starstarstar","text":"","title":"772. Basic Calculator III $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/0701-0800/0771-0780/#773-sliding-puzzle-starstarstar","text":"","title":"773. Sliding Puzzle $\\star\\star\\star$"},{"location":"cpp/0701-0800/0771-0780/#774-minimize-max-distance-to-gas-station-starstarstar","text":"","title":"774. Minimize Max Distance to Gas Station $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/0701-0800/0771-0780/#775-global-and-local-inversions-starstar","text":"class Solution { public : bool isIdealPermutation ( vector < int >& A ) { for ( int i = 0 ; i < A . size (); ++ i ) if ( abs ( A [ i ] - i ) > 1 ) return false ; return true ; } };","title":"775. Global and Local Inversions $\\star\\star$"},{"location":"cpp/0701-0800/0771-0780/#776-split-bst-starstar","text":"","title":"776. Split BST $\\star\\star$ \ud83d\udd12"},{"location":"cpp/0701-0800/0771-0780/#777-swap-adjacent-in-lr-string-starstar","text":"","title":"777. Swap Adjacent in LR String $\\star\\star$"},{"location":"cpp/0701-0800/0771-0780/#778-swim-in-rising-water-starstarstar","text":"","title":"778. Swim in Rising Water $\\star\\star\\star$"},{"location":"cpp/0701-0800/0771-0780/#779-k-th-symbol-in-grammar-starstar","text":"","title":"779. K-th Symbol in Grammar $\\star\\star$"},{"location":"cpp/0701-0800/0771-0780/#780-reaching-points-starstarstar","text":"class Solution { public : bool reachingPoints ( int sx , int sy , int tx , int ty ) { while ( sx < tx && sy < ty ) if ( tx > ty ) tx %= ty ; else ty %= tx ; return sx == tx && sy <= ty && ( ty - sy ) % tx == 0 || sy == ty && sx <= tx && ( tx - sx ) % ty == 0 ; } };","title":"780. Reaching Points $\\star\\star\\star$"},{"location":"cpp/0701-0800/0781-0790/","text":"781. Rabbits in Forest $\\star\\star$ class Solution { public : int numRabbits ( vector < int >& answers ) { int ans = 0 ; vector < int > count ( 1000 ); for ( int answer : answers ) { if ( count [ answer ] % ( answer + 1 ) == 0 ) ans += answer + 1 ; ++ count [ answer ]; } return ans ; } }; 782. Transform to Chessboard $\\star\\star\\star$ class Solution { public : int movesToChessboard ( vector < vector < int >>& board ) { const int n = board . size (); int rowSum = 0 ; int colSum = 0 ; int rowSwaps = 0 ; int colSwaps = 0 ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( board [ 0 ][ 0 ] ^ board [ i ][ 0 ] ^ board [ 0 ][ j ] ^ board [ i ][ j ] == 1 ) return - 1 ; for ( int i = 0 ; i < n ; ++ i ) { rowSum += board [ 0 ][ i ]; colSum += board [ i ][ 0 ]; } if ( rowSum != n / 2 && rowSum != ( n + 1 ) / 2 ) return - 1 ; if ( colSum != n / 2 && colSum != ( n + 1 ) / 2 ) return - 1 ; for ( int i = 0 ; i < n ; ++ i ) { rowSwaps += board [ i ][ 0 ] == ( i & 1 ); colSwaps += board [ 0 ][ i ] == ( i & 1 ); } if ( n & 1 ) { if ( rowSwaps & 1 ) rowSwaps = n - rowSwaps ; if ( colSwaps & 1 ) colSwaps = n - colSwaps ; } else { rowSwaps = min ( rowSwaps , n - rowSwaps ); colSwaps = min ( colSwaps , n - colSwaps ); } return ( rowSwaps + colSwaps ) / 2 ; } }; 783. Minimum Distance Between BST Nodes $\\star$ 784. Letter Case Permutation $\\star$ 785. Is Graph Bipartite? $\\star\\star$ 786. K-th Smallest Prime Fraction $\\star\\star\\star$ class Solution { public : vector < int > kthSmallestPrimeFraction ( vector < int >& A , int K ) { const int n = A . size (); vector < int > ans = { 0 , 1 }; double l = 0 ; double r = 1 ; while ( true ) { double m = ( l + r ) / 2 ; ans [ 0 ] = 0 ; int count = 0 ; int j = 1 ; for ( int i = 0 ; i < n ; ++ i ) { while ( j < n && A [ i ] > m * A [ j ]) ++ j ; count += n - j ; if ( j == n ) break ; if ( ans [ 0 ] * A [ j ] < ans [ 1 ] * A [ i ]) { ans [ 0 ] = A [ i ]; ans [ 1 ] = A [ j ]; } } if ( count < K ) l = m ; else if ( count > K ) r = m ; else return ans ; } } }; 787. Cheapest Flights Within K Stops $\\star\\star$ 788. Rotated Digits $\\star$ class Solution { public : int rotatedDigits ( int N ) { int ans = 0 ; for ( int i = 1 ; i <= N ; ++ i ) if ( isGoodNumber ( i )) ++ ans ; return ans ; } private : bool isGoodNumber ( int i ) { bool isRotated = false ; for ( char c : to_string ( i )) { if ( c == '0' || c == '1' || c == '8' ) continue ; if ( c == '2' || c == '5' || c == '6' || c == '9' ) isRotated = true ; else return false ; } return isRotated ; } }; 789. Escape The Ghosts $\\star\\star$ class Solution { public : bool escapeGhosts ( vector < vector < int >>& ghosts , vector < int >& target ) { int ghostSteps = INT_MAX ; for ( vector < int >& ghost : ghosts ) ghostSteps = min ( ghostSteps , abs ( ghost [ 0 ] - target [ 0 ]) + abs ( ghost [ 1 ] - target [ 1 ])); return abs ( target [ 0 ]) + abs ( target [ 1 ]) < ghostSteps ; } }; 790. Domino and Tromino Tiling $\\star\\star$ class Solution { public : int numTilings ( int N ) { const int kMod = 1e9 + 7 ; vector < long > dp ( 1001 , 0 ); dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 5 ; for ( int i = 4 ; i <= N ; ++ i ) dp [ i ] = ( 2 * dp [ i - 1 ] + dp [ i - 3 ]) % kMod ; return dp [ N ]; } };","title":"0781-0790"},{"location":"cpp/0701-0800/0781-0790/#781-rabbits-in-forest-starstar","text":"class Solution { public : int numRabbits ( vector < int >& answers ) { int ans = 0 ; vector < int > count ( 1000 ); for ( int answer : answers ) { if ( count [ answer ] % ( answer + 1 ) == 0 ) ans += answer + 1 ; ++ count [ answer ]; } return ans ; } };","title":"781. Rabbits in Forest $\\star\\star$"},{"location":"cpp/0701-0800/0781-0790/#782-transform-to-chessboard-starstarstar","text":"class Solution { public : int movesToChessboard ( vector < vector < int >>& board ) { const int n = board . size (); int rowSum = 0 ; int colSum = 0 ; int rowSwaps = 0 ; int colSwaps = 0 ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( board [ 0 ][ 0 ] ^ board [ i ][ 0 ] ^ board [ 0 ][ j ] ^ board [ i ][ j ] == 1 ) return - 1 ; for ( int i = 0 ; i < n ; ++ i ) { rowSum += board [ 0 ][ i ]; colSum += board [ i ][ 0 ]; } if ( rowSum != n / 2 && rowSum != ( n + 1 ) / 2 ) return - 1 ; if ( colSum != n / 2 && colSum != ( n + 1 ) / 2 ) return - 1 ; for ( int i = 0 ; i < n ; ++ i ) { rowSwaps += board [ i ][ 0 ] == ( i & 1 ); colSwaps += board [ 0 ][ i ] == ( i & 1 ); } if ( n & 1 ) { if ( rowSwaps & 1 ) rowSwaps = n - rowSwaps ; if ( colSwaps & 1 ) colSwaps = n - colSwaps ; } else { rowSwaps = min ( rowSwaps , n - rowSwaps ); colSwaps = min ( colSwaps , n - colSwaps ); } return ( rowSwaps + colSwaps ) / 2 ; } };","title":"782. Transform to Chessboard $\\star\\star\\star$"},{"location":"cpp/0701-0800/0781-0790/#783-minimum-distance-between-bst-nodes-star","text":"","title":"783. Minimum Distance Between BST Nodes $\\star$"},{"location":"cpp/0701-0800/0781-0790/#784-letter-case-permutation-star","text":"","title":"784. Letter Case Permutation $\\star$"},{"location":"cpp/0701-0800/0781-0790/#785-is-graph-bipartite-starstar","text":"","title":"785. Is Graph Bipartite? $\\star\\star$"},{"location":"cpp/0701-0800/0781-0790/#786-k-th-smallest-prime-fraction-starstarstar","text":"class Solution { public : vector < int > kthSmallestPrimeFraction ( vector < int >& A , int K ) { const int n = A . size (); vector < int > ans = { 0 , 1 }; double l = 0 ; double r = 1 ; while ( true ) { double m = ( l + r ) / 2 ; ans [ 0 ] = 0 ; int count = 0 ; int j = 1 ; for ( int i = 0 ; i < n ; ++ i ) { while ( j < n && A [ i ] > m * A [ j ]) ++ j ; count += n - j ; if ( j == n ) break ; if ( ans [ 0 ] * A [ j ] < ans [ 1 ] * A [ i ]) { ans [ 0 ] = A [ i ]; ans [ 1 ] = A [ j ]; } } if ( count < K ) l = m ; else if ( count > K ) r = m ; else return ans ; } } };","title":"786. K-th Smallest Prime Fraction $\\star\\star\\star$"},{"location":"cpp/0701-0800/0781-0790/#787-cheapest-flights-within-k-stops-starstar","text":"","title":"787. Cheapest Flights Within K Stops $\\star\\star$"},{"location":"cpp/0701-0800/0781-0790/#788-rotated-digits-star","text":"class Solution { public : int rotatedDigits ( int N ) { int ans = 0 ; for ( int i = 1 ; i <= N ; ++ i ) if ( isGoodNumber ( i )) ++ ans ; return ans ; } private : bool isGoodNumber ( int i ) { bool isRotated = false ; for ( char c : to_string ( i )) { if ( c == '0' || c == '1' || c == '8' ) continue ; if ( c == '2' || c == '5' || c == '6' || c == '9' ) isRotated = true ; else return false ; } return isRotated ; } };","title":"788. Rotated Digits $\\star$"},{"location":"cpp/0701-0800/0781-0790/#789-escape-the-ghosts-starstar","text":"class Solution { public : bool escapeGhosts ( vector < vector < int >>& ghosts , vector < int >& target ) { int ghostSteps = INT_MAX ; for ( vector < int >& ghost : ghosts ) ghostSteps = min ( ghostSteps , abs ( ghost [ 0 ] - target [ 0 ]) + abs ( ghost [ 1 ] - target [ 1 ])); return abs ( target [ 0 ]) + abs ( target [ 1 ]) < ghostSteps ; } };","title":"789. Escape The Ghosts $\\star\\star$"},{"location":"cpp/0701-0800/0781-0790/#790-domino-and-tromino-tiling-starstar","text":"class Solution { public : int numTilings ( int N ) { const int kMod = 1e9 + 7 ; vector < long > dp ( 1001 , 0 ); dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 5 ; for ( int i = 4 ; i <= N ; ++ i ) dp [ i ] = ( 2 * dp [ i - 1 ] + dp [ i - 3 ]) % kMod ; return dp [ N ]; } };","title":"790. Domino and Tromino Tiling $\\star\\star$"},{"location":"cpp/0701-0800/0791-0800/","text":"791. Custom Sort String $\\star\\star$ class Solution { public : string customSortString ( string S , string T ) { string ans ; vector < int > count ( 26 ); for ( char c : T ) ++ count [ c - 'a' ]; for ( char c : S ) while ( count [ c - 'a' ] -- > 0 ) ans += c ; for ( int i = 0 ; i < 26 ; ++ i ) while ( count [ i ] -- > 0 ) ans += i + 'a' ; return ans ; } }; 792. Number of Matching Subsequences $\\star\\star$ class Solution { public : int numMatchingSubseq ( string S , vector < string >& words ) { for ( const string & word : words ) insert ( word ); return dfs ( S , 0 , & root ); } private : struct TrieNode { TrieNode () : children ( 26 ), count ( 0 ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete child ; } vector < TrieNode *> children ; int count ; }; void insert ( const string & word ) { TrieNode * node = & root ; for ( char c : word ) { TrieNode *& next = node -> children [ c - 'a' ]; if ( ! next ) next = new TrieNode ; node = next ; } ++ node -> count ; } int dfs ( const string & S , int s , TrieNode * node ) { int ans = node -> count ; if ( s >= S . length ()) return ans ; for ( int i = 0 ; i < 26 ; ++ i ) if ( node -> children [ i ]) { int index = indexOf ( S , i + 'a' , s ); if ( index != - 1 ) ans += dfs ( S , index + 1 , node -> children [ i ]); } return ans ; } int indexOf ( const string & S , char c , int s ) { for ( int i = s ; i < S . length (); ++ i ) if ( S [ i ] == c ) return i ; return - 1 ; } TrieNode root ; }; 793. Preimage Size of Factorial Zeroes Function $\\star\\star\\star$ 794. Valid Tic-Tac-Toe State $\\star\\star$ class Solution { public : bool validTicTacToe ( vector < string >& board ) { int countX = sum ( board , 'X' ); int countO = sum ( board , 'O' ); if ( countX < countO || countX - countO > 1 ) return false ; if ( isWinned ( board , 'X' ) && countX == countO || isWinned ( board , 'O' ) && countX != countO ) return false ; return true ; } private : int sum ( const vector < string >& board , char c ) { int ans = 0 ; for ( const string & row : board ) ans += count ( begin ( row ), end ( row ), c ); return ans ; } bool isWinned ( const vector < string >& board , char c ) { vector < string > rotated = rotate ( board ); auto equalsToThree = [ & c ]( const string & row ) { return count ( begin ( row ), end ( row ), c ) == 3 ; }; return any_of ( begin ( board ), end ( board ), equalsToThree ) || any_of ( begin ( rotated ), end ( rotated ), equalsToThree ) || board [ 0 ][ 0 ] == c && board [ 1 ][ 1 ] == c && board [ 2 ][ 2 ] == c || board [ 0 ][ 2 ] == c && board [ 1 ][ 1 ] == c && board [ 2 ][ 0 ] == c ; } vector < string > rotate ( const vector < string >& board ) { vector < string > rotated ( 3 ); for ( const string & row : board ) for ( int i = 0 ; i < 3 ; ++ i ) rotated [ i ]. push_back ( row [ i ]); return rotated ; } }; 795. Number of Subarrays with Bounded Maximum $\\star\\star$ class Solution { public : int numSubarrayBoundedMax ( vector < int >& A , int L , int R ) { int ans = 0 ; int l = - 1 ; int r = - 1 ; for ( int i = 0 ; i < A . size (); ++ i ) { if ( A [ i ] > R ) l = i ; if ( A [ i ] >= L ) r = i ; ans += r - l ; } return ans ; } }; 796. Rotate String $\\star$ 797. All Paths From Source to Target $\\star\\star$ 798. Smallest Rotation with Highest Score $\\star\\star\\star$ 799. Champagne Tower $\\star\\star$ 800. Similar RGB Color $\\star$ \ud83d\udd12","title":"0791-0800"},{"location":"cpp/0701-0800/0791-0800/#791-custom-sort-string-starstar","text":"class Solution { public : string customSortString ( string S , string T ) { string ans ; vector < int > count ( 26 ); for ( char c : T ) ++ count [ c - 'a' ]; for ( char c : S ) while ( count [ c - 'a' ] -- > 0 ) ans += c ; for ( int i = 0 ; i < 26 ; ++ i ) while ( count [ i ] -- > 0 ) ans += i + 'a' ; return ans ; } };","title":"791. Custom Sort String $\\star\\star$"},{"location":"cpp/0701-0800/0791-0800/#792-number-of-matching-subsequences-starstar","text":"class Solution { public : int numMatchingSubseq ( string S , vector < string >& words ) { for ( const string & word : words ) insert ( word ); return dfs ( S , 0 , & root ); } private : struct TrieNode { TrieNode () : children ( 26 ), count ( 0 ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete child ; } vector < TrieNode *> children ; int count ; }; void insert ( const string & word ) { TrieNode * node = & root ; for ( char c : word ) { TrieNode *& next = node -> children [ c - 'a' ]; if ( ! next ) next = new TrieNode ; node = next ; } ++ node -> count ; } int dfs ( const string & S , int s , TrieNode * node ) { int ans = node -> count ; if ( s >= S . length ()) return ans ; for ( int i = 0 ; i < 26 ; ++ i ) if ( node -> children [ i ]) { int index = indexOf ( S , i + 'a' , s ); if ( index != - 1 ) ans += dfs ( S , index + 1 , node -> children [ i ]); } return ans ; } int indexOf ( const string & S , char c , int s ) { for ( int i = s ; i < S . length (); ++ i ) if ( S [ i ] == c ) return i ; return - 1 ; } TrieNode root ; };","title":"792. Number of Matching Subsequences $\\star\\star$"},{"location":"cpp/0701-0800/0791-0800/#793-preimage-size-of-factorial-zeroes-function-starstarstar","text":"","title":"793. Preimage Size of Factorial Zeroes Function $\\star\\star\\star$"},{"location":"cpp/0701-0800/0791-0800/#794-valid-tic-tac-toe-state-starstar","text":"class Solution { public : bool validTicTacToe ( vector < string >& board ) { int countX = sum ( board , 'X' ); int countO = sum ( board , 'O' ); if ( countX < countO || countX - countO > 1 ) return false ; if ( isWinned ( board , 'X' ) && countX == countO || isWinned ( board , 'O' ) && countX != countO ) return false ; return true ; } private : int sum ( const vector < string >& board , char c ) { int ans = 0 ; for ( const string & row : board ) ans += count ( begin ( row ), end ( row ), c ); return ans ; } bool isWinned ( const vector < string >& board , char c ) { vector < string > rotated = rotate ( board ); auto equalsToThree = [ & c ]( const string & row ) { return count ( begin ( row ), end ( row ), c ) == 3 ; }; return any_of ( begin ( board ), end ( board ), equalsToThree ) || any_of ( begin ( rotated ), end ( rotated ), equalsToThree ) || board [ 0 ][ 0 ] == c && board [ 1 ][ 1 ] == c && board [ 2 ][ 2 ] == c || board [ 0 ][ 2 ] == c && board [ 1 ][ 1 ] == c && board [ 2 ][ 0 ] == c ; } vector < string > rotate ( const vector < string >& board ) { vector < string > rotated ( 3 ); for ( const string & row : board ) for ( int i = 0 ; i < 3 ; ++ i ) rotated [ i ]. push_back ( row [ i ]); return rotated ; } };","title":"794. Valid Tic-Tac-Toe State $\\star\\star$"},{"location":"cpp/0701-0800/0791-0800/#795-number-of-subarrays-with-bounded-maximum-starstar","text":"class Solution { public : int numSubarrayBoundedMax ( vector < int >& A , int L , int R ) { int ans = 0 ; int l = - 1 ; int r = - 1 ; for ( int i = 0 ; i < A . size (); ++ i ) { if ( A [ i ] > R ) l = i ; if ( A [ i ] >= L ) r = i ; ans += r - l ; } return ans ; } };","title":"795. Number of Subarrays with Bounded Maximum $\\star\\star$"},{"location":"cpp/0701-0800/0791-0800/#796-rotate-string-star","text":"","title":"796. Rotate String $\\star$"},{"location":"cpp/0701-0800/0791-0800/#797-all-paths-from-source-to-target-starstar","text":"","title":"797. All Paths From Source to Target $\\star\\star$"},{"location":"cpp/0701-0800/0791-0800/#798-smallest-rotation-with-highest-score-starstarstar","text":"","title":"798. Smallest Rotation with Highest Score $\\star\\star\\star$"},{"location":"cpp/0701-0800/0791-0800/#799-champagne-tower-starstar","text":"","title":"799. Champagne Tower $\\star\\star$"},{"location":"cpp/0701-0800/0791-0800/#800-similar-rgb-color-star","text":"","title":"800. Similar RGB Color $\\star$ \ud83d\udd12"},{"location":"cpp/0801-0900/0801-0810/","text":"801. Minimum Swaps To Make Sequences Increasing $\\star\\star$ class Solution { public : int minSwap ( vector < int >& A , vector < int >& B ) { vector < int > keepAt ( A . size (), INT_MAX ); vector < int > swapAt ( A . size (), INT_MAX ); keepAt [ 0 ] = 0 ; swapAt [ 0 ] = 1 ; for ( int i = 1 ; i < A . size (); ++ i ) { if ( A [ i ] > A [ i - 1 ] && B [ i ] > B [ i - 1 ]) { keepAt [ i ] = keepAt [ i - 1 ]; swapAt [ i ] = swapAt [ i - 1 ] + 1 ; } if ( A [ i ] > B [ i - 1 ] && B [ i ] > A [ i - 1 ]) { keepAt [ i ] = min ( keepAt [ i ], swapAt [ i - 1 ]); swapAt [ i ] = min ( swapAt [ i ], keepAt [ i - 1 ] + 1 ); } } return min ( keepAt . back (), swapAt . back ()); } }; 802. Find Eventual Safe States $\\star\\star$ 803. Bricks Falling When Hit $\\star\\star\\star$ 804. Unique Morse Code Words $\\star$ class Solution { public : int uniqueMorseRepresentations ( vector < string >& words ) { vector < string > morse { \".-\" , \"-...\" , \"-.-.\" , \"-..\" , \".\" , \"..-.\" , \"--.\" , \"....\" , \"..\" , \".---\" , \"-.-\" , \".-..\" , \"--\" , \"-.\" , \"---\" , \".--.\" , \"--.-\" , \".-.\" , \"...\" , \"-\" , \"..-\" , \"...-\" , \".--\" , \"-..-\" , \"-.--\" , \"--..\" }; unordered_set < string > transformations ; for ( const string & word : words ) { string transformation ; for ( char c : word ) transformation += morse [ c - 'a' ]; transformations . insert ( transformation ); } return transformations . size (); } }; 805. Split Array With Same Average $\\star\\star\\star$ class Solution { public : bool splitArraySameAverage ( vector < int >& A ) { const int n = A . size (); const int sum = accumulate ( begin ( A ), end ( A ), 0 ); if ( ! isPossible ( sum , n )) return false ; vector < unordered_set < int >> sums ( n / 2 + 1 ); sums [ 0 ]. insert ( 0 ); for ( int a : A ) for ( int i = n / 2 ; i > 0 ; -- i ) for ( int num : sums [ i - 1 ]) sums [ i ]. insert ( a + num ); for ( int i = 1 ; i < n / 2 + 1 ; ++ i ) if ( i * sum % n == 0 && sums [ i ]. count ( i * sum / n )) return true ; return false ; } private : bool isPossible ( int sum , int n ) { for ( int i = 1 ; i < n / 2 + 1 ; ++ i ) if ( i * sum % n == 0 ) return true ; return false ; } }; 806. Number of Lines To Write String $\\star$ 807. Max Increase to Keep City Skyline $\\star\\star$ 808. Soup Servings $\\star\\star$ class Solution { public : double soupServings ( int N ) { memo = vector < vector < double >> ( 4800 / 25 , vector < double > ( 4800 / 25 , 0 )); return N >= 4800 ? 1.0 : dfs (( N + 24 ) / 25 , ( N + 24 ) / 25 ); } private : vector < vector < double >> memo ; double dfs ( int a , int b ) { if ( a <= 0 && b <= 0 ) return 0.5 ; if ( a <= 0 ) return 1.0 ; if ( b <= 0 ) return 0.0 ; if ( memo [ a ][ b ] > 0 ) return memo [ a ][ b ]; memo [ a ][ b ] = 0.25 * ( dfs ( a - 4 , b ) + dfs ( a - 3 , b - 1 ) + dfs ( a - 2 , b - 2 ) + dfs ( a - 1 , b - 3 )); return memo [ a ][ b ]; } }; 809. Expressive Words $\\star\\star$ class Solution { public : int expressiveWords ( string S , vector < string >& words ) { int ans = 0 ; for ( const string & word : words ) if ( isStretchy ( S , word )) ++ ans ; return ans ; } private : bool isStretchy ( const string & S , const string & word ) { const int n = S . length (); const int m = word . length (); int j = 0 ; for ( int i = 0 ; i < n ; ++ i ) if ( j < m && S [ i ] == word [ j ]) ++ j ; else if ( i > 1 && S [ i ] == S [ i - 1 ] && S [ i - 1 ] == S [ i - 2 ]) continue ; else if ( 0 < i && i + 1 < n && S [ i - 1 ] == S [ i ] && S [ i ] == S [ i + 1 ]) continue ; else return false ; return j == m ; } }; 810. Chalkboard XOR Game $\\star\\star\\star$ class Solution { public : bool xorGame ( vector < int >& nums ) { int xors = accumulate ( begin ( nums ), end ( nums ), 0 , bit_xor < int > ()); return xors == 0 || nums . size () % 2 == 0 ; } };","title":"0801-0810"},{"location":"cpp/0801-0900/0801-0810/#801-minimum-swaps-to-make-sequences-increasing-starstar","text":"class Solution { public : int minSwap ( vector < int >& A , vector < int >& B ) { vector < int > keepAt ( A . size (), INT_MAX ); vector < int > swapAt ( A . size (), INT_MAX ); keepAt [ 0 ] = 0 ; swapAt [ 0 ] = 1 ; for ( int i = 1 ; i < A . size (); ++ i ) { if ( A [ i ] > A [ i - 1 ] && B [ i ] > B [ i - 1 ]) { keepAt [ i ] = keepAt [ i - 1 ]; swapAt [ i ] = swapAt [ i - 1 ] + 1 ; } if ( A [ i ] > B [ i - 1 ] && B [ i ] > A [ i - 1 ]) { keepAt [ i ] = min ( keepAt [ i ], swapAt [ i - 1 ]); swapAt [ i ] = min ( swapAt [ i ], keepAt [ i - 1 ] + 1 ); } } return min ( keepAt . back (), swapAt . back ()); } };","title":"801. Minimum Swaps To Make Sequences Increasing $\\star\\star$"},{"location":"cpp/0801-0900/0801-0810/#802-find-eventual-safe-states-starstar","text":"","title":"802. Find Eventual Safe States $\\star\\star$"},{"location":"cpp/0801-0900/0801-0810/#803-bricks-falling-when-hit-starstarstar","text":"","title":"803. Bricks Falling When Hit $\\star\\star\\star$"},{"location":"cpp/0801-0900/0801-0810/#804-unique-morse-code-words-star","text":"class Solution { public : int uniqueMorseRepresentations ( vector < string >& words ) { vector < string > morse { \".-\" , \"-...\" , \"-.-.\" , \"-..\" , \".\" , \"..-.\" , \"--.\" , \"....\" , \"..\" , \".---\" , \"-.-\" , \".-..\" , \"--\" , \"-.\" , \"---\" , \".--.\" , \"--.-\" , \".-.\" , \"...\" , \"-\" , \"..-\" , \"...-\" , \".--\" , \"-..-\" , \"-.--\" , \"--..\" }; unordered_set < string > transformations ; for ( const string & word : words ) { string transformation ; for ( char c : word ) transformation += morse [ c - 'a' ]; transformations . insert ( transformation ); } return transformations . size (); } };","title":"804. Unique Morse Code Words $\\star$"},{"location":"cpp/0801-0900/0801-0810/#805-split-array-with-same-average-starstarstar","text":"class Solution { public : bool splitArraySameAverage ( vector < int >& A ) { const int n = A . size (); const int sum = accumulate ( begin ( A ), end ( A ), 0 ); if ( ! isPossible ( sum , n )) return false ; vector < unordered_set < int >> sums ( n / 2 + 1 ); sums [ 0 ]. insert ( 0 ); for ( int a : A ) for ( int i = n / 2 ; i > 0 ; -- i ) for ( int num : sums [ i - 1 ]) sums [ i ]. insert ( a + num ); for ( int i = 1 ; i < n / 2 + 1 ; ++ i ) if ( i * sum % n == 0 && sums [ i ]. count ( i * sum / n )) return true ; return false ; } private : bool isPossible ( int sum , int n ) { for ( int i = 1 ; i < n / 2 + 1 ; ++ i ) if ( i * sum % n == 0 ) return true ; return false ; } };","title":"805. Split Array With Same Average $\\star\\star\\star$"},{"location":"cpp/0801-0900/0801-0810/#806-number-of-lines-to-write-string-star","text":"","title":"806. Number of Lines To Write String $\\star$"},{"location":"cpp/0801-0900/0801-0810/#807-max-increase-to-keep-city-skyline-starstar","text":"","title":"807. Max Increase to Keep City Skyline $\\star\\star$"},{"location":"cpp/0801-0900/0801-0810/#808-soup-servings-starstar","text":"class Solution { public : double soupServings ( int N ) { memo = vector < vector < double >> ( 4800 / 25 , vector < double > ( 4800 / 25 , 0 )); return N >= 4800 ? 1.0 : dfs (( N + 24 ) / 25 , ( N + 24 ) / 25 ); } private : vector < vector < double >> memo ; double dfs ( int a , int b ) { if ( a <= 0 && b <= 0 ) return 0.5 ; if ( a <= 0 ) return 1.0 ; if ( b <= 0 ) return 0.0 ; if ( memo [ a ][ b ] > 0 ) return memo [ a ][ b ]; memo [ a ][ b ] = 0.25 * ( dfs ( a - 4 , b ) + dfs ( a - 3 , b - 1 ) + dfs ( a - 2 , b - 2 ) + dfs ( a - 1 , b - 3 )); return memo [ a ][ b ]; } };","title":"808. Soup Servings $\\star\\star$"},{"location":"cpp/0801-0900/0801-0810/#809-expressive-words-starstar","text":"class Solution { public : int expressiveWords ( string S , vector < string >& words ) { int ans = 0 ; for ( const string & word : words ) if ( isStretchy ( S , word )) ++ ans ; return ans ; } private : bool isStretchy ( const string & S , const string & word ) { const int n = S . length (); const int m = word . length (); int j = 0 ; for ( int i = 0 ; i < n ; ++ i ) if ( j < m && S [ i ] == word [ j ]) ++ j ; else if ( i > 1 && S [ i ] == S [ i - 1 ] && S [ i - 1 ] == S [ i - 2 ]) continue ; else if ( 0 < i && i + 1 < n && S [ i - 1 ] == S [ i ] && S [ i ] == S [ i + 1 ]) continue ; else return false ; return j == m ; } };","title":"809. Expressive Words $\\star\\star$"},{"location":"cpp/0801-0900/0801-0810/#810-chalkboard-xor-game-starstarstar","text":"class Solution { public : bool xorGame ( vector < int >& nums ) { int xors = accumulate ( begin ( nums ), end ( nums ), 0 , bit_xor < int > ()); return xors == 0 || nums . size () % 2 == 0 ; } };","title":"810. Chalkboard XOR Game $\\star\\star\\star$"},{"location":"cpp/0801-0900/0811-0820/","text":"811. Subdomain Visit Count $\\star$ class Solution { public : vector < string > subdomainVisits ( vector < string >& cpdomains ) { vector < string > ans ; unordered_map < string , int > count ; for ( const string & cpdomain : cpdomains ) { int space = cpdomain . find ( ' ' ); int num = stoi ( cpdomain . substr ( 0 , space )); string domain = cpdomain . substr ( space + 1 ); count [ domain ] += num ; for ( int i = 0 ; i < domain . length (); ++ i ) if ( domain [ i ] == '.' ) count [ domain . substr ( i + 1 )] += num ; } for ( const auto & [ subdomain , freq ] : count ) ans . push_back ( to_string ( freq ) + ' ' + subdomain ); return ans ; } }; 812. Largest Triangle Area $\\star$ class Solution { public : double largestTriangleArea ( vector < vector < int >>& points ) { double ans = 0 ; for ( vector < int >& A : points ) for ( vector < int >& B : points ) for ( vector < int >& C : points ) ans = max ( ans , 0.5 * abs (( B [ 0 ] - A [ 0 ]) * ( C [ 1 ] - A [ 1 ]) - ( C [ 0 ] - A [ 0 ]) * ( B [ 1 ] - A [ 1 ]))); return ans ; } }; 813. Largest Sum of Averages $\\star\\star$ Time: $O(kn^3) \\to O(kn^2)$ Space: $O(kn) \\to O(n)$ class Solution { public : double largestSumOfAverages ( vector < int >& A , int K ) { const int n = A . size (); vector < vector < double >> dp ( K + 1 , vector < double > ( n + 1 , 0.0 )); vector < double > prefixSum ( n + 1 , 0.0 ); for ( int i = 1 ; i <= n ; ++ i ) { prefixSum [ i ] = prefixSum [ i - 1 ] + A [ i - 1 ]; dp [ 1 ][ i ] = prefixSum [ i ] / i ; } for ( int k = 2 ; k <= K ; ++ k ) for ( int i = k ; i <= n ; ++ i ) for ( int j = k - 1 ; j < i ; ++ j ) dp [ k ][ i ] = max ( dp [ k ][ i ], dp [ k - 1 ][ j ] + ( prefixSum [ i ] - prefixSum [ j ]) / ( i - j )); return dp [ K ][ n ]; } }; 814. Binary Tree Pruning $\\star\\star$ 815. Bus Routes $\\star\\star\\star$ 816. Ambiguous Coordinates $\\star\\star$ class Solution { public : vector < string > ambiguousCoordinates ( string S ) { vector < string > ans ; S = S . substr ( 1 , S . length () - 2 ); for ( int i = 1 ; i < S . length (); ++ i ) for ( const string & x : splits ( S . substr ( 0 , i ))) for ( const string & y : splits ( S . substr ( i ))) ans . push_back ( '(' + x + \", \" + y + ')' ); return ans ; } private : vector < string > splits ( const string S ) { if ( S . empty () || S . length () > 1 && S . front () == '0' && S . back () == '0' ) return {}; if ( S . back () == '0' ) return { S }; if ( S . front () == '0' ) return { \"0.\" + S . substr ( 1 )}; vector < string > candidates { S }; for ( int i = 1 ; i < S . length (); ++ i ) candidates . push_back ( S . substr ( 0 , i ) + '.' + S . substr ( i )); return candidates ; } }; 817. Linked List Components $\\star\\star$ class Solution { public : int numComponents ( ListNode * head , vector < int >& G ) { int ans = 0 ; unordered_set < int > setG { begin ( G ), end ( G )}; for (; head ; head = head -> next ) if ( setG . count ( head -> val ) && ( ! head -> next || ! setG . count ( head -> next -> val ))) ++ ans ; return ans ; } }; 818. Race Car $\\star\\star\\star$ 819. Most Common Word $\\star$ class Solution { public : string mostCommonWord ( string paragraph , vector < string >& banned ) { pair < string , int > ans { \"\" , 0 }; unordered_set < string > bannedSet { begin ( banned ), end ( banned )}; unordered_map < string , int > count ; for ( char & c : paragraph ) c = isalpha ( c ) ? tolower ( c ) : ' ' ; istringstream iss ( paragraph ); string word ; while ( iss >> word ) if ( ! bannedSet . count ( word ) && ++ count [ word ] > ans . second ) ans = { word , count [ word ]}; return ans . first ; } }; 820. Short Encoding of Words $\\star\\star$","title":"0811-0820"},{"location":"cpp/0801-0900/0811-0820/#811-subdomain-visit-count-star","text":"class Solution { public : vector < string > subdomainVisits ( vector < string >& cpdomains ) { vector < string > ans ; unordered_map < string , int > count ; for ( const string & cpdomain : cpdomains ) { int space = cpdomain . find ( ' ' ); int num = stoi ( cpdomain . substr ( 0 , space )); string domain = cpdomain . substr ( space + 1 ); count [ domain ] += num ; for ( int i = 0 ; i < domain . length (); ++ i ) if ( domain [ i ] == '.' ) count [ domain . substr ( i + 1 )] += num ; } for ( const auto & [ subdomain , freq ] : count ) ans . push_back ( to_string ( freq ) + ' ' + subdomain ); return ans ; } };","title":"811. Subdomain Visit Count $\\star$"},{"location":"cpp/0801-0900/0811-0820/#812-largest-triangle-area-star","text":"class Solution { public : double largestTriangleArea ( vector < vector < int >>& points ) { double ans = 0 ; for ( vector < int >& A : points ) for ( vector < int >& B : points ) for ( vector < int >& C : points ) ans = max ( ans , 0.5 * abs (( B [ 0 ] - A [ 0 ]) * ( C [ 1 ] - A [ 1 ]) - ( C [ 0 ] - A [ 0 ]) * ( B [ 1 ] - A [ 1 ]))); return ans ; } };","title":"812. Largest Triangle Area $\\star$"},{"location":"cpp/0801-0900/0811-0820/#813-largest-sum-of-averages-starstar","text":"Time: $O(kn^3) \\to O(kn^2)$ Space: $O(kn) \\to O(n)$ class Solution { public : double largestSumOfAverages ( vector < int >& A , int K ) { const int n = A . size (); vector < vector < double >> dp ( K + 1 , vector < double > ( n + 1 , 0.0 )); vector < double > prefixSum ( n + 1 , 0.0 ); for ( int i = 1 ; i <= n ; ++ i ) { prefixSum [ i ] = prefixSum [ i - 1 ] + A [ i - 1 ]; dp [ 1 ][ i ] = prefixSum [ i ] / i ; } for ( int k = 2 ; k <= K ; ++ k ) for ( int i = k ; i <= n ; ++ i ) for ( int j = k - 1 ; j < i ; ++ j ) dp [ k ][ i ] = max ( dp [ k ][ i ], dp [ k - 1 ][ j ] + ( prefixSum [ i ] - prefixSum [ j ]) / ( i - j )); return dp [ K ][ n ]; } };","title":"813. Largest Sum of Averages $\\star\\star$"},{"location":"cpp/0801-0900/0811-0820/#814-binary-tree-pruning-starstar","text":"","title":"814. Binary Tree Pruning $\\star\\star$"},{"location":"cpp/0801-0900/0811-0820/#815-bus-routes-starstarstar","text":"","title":"815. Bus Routes $\\star\\star\\star$"},{"location":"cpp/0801-0900/0811-0820/#816-ambiguous-coordinates-starstar","text":"class Solution { public : vector < string > ambiguousCoordinates ( string S ) { vector < string > ans ; S = S . substr ( 1 , S . length () - 2 ); for ( int i = 1 ; i < S . length (); ++ i ) for ( const string & x : splits ( S . substr ( 0 , i ))) for ( const string & y : splits ( S . substr ( i ))) ans . push_back ( '(' + x + \", \" + y + ')' ); return ans ; } private : vector < string > splits ( const string S ) { if ( S . empty () || S . length () > 1 && S . front () == '0' && S . back () == '0' ) return {}; if ( S . back () == '0' ) return { S }; if ( S . front () == '0' ) return { \"0.\" + S . substr ( 1 )}; vector < string > candidates { S }; for ( int i = 1 ; i < S . length (); ++ i ) candidates . push_back ( S . substr ( 0 , i ) + '.' + S . substr ( i )); return candidates ; } };","title":"816. Ambiguous Coordinates $\\star\\star$"},{"location":"cpp/0801-0900/0811-0820/#817-linked-list-components-starstar","text":"class Solution { public : int numComponents ( ListNode * head , vector < int >& G ) { int ans = 0 ; unordered_set < int > setG { begin ( G ), end ( G )}; for (; head ; head = head -> next ) if ( setG . count ( head -> val ) && ( ! head -> next || ! setG . count ( head -> next -> val ))) ++ ans ; return ans ; } };","title":"817. Linked List Components $\\star\\star$"},{"location":"cpp/0801-0900/0811-0820/#818-race-car-starstarstar","text":"","title":"818. Race Car $\\star\\star\\star$"},{"location":"cpp/0801-0900/0811-0820/#819-most-common-word-star","text":"class Solution { public : string mostCommonWord ( string paragraph , vector < string >& banned ) { pair < string , int > ans { \"\" , 0 }; unordered_set < string > bannedSet { begin ( banned ), end ( banned )}; unordered_map < string , int > count ; for ( char & c : paragraph ) c = isalpha ( c ) ? tolower ( c ) : ' ' ; istringstream iss ( paragraph ); string word ; while ( iss >> word ) if ( ! bannedSet . count ( word ) && ++ count [ word ] > ans . second ) ans = { word , count [ word ]}; return ans . first ; } };","title":"819. Most Common Word $\\star$"},{"location":"cpp/0801-0900/0811-0820/#820-short-encoding-of-words-starstar","text":"","title":"820. Short Encoding of Words $\\star\\star$"},{"location":"cpp/0801-0900/0821-0830/","text":"821. Shortest Distance to a Character $\\star$ 822. Card Flipping Game $\\star\\star$ 823. Binary Trees With Factors $\\star\\star$ 824. Goat Latin $\\star$ class Solution { public : string toGoatLatin ( string S ) { string ans ; unordered_set < char > vowels { 'a' , 'e' , 'i' , 'o' , 'u' , 'A' , 'E' , 'I' , 'O' , 'U' }; istringstream iss ( S ); string word ; int i = 1 ; while ( iss >> word ) { if ( i > 1 ) ans += ' ' ; if ( vowels . count ( word [ 0 ])) ans += word ; else ans += word . substr ( 1 ) + word [ 0 ]; ans += \"ma\" + string ( i ++ , 'a' ); } return ans ; } }; 825. Friends Of Appropriate Ages $\\star\\star$ class Solution { public : int numFriendRequests ( vector < int >& ages ) { int ans = 0 ; vector < int > count ( 121 ); for ( int age : ages ) ++ count [ age ]; for ( int i = 15 ; i <= 120 ; ++ i ) ans += count [ i ] * ( count [ i ] - 1 ); for ( int i = 15 ; i <= 120 ; ++ i ) for ( int j = i / 2 + 8 ; j < i ; ++ j ) ans += count [ i ] * count [ j ]; return ans ; } }; 826. Most Profit Assigning Work $\\star\\star$ class Solution { public : int maxProfitAssignment ( vector < int >& difficulty , vector < int >& profit , vector < int >& worker ) { int ans = 0 ; vector < pair < int , int >> jobs ; for ( int i = 0 ; i < difficulty . size (); ++ i ) jobs . push_back ({ difficulty [ i ], profit [ i ]}); sort ( begin ( jobs ), end ( jobs )); sort ( begin ( worker ), end ( worker )); int i = 0 ; int maxProfit = 0 ; for ( int w : worker ) { for (; i < jobs . size () && w >= jobs [ i ]. first ; ++ i ) maxProfit = max ( maxProfit , jobs [ i ]. second ); ans += maxProfit ; } return ans ; } }; 827. Making A Large Island $\\star\\star\\star$ 828. Count Unique Characters of All Substrings of a Given String $\\star\\star\\star$ class Solution { public : int uniqueLetterString ( string s ) { int ans = 0 ; int count = 0 ; vector < int > lastCount ( 26 ); vector < int > lastSeen ( 26 , - 1 ); for ( int i = 0 ; i < s . length (); ++ i ) { int c = s [ i ] - 'A' ; int currentCount = i - lastSeen [ c ]; count = count - lastCount [ c ] + currentCount ; lastCount [ c ] = currentCount ; lastSeen [ c ] = i ; ans += count ; } return ans ; } }; 829. Consecutive Numbers Sum $\\star\\star\\star$ class Solution { public : int consecutiveNumbersSum ( int N ) { int ans = 0 ; for ( int i = 1 , triangleNum = i ; triangleNum <= N ; ++ i , triangleNum += i ) if (( N - triangleNum ) % i == 0 ) ++ ans ; return ans ; } }; 830. Positions of Large Groups $\\star$ class Solution { public : vector < vector < int >> largeGroupPositions ( string S ) { const int n = S . length (); vector < vector < int >> ans ; for ( int i = 0 , j = 0 ; i < n ; i = j ) { while ( j < n && S [ j ] == S [ i ]) ++ j ; if ( j - i >= 3 ) ans . push_back ({ i , j - 1 }); } return ans ; } };","title":"0821-0830"},{"location":"cpp/0801-0900/0821-0830/#821-shortest-distance-to-a-character-star","text":"","title":"821. Shortest Distance to a Character $\\star$"},{"location":"cpp/0801-0900/0821-0830/#822-card-flipping-game-starstar","text":"","title":"822. Card Flipping Game $\\star\\star$"},{"location":"cpp/0801-0900/0821-0830/#823-binary-trees-with-factors-starstar","text":"","title":"823. Binary Trees With Factors $\\star\\star$"},{"location":"cpp/0801-0900/0821-0830/#824-goat-latin-star","text":"class Solution { public : string toGoatLatin ( string S ) { string ans ; unordered_set < char > vowels { 'a' , 'e' , 'i' , 'o' , 'u' , 'A' , 'E' , 'I' , 'O' , 'U' }; istringstream iss ( S ); string word ; int i = 1 ; while ( iss >> word ) { if ( i > 1 ) ans += ' ' ; if ( vowels . count ( word [ 0 ])) ans += word ; else ans += word . substr ( 1 ) + word [ 0 ]; ans += \"ma\" + string ( i ++ , 'a' ); } return ans ; } };","title":"824. Goat Latin $\\star$"},{"location":"cpp/0801-0900/0821-0830/#825-friends-of-appropriate-ages-starstar","text":"class Solution { public : int numFriendRequests ( vector < int >& ages ) { int ans = 0 ; vector < int > count ( 121 ); for ( int age : ages ) ++ count [ age ]; for ( int i = 15 ; i <= 120 ; ++ i ) ans += count [ i ] * ( count [ i ] - 1 ); for ( int i = 15 ; i <= 120 ; ++ i ) for ( int j = i / 2 + 8 ; j < i ; ++ j ) ans += count [ i ] * count [ j ]; return ans ; } };","title":"825. Friends Of Appropriate Ages $\\star\\star$"},{"location":"cpp/0801-0900/0821-0830/#826-most-profit-assigning-work-starstar","text":"class Solution { public : int maxProfitAssignment ( vector < int >& difficulty , vector < int >& profit , vector < int >& worker ) { int ans = 0 ; vector < pair < int , int >> jobs ; for ( int i = 0 ; i < difficulty . size (); ++ i ) jobs . push_back ({ difficulty [ i ], profit [ i ]}); sort ( begin ( jobs ), end ( jobs )); sort ( begin ( worker ), end ( worker )); int i = 0 ; int maxProfit = 0 ; for ( int w : worker ) { for (; i < jobs . size () && w >= jobs [ i ]. first ; ++ i ) maxProfit = max ( maxProfit , jobs [ i ]. second ); ans += maxProfit ; } return ans ; } };","title":"826. Most Profit Assigning Work $\\star\\star$"},{"location":"cpp/0801-0900/0821-0830/#827-making-a-large-island-starstarstar","text":"","title":"827. Making A Large Island $\\star\\star\\star$"},{"location":"cpp/0801-0900/0821-0830/#828-count-unique-characters-of-all-substrings-of-a-given-string-starstarstar","text":"class Solution { public : int uniqueLetterString ( string s ) { int ans = 0 ; int count = 0 ; vector < int > lastCount ( 26 ); vector < int > lastSeen ( 26 , - 1 ); for ( int i = 0 ; i < s . length (); ++ i ) { int c = s [ i ] - 'A' ; int currentCount = i - lastSeen [ c ]; count = count - lastCount [ c ] + currentCount ; lastCount [ c ] = currentCount ; lastSeen [ c ] = i ; ans += count ; } return ans ; } };","title":"828. Count Unique Characters of All Substrings of a Given String $\\star\\star\\star$"},{"location":"cpp/0801-0900/0821-0830/#829-consecutive-numbers-sum-starstarstar","text":"class Solution { public : int consecutiveNumbersSum ( int N ) { int ans = 0 ; for ( int i = 1 , triangleNum = i ; triangleNum <= N ; ++ i , triangleNum += i ) if (( N - triangleNum ) % i == 0 ) ++ ans ; return ans ; } };","title":"829. Consecutive Numbers Sum $\\star\\star\\star$"},{"location":"cpp/0801-0900/0821-0830/#830-positions-of-large-groups-star","text":"class Solution { public : vector < vector < int >> largeGroupPositions ( string S ) { const int n = S . length (); vector < vector < int >> ans ; for ( int i = 0 , j = 0 ; i < n ; i = j ) { while ( j < n && S [ j ] == S [ i ]) ++ j ; if ( j - i >= 3 ) ans . push_back ({ i , j - 1 }); } return ans ; } };","title":"830. Positions of Large Groups $\\star$"},{"location":"cpp/0801-0900/0831-0840/","text":"831. Masking Personal Information $\\star\\star$ class Solution { public : string maskPII ( string S ) { int atIndex = S . find ( '@' ); if ( atIndex != string :: npos ) { transform ( begin ( S ), end ( S ), begin ( S ), :: tolower ); return S . substr ( 0 , 1 ) + \"*****\" + S . substr ( atIndex - 1 ); } string ans ; for ( char c : S ) if ( isdigit ( c )) ans += c ; if ( ans . length () == 10 ) return \"***-***-\" + ans . substr ( ans . length () - 4 ); return '+' + string ( ans . length () - 10 , '*' ) + \"-***-***-\" + ans . substr ( ans . length () - 4 ); } }; 832. Flipping an Image $\\star$ class Solution { public : vector < vector < int >> flipAndInvertImage ( vector < vector < int >>& A ) { const int n = A . size (); for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < ( n + 1 ) / 2 ; ++ j ) { int temp = A [ i ][ j ]; A [ i ][ j ] = A [ i ][ n - j - 1 ] ^ 1 ; A [ i ][ n - j - 1 ] = temp ^ 1 ; } return A ; } }; 833. Find And Replace in String $\\star\\star$ class Solution { public : string findReplaceString ( string S , vector < int >& indexes , vector < string >& sources , vector < string >& targets ) { vector < pair < int , int >> sortedIndexes ; for ( int i = 0 ; i < indexes . size (); ++ i ) sortedIndexes . push_back ({ indexes [ i ], i }); sort ( rbegin ( sortedIndexes ), rend ( sortedIndexes )); for ( const auto & [ index , i ] : sortedIndexes ) { string source = sources [ i ]; string target = targets [ i ]; if ( S . substr ( index , source . length ()) == source ) S = S . substr ( 0 , index ) + target + S . substr ( index + source . length ()); } return S ; } }; 834. Sum of Distances in Tree $\\star\\star\\star$ 835. Image Overlap $\\star\\star$ class Solution { public : int largestOverlap ( vector < vector < int >>& A , vector < vector < int >>& B ) { const int n = A . size (); const int magic = 100 ; int ans = 0 ; vector < pair < int , int >> onesA ; vector < pair < int , int >> onesB ; unordered_map < int , int > map ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { if ( A [ i ][ j ] == 1 ) onesA . push_back ({ i , j }); if ( B [ i ][ j ] == 1 ) onesB . push_back ({ i , j }); } for ( pair < int , int >& a : onesA ) for ( pair < int , int >& b : onesB ) ++ map [( a . first - b . first ) * magic + ( a . second - b . second )]; for ( const auto & [ _ , value ] : map ) ans = max ( ans , value ); return ans ; } }; 836. Rectangle Overlap $\\star$ class Solution { public : bool isRectangleOverlap ( vector < int >& rec1 , vector < int >& rec2 ) { return rec1 [ 0 ] < rec2 [ 2 ] && rec2 [ 0 ] < rec1 [ 2 ] && rec1 [ 1 ] < rec2 [ 3 ] && rec2 [ 1 ] < rec1 [ 3 ]; } }; 837. New 21 Game $\\star\\star$ 838. Push Dominoes $\\star\\star$ class Solution { public : string pushDominoes ( string dominoes ) { int L = - 1 ; int R = - 1 ; for ( int i = 0 ; i <= dominoes . length (); ++ i ) if ( i == dominoes . length () || dominoes [ i ] == 'R' ) { if ( L < R ) while ( R < i ) dominoes [ R ++ ] = 'R' ; R = i ; } else if ( dominoes [ i ] == 'L' ) { if ( R < L || L == - 1 && R == - 1 ) { if ( L == - 1 && R == - 1 ) ++ L ; while ( L < i ) dominoes [ L ++ ] = 'L' ; } else { int l = R + 1 ; int r = i - 1 ; while ( l < r ) { dominoes [ l ++ ] = 'R' ; dominoes [ r -- ] = 'L' ; } } L = i ; } return dominoes ; } }; 839. Similar String Groups $\\star\\star\\star$ 840. Magic Squares In Grid $\\star$ class Solution { public : int numMagicSquaresInside ( vector < vector < int >>& grid ) { int ans = 0 ; for ( int i = 0 ; i + 2 < grid . size (); ++ i ) for ( int j = 0 ; j + 2 < grid [ 0 ]. size (); ++ j ) if ( grid [ i ][ j ] % 2 == 0 && grid [ i + 1 ][ j + 1 ] == 5 ) ans += isMagic ( grid , i , j ); return ans ; } private : int isMagic ( vector < vector < int >>& grid , int i , int j ) { string s ; for ( int num : { 0 , 1 , 2 , 5 , 8 , 7 , 6 , 3 }) s += to_string ( grid [ i + num / 3 ][ j + num % 3 ]); return string ( \"4381672943816729\" ). find ( s ) != string :: npos || string ( \"9276183492761834\" ). find ( s ) != string :: npos ; } };","title":"0831-0840"},{"location":"cpp/0801-0900/0831-0840/#831-masking-personal-information-starstar","text":"class Solution { public : string maskPII ( string S ) { int atIndex = S . find ( '@' ); if ( atIndex != string :: npos ) { transform ( begin ( S ), end ( S ), begin ( S ), :: tolower ); return S . substr ( 0 , 1 ) + \"*****\" + S . substr ( atIndex - 1 ); } string ans ; for ( char c : S ) if ( isdigit ( c )) ans += c ; if ( ans . length () == 10 ) return \"***-***-\" + ans . substr ( ans . length () - 4 ); return '+' + string ( ans . length () - 10 , '*' ) + \"-***-***-\" + ans . substr ( ans . length () - 4 ); } };","title":"831. Masking Personal Information $\\star\\star$"},{"location":"cpp/0801-0900/0831-0840/#832-flipping-an-image-star","text":"class Solution { public : vector < vector < int >> flipAndInvertImage ( vector < vector < int >>& A ) { const int n = A . size (); for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < ( n + 1 ) / 2 ; ++ j ) { int temp = A [ i ][ j ]; A [ i ][ j ] = A [ i ][ n - j - 1 ] ^ 1 ; A [ i ][ n - j - 1 ] = temp ^ 1 ; } return A ; } };","title":"832. Flipping an Image $\\star$"},{"location":"cpp/0801-0900/0831-0840/#833-find-and-replace-in-string-starstar","text":"class Solution { public : string findReplaceString ( string S , vector < int >& indexes , vector < string >& sources , vector < string >& targets ) { vector < pair < int , int >> sortedIndexes ; for ( int i = 0 ; i < indexes . size (); ++ i ) sortedIndexes . push_back ({ indexes [ i ], i }); sort ( rbegin ( sortedIndexes ), rend ( sortedIndexes )); for ( const auto & [ index , i ] : sortedIndexes ) { string source = sources [ i ]; string target = targets [ i ]; if ( S . substr ( index , source . length ()) == source ) S = S . substr ( 0 , index ) + target + S . substr ( index + source . length ()); } return S ; } };","title":"833. Find And Replace in String $\\star\\star$"},{"location":"cpp/0801-0900/0831-0840/#834-sum-of-distances-in-tree-starstarstar","text":"","title":"834. Sum of Distances in Tree $\\star\\star\\star$"},{"location":"cpp/0801-0900/0831-0840/#835-image-overlap-starstar","text":"class Solution { public : int largestOverlap ( vector < vector < int >>& A , vector < vector < int >>& B ) { const int n = A . size (); const int magic = 100 ; int ans = 0 ; vector < pair < int , int >> onesA ; vector < pair < int , int >> onesB ; unordered_map < int , int > map ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { if ( A [ i ][ j ] == 1 ) onesA . push_back ({ i , j }); if ( B [ i ][ j ] == 1 ) onesB . push_back ({ i , j }); } for ( pair < int , int >& a : onesA ) for ( pair < int , int >& b : onesB ) ++ map [( a . first - b . first ) * magic + ( a . second - b . second )]; for ( const auto & [ _ , value ] : map ) ans = max ( ans , value ); return ans ; } };","title":"835. Image Overlap $\\star\\star$"},{"location":"cpp/0801-0900/0831-0840/#836-rectangle-overlap-star","text":"class Solution { public : bool isRectangleOverlap ( vector < int >& rec1 , vector < int >& rec2 ) { return rec1 [ 0 ] < rec2 [ 2 ] && rec2 [ 0 ] < rec1 [ 2 ] && rec1 [ 1 ] < rec2 [ 3 ] && rec2 [ 1 ] < rec1 [ 3 ]; } };","title":"836. Rectangle Overlap $\\star$"},{"location":"cpp/0801-0900/0831-0840/#837-new-21-game-starstar","text":"","title":"837. New 21 Game $\\star\\star$"},{"location":"cpp/0801-0900/0831-0840/#838-push-dominoes-starstar","text":"class Solution { public : string pushDominoes ( string dominoes ) { int L = - 1 ; int R = - 1 ; for ( int i = 0 ; i <= dominoes . length (); ++ i ) if ( i == dominoes . length () || dominoes [ i ] == 'R' ) { if ( L < R ) while ( R < i ) dominoes [ R ++ ] = 'R' ; R = i ; } else if ( dominoes [ i ] == 'L' ) { if ( R < L || L == - 1 && R == - 1 ) { if ( L == - 1 && R == - 1 ) ++ L ; while ( L < i ) dominoes [ L ++ ] = 'L' ; } else { int l = R + 1 ; int r = i - 1 ; while ( l < r ) { dominoes [ l ++ ] = 'R' ; dominoes [ r -- ] = 'L' ; } } L = i ; } return dominoes ; } };","title":"838. Push Dominoes $\\star\\star$"},{"location":"cpp/0801-0900/0831-0840/#839-similar-string-groups-starstarstar","text":"","title":"839. Similar String Groups $\\star\\star\\star$"},{"location":"cpp/0801-0900/0831-0840/#840-magic-squares-in-grid-star","text":"class Solution { public : int numMagicSquaresInside ( vector < vector < int >>& grid ) { int ans = 0 ; for ( int i = 0 ; i + 2 < grid . size (); ++ i ) for ( int j = 0 ; j + 2 < grid [ 0 ]. size (); ++ j ) if ( grid [ i ][ j ] % 2 == 0 && grid [ i + 1 ][ j + 1 ] == 5 ) ans += isMagic ( grid , i , j ); return ans ; } private : int isMagic ( vector < vector < int >>& grid , int i , int j ) { string s ; for ( int num : { 0 , 1 , 2 , 5 , 8 , 7 , 6 , 3 }) s += to_string ( grid [ i + num / 3 ][ j + num % 3 ]); return string ( \"4381672943816729\" ). find ( s ) != string :: npos || string ( \"9276183492761834\" ). find ( s ) != string :: npos ; } };","title":"840. Magic Squares In Grid $\\star$"},{"location":"cpp/0801-0900/0841-0850/","text":"841. Keys and Rooms $\\star\\star$ 842. Split Array into Fibonacci Sequence $\\star\\star$ class Solution { public : vector < int > splitIntoFibonacci ( string S ) { vector < int > ans ; dfs ( S , 0 , ans ); return ans ; } private : bool dfs ( const string & S , int s , vector < int >& ans ) { if ( s == S . length () && ans . size () >= 3 ) return true ; for ( int i = s ; i < S . length (); ++ i ) { if ( S [ s ] == '0' && i > s ) break ; long num = stol ( S . substr ( s , i + 1 - s )); if ( num > INT_MAX ) break ; if ( ans . size () >= 2 && num > ( long ) ans [ ans . size () - 2 ] + ans . back ()) break ; if ( ans . size () <= 1 || num == ( long ) ans [ ans . size () - 2 ] + ans . back ()) { ans . push_back ( num ); if ( dfs ( S , i + 1 , ans )) return true ; ans . pop_back (); } } return false ; } }; 843. Guess the Word $\\star\\star\\star$ 844. Backspace String Compare $\\star$ class Solution { public : bool backspaceCompare ( string S , string T ) { for ( int i = S . length () - 1 , j = T . length () - 1 ; i >= 0 || j >= 0 ; -- i , -- j ) { for ( int backspace = 0 ; i >= 0 && ( S [ i ] == '#' || backspace ); -- i ) backspace += S [ i ] == '#' ? 1 : - 1 ; for ( int backspace = 0 ; j >= 0 && ( T [ j ] == '#' || backspace ); -- j ) backspace += T [ j ] == '#' ? 1 : - 1 ; if ( i >= 0 && j >= 0 && S [ i ] != T [ j ]) return false ; if ( i < 0 && j >= 0 && T [ j ] != '#' || j < 0 && i >= 0 && S [ i ] != '#' ) return false ; } return true ; } }; 845. Longest Mountain in Array $\\star\\star$ class Solution { public : int longestMountain ( vector < int >& A ) { int ans = 0 ; for ( int i = 0 ; i + 1 < A . size ();) { while ( i + 1 < A . size () && A [ i ] == A [ i + 1 ]) ++ i ; int increasing = 0 ; int decreasing = 0 ; while ( i + 1 < A . size () && A [ i ] < A [ i + 1 ]) { ++ increasing ; ++ i ; } while ( i + 1 < A . size () && A [ i ] > A [ i + 1 ]) { ++ decreasing ; ++ i ; } if ( increasing > 0 && decreasing > 0 ) ans = max ( ans , increasing + decreasing + 1 ); } return ans ; } }; 846. Hand of Straights $\\star\\star$ 847. Shortest Path Visiting All Nodes $\\star\\star\\star$ class Solution { public : int shortestPathLength ( vector < vector < int >>& graph ) { const int n = graph . size (); const int goal = ( 1 << n ) - 1 ; int ans = 0 ; queue < pair < int , int >> q ; vector < vector < int >> visited ( n , vector < int > ( 1 << n )); for ( int i = 0 ; i < graph . size (); ++ i ) q . push ({ i , 1 << i }); while ( ! q . empty ()) { int s = q . size (); while ( s -- ) { auto p = q . front (); q . pop (); int node = p . first ; int state = p . second ; if ( state == goal ) return ans ; if ( visited [ node ][ state ]) continue ; visited [ node ][ state ] = 1 ; for ( int next : graph [ node ]) q . push ({ next , state | ( 1 << next )}); } ++ ans ; } return - 1 ; } }; 848. Shifting Letters $\\star\\star$ class Solution { public : string shiftingLetters ( string S , vector < int >& shifts ) { string ans ; for ( int i = shifts . size () - 2 ; i >= 0 ; -- i ) shifts [ i ] = ( shifts [ i ] + shifts [ i + 1 ]) % 26 ; for ( int i = 0 ; i < S . length (); ++ i ) ans += ( S [ i ] - 'a' + shifts [ i ]) % 26 + 'a' ; return ans ; } }; 849. Maximize Distance to Closest Person $\\star$ class Solution { public : int maxDistToClosest ( vector < int >& seats ) { const int n = seats . size (); int ans = 0 ; int j = - 1 ; for ( int i = 0 ; i < n ; ++ i ) if ( seats [ i ] == 1 ) { ans = j == - 1 ? i : max ( ans , ( i - j ) / 2 ); j = i ; } return max ( ans , n - j - 1 ); } }; 850. Rectangle Area II $\\star\\star\\star$","title":"0841-0850"},{"location":"cpp/0801-0900/0841-0850/#841-keys-and-rooms-starstar","text":"","title":"841. Keys and Rooms $\\star\\star$"},{"location":"cpp/0801-0900/0841-0850/#842-split-array-into-fibonacci-sequence-starstar","text":"class Solution { public : vector < int > splitIntoFibonacci ( string S ) { vector < int > ans ; dfs ( S , 0 , ans ); return ans ; } private : bool dfs ( const string & S , int s , vector < int >& ans ) { if ( s == S . length () && ans . size () >= 3 ) return true ; for ( int i = s ; i < S . length (); ++ i ) { if ( S [ s ] == '0' && i > s ) break ; long num = stol ( S . substr ( s , i + 1 - s )); if ( num > INT_MAX ) break ; if ( ans . size () >= 2 && num > ( long ) ans [ ans . size () - 2 ] + ans . back ()) break ; if ( ans . size () <= 1 || num == ( long ) ans [ ans . size () - 2 ] + ans . back ()) { ans . push_back ( num ); if ( dfs ( S , i + 1 , ans )) return true ; ans . pop_back (); } } return false ; } };","title":"842. Split Array into Fibonacci Sequence $\\star\\star$"},{"location":"cpp/0801-0900/0841-0850/#843-guess-the-word-starstarstar","text":"","title":"843. Guess the Word $\\star\\star\\star$"},{"location":"cpp/0801-0900/0841-0850/#844-backspace-string-compare-star","text":"class Solution { public : bool backspaceCompare ( string S , string T ) { for ( int i = S . length () - 1 , j = T . length () - 1 ; i >= 0 || j >= 0 ; -- i , -- j ) { for ( int backspace = 0 ; i >= 0 && ( S [ i ] == '#' || backspace ); -- i ) backspace += S [ i ] == '#' ? 1 : - 1 ; for ( int backspace = 0 ; j >= 0 && ( T [ j ] == '#' || backspace ); -- j ) backspace += T [ j ] == '#' ? 1 : - 1 ; if ( i >= 0 && j >= 0 && S [ i ] != T [ j ]) return false ; if ( i < 0 && j >= 0 && T [ j ] != '#' || j < 0 && i >= 0 && S [ i ] != '#' ) return false ; } return true ; } };","title":"844. Backspace String Compare $\\star$"},{"location":"cpp/0801-0900/0841-0850/#845-longest-mountain-in-array-starstar","text":"class Solution { public : int longestMountain ( vector < int >& A ) { int ans = 0 ; for ( int i = 0 ; i + 1 < A . size ();) { while ( i + 1 < A . size () && A [ i ] == A [ i + 1 ]) ++ i ; int increasing = 0 ; int decreasing = 0 ; while ( i + 1 < A . size () && A [ i ] < A [ i + 1 ]) { ++ increasing ; ++ i ; } while ( i + 1 < A . size () && A [ i ] > A [ i + 1 ]) { ++ decreasing ; ++ i ; } if ( increasing > 0 && decreasing > 0 ) ans = max ( ans , increasing + decreasing + 1 ); } return ans ; } };","title":"845. Longest Mountain in Array $\\star\\star$"},{"location":"cpp/0801-0900/0841-0850/#846-hand-of-straights-starstar","text":"","title":"846. Hand of Straights $\\star\\star$"},{"location":"cpp/0801-0900/0841-0850/#847-shortest-path-visiting-all-nodes-starstarstar","text":"class Solution { public : int shortestPathLength ( vector < vector < int >>& graph ) { const int n = graph . size (); const int goal = ( 1 << n ) - 1 ; int ans = 0 ; queue < pair < int , int >> q ; vector < vector < int >> visited ( n , vector < int > ( 1 << n )); for ( int i = 0 ; i < graph . size (); ++ i ) q . push ({ i , 1 << i }); while ( ! q . empty ()) { int s = q . size (); while ( s -- ) { auto p = q . front (); q . pop (); int node = p . first ; int state = p . second ; if ( state == goal ) return ans ; if ( visited [ node ][ state ]) continue ; visited [ node ][ state ] = 1 ; for ( int next : graph [ node ]) q . push ({ next , state | ( 1 << next )}); } ++ ans ; } return - 1 ; } };","title":"847. Shortest Path Visiting All Nodes $\\star\\star\\star$"},{"location":"cpp/0801-0900/0841-0850/#848-shifting-letters-starstar","text":"class Solution { public : string shiftingLetters ( string S , vector < int >& shifts ) { string ans ; for ( int i = shifts . size () - 2 ; i >= 0 ; -- i ) shifts [ i ] = ( shifts [ i ] + shifts [ i + 1 ]) % 26 ; for ( int i = 0 ; i < S . length (); ++ i ) ans += ( S [ i ] - 'a' + shifts [ i ]) % 26 + 'a' ; return ans ; } };","title":"848. Shifting Letters $\\star\\star$"},{"location":"cpp/0801-0900/0841-0850/#849-maximize-distance-to-closest-person-star","text":"class Solution { public : int maxDistToClosest ( vector < int >& seats ) { const int n = seats . size (); int ans = 0 ; int j = - 1 ; for ( int i = 0 ; i < n ; ++ i ) if ( seats [ i ] == 1 ) { ans = j == - 1 ? i : max ( ans , ( i - j ) / 2 ); j = i ; } return max ( ans , n - j - 1 ); } };","title":"849. Maximize Distance to Closest Person $\\star$"},{"location":"cpp/0801-0900/0841-0850/#850-rectangle-area-ii-starstarstar","text":"","title":"850. Rectangle Area II $\\star\\star\\star$"},{"location":"cpp/0801-0900/0851-0860/","text":"851. Loud and Rich $\\star\\star$ 852. Peak Index in a Mountain Array $\\star$ 853. Car Fleet $\\star\\star$ 854. K-Similar Strings $\\star\\star\\star$ 855. Exam Room $\\star\\star$ 856. Score of Parentheses $\\star\\star$ class Solution { public : int scoreOfParentheses ( string S ) { int ans = 0 ; int layer = 0 ; for ( int i = 0 ; i < S . length (); ++ i ) { layer += S [ i ] == '(' ? 1 : - 1 ; if ( S [ i ] == ')' && S [ i - 1 ] == '(' ) ans += 1 << layer ; } return ans ; } }; 857. Minimum Cost to Hire K Workers $\\star\\star\\star$ 858. Mirror Reflection $\\star\\star$ class Solution { public : int mirrorReflection ( int p , int q ) { int m = 1 ; int n = 1 ; while ( m * p != n * q ) m = ++ n * q / p ; if ( m % 2 == 0 && n % 2 == 1 ) return 0 ; if ( m % 2 == 1 && n % 2 == 1 ) return 1 ; if ( m % 2 == 1 && n % 2 == 0 ) return 2 ; throw ; } }; 859. Buddy Strings $\\star$ class Solution { public : bool buddyStrings ( string A , string B ) { if ( A . length () != B . length ()) return false ; if ( A == B && set < char > ( begin ( A ), end ( A )). size () < A . length ()) return true ; vector < int > diff ; for ( int i = 0 ; i < A . length (); ++ i ) if ( A [ i ] != B [ i ]) diff . push_back ( i ); return diff . size () == 2 && A [ diff [ 0 ]] == B [ diff [ 1 ]] && A [ diff [ 1 ]] == B [ diff [ 0 ]]; } }; 860. Lemonade Change $\\star$","title":"0851-0860"},{"location":"cpp/0801-0900/0851-0860/#851-loud-and-rich-starstar","text":"","title":"851. Loud and Rich $\\star\\star$"},{"location":"cpp/0801-0900/0851-0860/#852-peak-index-in-a-mountain-array-star","text":"","title":"852. Peak Index in a Mountain Array $\\star$"},{"location":"cpp/0801-0900/0851-0860/#853-car-fleet-starstar","text":"","title":"853. Car Fleet $\\star\\star$"},{"location":"cpp/0801-0900/0851-0860/#854-k-similar-strings-starstarstar","text":"","title":"854. K-Similar Strings $\\star\\star\\star$"},{"location":"cpp/0801-0900/0851-0860/#855-exam-room-starstar","text":"","title":"855. Exam Room $\\star\\star$"},{"location":"cpp/0801-0900/0851-0860/#856-score-of-parentheses-starstar","text":"class Solution { public : int scoreOfParentheses ( string S ) { int ans = 0 ; int layer = 0 ; for ( int i = 0 ; i < S . length (); ++ i ) { layer += S [ i ] == '(' ? 1 : - 1 ; if ( S [ i ] == ')' && S [ i - 1 ] == '(' ) ans += 1 << layer ; } return ans ; } };","title":"856. Score of Parentheses $\\star\\star$"},{"location":"cpp/0801-0900/0851-0860/#857-minimum-cost-to-hire-k-workers-starstarstar","text":"","title":"857. Minimum Cost to Hire K Workers $\\star\\star\\star$"},{"location":"cpp/0801-0900/0851-0860/#858-mirror-reflection-starstar","text":"class Solution { public : int mirrorReflection ( int p , int q ) { int m = 1 ; int n = 1 ; while ( m * p != n * q ) m = ++ n * q / p ; if ( m % 2 == 0 && n % 2 == 1 ) return 0 ; if ( m % 2 == 1 && n % 2 == 1 ) return 1 ; if ( m % 2 == 1 && n % 2 == 0 ) return 2 ; throw ; } };","title":"858. Mirror Reflection $\\star\\star$"},{"location":"cpp/0801-0900/0851-0860/#859-buddy-strings-star","text":"class Solution { public : bool buddyStrings ( string A , string B ) { if ( A . length () != B . length ()) return false ; if ( A == B && set < char > ( begin ( A ), end ( A )). size () < A . length ()) return true ; vector < int > diff ; for ( int i = 0 ; i < A . length (); ++ i ) if ( A [ i ] != B [ i ]) diff . push_back ( i ); return diff . size () == 2 && A [ diff [ 0 ]] == B [ diff [ 1 ]] && A [ diff [ 1 ]] == B [ diff [ 0 ]]; } };","title":"859. Buddy Strings $\\star$"},{"location":"cpp/0801-0900/0851-0860/#860-lemonade-change-star","text":"","title":"860. Lemonade Change $\\star$"},{"location":"cpp/0801-0900/0861-0870/","text":"861. Score After Flipping Matrix $\\star\\star$ 862. Shortest Subarray with Sum at Least K $\\star\\star\\star$ class Solution { public : int shortestSubarray ( vector < int >& A , int K ) { const int n = A . size (); int ans = n + 1 ; deque < int > deque ; vector < int > prefixSum ( n + 1 ); for ( int i = 0 ; i < n ; ++ i ) prefixSum [ i + 1 ] = prefixSum [ i ] + A [ i ]; for ( int i = 0 ; i < n + 1 ; ++ i ) { while ( ! deque . empty () && prefixSum [ i ] - prefixSum [ deque . front ()] >= K ) ans = min ( ans , i - deque . front ()), deque . pop_front (); while ( ! deque . empty () && prefixSum [ i ] <= prefixSum [ deque . back ()]) deque . pop_back (); deque . push_back ( i ); } return ans <= n ? ans : - 1 ; } }; 863. All Nodes Distance K in Binary Tree $\\star\\star$ 864. Shortest Path to Get All Keys $\\star\\star\\star$ 865. Smallest Subtree with all the Deepest Nodes $\\star\\star$ 866. Prime Palindrome $\\star\\star$ class Solution { public : int primePalindrome ( int N ) { if ( N <= 2 ) return 2 ; if ( N == 3 ) return 3 ; if ( N <= 5 ) return 5 ; if ( N <= 7 ) return 7 ; if ( N <= 11 ) return 11 ; int n = to_string ( N ). length (); while ( true ) { for ( int num : getPalindromes ( n )) if ( num >= N && isPrime ( num )) return num ; ++ n ; } throw ; } private : vector < int > getPalindromes ( int n ) { vector < int > palindromes ; int length = n / 2 ; for ( int i = pow ( 10 , length - 1 ); i < pow ( 10 , length ); ++ i ) { string s = to_string ( i ); string reversedS = s ; reverse ( begin ( reversedS ), end ( reversedS )); for ( int j = 0 ; j < 10 ; ++ j ) palindromes . push_back ( stoi ( s + to_string ( j ) + reversedS )); } return palindromes ; } bool isPrime ( int num ) { for ( int i = 2 ; i < sqrt ( num ) + 1 ; ++ i ) if ( num % i == 0 ) return false ; return true ; } }; 867. Transpose Matrix $\\star$ class Solution { public : vector < vector < int >> transpose ( vector < vector < int >>& A ) { vector < vector < int >> ans ( A [ 0 ]. size (), vector < int > ( A . size ())); for ( int i = 0 ; i < A . size (); ++ i ) for ( int j = 0 ; j < A [ 0 ]. size (); ++ j ) ans [ j ][ i ] = A [ i ][ j ]; return ans ; } }; 868. Binary Gap $\\star$ class Solution { public : int binaryGap ( int N ) { int ans = 0 ; int prevOneIndex = 30 ; for ( int n = N , i = 0 ; n > 0 ; n >>= 1 , ++ i ) if ( n % 2 == 1 ) { ans = max ( ans , i - prevOneIndex ); prevOneIndex = i ; } return ans ; } }; 869. Reordered Power of 2 $\\star\\star$ class Solution { public : bool reorderedPowerOf2 ( int N ) { int count = counter ( N ); for ( int i = 0 ; i < 30 ; ++ i ) if ( counter ( 1 << i ) == count ) return true ; return false ; } private : int counter ( int n ) { int count = 0 ; for (; n > 0 ; n /= 10 ) count += pow ( 10 , n % 10 ); return count ; } }; 870. Advantage Shuffle $\\star\\star$ class Solution { public : vector < int > advantageCount ( vector < int >& A , vector < int >& B ) { multiset < int > set { begin ( A ), end ( A )}; for ( int i = 0 ; i < B . size (); ++ i ) { auto p = * rbegin ( set ) <= B [ i ] ? begin ( set ) : set . upper_bound ( B [ i ]); A [ i ] = * p ; set . erase ( p ); } return A ; } };","title":"0861-0870"},{"location":"cpp/0801-0900/0861-0870/#861-score-after-flipping-matrix-starstar","text":"","title":"861. Score After Flipping Matrix $\\star\\star$"},{"location":"cpp/0801-0900/0861-0870/#862-shortest-subarray-with-sum-at-least-k-starstarstar","text":"class Solution { public : int shortestSubarray ( vector < int >& A , int K ) { const int n = A . size (); int ans = n + 1 ; deque < int > deque ; vector < int > prefixSum ( n + 1 ); for ( int i = 0 ; i < n ; ++ i ) prefixSum [ i + 1 ] = prefixSum [ i ] + A [ i ]; for ( int i = 0 ; i < n + 1 ; ++ i ) { while ( ! deque . empty () && prefixSum [ i ] - prefixSum [ deque . front ()] >= K ) ans = min ( ans , i - deque . front ()), deque . pop_front (); while ( ! deque . empty () && prefixSum [ i ] <= prefixSum [ deque . back ()]) deque . pop_back (); deque . push_back ( i ); } return ans <= n ? ans : - 1 ; } };","title":"862. Shortest Subarray with Sum at Least K $\\star\\star\\star$"},{"location":"cpp/0801-0900/0861-0870/#863-all-nodes-distance-k-in-binary-tree-starstar","text":"","title":"863. All Nodes Distance K in Binary Tree $\\star\\star$"},{"location":"cpp/0801-0900/0861-0870/#864-shortest-path-to-get-all-keys-starstarstar","text":"","title":"864. Shortest Path to Get All Keys $\\star\\star\\star$"},{"location":"cpp/0801-0900/0861-0870/#865-smallest-subtree-with-all-the-deepest-nodes-starstar","text":"","title":"865. Smallest Subtree with all the Deepest Nodes $\\star\\star$"},{"location":"cpp/0801-0900/0861-0870/#866-prime-palindrome-starstar","text":"class Solution { public : int primePalindrome ( int N ) { if ( N <= 2 ) return 2 ; if ( N == 3 ) return 3 ; if ( N <= 5 ) return 5 ; if ( N <= 7 ) return 7 ; if ( N <= 11 ) return 11 ; int n = to_string ( N ). length (); while ( true ) { for ( int num : getPalindromes ( n )) if ( num >= N && isPrime ( num )) return num ; ++ n ; } throw ; } private : vector < int > getPalindromes ( int n ) { vector < int > palindromes ; int length = n / 2 ; for ( int i = pow ( 10 , length - 1 ); i < pow ( 10 , length ); ++ i ) { string s = to_string ( i ); string reversedS = s ; reverse ( begin ( reversedS ), end ( reversedS )); for ( int j = 0 ; j < 10 ; ++ j ) palindromes . push_back ( stoi ( s + to_string ( j ) + reversedS )); } return palindromes ; } bool isPrime ( int num ) { for ( int i = 2 ; i < sqrt ( num ) + 1 ; ++ i ) if ( num % i == 0 ) return false ; return true ; } };","title":"866. Prime Palindrome $\\star\\star$"},{"location":"cpp/0801-0900/0861-0870/#867-transpose-matrix-star","text":"class Solution { public : vector < vector < int >> transpose ( vector < vector < int >>& A ) { vector < vector < int >> ans ( A [ 0 ]. size (), vector < int > ( A . size ())); for ( int i = 0 ; i < A . size (); ++ i ) for ( int j = 0 ; j < A [ 0 ]. size (); ++ j ) ans [ j ][ i ] = A [ i ][ j ]; return ans ; } };","title":"867. Transpose Matrix $\\star$"},{"location":"cpp/0801-0900/0861-0870/#868-binary-gap-star","text":"class Solution { public : int binaryGap ( int N ) { int ans = 0 ; int prevOneIndex = 30 ; for ( int n = N , i = 0 ; n > 0 ; n >>= 1 , ++ i ) if ( n % 2 == 1 ) { ans = max ( ans , i - prevOneIndex ); prevOneIndex = i ; } return ans ; } };","title":"868. Binary Gap $\\star$"},{"location":"cpp/0801-0900/0861-0870/#869-reordered-power-of-2-starstar","text":"class Solution { public : bool reorderedPowerOf2 ( int N ) { int count = counter ( N ); for ( int i = 0 ; i < 30 ; ++ i ) if ( counter ( 1 << i ) == count ) return true ; return false ; } private : int counter ( int n ) { int count = 0 ; for (; n > 0 ; n /= 10 ) count += pow ( 10 , n % 10 ); return count ; } };","title":"869. Reordered Power of 2 $\\star\\star$"},{"location":"cpp/0801-0900/0861-0870/#870-advantage-shuffle-starstar","text":"class Solution { public : vector < int > advantageCount ( vector < int >& A , vector < int >& B ) { multiset < int > set { begin ( A ), end ( A )}; for ( int i = 0 ; i < B . size (); ++ i ) { auto p = * rbegin ( set ) <= B [ i ] ? begin ( set ) : set . upper_bound ( B [ i ]); A [ i ] = * p ; set . erase ( p ); } return A ; } };","title":"870. Advantage Shuffle $\\star\\star$"},{"location":"cpp/0801-0900/0871-0880/","text":"871. Minimum Number of Refueling Stops $\\star\\star\\star$ class Solution { public : int minRefuelStops ( int target , int startFuel , vector < vector < int >>& stations ) { vector < long > dp ( stations . size () + 1 , 0 ); dp [ 0 ] = startFuel ; for ( int i = 0 ; i < stations . size (); ++ i ) for ( int j = i + 1 ; j > 0 ; -- j ) if ( dp [ j - 1 ] >= stations [ i ][ 0 ]) dp [ j ] = max ( dp [ j ], dp [ j - 1 ] + stations [ i ][ 1 ]); for ( int i = 0 ; i <= stations . size (); ++ i ) if ( dp [ i ] >= target ) return i ; return - 1 ; } }; 872. Leaf-Similar Trees $\\star$ 873. Length of Longest Fibonacci Subsequence $\\star\\star$ class Solution { public : int lenLongestFibSubseq ( vector < int >& A ) { const int n = A . size (); int ans = 0 ; unordered_map < int , int > numToIndex ; vector < vector < int >> dp ( n , vector < int > ( n , 2 )); for ( int i = 0 ; i < n ; ++ i ) numToIndex [ A [ i ]] = i ; for ( int j = 0 ; j < n ; ++ j ) for ( int k = j + 1 ; k < n ; ++ k ) { int ai = A [ k ] - A [ j ]; if ( ai < A [ j ] && numToIndex . count ( ai )) { int i = numToIndex [ ai ]; dp [ j ][ k ] = dp [ i ][ j ] + 1 ; ans = max ( ans , dp [ j ][ k ]); } } return ans ; } }; 874. Walking Robot Simulation $\\star$ 875. Koko Eating Bananas $\\star\\star$ class Solution { public : int minEatingSpeed ( vector < int >& piles , int H ) { int l = 1 ; int r = * max_element ( begin ( piles ), end ( piles )) + 1 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; int hour = 0 ; for ( int pile : piles ) hour += ( pile - 1 ) / m + 1 ; if ( hour > H ) l = m + 1 ; else r = m ; } return l ; } }; 876. Middle of the Linked List $\\star$ class Solution { public : ListNode * middleNode ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } return slow ; } }; 877. Stone Game $\\star\\star$ class Solution { public : bool stoneGame ( vector < int >& piles ) { const int n = piles . size (); vector < int > dp = piles ; for ( int d = 1 ; d < n ; ++ d ) for ( int i = n - d - 1 ; i >= 0 ; -- i ) dp [ i + d ] = max ( piles [ i ] - dp [ i + d ], piles [ i + d ] - dp [ i + d - 1 ]); return dp [ n - 1 ] > 0 ; } }; 878. Nth Magical Number $\\star\\star\\star$ class Solution { public : int nthMagicalNumber ( long N , long A , long B ) { const int kMod = int ( 1e9 + 7 ); long lcm = A * B / __gcd ( A , B ); long l = min ( A , B ); long r = min ( A , B ) * N ; while ( l < r ) { long m = l + ( r - l ) / 2 ; if ( m / A + m / B - m / lcm < N ) l = m + 1 ; else r = m ; } return l % kMod ; } }; 879. Profitable Schemes $\\star\\star\\star$ 880. Decoded String at Index $\\star\\star$","title":"0871-0880"},{"location":"cpp/0801-0900/0871-0880/#871-minimum-number-of-refueling-stops-starstarstar","text":"class Solution { public : int minRefuelStops ( int target , int startFuel , vector < vector < int >>& stations ) { vector < long > dp ( stations . size () + 1 , 0 ); dp [ 0 ] = startFuel ; for ( int i = 0 ; i < stations . size (); ++ i ) for ( int j = i + 1 ; j > 0 ; -- j ) if ( dp [ j - 1 ] >= stations [ i ][ 0 ]) dp [ j ] = max ( dp [ j ], dp [ j - 1 ] + stations [ i ][ 1 ]); for ( int i = 0 ; i <= stations . size (); ++ i ) if ( dp [ i ] >= target ) return i ; return - 1 ; } };","title":"871. Minimum Number of Refueling Stops $\\star\\star\\star$"},{"location":"cpp/0801-0900/0871-0880/#872-leaf-similar-trees-star","text":"","title":"872. Leaf-Similar Trees $\\star$"},{"location":"cpp/0801-0900/0871-0880/#873-length-of-longest-fibonacci-subsequence-starstar","text":"class Solution { public : int lenLongestFibSubseq ( vector < int >& A ) { const int n = A . size (); int ans = 0 ; unordered_map < int , int > numToIndex ; vector < vector < int >> dp ( n , vector < int > ( n , 2 )); for ( int i = 0 ; i < n ; ++ i ) numToIndex [ A [ i ]] = i ; for ( int j = 0 ; j < n ; ++ j ) for ( int k = j + 1 ; k < n ; ++ k ) { int ai = A [ k ] - A [ j ]; if ( ai < A [ j ] && numToIndex . count ( ai )) { int i = numToIndex [ ai ]; dp [ j ][ k ] = dp [ i ][ j ] + 1 ; ans = max ( ans , dp [ j ][ k ]); } } return ans ; } };","title":"873. Length of Longest Fibonacci Subsequence $\\star\\star$"},{"location":"cpp/0801-0900/0871-0880/#874-walking-robot-simulation-star","text":"","title":"874. Walking Robot Simulation $\\star$"},{"location":"cpp/0801-0900/0871-0880/#875-koko-eating-bananas-starstar","text":"class Solution { public : int minEatingSpeed ( vector < int >& piles , int H ) { int l = 1 ; int r = * max_element ( begin ( piles ), end ( piles )) + 1 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; int hour = 0 ; for ( int pile : piles ) hour += ( pile - 1 ) / m + 1 ; if ( hour > H ) l = m + 1 ; else r = m ; } return l ; } };","title":"875. Koko Eating Bananas $\\star\\star$"},{"location":"cpp/0801-0900/0871-0880/#876-middle-of-the-linked-list-star","text":"class Solution { public : ListNode * middleNode ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } return slow ; } };","title":"876. Middle of the Linked List $\\star$"},{"location":"cpp/0801-0900/0871-0880/#877-stone-game-starstar","text":"class Solution { public : bool stoneGame ( vector < int >& piles ) { const int n = piles . size (); vector < int > dp = piles ; for ( int d = 1 ; d < n ; ++ d ) for ( int i = n - d - 1 ; i >= 0 ; -- i ) dp [ i + d ] = max ( piles [ i ] - dp [ i + d ], piles [ i + d ] - dp [ i + d - 1 ]); return dp [ n - 1 ] > 0 ; } };","title":"877. Stone Game $\\star\\star$"},{"location":"cpp/0801-0900/0871-0880/#878-nth-magical-number-starstarstar","text":"class Solution { public : int nthMagicalNumber ( long N , long A , long B ) { const int kMod = int ( 1e9 + 7 ); long lcm = A * B / __gcd ( A , B ); long l = min ( A , B ); long r = min ( A , B ) * N ; while ( l < r ) { long m = l + ( r - l ) / 2 ; if ( m / A + m / B - m / lcm < N ) l = m + 1 ; else r = m ; } return l % kMod ; } };","title":"878. Nth Magical Number $\\star\\star\\star$"},{"location":"cpp/0801-0900/0871-0880/#879-profitable-schemes-starstarstar","text":"","title":"879. Profitable Schemes $\\star\\star\\star$"},{"location":"cpp/0801-0900/0871-0880/#880-decoded-string-at-index-starstar","text":"","title":"880. Decoded String at Index $\\star\\star$"},{"location":"cpp/0801-0900/0881-0890/","text":"881. Boats to Save People $\\star\\star$ class Solution { public : int numRescueBoats ( vector < int >& people , int limit ) { int ans = 0 ; sort ( begin ( people ), end ( people )); for ( int i = 0 , j = people . size () - 1 ; i <= j ; ++ ans ) { int remain = limit - people [ j -- ]; if ( people [ i ] <= remain ) ++ i ; } return ans ; } }; 882. Reachable Nodes In Subdivided Graph $\\star\\star\\star$ 883. Projection Area of 3D Shapes $\\star$ class Solution { public : int projectionArea ( vector < vector < int >>& grid ) { int ans = 0 ; for ( int i = 0 ; i < grid . size (); ++ i ) { int maxOfRow = 0 ; int maxOfCol = 0 ; for ( int j = 0 ; j < grid . size (); ++ j ) { maxOfRow = max ( maxOfRow , grid [ i ][ j ]); maxOfCol = max ( maxOfCol , grid [ j ][ i ]); if ( grid [ i ][ j ]) ++ ans ; } ans += maxOfRow + maxOfCol ; } return ans ; } }; 884. Uncommon Words from Two Sentences $\\star$ class Solution { public : vector < string > uncommonFromSentences ( string A , string B ) { vector < string > ans ; unordered_map < string , int > count ; istringstream iss ( A + ' ' + B ); while ( iss >> A ) ++ count [ A ]; for ( const auto & [ word , freq ] : count ) if ( freq == 1 ) ans . push_back ( word ); return ans ; } }; 885. Spiral Matrix III $\\star\\star$ class Solution { public : vector < vector < int >> spiralMatrixIII ( int R , int C , int r0 , int c0 ) { vector < vector < int >> ans {{ r0 , c0 }}; vector < int > dx { 1 , 0 , - 1 , 0 }; vector < int > dy { 0 , 1 , 0 , - 1 }; for ( int i = 0 ; ans . size () < R * C ; ++ i ) for ( int step = 0 ; step < i / 2 + 1 ; ++ step ) { r0 += dy [ i % 4 ]; c0 += dx [ i % 4 ]; if ( 0 <= r0 && r0 < R && 0 <= c0 && c0 < C ) ans . push_back ({ r0 , c0 }); } return ans ; } }; 886. Possible Bipartition $\\star\\star$ 887. Super Egg Drop $\\star\\star\\star$ class Solution { public : int superEggDrop ( int K , int N ) { int moves = 0 ; vector < vector < int >> dp ( N + 1 , vector < int > ( K + 1 )); while ( dp [ moves ][ K ] < N ) { ++ moves ; for ( int eggs = 1 ; eggs <= K ; ++ eggs ) dp [ moves ][ eggs ] = dp [ moves - 1 ][ eggs - 1 ] + dp [ moves - 1 ][ eggs ] + 1 ; } return moves ; } }; 888. Fair Candy Swap $\\star$ class Solution { public : vector < int > fairCandySwap ( vector < int >& A , vector < int >& B ) { int diff = ( accumulate ( begin ( A ), end ( A ), 0 ) - accumulate ( begin ( B ), end ( B ), 0 )) / 2 ; unordered_set < int > set { begin ( B ), end ( B )}; for ( int a : A ) if ( set . count ( a - diff )) return { a , a - diff }; throw ; } }; 889. Construct Binary Tree from Preorder and Postorder Traversal $\\star\\star$ class Solution { public : TreeNode * constructFromPrePost ( vector < int >& pre , vector < int >& post ) { return helper ( 0 , 0 , pre . size (), pre , post ); } private : TreeNode * helper ( int i , int j , int n , vector < int >& pre , vector < int >& post ) { if ( n == 0 ) return NULL ; TreeNode * root = new TreeNode ( pre [ i ]); if ( n == 1 ) return root ; int k = j ; while ( post [ k ] != pre [ i + 1 ]) ++ k ; int l = k - j + 1 ; root -> left = helper ( i + 1 , j , l , pre , post ); root -> right = helper ( i + l + 1 , j + l , n - l - 1 , pre , post ); return root ; } }; 890. Find and Replace Pattern $\\star\\star$ class Solution { public : vector < string > findAndReplacePattern ( vector < string >& words , string pattern ) { vector < string > ans ; for ( const string & word : words ) if ( isIsomorphic ( word , pattern )) ans . push_back ( word ); return ans ; } private : bool isIsomorphic ( const string & w , const string & p ) { vector < int > map_w ( 128 ); vector < int > map_p ( 128 ); for ( int i = 0 ; i < w . length (); ++ i ) { if ( map_w [ w [ i ]] != map_p [ p [ i ]]) return false ; map_w [ w [ i ]] = i + 1 ; map_p [ p [ i ]] = i + 1 ; } return true ; } };","title":"0881-0890"},{"location":"cpp/0801-0900/0881-0890/#881-boats-to-save-people-starstar","text":"class Solution { public : int numRescueBoats ( vector < int >& people , int limit ) { int ans = 0 ; sort ( begin ( people ), end ( people )); for ( int i = 0 , j = people . size () - 1 ; i <= j ; ++ ans ) { int remain = limit - people [ j -- ]; if ( people [ i ] <= remain ) ++ i ; } return ans ; } };","title":"881. Boats to Save People $\\star\\star$"},{"location":"cpp/0801-0900/0881-0890/#882-reachable-nodes-in-subdivided-graph-starstarstar","text":"","title":"882. Reachable Nodes In Subdivided Graph $\\star\\star\\star$"},{"location":"cpp/0801-0900/0881-0890/#883-projection-area-of-3d-shapes-star","text":"class Solution { public : int projectionArea ( vector < vector < int >>& grid ) { int ans = 0 ; for ( int i = 0 ; i < grid . size (); ++ i ) { int maxOfRow = 0 ; int maxOfCol = 0 ; for ( int j = 0 ; j < grid . size (); ++ j ) { maxOfRow = max ( maxOfRow , grid [ i ][ j ]); maxOfCol = max ( maxOfCol , grid [ j ][ i ]); if ( grid [ i ][ j ]) ++ ans ; } ans += maxOfRow + maxOfCol ; } return ans ; } };","title":"883. Projection Area of 3D Shapes $\\star$"},{"location":"cpp/0801-0900/0881-0890/#884-uncommon-words-from-two-sentences-star","text":"class Solution { public : vector < string > uncommonFromSentences ( string A , string B ) { vector < string > ans ; unordered_map < string , int > count ; istringstream iss ( A + ' ' + B ); while ( iss >> A ) ++ count [ A ]; for ( const auto & [ word , freq ] : count ) if ( freq == 1 ) ans . push_back ( word ); return ans ; } };","title":"884. Uncommon Words from Two Sentences $\\star$"},{"location":"cpp/0801-0900/0881-0890/#885-spiral-matrix-iii-starstar","text":"class Solution { public : vector < vector < int >> spiralMatrixIII ( int R , int C , int r0 , int c0 ) { vector < vector < int >> ans {{ r0 , c0 }}; vector < int > dx { 1 , 0 , - 1 , 0 }; vector < int > dy { 0 , 1 , 0 , - 1 }; for ( int i = 0 ; ans . size () < R * C ; ++ i ) for ( int step = 0 ; step < i / 2 + 1 ; ++ step ) { r0 += dy [ i % 4 ]; c0 += dx [ i % 4 ]; if ( 0 <= r0 && r0 < R && 0 <= c0 && c0 < C ) ans . push_back ({ r0 , c0 }); } return ans ; } };","title":"885. Spiral Matrix III $\\star\\star$"},{"location":"cpp/0801-0900/0881-0890/#886-possible-bipartition-starstar","text":"","title":"886. Possible Bipartition $\\star\\star$"},{"location":"cpp/0801-0900/0881-0890/#887-super-egg-drop-starstarstar","text":"class Solution { public : int superEggDrop ( int K , int N ) { int moves = 0 ; vector < vector < int >> dp ( N + 1 , vector < int > ( K + 1 )); while ( dp [ moves ][ K ] < N ) { ++ moves ; for ( int eggs = 1 ; eggs <= K ; ++ eggs ) dp [ moves ][ eggs ] = dp [ moves - 1 ][ eggs - 1 ] + dp [ moves - 1 ][ eggs ] + 1 ; } return moves ; } };","title":"887. Super Egg Drop $\\star\\star\\star$"},{"location":"cpp/0801-0900/0881-0890/#888-fair-candy-swap-star","text":"class Solution { public : vector < int > fairCandySwap ( vector < int >& A , vector < int >& B ) { int diff = ( accumulate ( begin ( A ), end ( A ), 0 ) - accumulate ( begin ( B ), end ( B ), 0 )) / 2 ; unordered_set < int > set { begin ( B ), end ( B )}; for ( int a : A ) if ( set . count ( a - diff )) return { a , a - diff }; throw ; } };","title":"888. Fair Candy Swap $\\star$"},{"location":"cpp/0801-0900/0881-0890/#889-construct-binary-tree-from-preorder-and-postorder-traversal-starstar","text":"class Solution { public : TreeNode * constructFromPrePost ( vector < int >& pre , vector < int >& post ) { return helper ( 0 , 0 , pre . size (), pre , post ); } private : TreeNode * helper ( int i , int j , int n , vector < int >& pre , vector < int >& post ) { if ( n == 0 ) return NULL ; TreeNode * root = new TreeNode ( pre [ i ]); if ( n == 1 ) return root ; int k = j ; while ( post [ k ] != pre [ i + 1 ]) ++ k ; int l = k - j + 1 ; root -> left = helper ( i + 1 , j , l , pre , post ); root -> right = helper ( i + l + 1 , j + l , n - l - 1 , pre , post ); return root ; } };","title":"889. Construct Binary Tree from Preorder and Postorder Traversal $\\star\\star$"},{"location":"cpp/0801-0900/0881-0890/#890-find-and-replace-pattern-starstar","text":"class Solution { public : vector < string > findAndReplacePattern ( vector < string >& words , string pattern ) { vector < string > ans ; for ( const string & word : words ) if ( isIsomorphic ( word , pattern )) ans . push_back ( word ); return ans ; } private : bool isIsomorphic ( const string & w , const string & p ) { vector < int > map_w ( 128 ); vector < int > map_p ( 128 ); for ( int i = 0 ; i < w . length (); ++ i ) { if ( map_w [ w [ i ]] != map_p [ p [ i ]]) return false ; map_w [ w [ i ]] = i + 1 ; map_p [ p [ i ]] = i + 1 ; } return true ; } };","title":"890. Find and Replace Pattern $\\star\\star$"},{"location":"cpp/0801-0900/0891-0900/","text":"891. Sum of Subsequence Widths $\\star\\star\\star$ class Solution { public : int sumSubseqWidths ( vector < int >& A ) { const int n = A . size (); const int kMod = 1e9 + 7 ; int ans = 0 ; long exp = 1 ; sort ( begin ( A ), end ( A )); for ( int i = 0 ; i < n ; ++ i , exp = exp * 2 % kMod ) ans = ( ans + A [ i ] * exp - A [ n - i - 1 ] * exp ) % kMod ; return ans ; } }; 892. Surface Area of 3D Shapes $\\star$ class Solution { public : int surfaceArea ( vector < vector < int >>& grid ) { int ans = 0 ; for ( int i = 0 ; i < grid . size (); ++ i ) for ( int j = 0 ; j < grid . size (); ++ j ) { if ( grid [ i ][ j ]) ans += grid [ i ][ j ] * 4 + 2 ; if ( i ) ans -= min ( grid [ i ][ j ], grid [ i - 1 ][ j ]) * 2 ; if ( j ) ans -= min ( grid [ i ][ j ], grid [ i ][ j - 1 ]) * 2 ; } return ans ; } }; 893. Groups of Special-Equivalent Strings $\\star$ class Solution { public : int numSpecialEquivGroups ( vector < string >& A ) { unordered_set < string > set ; for ( const string & s : A ) { string even ; string odd ; for ( int i = 0 ; i < s . length (); ++ i ) if ( i % 2 == 0 ) even += s [ i ]; else odd += s [ i ]; sort ( begin ( even ), end ( even )); sort ( begin ( odd ), end ( odd )); set . insert ( even + odd ); } return set . size (); } }; 894. All Possible Full Binary Trees $\\star\\star$ 895. Maximum Frequency Stack $\\star\\star\\star$ class FreqStack { public : void push ( int x ) { maxFreq = max ( maxFreq , ++ count [ x ]); countToStack [ count [ x ]]. push ( x ); } int pop () { int value = countToStack [ maxFreq ]. top (); -- count [ value ]; countToStack [ maxFreq ]. pop (); if ( countToStack [ maxFreq ]. empty ()) -- maxFreq ; return value ; } private : int maxFreq = 0 ; unordered_map < int , int > count ; unordered_map < int , stack < int >> countToStack ; }; 896. Monotonic Array $\\star$ class Solution { public : bool isMonotonic ( vector < int >& A ) { bool increasing = true ; bool decreasing = true ; for ( int i = 1 ; i < A . size (); ++ i ) { increasing &= A [ i - 1 ] <= A [ i ]; decreasing &= A [ i - 1 ] >= A [ i ]; } return increasing || decreasing ; } }; 897. Increasing Order Search Tree $\\star$ 898. Bitwise ORs of Subarrays $\\star\\star$ 899. Orderly Queue $\\star\\star\\star$ class Solution { public : string orderlyQueue ( string S , int K ) { if ( K > 1 ) { sort ( begin ( S ), end ( S )); return S ; } string ans = S ; for ( int i = 1 ; i < S . length (); ++ i ) ans = min ( ans , S . substr ( i ) + S . substr ( 0 , i )); return ans ; } }; 900. RLE Iterator $\\star\\star$ class RLEIterator { public : RLEIterator ( vector < int >& A ) { this -> A = A ; } int next ( int n ) { while ( index < A . size () && A [ index ] < n ) { n -= A [ index ]; index += 2 ; } if ( index == A . size ()) return - 1 ; A [ index ] -= n ; return A [ index + 1 ]; } private : int index = 0 ; vector < int > A ; };","title":"0891-0900"},{"location":"cpp/0801-0900/0891-0900/#891-sum-of-subsequence-widths-starstarstar","text":"class Solution { public : int sumSubseqWidths ( vector < int >& A ) { const int n = A . size (); const int kMod = 1e9 + 7 ; int ans = 0 ; long exp = 1 ; sort ( begin ( A ), end ( A )); for ( int i = 0 ; i < n ; ++ i , exp = exp * 2 % kMod ) ans = ( ans + A [ i ] * exp - A [ n - i - 1 ] * exp ) % kMod ; return ans ; } };","title":"891. Sum of Subsequence Widths $\\star\\star\\star$"},{"location":"cpp/0801-0900/0891-0900/#892-surface-area-of-3d-shapes-star","text":"class Solution { public : int surfaceArea ( vector < vector < int >>& grid ) { int ans = 0 ; for ( int i = 0 ; i < grid . size (); ++ i ) for ( int j = 0 ; j < grid . size (); ++ j ) { if ( grid [ i ][ j ]) ans += grid [ i ][ j ] * 4 + 2 ; if ( i ) ans -= min ( grid [ i ][ j ], grid [ i - 1 ][ j ]) * 2 ; if ( j ) ans -= min ( grid [ i ][ j ], grid [ i ][ j - 1 ]) * 2 ; } return ans ; } };","title":"892. Surface Area of 3D Shapes $\\star$"},{"location":"cpp/0801-0900/0891-0900/#893-groups-of-special-equivalent-strings-star","text":"class Solution { public : int numSpecialEquivGroups ( vector < string >& A ) { unordered_set < string > set ; for ( const string & s : A ) { string even ; string odd ; for ( int i = 0 ; i < s . length (); ++ i ) if ( i % 2 == 0 ) even += s [ i ]; else odd += s [ i ]; sort ( begin ( even ), end ( even )); sort ( begin ( odd ), end ( odd )); set . insert ( even + odd ); } return set . size (); } };","title":"893. Groups of Special-Equivalent Strings $\\star$"},{"location":"cpp/0801-0900/0891-0900/#894-all-possible-full-binary-trees-starstar","text":"","title":"894. All Possible Full Binary Trees $\\star\\star$"},{"location":"cpp/0801-0900/0891-0900/#895-maximum-frequency-stack-starstarstar","text":"class FreqStack { public : void push ( int x ) { maxFreq = max ( maxFreq , ++ count [ x ]); countToStack [ count [ x ]]. push ( x ); } int pop () { int value = countToStack [ maxFreq ]. top (); -- count [ value ]; countToStack [ maxFreq ]. pop (); if ( countToStack [ maxFreq ]. empty ()) -- maxFreq ; return value ; } private : int maxFreq = 0 ; unordered_map < int , int > count ; unordered_map < int , stack < int >> countToStack ; };","title":"895. Maximum Frequency Stack $\\star\\star\\star$"},{"location":"cpp/0801-0900/0891-0900/#896-monotonic-array-star","text":"class Solution { public : bool isMonotonic ( vector < int >& A ) { bool increasing = true ; bool decreasing = true ; for ( int i = 1 ; i < A . size (); ++ i ) { increasing &= A [ i - 1 ] <= A [ i ]; decreasing &= A [ i - 1 ] >= A [ i ]; } return increasing || decreasing ; } };","title":"896. Monotonic Array $\\star$"},{"location":"cpp/0801-0900/0891-0900/#897-increasing-order-search-tree-star","text":"","title":"897. Increasing Order Search Tree $\\star$"},{"location":"cpp/0801-0900/0891-0900/#898-bitwise-ors-of-subarrays-starstar","text":"","title":"898. Bitwise ORs of Subarrays $\\star\\star$"},{"location":"cpp/0801-0900/0891-0900/#899-orderly-queue-starstarstar","text":"class Solution { public : string orderlyQueue ( string S , int K ) { if ( K > 1 ) { sort ( begin ( S ), end ( S )); return S ; } string ans = S ; for ( int i = 1 ; i < S . length (); ++ i ) ans = min ( ans , S . substr ( i ) + S . substr ( 0 , i )); return ans ; } };","title":"899. Orderly Queue $\\star\\star\\star$"},{"location":"cpp/0801-0900/0891-0900/#900-rle-iterator-starstar","text":"class RLEIterator { public : RLEIterator ( vector < int >& A ) { this -> A = A ; } int next ( int n ) { while ( index < A . size () && A [ index ] < n ) { n -= A [ index ]; index += 2 ; } if ( index == A . size ()) return - 1 ; A [ index ] -= n ; return A [ index + 1 ]; } private : int index = 0 ; vector < int > A ; };","title":"900. RLE Iterator $\\star\\star$"},{"location":"cpp/0901-1000/0901-0910/","text":"901. Online Stock Span $\\star\\star$ 902. Numbers At Most N Given Digit Set $\\star\\star\\star$ class Solution { public : int atMostNGivenDigitSet ( vector < string >& D , int N ) { int ans = 0 ; string num = to_string ( N ); for ( int i = 1 ; i < num . length (); ++ i ) ans += pow ( D . size (), i ); for ( int i = 0 ; i < num . length (); ++ i ) { bool dHasSameNum = false ; for ( const string & digit : D ) { if ( digit [ 0 ] < num [ i ]) ans += pow ( D . size (), num . length () - i - 1 ); else if ( digit [ 0 ] == num [ i ]) dHasSameNum = true ; } if ( ! dHasSameNum ) return ans ; } return ans + 1 ; } }; 903. Valid Permutations for DI Sequence $\\star\\star\\star$ 904. Fruit Into Baskets $\\star\\star$ class Solution { public : int totalFruit ( vector < int >& tree ) { int ans = 0 ; unordered_map < int , int > count ; for ( int l = 0 , r = 0 ; r < tree . size (); ++ r ) { ++ count [ tree [ r ]]; while ( count . size () > 2 ) { if ( -- count [ tree [ l ]] == 0 ) count . erase ( tree [ l ]); ++ l ; } ans = max ( ans , r - l + 1 ); } return ans ; } }; 905. Sort Array By Parity $\\star$ class Solution { public : vector < int > sortArrayByParity ( vector < int >& A ) { int l = 0 ; int r = A . size () - 1 ; while ( l < r ) { if ( A [ l ] % 2 == 1 && A [ r ] % 2 == 0 ) swap ( A [ l ], A [ r ]); if ( A [ l ] % 2 == 0 ) ++ l ; if ( A [ r ] % 2 == 1 ) -- r ; } return A ; } }; 906. Super Palindromes $\\star\\star\\star$ class Solution { public : int superpalindromesInRange ( string L , string R ) { int ans = 0 ; long long l = stoll ( L ); long long r = stoll ( R ); for ( long long i = sqrt ( l ); i * i <= r ;) { long long palindrome = nextPalindrome ( i ); long long squared = palindrome * palindrome ; if ( squared <= r && isPalindrome ( squared )) ++ ans ; i = palindrome + 1 ; } return ans ; } private : long long nextPalindrome ( int num ) { const string s = to_string ( num ); const int n = s . length (); string half = s . substr ( 0 , ( n + 1 ) / 2 ); string reversedHalf = reversed ( half . substr ( 0 , n / 2 )); long long candidate = stoll ( half + reversedHalf ); if ( candidate >= num ) return candidate ; half = to_string ( stoll ( half ) + 1 ); reversedHalf = reversed ( half . substr ( 0 , n / 2 )); return stoll ( half + reversedHalf ); } string reversed ( const string & s ) { string r = s ; reverse ( begin ( r ), end ( r )); return r ; } bool isPalindrome ( long long num ) { const string s = to_string ( num ); int l = 0 ; int r = s . length () - 1 ; while ( l < r ) if ( s [ l ++ ] != s [ r -- ]) return false ; return true ; } }; 907. Sum of Subarray Minimums $\\star\\star$ class Solution { public : int sumSubarrayMins ( vector < int >& A ) { const int n = A . size (); const int kMod = 1e9 + 7 ; int ans = 0 ; vector < int > prev ( n , - 1 ); vector < int > next ( n , n ); stack < int > stack1 ; stack < int > stack2 ; for ( int i = 0 ; i < n ; ++ i ) { while ( ! stack1 . empty () && A [ stack1 . top ()] > A [ i ]) stack1 . pop (); prev [ i ] = stack1 . empty () ? - 1 : stack1 . top (); stack1 . push ( i ); while ( ! stack2 . empty () && A [ stack2 . top ()] > A [ i ]) { int index = stack2 . top (); stack2 . pop (); next [ index ] = i ; } stack2 . push ( i ); } for ( int i = 0 ; i < n ; ++ i ) ans = ( ans + A [ i ] * ( i - prev [ i ]) * ( next [ i ] - i )) % kMod ; return ans ; } }; 908. Smallest Range I $\\star$ class Solution { public : int smallestRangeI ( vector < int >& A , int K ) { int max = * max_element ( begin ( A ), end ( A )); int min = * min_element ( begin ( A ), end ( A )); return std :: max ( 0 , max - min - 2 * K ); } }; 909. Snakes and Ladders $\\star\\star$ 910. Smallest Range II $\\star\\star$ class Solution { public : int smallestRangeII ( vector < int >& A , int K ) { sort ( begin ( A ), end ( A )); int ans = A . back () - A . front (); int left = A . front () + K ; int right = A . back () - K ; for ( int i = 0 ; i + 1 < A . size (); ++ i ) { int min = std :: min ( left , A [ i + 1 ] - K ); int max = std :: max ( right , A [ i ] + K ); ans = std :: min ( ans , max - min ); } return ans ; } };","title":"0901-0910"},{"location":"cpp/0901-1000/0901-0910/#901-online-stock-span-starstar","text":"","title":"901. Online Stock Span $\\star\\star$"},{"location":"cpp/0901-1000/0901-0910/#902-numbers-at-most-n-given-digit-set-starstarstar","text":"class Solution { public : int atMostNGivenDigitSet ( vector < string >& D , int N ) { int ans = 0 ; string num = to_string ( N ); for ( int i = 1 ; i < num . length (); ++ i ) ans += pow ( D . size (), i ); for ( int i = 0 ; i < num . length (); ++ i ) { bool dHasSameNum = false ; for ( const string & digit : D ) { if ( digit [ 0 ] < num [ i ]) ans += pow ( D . size (), num . length () - i - 1 ); else if ( digit [ 0 ] == num [ i ]) dHasSameNum = true ; } if ( ! dHasSameNum ) return ans ; } return ans + 1 ; } };","title":"902. Numbers At Most N Given Digit Set $\\star\\star\\star$"},{"location":"cpp/0901-1000/0901-0910/#903-valid-permutations-for-di-sequence-starstarstar","text":"","title":"903. Valid Permutations for DI Sequence $\\star\\star\\star$"},{"location":"cpp/0901-1000/0901-0910/#904-fruit-into-baskets-starstar","text":"class Solution { public : int totalFruit ( vector < int >& tree ) { int ans = 0 ; unordered_map < int , int > count ; for ( int l = 0 , r = 0 ; r < tree . size (); ++ r ) { ++ count [ tree [ r ]]; while ( count . size () > 2 ) { if ( -- count [ tree [ l ]] == 0 ) count . erase ( tree [ l ]); ++ l ; } ans = max ( ans , r - l + 1 ); } return ans ; } };","title":"904. Fruit Into Baskets $\\star\\star$"},{"location":"cpp/0901-1000/0901-0910/#905-sort-array-by-parity-star","text":"class Solution { public : vector < int > sortArrayByParity ( vector < int >& A ) { int l = 0 ; int r = A . size () - 1 ; while ( l < r ) { if ( A [ l ] % 2 == 1 && A [ r ] % 2 == 0 ) swap ( A [ l ], A [ r ]); if ( A [ l ] % 2 == 0 ) ++ l ; if ( A [ r ] % 2 == 1 ) -- r ; } return A ; } };","title":"905. Sort Array By Parity $\\star$"},{"location":"cpp/0901-1000/0901-0910/#906-super-palindromes-starstarstar","text":"class Solution { public : int superpalindromesInRange ( string L , string R ) { int ans = 0 ; long long l = stoll ( L ); long long r = stoll ( R ); for ( long long i = sqrt ( l ); i * i <= r ;) { long long palindrome = nextPalindrome ( i ); long long squared = palindrome * palindrome ; if ( squared <= r && isPalindrome ( squared )) ++ ans ; i = palindrome + 1 ; } return ans ; } private : long long nextPalindrome ( int num ) { const string s = to_string ( num ); const int n = s . length (); string half = s . substr ( 0 , ( n + 1 ) / 2 ); string reversedHalf = reversed ( half . substr ( 0 , n / 2 )); long long candidate = stoll ( half + reversedHalf ); if ( candidate >= num ) return candidate ; half = to_string ( stoll ( half ) + 1 ); reversedHalf = reversed ( half . substr ( 0 , n / 2 )); return stoll ( half + reversedHalf ); } string reversed ( const string & s ) { string r = s ; reverse ( begin ( r ), end ( r )); return r ; } bool isPalindrome ( long long num ) { const string s = to_string ( num ); int l = 0 ; int r = s . length () - 1 ; while ( l < r ) if ( s [ l ++ ] != s [ r -- ]) return false ; return true ; } };","title":"906. Super Palindromes $\\star\\star\\star$"},{"location":"cpp/0901-1000/0901-0910/#907-sum-of-subarray-minimums-starstar","text":"class Solution { public : int sumSubarrayMins ( vector < int >& A ) { const int n = A . size (); const int kMod = 1e9 + 7 ; int ans = 0 ; vector < int > prev ( n , - 1 ); vector < int > next ( n , n ); stack < int > stack1 ; stack < int > stack2 ; for ( int i = 0 ; i < n ; ++ i ) { while ( ! stack1 . empty () && A [ stack1 . top ()] > A [ i ]) stack1 . pop (); prev [ i ] = stack1 . empty () ? - 1 : stack1 . top (); stack1 . push ( i ); while ( ! stack2 . empty () && A [ stack2 . top ()] > A [ i ]) { int index = stack2 . top (); stack2 . pop (); next [ index ] = i ; } stack2 . push ( i ); } for ( int i = 0 ; i < n ; ++ i ) ans = ( ans + A [ i ] * ( i - prev [ i ]) * ( next [ i ] - i )) % kMod ; return ans ; } };","title":"907. Sum of Subarray Minimums $\\star\\star$"},{"location":"cpp/0901-1000/0901-0910/#908-smallest-range-i-star","text":"class Solution { public : int smallestRangeI ( vector < int >& A , int K ) { int max = * max_element ( begin ( A ), end ( A )); int min = * min_element ( begin ( A ), end ( A )); return std :: max ( 0 , max - min - 2 * K ); } };","title":"908. Smallest Range I $\\star$"},{"location":"cpp/0901-1000/0901-0910/#909-snakes-and-ladders-starstar","text":"","title":"909. Snakes and Ladders $\\star\\star$"},{"location":"cpp/0901-1000/0901-0910/#910-smallest-range-ii-starstar","text":"class Solution { public : int smallestRangeII ( vector < int >& A , int K ) { sort ( begin ( A ), end ( A )); int ans = A . back () - A . front (); int left = A . front () + K ; int right = A . back () - K ; for ( int i = 0 ; i + 1 < A . size (); ++ i ) { int min = std :: min ( left , A [ i + 1 ] - K ); int max = std :: max ( right , A [ i ] + K ); ans = std :: min ( ans , max - min ); } return ans ; } };","title":"910. Smallest Range II $\\star\\star$"},{"location":"cpp/0901-1000/0911-0920/","text":"911. Online Election $\\star\\star$ 912. Sort an Array $\\star\\star$ 913. Cat and Mouse $\\star\\star\\star$ 914. X of a Kind in a Deck of Cards $\\star$ class Solution { public : bool hasGroupsSizeX ( vector < int >& deck ) { unordered_map < int , int > count ; int gcd = 0 ; for ( int d : deck ) ++ count [ d ]; for ( const auto & [ _ , value ] : count ) gcd = __gcd ( gcd , value ); return gcd >= 2 ; } }; 915. Partition Array into Disjoint Intervals $\\star\\star$ class Solution { public : int partitionDisjoint ( vector < int >& A ) { const int n = A . size (); vector < int > min ( n ); min [ n - 1 ] = A [ n - 1 ]; int max = INT_MIN ; for ( int i = n - 2 ; i >= 0 ; -- i ) min [ i ] = std :: min ( min [ i + 1 ], A [ i ]); for ( int i = 0 ; i < n ; ++ i ) { max = std :: max ( max , A [ i ]); if ( max <= min [ i + 1 ]) return i + 1 ; } throw ; } }; 916. Word Subsets $\\star\\star$ class Solution { public : vector < string > wordSubsets ( vector < string >& A , vector < string >& B ) { vector < string > ans ; vector < int > countB ( 26 ); for ( const string & b : B ) { vector < int > temp = counter ( b ); for ( int i = 0 ; i < 26 ; ++ i ) countB [ i ] = max ( countB [ i ], temp [ i ]); } for ( const string & a : A ) if ( isUniversal ( counter ( a ), countB )) ans . push_back ( a ); return ans ; } private : vector < int > counter ( const string & s ) { vector < int > count ( 26 ); for ( char c : s ) ++ count [ c - 'a' ]; return count ; } bool isUniversal ( vector < int > countA , vector < int >& countB ) { for ( int i = 0 ; i < 26 ; ++ i ) if ( countA [ i ] < countB [ i ]) return false ; return true ; } }; 917. Reverse Only Letters $\\star$ class Solution { public : string reverseOnlyLetters ( string S ) { for ( int i = 0 , j = S . length () - 1 ; i < j ; ++ i , -- j ) { while ( i < j && ! isalpha ( S [ i ])) ++ i ; while ( i < j && ! isalpha ( S [ j ])) -- j ; swap ( S [ i ], S [ j ]); } return S ; } }; 918. Maximum Sum Circular Subarray $\\star\\star$ class Solution { public : int maxSubarraySumCircular ( vector < int >& A ) { int totalSum = 0 ; int currMaxSum = 0 ; int currMinSum = 0 ; int maxSum = INT_MIN ; int minSum = INT_MAX ; for ( int a : A ) { totalSum += a ; currMaxSum = max ( currMaxSum + a , a ); currMinSum = min ( currMinSum + a , a ); maxSum = max ( maxSum , currMaxSum ); minSum = min ( minSum , currMinSum ); } return maxSum < 0 ? maxSum : max ( maxSum , totalSum - minSum ); } }; 919. Complete Binary Tree Inserter $\\star\\star$ 920. Number of Music Playlists $\\star\\star\\star$","title":"0911-0920"},{"location":"cpp/0901-1000/0911-0920/#911-online-election-starstar","text":"","title":"911. Online Election $\\star\\star$"},{"location":"cpp/0901-1000/0911-0920/#912-sort-an-array-starstar","text":"","title":"912. Sort an Array $\\star\\star$"},{"location":"cpp/0901-1000/0911-0920/#913-cat-and-mouse-starstarstar","text":"","title":"913. Cat and Mouse $\\star\\star\\star$"},{"location":"cpp/0901-1000/0911-0920/#914-x-of-a-kind-in-a-deck-of-cards-star","text":"class Solution { public : bool hasGroupsSizeX ( vector < int >& deck ) { unordered_map < int , int > count ; int gcd = 0 ; for ( int d : deck ) ++ count [ d ]; for ( const auto & [ _ , value ] : count ) gcd = __gcd ( gcd , value ); return gcd >= 2 ; } };","title":"914. X of a Kind in a Deck of Cards $\\star$"},{"location":"cpp/0901-1000/0911-0920/#915-partition-array-into-disjoint-intervals-starstar","text":"class Solution { public : int partitionDisjoint ( vector < int >& A ) { const int n = A . size (); vector < int > min ( n ); min [ n - 1 ] = A [ n - 1 ]; int max = INT_MIN ; for ( int i = n - 2 ; i >= 0 ; -- i ) min [ i ] = std :: min ( min [ i + 1 ], A [ i ]); for ( int i = 0 ; i < n ; ++ i ) { max = std :: max ( max , A [ i ]); if ( max <= min [ i + 1 ]) return i + 1 ; } throw ; } };","title":"915. Partition Array into Disjoint Intervals $\\star\\star$"},{"location":"cpp/0901-1000/0911-0920/#916-word-subsets-starstar","text":"class Solution { public : vector < string > wordSubsets ( vector < string >& A , vector < string >& B ) { vector < string > ans ; vector < int > countB ( 26 ); for ( const string & b : B ) { vector < int > temp = counter ( b ); for ( int i = 0 ; i < 26 ; ++ i ) countB [ i ] = max ( countB [ i ], temp [ i ]); } for ( const string & a : A ) if ( isUniversal ( counter ( a ), countB )) ans . push_back ( a ); return ans ; } private : vector < int > counter ( const string & s ) { vector < int > count ( 26 ); for ( char c : s ) ++ count [ c - 'a' ]; return count ; } bool isUniversal ( vector < int > countA , vector < int >& countB ) { for ( int i = 0 ; i < 26 ; ++ i ) if ( countA [ i ] < countB [ i ]) return false ; return true ; } };","title":"916. Word Subsets $\\star\\star$"},{"location":"cpp/0901-1000/0911-0920/#917-reverse-only-letters-star","text":"class Solution { public : string reverseOnlyLetters ( string S ) { for ( int i = 0 , j = S . length () - 1 ; i < j ; ++ i , -- j ) { while ( i < j && ! isalpha ( S [ i ])) ++ i ; while ( i < j && ! isalpha ( S [ j ])) -- j ; swap ( S [ i ], S [ j ]); } return S ; } };","title":"917. Reverse Only Letters $\\star$"},{"location":"cpp/0901-1000/0911-0920/#918-maximum-sum-circular-subarray-starstar","text":"class Solution { public : int maxSubarraySumCircular ( vector < int >& A ) { int totalSum = 0 ; int currMaxSum = 0 ; int currMinSum = 0 ; int maxSum = INT_MIN ; int minSum = INT_MAX ; for ( int a : A ) { totalSum += a ; currMaxSum = max ( currMaxSum + a , a ); currMinSum = min ( currMinSum + a , a ); maxSum = max ( maxSum , currMaxSum ); minSum = min ( minSum , currMinSum ); } return maxSum < 0 ? maxSum : max ( maxSum , totalSum - minSum ); } };","title":"918. Maximum Sum Circular Subarray $\\star\\star$"},{"location":"cpp/0901-1000/0911-0920/#919-complete-binary-tree-inserter-starstar","text":"","title":"919. Complete Binary Tree Inserter $\\star\\star$"},{"location":"cpp/0901-1000/0911-0920/#920-number-of-music-playlists-starstarstar","text":"","title":"920. Number of Music Playlists $\\star\\star\\star$"},{"location":"cpp/0901-1000/0921-0930/","text":"921. Minimum Add to Make Parentheses Valid $\\star\\star$ 922. Sort Array By Parity II $\\star$ class Solution { public : vector < int > sortArrayByParityII ( vector < int >& A ) { const int n = A . size (); for ( int i = 0 , j = 1 ; i < n ; i += 2 , j += 2 ) { while ( i < n && A [ i ] % 2 == 0 ) i += 2 ; while ( j < n && A [ j ] % 2 == 1 ) j += 2 ; if ( i < n ) swap ( A [ i ], A [ j ]); } return A ; } }; 923. 3Sum With Multiplicity $\\star\\star$ class Solution { public : int threeSumMulti ( vector < int >& A , int target ) { const int kMod = 1e9 + 7 ; long ans = 0 ; unordered_map < int , long > count ; for ( int a : A ) ++ count [ a ]; for ( const auto & [ i , x ] : count ) for ( const auto & [ j , y ] : count ) { int k = target - i - j ; if ( ! count . count ( k )) continue ; if ( i == j && j == k ) ans += x * ( x - 1 ) * ( x - 2 ) / 6 ; else if ( i == j && j != k ) ans += x * ( x - 1 ) / 2 * count [ k ]; else if ( i < j && j < k ) ans += x * y * count [ k ]; } return ans % kMod ; } }; 924. Minimize Malware Spread $\\star\\star\\star$ 925. Long Pressed Name $\\star$ class Solution { public : bool isLongPressedName ( string name , string typed ) { int i = 0 ; for ( int j = 0 ; j < typed . length (); ++ j ) if ( i < name . length () && name [ i ] == typed [ j ]) ++ i ; else if ( j == 0 || typed [ j ] != typed [ j - 1 ]) return false ; return i == name . length (); } }; 926. Flip String to Monotone Increasing $\\star\\star$ class Solution { public : int minFlipsMonoIncr ( string S ) { vector < int > dp ( 2 ); for ( int i = 0 ; i < S . length (); ++ i ) { int temp = dp [ 0 ] + ( S [ i ] == '1' ); dp [ 1 ] = min ( dp [ 0 ], dp [ 1 ]) + ( S [ i ] == '0' ); dp [ 0 ] = temp ; } return min ( dp [ 0 ], dp [ 1 ]); } }; 927. Three Equal Parts $\\star\\star\\star$ class Solution { public : vector < int > threeEqualParts ( vector < int >& A ) { int ones = count_if ( begin ( A ), end ( A ), []( int a ) { return a == 1 ; }); if ( ones == 0 ) return { 0 , A . size () - 1 }; if ( ones % 3 != 0 ) return { - 1 , - 1 }; int k = ones / 3 ; int i ; int j ; int first ; int second ; int third ; for ( i = 0 ; i < A . size (); ++ i ) if ( A [ i ] == 1 ) { first = i ; break ; } int gapOnes = k ; for ( j = i + 1 ; j < A . size (); ++ j ) if ( A [ j ] == 1 && -- gapOnes == 0 ) { second = j ; break ; } gapOnes = k ; for ( i = j + 1 ; i < A . size (); ++ i ) if ( A [ i ] == 1 && -- gapOnes == 0 ) { third = i ; break ; } while ( third < A . size () && A [ first ] == A [ second ] && A [ second ] == A [ third ]) { ++ first ; ++ second ; ++ third ; } if ( third == A . size ()) return { first - 1 , second }; return { - 1 , - 1 }; } }; 928. Minimize Malware Spread II $\\star\\star\\star$ 929. Unique Email Addresses $\\star$ class Solution { public : int numUniqueEmails ( vector < string >& emails ) { unordered_set < string > seen ; for ( const string & email : emails ) { string local ; for ( char c : email ) { if ( c == '+' || c == '@' ) break ; if ( c == '.' ) continue ; local += c ; } string atDomain = email . substr ( email . find ( '@' )); seen . insert ( local + atDomain ); } return seen . size (); } }; 930. Binary Subarrays With Sum $\\star\\star$ class Solution { public : int numSubarraysWithSum ( vector < int >& A , int S ) { int ans = 0 ; int prefixSum = 0 ; unordered_map < int , int > count {{ 0 , 1 }}; for ( int a : A ) { prefixSum += a ; if ( count . count ( prefixSum - S )) ans += count [ prefixSum - S ]; ++ count [ prefixSum ]; } return ans ; } };","title":"0921-0930"},{"location":"cpp/0901-1000/0921-0930/#921-minimum-add-to-make-parentheses-valid-starstar","text":"","title":"921. Minimum Add to Make Parentheses Valid $\\star\\star$"},{"location":"cpp/0901-1000/0921-0930/#922-sort-array-by-parity-ii-star","text":"class Solution { public : vector < int > sortArrayByParityII ( vector < int >& A ) { const int n = A . size (); for ( int i = 0 , j = 1 ; i < n ; i += 2 , j += 2 ) { while ( i < n && A [ i ] % 2 == 0 ) i += 2 ; while ( j < n && A [ j ] % 2 == 1 ) j += 2 ; if ( i < n ) swap ( A [ i ], A [ j ]); } return A ; } };","title":"922. Sort Array By Parity II $\\star$"},{"location":"cpp/0901-1000/0921-0930/#923-3sum-with-multiplicity-starstar","text":"class Solution { public : int threeSumMulti ( vector < int >& A , int target ) { const int kMod = 1e9 + 7 ; long ans = 0 ; unordered_map < int , long > count ; for ( int a : A ) ++ count [ a ]; for ( const auto & [ i , x ] : count ) for ( const auto & [ j , y ] : count ) { int k = target - i - j ; if ( ! count . count ( k )) continue ; if ( i == j && j == k ) ans += x * ( x - 1 ) * ( x - 2 ) / 6 ; else if ( i == j && j != k ) ans += x * ( x - 1 ) / 2 * count [ k ]; else if ( i < j && j < k ) ans += x * y * count [ k ]; } return ans % kMod ; } };","title":"923. 3Sum With Multiplicity $\\star\\star$"},{"location":"cpp/0901-1000/0921-0930/#924-minimize-malware-spread-starstarstar","text":"","title":"924. Minimize Malware Spread $\\star\\star\\star$"},{"location":"cpp/0901-1000/0921-0930/#925-long-pressed-name-star","text":"class Solution { public : bool isLongPressedName ( string name , string typed ) { int i = 0 ; for ( int j = 0 ; j < typed . length (); ++ j ) if ( i < name . length () && name [ i ] == typed [ j ]) ++ i ; else if ( j == 0 || typed [ j ] != typed [ j - 1 ]) return false ; return i == name . length (); } };","title":"925. Long Pressed Name $\\star$"},{"location":"cpp/0901-1000/0921-0930/#926-flip-string-to-monotone-increasing-starstar","text":"class Solution { public : int minFlipsMonoIncr ( string S ) { vector < int > dp ( 2 ); for ( int i = 0 ; i < S . length (); ++ i ) { int temp = dp [ 0 ] + ( S [ i ] == '1' ); dp [ 1 ] = min ( dp [ 0 ], dp [ 1 ]) + ( S [ i ] == '0' ); dp [ 0 ] = temp ; } return min ( dp [ 0 ], dp [ 1 ]); } };","title":"926. Flip String to Monotone Increasing $\\star\\star$"},{"location":"cpp/0901-1000/0921-0930/#927-three-equal-parts-starstarstar","text":"class Solution { public : vector < int > threeEqualParts ( vector < int >& A ) { int ones = count_if ( begin ( A ), end ( A ), []( int a ) { return a == 1 ; }); if ( ones == 0 ) return { 0 , A . size () - 1 }; if ( ones % 3 != 0 ) return { - 1 , - 1 }; int k = ones / 3 ; int i ; int j ; int first ; int second ; int third ; for ( i = 0 ; i < A . size (); ++ i ) if ( A [ i ] == 1 ) { first = i ; break ; } int gapOnes = k ; for ( j = i + 1 ; j < A . size (); ++ j ) if ( A [ j ] == 1 && -- gapOnes == 0 ) { second = j ; break ; } gapOnes = k ; for ( i = j + 1 ; i < A . size (); ++ i ) if ( A [ i ] == 1 && -- gapOnes == 0 ) { third = i ; break ; } while ( third < A . size () && A [ first ] == A [ second ] && A [ second ] == A [ third ]) { ++ first ; ++ second ; ++ third ; } if ( third == A . size ()) return { first - 1 , second }; return { - 1 , - 1 }; } };","title":"927. Three Equal Parts $\\star\\star\\star$"},{"location":"cpp/0901-1000/0921-0930/#928-minimize-malware-spread-ii-starstarstar","text":"","title":"928. Minimize Malware Spread II $\\star\\star\\star$"},{"location":"cpp/0901-1000/0921-0930/#929-unique-email-addresses-star","text":"class Solution { public : int numUniqueEmails ( vector < string >& emails ) { unordered_set < string > seen ; for ( const string & email : emails ) { string local ; for ( char c : email ) { if ( c == '+' || c == '@' ) break ; if ( c == '.' ) continue ; local += c ; } string atDomain = email . substr ( email . find ( '@' )); seen . insert ( local + atDomain ); } return seen . size (); } };","title":"929. Unique Email Addresses $\\star$"},{"location":"cpp/0901-1000/0921-0930/#930-binary-subarrays-with-sum-starstar","text":"class Solution { public : int numSubarraysWithSum ( vector < int >& A , int S ) { int ans = 0 ; int prefixSum = 0 ; unordered_map < int , int > count {{ 0 , 1 }}; for ( int a : A ) { prefixSum += a ; if ( count . count ( prefixSum - S )) ans += count [ prefixSum - S ]; ++ count [ prefixSum ]; } return ans ; } };","title":"930. Binary Subarrays With Sum $\\star\\star$"},{"location":"cpp/0901-1000/0931-0940/","text":"931. Minimum Falling Path Sum $\\star\\star$ class Solution { public : int minFallingPathSum ( vector < vector < int >>& A ) { const int n = A . size (); for ( int i = 1 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int mini = INT_MAX ; for ( int k = max ( 0 , j - 1 ); k < min ( n , j + 2 ); ++ k ) mini = min ( mini , A [ i - 1 ][ k ]); A [ i ][ j ] += mini ; } return * min_element ( begin ( A [ n - 1 ]), end ( A [ n - 1 ])); } }; 932. Beautiful Array $\\star\\star$ 933. Number of Recent Calls $\\star$ 934. Shortest Bridge $\\star\\star$ 935. Knight Dialer $\\star\\star$ 936. Stamping The Sequence $\\star\\star\\star$ class Solution { public : vector < int > movesToStamp ( string stamp , string target ) { vector < int > ans ; vector < bool > stamped ( target . length ()); int stampedCount = 0 ; while ( stampedCount < target . length ()) { bool isStamped = false ; for ( int i = 0 ; i <= target . length () - stamp . length (); ++ i ) { if ( stamped [ i ]) continue ; int stampified = stampify ( stamp , target , i ); if ( stampified == 0 ) continue ; stampedCount += stampified ; isStamped = true ; stamped [ i ] = true ; ans . push_back ( i ); } if ( ! isStamped ) return {}; } reverse ( begin ( ans ), end ( ans )); return ans ; } private : int stampify ( const string & stamp , string & target , int s ) { int stampified = stamp . length (); for ( int i = 0 ; i < stamp . length (); ++ i ) if ( target [ s + i ] == '*' ) -- stampified ; else if ( target [ s + i ] != stamp [ i ]) return 0 ; fill ( begin ( target ) + s , begin ( target ) + s + stamp . length (), '*' ); return stampified ; } }; 937. Reorder Data in Log Files $\\star$ class Solution { public : vector < string > reorderLogFiles ( vector < string >& logs ) { vector < string > ans ; vector < string > digitLogs ; vector < pair < string , string >> letterLogs ; for ( const string & log : logs ) { int i = log . find_first_of ( ' ' ); if ( isdigit ( log [ i + 1 ])) digitLogs . push_back ( log ); else letterLogs . push_back ({ log . substr ( 0 , i ), log . substr ( i + 1 )}); } sort ( begin ( letterLogs ), end ( letterLogs ), []( const auto & a , const auto & b ) { return a . second == b . second ? a . first < b . first : a . second < b . second ; }); for ( const auto & [ identifier , letters ] : letterLogs ) ans . push_back ( identifier + ' ' + letters ); for ( const string & digitLog : digitLogs ) ans . push_back ( digitLog ); return ans ; } }; 938. Range Sum of BST $\\star$ 939. Minimum Area Rectangle $\\star\\star$ class Solution { public : int minAreaRect ( vector < vector < int >>& points ) { int ans = INT_MAX ; unordered_map < int , unordered_set < int >> xToYs ; for ( vector < int >& point : points ) xToYs [ point [ 0 ]]. insert ( point [ 1 ]); for ( int i = 0 ; i < points . size (); ++ i ) for ( int j = 0 ; j < i ; ++ j ) { if ( points [ i ][ 0 ] == points [ j ][ 0 ] || points [ i ][ 1 ] == points [ j ][ 1 ]) continue ; if ( xToYs [ points [ i ][ 0 ]]. count ( points [ j ][ 1 ]) && xToYs [ points [ j ][ 0 ]]. count ( points [ i ][ 1 ])) ans = min ( ans , abs ( points [ i ][ 0 ] - points [ j ][ 0 ]) * abs ( points [ i ][ 1 ] - points [ j ][ 1 ])); } return ans < INT_MAX ? ans : 0 ; } }; 940. Distinct Subsequences II $\\star\\star\\star$ class Solution { public : int distinctSubseqII ( string S ) { const int kMod = 1e9 + 7 ; vector < long > map ( 26 ); for ( char c : S ) map [ c - 'a' ] = accumulate ( begin ( map ), end ( map ), 1L ) % kMod ; return accumulate ( begin ( map ), end ( map ), 0L ) % kMod ; } };","title":"0931-0940"},{"location":"cpp/0901-1000/0931-0940/#931-minimum-falling-path-sum-starstar","text":"class Solution { public : int minFallingPathSum ( vector < vector < int >>& A ) { const int n = A . size (); for ( int i = 1 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int mini = INT_MAX ; for ( int k = max ( 0 , j - 1 ); k < min ( n , j + 2 ); ++ k ) mini = min ( mini , A [ i - 1 ][ k ]); A [ i ][ j ] += mini ; } return * min_element ( begin ( A [ n - 1 ]), end ( A [ n - 1 ])); } };","title":"931. Minimum Falling Path Sum $\\star\\star$"},{"location":"cpp/0901-1000/0931-0940/#932-beautiful-array-starstar","text":"","title":"932. Beautiful Array $\\star\\star$"},{"location":"cpp/0901-1000/0931-0940/#933-number-of-recent-calls-star","text":"","title":"933. Number of Recent Calls $\\star$"},{"location":"cpp/0901-1000/0931-0940/#934-shortest-bridge-starstar","text":"","title":"934. Shortest Bridge $\\star\\star$"},{"location":"cpp/0901-1000/0931-0940/#935-knight-dialer-starstar","text":"","title":"935. Knight Dialer $\\star\\star$"},{"location":"cpp/0901-1000/0931-0940/#936-stamping-the-sequence-starstarstar","text":"class Solution { public : vector < int > movesToStamp ( string stamp , string target ) { vector < int > ans ; vector < bool > stamped ( target . length ()); int stampedCount = 0 ; while ( stampedCount < target . length ()) { bool isStamped = false ; for ( int i = 0 ; i <= target . length () - stamp . length (); ++ i ) { if ( stamped [ i ]) continue ; int stampified = stampify ( stamp , target , i ); if ( stampified == 0 ) continue ; stampedCount += stampified ; isStamped = true ; stamped [ i ] = true ; ans . push_back ( i ); } if ( ! isStamped ) return {}; } reverse ( begin ( ans ), end ( ans )); return ans ; } private : int stampify ( const string & stamp , string & target , int s ) { int stampified = stamp . length (); for ( int i = 0 ; i < stamp . length (); ++ i ) if ( target [ s + i ] == '*' ) -- stampified ; else if ( target [ s + i ] != stamp [ i ]) return 0 ; fill ( begin ( target ) + s , begin ( target ) + s + stamp . length (), '*' ); return stampified ; } };","title":"936. Stamping The Sequence $\\star\\star\\star$"},{"location":"cpp/0901-1000/0931-0940/#937-reorder-data-in-log-files-star","text":"class Solution { public : vector < string > reorderLogFiles ( vector < string >& logs ) { vector < string > ans ; vector < string > digitLogs ; vector < pair < string , string >> letterLogs ; for ( const string & log : logs ) { int i = log . find_first_of ( ' ' ); if ( isdigit ( log [ i + 1 ])) digitLogs . push_back ( log ); else letterLogs . push_back ({ log . substr ( 0 , i ), log . substr ( i + 1 )}); } sort ( begin ( letterLogs ), end ( letterLogs ), []( const auto & a , const auto & b ) { return a . second == b . second ? a . first < b . first : a . second < b . second ; }); for ( const auto & [ identifier , letters ] : letterLogs ) ans . push_back ( identifier + ' ' + letters ); for ( const string & digitLog : digitLogs ) ans . push_back ( digitLog ); return ans ; } };","title":"937. Reorder Data in Log Files $\\star$"},{"location":"cpp/0901-1000/0931-0940/#938-range-sum-of-bst-star","text":"","title":"938. Range Sum of BST $\\star$"},{"location":"cpp/0901-1000/0931-0940/#939-minimum-area-rectangle-starstar","text":"class Solution { public : int minAreaRect ( vector < vector < int >>& points ) { int ans = INT_MAX ; unordered_map < int , unordered_set < int >> xToYs ; for ( vector < int >& point : points ) xToYs [ point [ 0 ]]. insert ( point [ 1 ]); for ( int i = 0 ; i < points . size (); ++ i ) for ( int j = 0 ; j < i ; ++ j ) { if ( points [ i ][ 0 ] == points [ j ][ 0 ] || points [ i ][ 1 ] == points [ j ][ 1 ]) continue ; if ( xToYs [ points [ i ][ 0 ]]. count ( points [ j ][ 1 ]) && xToYs [ points [ j ][ 0 ]]. count ( points [ i ][ 1 ])) ans = min ( ans , abs ( points [ i ][ 0 ] - points [ j ][ 0 ]) * abs ( points [ i ][ 1 ] - points [ j ][ 1 ])); } return ans < INT_MAX ? ans : 0 ; } };","title":"939. Minimum Area Rectangle $\\star\\star$"},{"location":"cpp/0901-1000/0931-0940/#940-distinct-subsequences-ii-starstarstar","text":"class Solution { public : int distinctSubseqII ( string S ) { const int kMod = 1e9 + 7 ; vector < long > map ( 26 ); for ( char c : S ) map [ c - 'a' ] = accumulate ( begin ( map ), end ( map ), 1L ) % kMod ; return accumulate ( begin ( map ), end ( map ), 0L ) % kMod ; } };","title":"940. Distinct Subsequences II $\\star\\star\\star$"},{"location":"cpp/0901-1000/0941-0950/","text":"941. Valid Mountain Array $\\star$ class Solution { public : bool validMountainArray ( vector < int >& A ) { if ( A . size () < 3 ) return false ; int l = 0 ; int r = A . size () - 1 ; while ( l + 1 < A . size () && A [ l ] < A [ l + 1 ]) ++ l ; while ( r > 0 && A [ r ] < A [ r - 1 ]) -- r ; return l > 0 && r < A . size () - 1 && l == r ; } }; 942. DI String Match $\\star$ class Solution { public : vector < int > diStringMatch ( string S ) { vector < int > ans ; int min = 0 ; int max = S . length (); for ( char c : S ) ans . push_back ( c == 'I' ? min ++ : max -- ); ans . push_back ( min ); return ans ; } }; 943. Find the Shortest Superstring $\\star\\star\\star$ 944. Delete Columns to Make Sorted $\\star$ 945. Minimum Increment to Make Array Unique $\\star\\star$ class Solution { public : int minIncrementForUnique ( vector < int >& A ) { int ans = 0 ; int minAvailable = 0 ; sort ( begin ( A ), end ( A )); for ( int a : A ) { ans += max ( minAvailable - a , 0 ); minAvailable = max ( minAvailable , a ) + 1 ; } return ans ; } }; 946. Validate Stack Sequences $\\star\\star$ 947. Most Stones Removed with Same Row or Column $\\star\\star$ 948. Bag of Tokens $\\star\\star$ 949. Largest Time for Given Digits $\\star$ class Solution { public : string largestTimeFromDigits ( vector < int >& A ) { string ans ; for ( int i = 0 ; i < 4 ; ++ i ) for ( int j = 0 ; j < 4 ; ++ j ) for ( int k = 0 ; k < 4 ; ++ k ) { if ( i == j || i == k || j == k ) continue ; string hours = to_string ( A [ i ]) + to_string ( A [ j ]); string minutes = to_string ( A [ k ]) + to_string ( A [ 6 - i - j - k ]); if ( hours < \"24\" && minutes < \"60\" ) ans = max ( ans , hours + ':' + minutes ); } return ans ; } }; 950. Reveal Cards In Increasing Order $\\star\\star$ class Solution { public : vector < int > deckRevealedIncreasing ( vector < int >& deck ) { sort ( begin ( deck ), end ( deck ), greater < int > ()); deque < int > deque { deck [ 0 ]}; for ( int i = 1 ; i < deck . size (); ++ i ) { deque . push_front ( deque . back ()); deque . pop_back (); deque . push_front ( deck [ i ]); } return { begin ( deque ), end ( deque )}; } };","title":"0941-0950"},{"location":"cpp/0901-1000/0941-0950/#941-valid-mountain-array-star","text":"class Solution { public : bool validMountainArray ( vector < int >& A ) { if ( A . size () < 3 ) return false ; int l = 0 ; int r = A . size () - 1 ; while ( l + 1 < A . size () && A [ l ] < A [ l + 1 ]) ++ l ; while ( r > 0 && A [ r ] < A [ r - 1 ]) -- r ; return l > 0 && r < A . size () - 1 && l == r ; } };","title":"941. Valid Mountain Array $\\star$"},{"location":"cpp/0901-1000/0941-0950/#942-di-string-match-star","text":"class Solution { public : vector < int > diStringMatch ( string S ) { vector < int > ans ; int min = 0 ; int max = S . length (); for ( char c : S ) ans . push_back ( c == 'I' ? min ++ : max -- ); ans . push_back ( min ); return ans ; } };","title":"942. DI String Match $\\star$"},{"location":"cpp/0901-1000/0941-0950/#943-find-the-shortest-superstring-starstarstar","text":"","title":"943. Find the Shortest Superstring $\\star\\star\\star$"},{"location":"cpp/0901-1000/0941-0950/#944-delete-columns-to-make-sorted-star","text":"","title":"944. Delete Columns to Make Sorted $\\star$"},{"location":"cpp/0901-1000/0941-0950/#945-minimum-increment-to-make-array-unique-starstar","text":"class Solution { public : int minIncrementForUnique ( vector < int >& A ) { int ans = 0 ; int minAvailable = 0 ; sort ( begin ( A ), end ( A )); for ( int a : A ) { ans += max ( minAvailable - a , 0 ); minAvailable = max ( minAvailable , a ) + 1 ; } return ans ; } };","title":"945. Minimum Increment to Make Array Unique $\\star\\star$"},{"location":"cpp/0901-1000/0941-0950/#946-validate-stack-sequences-starstar","text":"","title":"946. Validate Stack Sequences $\\star\\star$"},{"location":"cpp/0901-1000/0941-0950/#947-most-stones-removed-with-same-row-or-column-starstar","text":"","title":"947. Most Stones Removed with Same Row or Column $\\star\\star$"},{"location":"cpp/0901-1000/0941-0950/#948-bag-of-tokens-starstar","text":"","title":"948. Bag of Tokens $\\star\\star$"},{"location":"cpp/0901-1000/0941-0950/#949-largest-time-for-given-digits-star","text":"class Solution { public : string largestTimeFromDigits ( vector < int >& A ) { string ans ; for ( int i = 0 ; i < 4 ; ++ i ) for ( int j = 0 ; j < 4 ; ++ j ) for ( int k = 0 ; k < 4 ; ++ k ) { if ( i == j || i == k || j == k ) continue ; string hours = to_string ( A [ i ]) + to_string ( A [ j ]); string minutes = to_string ( A [ k ]) + to_string ( A [ 6 - i - j - k ]); if ( hours < \"24\" && minutes < \"60\" ) ans = max ( ans , hours + ':' + minutes ); } return ans ; } };","title":"949. Largest Time for Given Digits $\\star$"},{"location":"cpp/0901-1000/0941-0950/#950-reveal-cards-in-increasing-order-starstar","text":"class Solution { public : vector < int > deckRevealedIncreasing ( vector < int >& deck ) { sort ( begin ( deck ), end ( deck ), greater < int > ()); deque < int > deque { deck [ 0 ]}; for ( int i = 1 ; i < deck . size (); ++ i ) { deque . push_front ( deque . back ()); deque . pop_back (); deque . push_front ( deck [ i ]); } return { begin ( deque ), end ( deque )}; } };","title":"950. Reveal Cards In Increasing Order $\\star\\star$"},{"location":"cpp/0901-1000/0951-0960/","text":"951. Flip Equivalent Binary Trees $\\star\\star$ 952. Largest Component Size by Common Factor $\\star\\star\\star$ class UF { public : UF ( int n ) : rank ( n + 1 ), parent ( n + 1 ) { for ( int i = 0 ; i < parent . size (); ++ i ) parent [ i ] = i ; } void union_ ( int u , int v ) { int pu = find ( u ); int pv = find ( v ); if ( pu == pv ) return ; if ( rank [ pu ] < rank [ pv ]) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ]) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ]; } } int find ( int u ) { while ( u != parent [ u ]) { parent [ u ] = parent [ parent [ u ]]; u = parent [ u ]; } return u ; } private : vector < int > rank ; vector < int > parent ; }; class Solution { public : int largestComponentSize ( vector < int >& A ) { const int n = * max_element ( begin ( A ), end ( A )); int ans = 0 ; UF uf ( n ); unordered_map < int , int > count ; for ( int a : A ) for ( int num = 2 ; num <= sqrt ( a ); ++ num ) if ( a % num == 0 ) { uf . union_ ( a , num ); uf . union_ ( a , a / num ); } for ( int a : A ) ans = max ( ans , ++ count [ uf . find ( a )]); return ans ; } }; 953. Verifying an Alien Dictionary $\\star$ class Solution { public : bool isAlienSorted ( vector < string >& words , string order ) { unordered_map < char , char > map ; for ( int i = 0 ; i < 26 ; ++ i ) map [ order [ i ]] = ( char )( i + 'a' ); for ( string & word : words ) for ( char & c : word ) c = map [ c ]; return is_sorted ( begin ( words ), end ( words )); } }; 954. Array of Doubled Pairs $\\star\\star$ class Solution { public : bool canReorderDoubled ( vector < int >& A ) { unordered_map < int , int > count ; for ( int a : A ) count [ a ] ++ ; sort ( A . begin (), A . end (), []( const int a , const int b ) { return abs ( a ) < abs ( b ); }); for ( int a : A ) { if ( count [ a ] == 0 ) continue ; if ( count [ 2 * a ] == 0 ) return false ; -- count [ a ]; -- count [ 2 * a ]; } return true ; } }; 955. Delete Columns to Make Sorted II $\\star\\star$ 956. Tallest Billboard $\\star\\star\\star$ 957. Prison Cells After N Days $\\star\\star$ class Solution { public : vector < int > prisonAfterNDays ( vector < int >& cells , int N ) { vector < int > firstDayCells ; vector < int > nextDayCells ( cells . size ()); for ( int day = 0 ; N -- > 0 ; cells = nextDayCells , ++ day ) { for ( int i = 1 ; i + 1 < cells . size (); ++ i ) nextDayCells [ i ] = cells [ i - 1 ] == cells [ i + 1 ]; if ( day == 0 ) firstDayCells = nextDayCells ; else if ( nextDayCells == firstDayCells ) N %= day ; } return cells ; } }; 958. Check Completeness of a Binary Tree $\\star\\star$ 959. Regions Cut By Slashes $\\star\\star$ 960. Delete Columns to Make Sorted III $\\star\\star\\star$","title":"0951-0960"},{"location":"cpp/0901-1000/0951-0960/#951-flip-equivalent-binary-trees-starstar","text":"","title":"951. Flip Equivalent Binary Trees $\\star\\star$"},{"location":"cpp/0901-1000/0951-0960/#952-largest-component-size-by-common-factor-starstarstar","text":"class UF { public : UF ( int n ) : rank ( n + 1 ), parent ( n + 1 ) { for ( int i = 0 ; i < parent . size (); ++ i ) parent [ i ] = i ; } void union_ ( int u , int v ) { int pu = find ( u ); int pv = find ( v ); if ( pu == pv ) return ; if ( rank [ pu ] < rank [ pv ]) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ]) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ]; } } int find ( int u ) { while ( u != parent [ u ]) { parent [ u ] = parent [ parent [ u ]]; u = parent [ u ]; } return u ; } private : vector < int > rank ; vector < int > parent ; }; class Solution { public : int largestComponentSize ( vector < int >& A ) { const int n = * max_element ( begin ( A ), end ( A )); int ans = 0 ; UF uf ( n ); unordered_map < int , int > count ; for ( int a : A ) for ( int num = 2 ; num <= sqrt ( a ); ++ num ) if ( a % num == 0 ) { uf . union_ ( a , num ); uf . union_ ( a , a / num ); } for ( int a : A ) ans = max ( ans , ++ count [ uf . find ( a )]); return ans ; } };","title":"952. Largest Component Size by Common Factor $\\star\\star\\star$"},{"location":"cpp/0901-1000/0951-0960/#953-verifying-an-alien-dictionary-star","text":"class Solution { public : bool isAlienSorted ( vector < string >& words , string order ) { unordered_map < char , char > map ; for ( int i = 0 ; i < 26 ; ++ i ) map [ order [ i ]] = ( char )( i + 'a' ); for ( string & word : words ) for ( char & c : word ) c = map [ c ]; return is_sorted ( begin ( words ), end ( words )); } };","title":"953. Verifying an Alien Dictionary $\\star$"},{"location":"cpp/0901-1000/0951-0960/#954-array-of-doubled-pairs-starstar","text":"class Solution { public : bool canReorderDoubled ( vector < int >& A ) { unordered_map < int , int > count ; for ( int a : A ) count [ a ] ++ ; sort ( A . begin (), A . end (), []( const int a , const int b ) { return abs ( a ) < abs ( b ); }); for ( int a : A ) { if ( count [ a ] == 0 ) continue ; if ( count [ 2 * a ] == 0 ) return false ; -- count [ a ]; -- count [ 2 * a ]; } return true ; } };","title":"954. Array of Doubled Pairs $\\star\\star$"},{"location":"cpp/0901-1000/0951-0960/#955-delete-columns-to-make-sorted-ii-starstar","text":"","title":"955. Delete Columns to Make Sorted II $\\star\\star$"},{"location":"cpp/0901-1000/0951-0960/#956-tallest-billboard-starstarstar","text":"","title":"956. Tallest Billboard $\\star\\star\\star$"},{"location":"cpp/0901-1000/0951-0960/#957-prison-cells-after-n-days-starstar","text":"class Solution { public : vector < int > prisonAfterNDays ( vector < int >& cells , int N ) { vector < int > firstDayCells ; vector < int > nextDayCells ( cells . size ()); for ( int day = 0 ; N -- > 0 ; cells = nextDayCells , ++ day ) { for ( int i = 1 ; i + 1 < cells . size (); ++ i ) nextDayCells [ i ] = cells [ i - 1 ] == cells [ i + 1 ]; if ( day == 0 ) firstDayCells = nextDayCells ; else if ( nextDayCells == firstDayCells ) N %= day ; } return cells ; } };","title":"957. Prison Cells After N Days $\\star\\star$"},{"location":"cpp/0901-1000/0951-0960/#958-check-completeness-of-a-binary-tree-starstar","text":"","title":"958. Check Completeness of a Binary Tree $\\star\\star$"},{"location":"cpp/0901-1000/0951-0960/#959-regions-cut-by-slashes-starstar","text":"","title":"959. Regions Cut By Slashes $\\star\\star$"},{"location":"cpp/0901-1000/0951-0960/#960-delete-columns-to-make-sorted-iii-starstarstar","text":"","title":"960. Delete Columns to Make Sorted III $\\star\\star\\star$"},{"location":"cpp/0901-1000/0961-0970/","text":"961. N-Repeated Element in Size 2N Array $\\star$ class Solution { public : int repeatedNTimes ( vector < int >& A ) { for ( int i = 0 ; i + 2 < A . size (); ++ i ) if ( A [ i ] == A [ i + 1 ] || A [ i ] == A [ i + 2 ]) return A [ i ]; return A . back (); } }; 962. Maximum Width Ramp $\\star\\star$ class Solution { public : int maxWidthRamp ( vector < int >& A ) { int ans = 0 ; stack < int > stack ; for ( int i = 0 ; i < A . size (); ++ i ) if ( stack . empty () || A [ i ] < A [ stack . top ()]) stack . push ( i ); for ( int i = A . size () - 1 ; i > ans ; -- i ) while ( ! stack . empty () && A [ i ] >= A [ stack . top ()]) ans = max ( ans , i - stack . top ()), stack . pop (); return ans ; } }; 963. Minimum Area Rectangle II $\\star\\star$ class Solution { public : double minAreaFreeRect ( vector < vector < int >>& points ) { long long ans = LLONG_MAX ; unordered_map < int , vector < tuple < int , int , int , int >>> centerToPoints ; for ( vector < int >& A : points ) for ( vector < int >& B : points ) { int center = hash ( A , B ); centerToPoints [ center ]. push_back ({ A [ 0 ], A [ 1 ], B [ 0 ], B [ 1 ]}); } for ( const auto & [ _ , points ] : centerToPoints ) for ( const auto & [ ax , ay , bx , by ] : points ) for ( const auto & [ cx , cy , dx , dy ] : points ) if (( cx - ax ) * ( dx - ax ) + ( cy - ay ) * ( dy - ay ) == 0 ) { long long squaredArea = dist ( ax , ay , cx , cy ) * dist ( ax , ay , dx , dy ); if ( squaredArea > 0 ) ans = min ( ans , squaredArea ); } return ans == LLONG_MAX ? 0 : sqrt ( ans ); } private : int hash ( vector < int >& p , vector < int >& q ) { return (( long long )( p [ 0 ] + q [ 0 ]) << 16 ) + ( p [ 1 ] + q [ 1 ]); } long long dist ( int px , int py , int qx , int qy ) { return ( px - qx ) * ( px - qx ) + ( py - qy ) * ( py - qy ); } }; 964. Least Operators to Express Number $\\star\\star\\star$ class Solution { public : int leastOpsExpressTarget ( int x , int target ) { return dfs ( x , target ); } private : unordered_map < int , int > memo ; int dfs ( int x , int target ) { if ( memo . count ( target )) return memo [ target ]; if ( x > target ) return min ( 2 * target - 1 , 2 * ( x - target )); if ( x == target ) return 0 ; long prod = x ; int n = 0 ; while ( prod < target ) { prod *= x ; ++ n ; } if ( prod == target ) return memo [ target ] = n ; memo [ target ] = INT_MAX ; if ( prod < 2 * target ) memo [ target ] = dfs ( x , prod - target ) + n + 1 ; memo [ target ] = min ( memo [ target ], dfs ( x , target - prod / x ) + n ); return memo [ target ]; } }; 965. Univalued Binary Tree $\\star$ 966. Vowel Spellchecker $\\star\\star$ class Solution { public : vector < string > spellchecker ( vector < string >& wordlist , vector < string >& queries ) { vector < string > ans ; unordered_map < string , string > dict ; for ( const string & word : wordlist ) { dict . insert ({ word , word }); dict . insert ({ lowerKey ( word ), word }); dict . insert ({ vowelKey ( word ), word }); } for ( const string & query : queries ) if ( dict . count ( query )) ans . push_back ( dict [ query ]); else if ( dict . count ( lowerKey ( query ))) ans . push_back ( dict [ lowerKey ( query )]); else if ( dict . count ( vowelKey ( query ))) ans . push_back ( dict [ vowelKey ( query )]); else ans . push_back ( \"\" ); return ans ; } private : string lowerKey ( const string & word ) { string s { \"$\" }; for ( char c : word ) s += tolower ( c ); return s ; } string vowelKey ( const string & word ) { string s ; for ( char c : word ) s += string ( \"aeiou\" ). find ( tolower ( c )) != string :: npos ? '*' : tolower ( c ); return s ; } }; 967. Numbers With Same Consecutive Differences $\\star\\star$ 968. Binary Tree Cameras $\\star\\star\\star$ 969. Pancake Sorting $\\star\\star$ class Solution { public : vector < int > pancakeSort ( vector < int >& A ) { vector < int > ans ; for ( int target = A . size (); target >= 1 ; -- target ) { int index = find ( A , target ); reverse ( begin ( A ), begin ( A ) + index + 1 ); reverse ( begin ( A ), begin ( A ) + target ); ans . push_back ( index + 1 ); ans . push_back ( target ); } return ans ; } private : int find ( vector < int >& A , int target ) { for ( int i = 0 ; i < A . size (); ++ i ) if ( A [ i ] == target ) return i ; throw ; } }; 970. Powerful Integers $\\star$ class Solution { public : vector < int > powerfulIntegers ( int x , int y , int bound ) { unordered_set < int > ans ; for ( int i = 1 ; i < bound ; i *= x ) { for ( int j = 1 ; i + j <= bound ; j *= y ) { ans . insert ( i + j ); if ( y == 1 ) break ; } if ( x == 1 ) break ; } return { begin ( ans ), end ( ans )}; } };","title":"0961-0970"},{"location":"cpp/0901-1000/0961-0970/#961-n-repeated-element-in-size-2n-array-star","text":"class Solution { public : int repeatedNTimes ( vector < int >& A ) { for ( int i = 0 ; i + 2 < A . size (); ++ i ) if ( A [ i ] == A [ i + 1 ] || A [ i ] == A [ i + 2 ]) return A [ i ]; return A . back (); } };","title":"961. N-Repeated Element in Size 2N Array $\\star$"},{"location":"cpp/0901-1000/0961-0970/#962-maximum-width-ramp-starstar","text":"class Solution { public : int maxWidthRamp ( vector < int >& A ) { int ans = 0 ; stack < int > stack ; for ( int i = 0 ; i < A . size (); ++ i ) if ( stack . empty () || A [ i ] < A [ stack . top ()]) stack . push ( i ); for ( int i = A . size () - 1 ; i > ans ; -- i ) while ( ! stack . empty () && A [ i ] >= A [ stack . top ()]) ans = max ( ans , i - stack . top ()), stack . pop (); return ans ; } };","title":"962. Maximum Width Ramp $\\star\\star$"},{"location":"cpp/0901-1000/0961-0970/#963-minimum-area-rectangle-ii-starstar","text":"class Solution { public : double minAreaFreeRect ( vector < vector < int >>& points ) { long long ans = LLONG_MAX ; unordered_map < int , vector < tuple < int , int , int , int >>> centerToPoints ; for ( vector < int >& A : points ) for ( vector < int >& B : points ) { int center = hash ( A , B ); centerToPoints [ center ]. push_back ({ A [ 0 ], A [ 1 ], B [ 0 ], B [ 1 ]}); } for ( const auto & [ _ , points ] : centerToPoints ) for ( const auto & [ ax , ay , bx , by ] : points ) for ( const auto & [ cx , cy , dx , dy ] : points ) if (( cx - ax ) * ( dx - ax ) + ( cy - ay ) * ( dy - ay ) == 0 ) { long long squaredArea = dist ( ax , ay , cx , cy ) * dist ( ax , ay , dx , dy ); if ( squaredArea > 0 ) ans = min ( ans , squaredArea ); } return ans == LLONG_MAX ? 0 : sqrt ( ans ); } private : int hash ( vector < int >& p , vector < int >& q ) { return (( long long )( p [ 0 ] + q [ 0 ]) << 16 ) + ( p [ 1 ] + q [ 1 ]); } long long dist ( int px , int py , int qx , int qy ) { return ( px - qx ) * ( px - qx ) + ( py - qy ) * ( py - qy ); } };","title":"963. Minimum Area Rectangle II $\\star\\star$"},{"location":"cpp/0901-1000/0961-0970/#964-least-operators-to-express-number-starstarstar","text":"class Solution { public : int leastOpsExpressTarget ( int x , int target ) { return dfs ( x , target ); } private : unordered_map < int , int > memo ; int dfs ( int x , int target ) { if ( memo . count ( target )) return memo [ target ]; if ( x > target ) return min ( 2 * target - 1 , 2 * ( x - target )); if ( x == target ) return 0 ; long prod = x ; int n = 0 ; while ( prod < target ) { prod *= x ; ++ n ; } if ( prod == target ) return memo [ target ] = n ; memo [ target ] = INT_MAX ; if ( prod < 2 * target ) memo [ target ] = dfs ( x , prod - target ) + n + 1 ; memo [ target ] = min ( memo [ target ], dfs ( x , target - prod / x ) + n ); return memo [ target ]; } };","title":"964. Least Operators to Express Number $\\star\\star\\star$"},{"location":"cpp/0901-1000/0961-0970/#965-univalued-binary-tree-star","text":"","title":"965. Univalued Binary Tree $\\star$"},{"location":"cpp/0901-1000/0961-0970/#966-vowel-spellchecker-starstar","text":"class Solution { public : vector < string > spellchecker ( vector < string >& wordlist , vector < string >& queries ) { vector < string > ans ; unordered_map < string , string > dict ; for ( const string & word : wordlist ) { dict . insert ({ word , word }); dict . insert ({ lowerKey ( word ), word }); dict . insert ({ vowelKey ( word ), word }); } for ( const string & query : queries ) if ( dict . count ( query )) ans . push_back ( dict [ query ]); else if ( dict . count ( lowerKey ( query ))) ans . push_back ( dict [ lowerKey ( query )]); else if ( dict . count ( vowelKey ( query ))) ans . push_back ( dict [ vowelKey ( query )]); else ans . push_back ( \"\" ); return ans ; } private : string lowerKey ( const string & word ) { string s { \"$\" }; for ( char c : word ) s += tolower ( c ); return s ; } string vowelKey ( const string & word ) { string s ; for ( char c : word ) s += string ( \"aeiou\" ). find ( tolower ( c )) != string :: npos ? '*' : tolower ( c ); return s ; } };","title":"966. Vowel Spellchecker $\\star\\star$"},{"location":"cpp/0901-1000/0961-0970/#967-numbers-with-same-consecutive-differences-starstar","text":"","title":"967. Numbers With Same Consecutive Differences $\\star\\star$"},{"location":"cpp/0901-1000/0961-0970/#968-binary-tree-cameras-starstarstar","text":"","title":"968. Binary Tree Cameras $\\star\\star\\star$"},{"location":"cpp/0901-1000/0961-0970/#969-pancake-sorting-starstar","text":"class Solution { public : vector < int > pancakeSort ( vector < int >& A ) { vector < int > ans ; for ( int target = A . size (); target >= 1 ; -- target ) { int index = find ( A , target ); reverse ( begin ( A ), begin ( A ) + index + 1 ); reverse ( begin ( A ), begin ( A ) + target ); ans . push_back ( index + 1 ); ans . push_back ( target ); } return ans ; } private : int find ( vector < int >& A , int target ) { for ( int i = 0 ; i < A . size (); ++ i ) if ( A [ i ] == target ) return i ; throw ; } };","title":"969. Pancake Sorting $\\star\\star$"},{"location":"cpp/0901-1000/0961-0970/#970-powerful-integers-star","text":"class Solution { public : vector < int > powerfulIntegers ( int x , int y , int bound ) { unordered_set < int > ans ; for ( int i = 1 ; i < bound ; i *= x ) { for ( int j = 1 ; i + j <= bound ; j *= y ) { ans . insert ( i + j ); if ( y == 1 ) break ; } if ( x == 1 ) break ; } return { begin ( ans ), end ( ans )}; } };","title":"970. Powerful Integers $\\star$"},{"location":"cpp/0901-1000/0971-0980/","text":"971. Flip Binary Tree To Match Preorder Traversal $\\star\\star$ 972. Equal Rational Numbers $\\star\\star\\star$ class Solution { public : bool isRationalEqual ( string S , string T ) { return abs ( valueOf ( S ) - valueOf ( T )) < 1e-9 ; } private : vector < double > ratios { 1.0 , 1.0 / 9 , 1.0 / 99 , 1.0 / 999 , 1.0 / 9999 }; double valueOf ( const string & s ) { if ( s . find ( '(' ) == string :: npos ) return stod ( s ); double integer_nonRepeating = stod ( s . substr ( 0 , s . find_first_of ( '(' ))); int nonRepeatingLength = s . find_first_of ( '(' ) - s . find_first_of ( '.' ) - 1 ; int repeating = stoi ( s . substr ( s . find_first_of ( '(' ) + 1 , s . find_first_of ( ')' ))); int repeatingLength = s . find_first_of ( ')' ) - s . find_first_of ( '(' ) - 1 ; return integer_nonRepeating + repeating * pow ( 0.1 , nonRepeatingLength ) * ratios [ repeatingLength ]; } }; 973. K Closest Points to Origin $\\star\\star$ 974. Subarray Sums Divisible by K $\\star\\star$ class Solution { public : int subarraysDivByK ( vector < int >& A , int K ) { int ans = 0 ; int prefixSum = 0 ; vector < int > count ( K ); count [ 0 ] = 1 ; for ( int a : A ) { prefixSum = ( prefixSum + a % K + K ) % K ; ans += count [ prefixSum ]; ++ count [ prefixSum ]; } return ans ; } }; 975. Odd Even Jump $\\star\\star\\star$ 976. Largest Perimeter Triangle $\\star$ class Solution { public : int largestPerimeter ( vector < int >& A ) { sort ( begin ( A ), end ( A )); for ( int i = A . size () - 1 ; i > 1 ; -- i ) if ( A [ i - 2 ] + A [ i - 1 ] > A [ i ]) return A [ i - 2 ] + A [ i - 1 ] + A [ i ]; return 0 ; } }; 977. Squares of a Sorted Array $\\star$ class Solution { public : vector < int > sortedSquares ( vector < int >& A ) { vector < int > ans ( A . size ()); int i = A . size () - 1 ; for ( int l = 0 , r = A . size () - 1 ; l <= r ;) if ( abs ( A [ l ]) > abs ( A [ r ])) ans [ i -- ] = A [ l ] * A [ l ++ ]; else ans [ i -- ] = A [ r ] * A [ r -- ]; return ans ; } }; 978. Longest Turbulent Subarray $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public : int maxTurbulenceSize ( vector < int >& A ) { int ans = 1 ; int increasing = 1 ; int decreasing = 1 ; for ( int i = 1 ; i < A . size (); ++ i ) { if ( A [ i ] > A [ i - 1 ]) { increasing = decreasing + 1 ; decreasing = 1 ; } else if ( A [ i ] < A [ i - 1 ]) { decreasing = increasing + 1 ; increasing = 1 ; } else { increasing = 1 ; decreasing = 1 ; } ans = max ( ans , max ( increasing , decreasing )); } return ans ; } }; 979. Distribute Coins in Binary Tree $\\star\\star$ 980. Unique Paths III $\\star\\star\\star$ class Solution { public : int uniquePathsIII ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); int ans = 0 ; int empty = 1 ; int sx ; int sy ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { if ( grid [ i ][ j ] == 0 ) { ++ empty ; } else if ( grid [ i ][ j ] == 1 ) { sx = i ; sy = j ; } else if ( grid [ i ][ j ] == 2 ) { ex = i ; ey = j ; } } dfs ( grid , empty , sx , sy , ans ); return ans ; } private : int ex ; int ey ; void dfs ( vector < vector < int >>& grid , int empty , int i , int j , int & ans ) { if ( i < 0 || i >= grid . size () || j < 0 || j >= grid [ 0 ]. size () || grid [ i ][ j ] < 0 ) return ; if ( i == ex && j == ey ) { if ( empty == 0 ) ++ ans ; return ; } grid [ i ][ j ] = - 2 ; dfs ( grid , empty - 1 , i + 1 , j , ans ); dfs ( grid , empty - 1 , i - 1 , j , ans ); dfs ( grid , empty - 1 , i , j + 1 , ans ); dfs ( grid , empty - 1 , i , j - 1 , ans ); grid [ i ][ j ] = 0 ; } };","title":"0971-0980"},{"location":"cpp/0901-1000/0971-0980/#971-flip-binary-tree-to-match-preorder-traversal-starstar","text":"","title":"971. Flip Binary Tree To Match Preorder Traversal $\\star\\star$"},{"location":"cpp/0901-1000/0971-0980/#972-equal-rational-numbers-starstarstar","text":"class Solution { public : bool isRationalEqual ( string S , string T ) { return abs ( valueOf ( S ) - valueOf ( T )) < 1e-9 ; } private : vector < double > ratios { 1.0 , 1.0 / 9 , 1.0 / 99 , 1.0 / 999 , 1.0 / 9999 }; double valueOf ( const string & s ) { if ( s . find ( '(' ) == string :: npos ) return stod ( s ); double integer_nonRepeating = stod ( s . substr ( 0 , s . find_first_of ( '(' ))); int nonRepeatingLength = s . find_first_of ( '(' ) - s . find_first_of ( '.' ) - 1 ; int repeating = stoi ( s . substr ( s . find_first_of ( '(' ) + 1 , s . find_first_of ( ')' ))); int repeatingLength = s . find_first_of ( ')' ) - s . find_first_of ( '(' ) - 1 ; return integer_nonRepeating + repeating * pow ( 0.1 , nonRepeatingLength ) * ratios [ repeatingLength ]; } };","title":"972. Equal Rational Numbers $\\star\\star\\star$"},{"location":"cpp/0901-1000/0971-0980/#973-k-closest-points-to-origin-starstar","text":"","title":"973. K Closest Points to Origin $\\star\\star$"},{"location":"cpp/0901-1000/0971-0980/#974-subarray-sums-divisible-by-k-starstar","text":"class Solution { public : int subarraysDivByK ( vector < int >& A , int K ) { int ans = 0 ; int prefixSum = 0 ; vector < int > count ( K ); count [ 0 ] = 1 ; for ( int a : A ) { prefixSum = ( prefixSum + a % K + K ) % K ; ans += count [ prefixSum ]; ++ count [ prefixSum ]; } return ans ; } };","title":"974. Subarray Sums Divisible by K $\\star\\star$"},{"location":"cpp/0901-1000/0971-0980/#975-odd-even-jump-starstarstar","text":"","title":"975. Odd Even Jump $\\star\\star\\star$"},{"location":"cpp/0901-1000/0971-0980/#976-largest-perimeter-triangle-star","text":"class Solution { public : int largestPerimeter ( vector < int >& A ) { sort ( begin ( A ), end ( A )); for ( int i = A . size () - 1 ; i > 1 ; -- i ) if ( A [ i - 2 ] + A [ i - 1 ] > A [ i ]) return A [ i - 2 ] + A [ i - 1 ] + A [ i ]; return 0 ; } };","title":"976. Largest Perimeter Triangle $\\star$"},{"location":"cpp/0901-1000/0971-0980/#977-squares-of-a-sorted-array-star","text":"class Solution { public : vector < int > sortedSquares ( vector < int >& A ) { vector < int > ans ( A . size ()); int i = A . size () - 1 ; for ( int l = 0 , r = A . size () - 1 ; l <= r ;) if ( abs ( A [ l ]) > abs ( A [ r ])) ans [ i -- ] = A [ l ] * A [ l ++ ]; else ans [ i -- ] = A [ r ] * A [ r -- ]; return ans ; } };","title":"977. Squares of a Sorted Array $\\star$"},{"location":"cpp/0901-1000/0971-0980/#978-longest-turbulent-subarray-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public : int maxTurbulenceSize ( vector < int >& A ) { int ans = 1 ; int increasing = 1 ; int decreasing = 1 ; for ( int i = 1 ; i < A . size (); ++ i ) { if ( A [ i ] > A [ i - 1 ]) { increasing = decreasing + 1 ; decreasing = 1 ; } else if ( A [ i ] < A [ i - 1 ]) { decreasing = increasing + 1 ; increasing = 1 ; } else { increasing = 1 ; decreasing = 1 ; } ans = max ( ans , max ( increasing , decreasing )); } return ans ; } };","title":"978. Longest Turbulent Subarray $\\star\\star$"},{"location":"cpp/0901-1000/0971-0980/#979-distribute-coins-in-binary-tree-starstar","text":"","title":"979. Distribute Coins in Binary Tree $\\star\\star$"},{"location":"cpp/0901-1000/0971-0980/#980-unique-paths-iii-starstarstar","text":"class Solution { public : int uniquePathsIII ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); int ans = 0 ; int empty = 1 ; int sx ; int sy ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { if ( grid [ i ][ j ] == 0 ) { ++ empty ; } else if ( grid [ i ][ j ] == 1 ) { sx = i ; sy = j ; } else if ( grid [ i ][ j ] == 2 ) { ex = i ; ey = j ; } } dfs ( grid , empty , sx , sy , ans ); return ans ; } private : int ex ; int ey ; void dfs ( vector < vector < int >>& grid , int empty , int i , int j , int & ans ) { if ( i < 0 || i >= grid . size () || j < 0 || j >= grid [ 0 ]. size () || grid [ i ][ j ] < 0 ) return ; if ( i == ex && j == ey ) { if ( empty == 0 ) ++ ans ; return ; } grid [ i ][ j ] = - 2 ; dfs ( grid , empty - 1 , i + 1 , j , ans ); dfs ( grid , empty - 1 , i - 1 , j , ans ); dfs ( grid , empty - 1 , i , j + 1 , ans ); dfs ( grid , empty - 1 , i , j - 1 , ans ); grid [ i ][ j ] = 0 ; } };","title":"980. Unique Paths III $\\star\\star\\star$"},{"location":"cpp/0901-1000/0981-0990/","text":"981. Time Based Key-Value Store $\\star\\star$ class TimeMap { public : void set ( string key , string value , int timestamp ) { map [ key ][ timestamp ] = value ; } string get ( string key , int timestamp ) { auto it = map [ key ]. upper_bound ( timestamp ); return it == begin ( map [ key ]) ? \"\" : prev ( it ) -> second ; } private : unordered_map < string , std :: map < int , string >> map ; }; 982. Triples with Bitwise AND Equal To Zero $\\star\\star\\star$ 983. Minimum Cost For Tickets $\\star\\star$ class Solution { public : int mincostTickets ( vector < int >& days , vector < int >& costs ) { int ans = 0 ; queue < pair < int , int >> last7 ; queue < pair < int , int >> last30 ; for ( int day : days ) { while ( ! last7 . empty () && last7 . front (). first + 7 <= day ) last7 . pop (); while ( ! last30 . empty () && last30 . front (). first + 30 <= day ) last30 . pop (); last7 . push ({ day , ans + costs [ 1 ]}); last30 . push ({ day , ans + costs [ 2 ]}); ans = min ({ ans + costs [ 0 ], last7 . front (). second , last30 . front (). second }); } return ans ; } }; 984. String Without AAA or BBB $\\star\\star$ 985. Sum of Even Numbers After Queries $\\star$ class Solution { public : vector < int > sumEvenAfterQueries ( vector < int >& A , vector < vector < int >>& queries ) { vector < int > ans ; int sum = accumulate ( begin ( A ), end ( A ), 0 , []( int a , int b ) { return a + ( b % 2 == 0 ? b : 0 ); }); for ( vector < int >& query : queries ) { if ( A [ query [ 1 ]] % 2 == 0 ) sum -= A [ query [ 1 ]]; A [ query [ 1 ]] += query [ 0 ]; if ( A [ query [ 1 ]] % 2 == 0 ) sum += A [ query [ 1 ]]; ans . push_back ( sum ); } return ans ; } }; 986. Interval List Intersections $\\star\\star$ class Solution { public : vector < vector < int >> intervalIntersection ( vector < vector < int >>& A , vector < vector < int >>& B ) { vector < vector < int >> ans ; short i = 0 ; short j = 0 ; while ( i < A . size () && j < B . size ()) { int start = max ( A [ i ][ 0 ], B [ j ][ 0 ]); int end = min ( A [ i ][ 1 ], B [ j ][ 1 ]); if ( end >= start ) ans . push_back ({ start , end }); if ( A [ i ][ 1 ] > B [ j ][ 1 ]) ++ j ; else ++ i ; } return ans ; } }; 987. Vertical Order Traversal of a Binary Tree $\\star\\star$ class Solution { public : vector < vector < int >> verticalTraversal ( TreeNode * root ) { vector < vector < int >> ans ; map < int , vector < pair < int , int >>> xToNodes ; dfs ( root , 0 , 0 , xToNodes ); for ( auto && [ _ , nodes ] : xToNodes ) { sort ( begin ( nodes ), end ( nodes )); vector < int > vals ; for ( pair < int , int >& node : nodes ) vals . push_back ( node . second ); ans . push_back ( vals ); } return ans ; } private : void dfs ( TreeNode * root , int x , int y , map < int , vector < pair < int , int >>>& xToNodes ) { if ( ! root ) return ; xToNodes [ x ]. push_back ( pair < int , int > ( - y , root -> val )); dfs ( root -> left , x - 1 , y - 1 , xToNodes ); dfs ( root -> right , x + 1 , y - 1 , xToNodes ); } }; 988. Smallest String Starting From Leaf $\\star\\star$ 989. Add to Array-Form of Integer $\\star$ class Solution { public : vector < int > addToArrayForm ( vector < int >& A , int K ) { for ( int i = A . size () - 1 ; i >= 0 ; -- i ) { A [ i ] += K ; K = A [ i ] / 10 ; A [ i ] %= 10 ; } while ( K > 0 ) { A . insert ( begin ( A ), K % 10 ); K /= 10 ; } return A ; } }; 990. Satisfiability of Equality Equations $\\star\\star$","title":"0981-0990"},{"location":"cpp/0901-1000/0981-0990/#981-time-based-key-value-store-starstar","text":"class TimeMap { public : void set ( string key , string value , int timestamp ) { map [ key ][ timestamp ] = value ; } string get ( string key , int timestamp ) { auto it = map [ key ]. upper_bound ( timestamp ); return it == begin ( map [ key ]) ? \"\" : prev ( it ) -> second ; } private : unordered_map < string , std :: map < int , string >> map ; };","title":"981. Time Based Key-Value Store $\\star\\star$"},{"location":"cpp/0901-1000/0981-0990/#982-triples-with-bitwise-and-equal-to-zero-starstarstar","text":"","title":"982. Triples with Bitwise AND Equal To Zero $\\star\\star\\star$"},{"location":"cpp/0901-1000/0981-0990/#983-minimum-cost-for-tickets-starstar","text":"class Solution { public : int mincostTickets ( vector < int >& days , vector < int >& costs ) { int ans = 0 ; queue < pair < int , int >> last7 ; queue < pair < int , int >> last30 ; for ( int day : days ) { while ( ! last7 . empty () && last7 . front (). first + 7 <= day ) last7 . pop (); while ( ! last30 . empty () && last30 . front (). first + 30 <= day ) last30 . pop (); last7 . push ({ day , ans + costs [ 1 ]}); last30 . push ({ day , ans + costs [ 2 ]}); ans = min ({ ans + costs [ 0 ], last7 . front (). second , last30 . front (). second }); } return ans ; } };","title":"983. Minimum Cost For Tickets $\\star\\star$"},{"location":"cpp/0901-1000/0981-0990/#984-string-without-aaa-or-bbb-starstar","text":"","title":"984. String Without AAA or BBB $\\star\\star$"},{"location":"cpp/0901-1000/0981-0990/#985-sum-of-even-numbers-after-queries-star","text":"class Solution { public : vector < int > sumEvenAfterQueries ( vector < int >& A , vector < vector < int >>& queries ) { vector < int > ans ; int sum = accumulate ( begin ( A ), end ( A ), 0 , []( int a , int b ) { return a + ( b % 2 == 0 ? b : 0 ); }); for ( vector < int >& query : queries ) { if ( A [ query [ 1 ]] % 2 == 0 ) sum -= A [ query [ 1 ]]; A [ query [ 1 ]] += query [ 0 ]; if ( A [ query [ 1 ]] % 2 == 0 ) sum += A [ query [ 1 ]]; ans . push_back ( sum ); } return ans ; } };","title":"985. Sum of Even Numbers After Queries $\\star$"},{"location":"cpp/0901-1000/0981-0990/#986-interval-list-intersections-starstar","text":"class Solution { public : vector < vector < int >> intervalIntersection ( vector < vector < int >>& A , vector < vector < int >>& B ) { vector < vector < int >> ans ; short i = 0 ; short j = 0 ; while ( i < A . size () && j < B . size ()) { int start = max ( A [ i ][ 0 ], B [ j ][ 0 ]); int end = min ( A [ i ][ 1 ], B [ j ][ 1 ]); if ( end >= start ) ans . push_back ({ start , end }); if ( A [ i ][ 1 ] > B [ j ][ 1 ]) ++ j ; else ++ i ; } return ans ; } };","title":"986. Interval List Intersections $\\star\\star$"},{"location":"cpp/0901-1000/0981-0990/#987-vertical-order-traversal-of-a-binary-tree-starstar","text":"class Solution { public : vector < vector < int >> verticalTraversal ( TreeNode * root ) { vector < vector < int >> ans ; map < int , vector < pair < int , int >>> xToNodes ; dfs ( root , 0 , 0 , xToNodes ); for ( auto && [ _ , nodes ] : xToNodes ) { sort ( begin ( nodes ), end ( nodes )); vector < int > vals ; for ( pair < int , int >& node : nodes ) vals . push_back ( node . second ); ans . push_back ( vals ); } return ans ; } private : void dfs ( TreeNode * root , int x , int y , map < int , vector < pair < int , int >>>& xToNodes ) { if ( ! root ) return ; xToNodes [ x ]. push_back ( pair < int , int > ( - y , root -> val )); dfs ( root -> left , x - 1 , y - 1 , xToNodes ); dfs ( root -> right , x + 1 , y - 1 , xToNodes ); } };","title":"987. Vertical Order Traversal of a Binary Tree $\\star\\star$"},{"location":"cpp/0901-1000/0981-0990/#988-smallest-string-starting-from-leaf-starstar","text":"","title":"988. Smallest String Starting From Leaf $\\star\\star$"},{"location":"cpp/0901-1000/0981-0990/#989-add-to-array-form-of-integer-star","text":"class Solution { public : vector < int > addToArrayForm ( vector < int >& A , int K ) { for ( int i = A . size () - 1 ; i >= 0 ; -- i ) { A [ i ] += K ; K = A [ i ] / 10 ; A [ i ] %= 10 ; } while ( K > 0 ) { A . insert ( begin ( A ), K % 10 ); K /= 10 ; } return A ; } };","title":"989. Add to Array-Form of Integer $\\star$"},{"location":"cpp/0901-1000/0981-0990/#990-satisfiability-of-equality-equations-starstar","text":"","title":"990. Satisfiability of Equality Equations $\\star\\star$"},{"location":"cpp/0901-1000/0991-1000/","text":"991. Broken Calculator $\\star\\star$ class Solution { public : int brokenCalc ( int X , int Y ) { int ops = 0 ; while ( X < Y ) { if ( Y % 2 == 0 ) Y /= 2 ; else Y += 1 ; ++ ops ; } return ops + X - Y ; } }; 992. Subarrays with K Different Integers $\\star\\star\\star$ class Solution { public : int subarraysWithKDistinct ( vector < int >& A , int K ) { return subarrayWithAtMostKDistinct ( A , K ) - subarrayWithAtMostKDistinct ( A , K - 1 ); } private : int subarrayWithAtMostKDistinct ( vector < int >& A , int K ) { int ans = 0 ; vector < int > count ( A . size () + 1 ); for ( int l = 0 , r = 0 ; r < A . size (); ++ r ) { if ( ++ count [ A [ r ]] == 1 ) -- K ; while ( K < 0 ) if ( -- count [ A [ l ++ ]] == 0 ) ++ K ; ans += r - l + 1 ; } return ans ; } }; 993. Cousins in Binary Tree $\\star$ 994. Rotting Oranges $\\star\\star$ 995. Minimum Number of K Consecutive Bit Flips $\\star\\star\\star$ class Solution { public : int minKBitFlips ( vector < int >& A , int K ) { int ans = 0 ; int flippedTime = 0 ; for ( int r = 0 ; r < A . size (); ++ r ) { if ( r >= K && A [ r - K ] == 2 ) -- flippedTime ; if ( flippedTime % 2 == A [ r ]) { if ( r + K > A . size ()) return - 1 ; ++ ans ; ++ flippedTime ; A [ r ] = 2 ; } } return ans ; } }; 996. Number of Squareful Arrays $\\star\\star\\star$ class Solution { public : int numSquarefulPerms ( vector < int >& A ) { int ans = 0 ; vector < int > path ; vector < bool > used ( A . size (), false ); sort ( begin ( A ), end ( A )); dfs ( A , used , path , ans ); return ans ; } private : void dfs ( vector < int >& A , vector < bool >& used , vector < int >& path , int & ans ) { if ( path . size () > 1 && ! isSquare ( path . back () + path [ path . size () - 2 ])) return ; if ( path . size () == A . size ()) { ++ ans ; return ; } for ( int i = 0 ; i < A . size (); ++ i ) { if ( used [ i ]) continue ; if ( i > 0 && A [ i ] == A [ i - 1 ] && ! used [ i - 1 ]) continue ; used [ i ] = true ; path . push_back ( A [ i ]); dfs ( A , used , path , ans ); path . pop_back (); used [ i ] = false ; } } bool isSquare ( int num ) { int root = sqrt ( num ); return root * root == num ; } }; 997. Find the Town Judge $\\star$ class Solution { public : int findJudge ( int N , vector < vector < int >>& trust ) { vector < int > count ( N + 1 ); for ( vector < int >& t : trust ) { -- count [ t [ 0 ]]; ++ count [ t [ 1 ]]; } for ( int i = 1 ; i < N + 1 ; ++ i ) if ( count [ i ] == N - 1 ) return i ; return - 1 ; } }; 998. Maximum Binary Tree II $\\star\\star$ 999. Available Captures for Rook $\\star$ class Solution { public : int numRookCaptures ( vector < vector < char >>& board ) { int ans = 0 ; int i0 = 0 ; int j0 = 0 ; for ( int i = 0 ; i < 8 ; ++ i ) for ( int j = 0 ; j < 8 ; ++ j ) if ( board [ i ][ j ] == 'R' ) { i0 = i ; j0 = j ; } for ( auto d : vector < vector < int >> ({{ 1 , 0 }, { 0 , 1 }, { - 1 , 0 }, { 0 , - 1 }})) for ( int i = i0 + d [ 0 ], j = j0 + d [ 1 ]; 0 <= i && i < 8 && 0 <= j && j < 8 ; i += d [ 0 ], j += d [ 1 ]) { if ( board [ i ][ j ] == 'p' ) ++ ans ; if ( board [ i ][ j ] != '.' ) break ; } return ans ; } }; 1000. Minimum Cost to Merge Stones $\\star\\star\\star$","title":"0991-1000"},{"location":"cpp/0901-1000/0991-1000/#991-broken-calculator-starstar","text":"class Solution { public : int brokenCalc ( int X , int Y ) { int ops = 0 ; while ( X < Y ) { if ( Y % 2 == 0 ) Y /= 2 ; else Y += 1 ; ++ ops ; } return ops + X - Y ; } };","title":"991. Broken Calculator $\\star\\star$"},{"location":"cpp/0901-1000/0991-1000/#992-subarrays-with-k-different-integers-starstarstar","text":"class Solution { public : int subarraysWithKDistinct ( vector < int >& A , int K ) { return subarrayWithAtMostKDistinct ( A , K ) - subarrayWithAtMostKDistinct ( A , K - 1 ); } private : int subarrayWithAtMostKDistinct ( vector < int >& A , int K ) { int ans = 0 ; vector < int > count ( A . size () + 1 ); for ( int l = 0 , r = 0 ; r < A . size (); ++ r ) { if ( ++ count [ A [ r ]] == 1 ) -- K ; while ( K < 0 ) if ( -- count [ A [ l ++ ]] == 0 ) ++ K ; ans += r - l + 1 ; } return ans ; } };","title":"992. Subarrays with K Different Integers $\\star\\star\\star$"},{"location":"cpp/0901-1000/0991-1000/#993-cousins-in-binary-tree-star","text":"","title":"993. Cousins in Binary Tree $\\star$"},{"location":"cpp/0901-1000/0991-1000/#994-rotting-oranges-starstar","text":"","title":"994. Rotting Oranges $\\star\\star$"},{"location":"cpp/0901-1000/0991-1000/#995-minimum-number-of-k-consecutive-bit-flips-starstarstar","text":"class Solution { public : int minKBitFlips ( vector < int >& A , int K ) { int ans = 0 ; int flippedTime = 0 ; for ( int r = 0 ; r < A . size (); ++ r ) { if ( r >= K && A [ r - K ] == 2 ) -- flippedTime ; if ( flippedTime % 2 == A [ r ]) { if ( r + K > A . size ()) return - 1 ; ++ ans ; ++ flippedTime ; A [ r ] = 2 ; } } return ans ; } };","title":"995. Minimum Number of K Consecutive Bit Flips $\\star\\star\\star$"},{"location":"cpp/0901-1000/0991-1000/#996-number-of-squareful-arrays-starstarstar","text":"class Solution { public : int numSquarefulPerms ( vector < int >& A ) { int ans = 0 ; vector < int > path ; vector < bool > used ( A . size (), false ); sort ( begin ( A ), end ( A )); dfs ( A , used , path , ans ); return ans ; } private : void dfs ( vector < int >& A , vector < bool >& used , vector < int >& path , int & ans ) { if ( path . size () > 1 && ! isSquare ( path . back () + path [ path . size () - 2 ])) return ; if ( path . size () == A . size ()) { ++ ans ; return ; } for ( int i = 0 ; i < A . size (); ++ i ) { if ( used [ i ]) continue ; if ( i > 0 && A [ i ] == A [ i - 1 ] && ! used [ i - 1 ]) continue ; used [ i ] = true ; path . push_back ( A [ i ]); dfs ( A , used , path , ans ); path . pop_back (); used [ i ] = false ; } } bool isSquare ( int num ) { int root = sqrt ( num ); return root * root == num ; } };","title":"996. Number of Squareful Arrays $\\star\\star\\star$"},{"location":"cpp/0901-1000/0991-1000/#997-find-the-town-judge-star","text":"class Solution { public : int findJudge ( int N , vector < vector < int >>& trust ) { vector < int > count ( N + 1 ); for ( vector < int >& t : trust ) { -- count [ t [ 0 ]]; ++ count [ t [ 1 ]]; } for ( int i = 1 ; i < N + 1 ; ++ i ) if ( count [ i ] == N - 1 ) return i ; return - 1 ; } };","title":"997. Find the Town Judge $\\star$"},{"location":"cpp/0901-1000/0991-1000/#998-maximum-binary-tree-ii-starstar","text":"","title":"998. Maximum Binary Tree II $\\star\\star$"},{"location":"cpp/0901-1000/0991-1000/#999-available-captures-for-rook-star","text":"class Solution { public : int numRookCaptures ( vector < vector < char >>& board ) { int ans = 0 ; int i0 = 0 ; int j0 = 0 ; for ( int i = 0 ; i < 8 ; ++ i ) for ( int j = 0 ; j < 8 ; ++ j ) if ( board [ i ][ j ] == 'R' ) { i0 = i ; j0 = j ; } for ( auto d : vector < vector < int >> ({{ 1 , 0 }, { 0 , 1 }, { - 1 , 0 }, { 0 , - 1 }})) for ( int i = i0 + d [ 0 ], j = j0 + d [ 1 ]; 0 <= i && i < 8 && 0 <= j && j < 8 ; i += d [ 0 ], j += d [ 1 ]) { if ( board [ i ][ j ] == 'p' ) ++ ans ; if ( board [ i ][ j ] != '.' ) break ; } return ans ; } };","title":"999. Available Captures for Rook $\\star$"},{"location":"cpp/0901-1000/0991-1000/#1000-minimum-cost-to-merge-stones-starstarstar","text":"","title":"1000. Minimum Cost to Merge Stones $\\star\\star\\star$"},{"location":"cpp/1001-1100/1001-1010/","text":"1001. Grid Illumination $\\star\\star\\star$ class Solution { public : vector < int > gridIllumination ( int N , vector < vector < int >>& lamps , vector < vector < int >>& queries ) { vector < int > ans ; unordered_map < int , int > rows ; unordered_map < int , int > cols ; unordered_map < int , int > diag1 ; unordered_map < int , int > diag2 ; unordered_set < pair < int , int > , pairHash > lampsSet ; for ( vector < int >& lamp : lamps ) { int i = lamp [ 0 ]; int j = lamp [ 1 ]; if ( lampsSet . insert ({ i , j }). second ) { ++ rows [ i ]; ++ cols [ j ]; ++ diag1 [ i + j ]; ++ diag2 [ i - j ]; } } for ( vector < int >& query : queries ) { int i = query [ 0 ]; int j = query [ 1 ]; if ( rows [ i ] || cols [ j ] || diag1 [ i + j ] || diag2 [ i - j ]) { ans . push_back ( 1 ); for ( int y = max ( 0 , i - 1 ); y < min ( N , i + 2 ); ++ y ) for ( int x = max ( 0 , j - 1 ); x < min ( N , j + 2 ); ++ x ) if ( lampsSet . erase ({ y , x })) { -- rows [ y ]; -- cols [ x ]; -- diag1 [ y + x ]; -- diag2 [ y - x ]; } } else ans . push_back ( 0 ); } return ans ; } private : struct pairHash { size_t operator ()( const pair < int , int >& p ) const { return p . first ^ p . second ; } }; }; 1002. Find Common Characters $\\star$ class Solution { public : vector < string > commonChars ( vector < string >& A ) { vector < string > ans ; vector < int > commonCount ( 26 , INT_MAX ); for ( const string & a : A ) { vector < int > count ( 26 ); for ( char c : a ) ++ count [ c - 'a' ]; for ( int i = 0 ; i < 26 ; ++ i ) commonCount [ i ] = min ( commonCount [ i ], count [ i ]); } for ( char c = 'a' ; c <= 'z' ; ++ c ) for ( int i = 0 ; i < commonCount [ c - 'a' ]; ++ i ) ans . push_back ( string ( 1 , c )); return ans ; } }; 1003. Check If Word Is Valid After Substitutions $\\star\\star$ class Solution { public : bool isValid ( string S ) { stack < char > stack ; for ( char c : S ) if ( c == 'c' ) { if ( stack . size () < 2 ) return false ; if ( stack . top () != 'b' ) return false ; stack . pop (); if ( stack . top () != 'a' ) return false ; stack . pop (); } else stack . push ( c ); return stack . empty (); } }; 1004. Max Consecutive Ones III $\\star\\star$ class Solution { public : int longestOnes ( vector < int >& A , int K ) { int ans = 0 ; for ( int l = 0 , r = 0 ; r < A . size (); ++ r ) { if ( A [ r ] == 0 ) -- K ; while ( K < 0 ) if ( A [ l ++ ] == 0 ) ++ K ; ans = max ( ans , r - l + 1 ); } return ans ; } }; 1005. Maximize Sum Of Array After K Negations $\\star$ class Solution { public : int largestSumAfterKNegations ( vector < int >& A , int K ) { sort ( begin ( A ), end ( A )); for ( int i = 0 ; i < A . size (); ++ i ) { if ( A [ i ] > 0 || K == 0 ) break ; A [ i ] = - A [ i ]; -- K ; } return accumulate ( begin ( A ), end ( A ), 0 ) - ( K % 2 ) * * min_element ( begin ( A ), end ( A )) * 2 ; } }; 1006. Clumsy Factorial $\\star\\star$ class Solution { public : int clumsy ( int N ) { if ( N == 1 ) return 1 ; if ( N == 2 ) return 2 ; if ( N == 3 ) return 6 ; if ( N == 4 ) return 7 ; if ( N % 4 == 1 ) return N + 2 ; if ( N % 4 == 2 ) return N + 2 ; if ( N % 4 == 3 ) return N - 1 ; return N + 1 ; } }; 1007. Minimum Domino Rotations For Equal Row $\\star\\star$ class Solution { public : int minDominoRotations ( vector < int >& A , vector < int >& B ) { const int n = A . size (); vector < int > countA ( 7 ); vector < int > countB ( 7 ); vector < int > countBoth ( 7 ); for ( int i = 0 ; i < n ; ++ i ) { ++ countA [ A [ i ]]; ++ countB [ B [ i ]]; if ( A [ i ] == B [ i ]) ++ countBoth [ A [ i ]]; } for ( int i = 1 ; i <= 6 ; ++ i ) if ( countA [ i ] + countB [ i ] - countBoth [ i ] == n ) return n - max ( countA [ i ], countB [ i ]); return - 1 ; } }; 1008. Construct Binary Search Tree from Preorder Traversal $\\star\\star$ 1009. Complement of Base 10 Integer $\\star$ class Solution { public : int bitwiseComplement ( int N ) { int mask = 1 ; while ( mask < N ) mask = ( mask << 1 ) + 1 ; return mask ^ N ; } }; 1010. Pairs of Songs With Total Durations Divisible by 60 $\\star$ class Solution { public : int numPairsDivisibleBy60 ( vector < int >& time ) { int ans = 0 ; vector < int > count ( 60 ); for ( int t : time ) { t %= 60 ; ans += count [( 60 - t ) % 60 ]; ++ count [ t ]; } return ans ; } };","title":"1001-1010"},{"location":"cpp/1001-1100/1001-1010/#1001-grid-illumination-starstarstar","text":"class Solution { public : vector < int > gridIllumination ( int N , vector < vector < int >>& lamps , vector < vector < int >>& queries ) { vector < int > ans ; unordered_map < int , int > rows ; unordered_map < int , int > cols ; unordered_map < int , int > diag1 ; unordered_map < int , int > diag2 ; unordered_set < pair < int , int > , pairHash > lampsSet ; for ( vector < int >& lamp : lamps ) { int i = lamp [ 0 ]; int j = lamp [ 1 ]; if ( lampsSet . insert ({ i , j }). second ) { ++ rows [ i ]; ++ cols [ j ]; ++ diag1 [ i + j ]; ++ diag2 [ i - j ]; } } for ( vector < int >& query : queries ) { int i = query [ 0 ]; int j = query [ 1 ]; if ( rows [ i ] || cols [ j ] || diag1 [ i + j ] || diag2 [ i - j ]) { ans . push_back ( 1 ); for ( int y = max ( 0 , i - 1 ); y < min ( N , i + 2 ); ++ y ) for ( int x = max ( 0 , j - 1 ); x < min ( N , j + 2 ); ++ x ) if ( lampsSet . erase ({ y , x })) { -- rows [ y ]; -- cols [ x ]; -- diag1 [ y + x ]; -- diag2 [ y - x ]; } } else ans . push_back ( 0 ); } return ans ; } private : struct pairHash { size_t operator ()( const pair < int , int >& p ) const { return p . first ^ p . second ; } }; };","title":"1001. Grid Illumination $\\star\\star\\star$"},{"location":"cpp/1001-1100/1001-1010/#1002-find-common-characters-star","text":"class Solution { public : vector < string > commonChars ( vector < string >& A ) { vector < string > ans ; vector < int > commonCount ( 26 , INT_MAX ); for ( const string & a : A ) { vector < int > count ( 26 ); for ( char c : a ) ++ count [ c - 'a' ]; for ( int i = 0 ; i < 26 ; ++ i ) commonCount [ i ] = min ( commonCount [ i ], count [ i ]); } for ( char c = 'a' ; c <= 'z' ; ++ c ) for ( int i = 0 ; i < commonCount [ c - 'a' ]; ++ i ) ans . push_back ( string ( 1 , c )); return ans ; } };","title":"1002. Find Common Characters $\\star$"},{"location":"cpp/1001-1100/1001-1010/#1003-check-if-word-is-valid-after-substitutions-starstar","text":"class Solution { public : bool isValid ( string S ) { stack < char > stack ; for ( char c : S ) if ( c == 'c' ) { if ( stack . size () < 2 ) return false ; if ( stack . top () != 'b' ) return false ; stack . pop (); if ( stack . top () != 'a' ) return false ; stack . pop (); } else stack . push ( c ); return stack . empty (); } };","title":"1003. Check If Word Is Valid After Substitutions $\\star\\star$"},{"location":"cpp/1001-1100/1001-1010/#1004-max-consecutive-ones-iii-starstar","text":"class Solution { public : int longestOnes ( vector < int >& A , int K ) { int ans = 0 ; for ( int l = 0 , r = 0 ; r < A . size (); ++ r ) { if ( A [ r ] == 0 ) -- K ; while ( K < 0 ) if ( A [ l ++ ] == 0 ) ++ K ; ans = max ( ans , r - l + 1 ); } return ans ; } };","title":"1004. Max Consecutive Ones III $\\star\\star$"},{"location":"cpp/1001-1100/1001-1010/#1005-maximize-sum-of-array-after-k-negations-star","text":"class Solution { public : int largestSumAfterKNegations ( vector < int >& A , int K ) { sort ( begin ( A ), end ( A )); for ( int i = 0 ; i < A . size (); ++ i ) { if ( A [ i ] > 0 || K == 0 ) break ; A [ i ] = - A [ i ]; -- K ; } return accumulate ( begin ( A ), end ( A ), 0 ) - ( K % 2 ) * * min_element ( begin ( A ), end ( A )) * 2 ; } };","title":"1005. Maximize Sum Of Array After K Negations $\\star$"},{"location":"cpp/1001-1100/1001-1010/#1006-clumsy-factorial-starstar","text":"class Solution { public : int clumsy ( int N ) { if ( N == 1 ) return 1 ; if ( N == 2 ) return 2 ; if ( N == 3 ) return 6 ; if ( N == 4 ) return 7 ; if ( N % 4 == 1 ) return N + 2 ; if ( N % 4 == 2 ) return N + 2 ; if ( N % 4 == 3 ) return N - 1 ; return N + 1 ; } };","title":"1006. Clumsy Factorial $\\star\\star$"},{"location":"cpp/1001-1100/1001-1010/#1007-minimum-domino-rotations-for-equal-row-starstar","text":"class Solution { public : int minDominoRotations ( vector < int >& A , vector < int >& B ) { const int n = A . size (); vector < int > countA ( 7 ); vector < int > countB ( 7 ); vector < int > countBoth ( 7 ); for ( int i = 0 ; i < n ; ++ i ) { ++ countA [ A [ i ]]; ++ countB [ B [ i ]]; if ( A [ i ] == B [ i ]) ++ countBoth [ A [ i ]]; } for ( int i = 1 ; i <= 6 ; ++ i ) if ( countA [ i ] + countB [ i ] - countBoth [ i ] == n ) return n - max ( countA [ i ], countB [ i ]); return - 1 ; } };","title":"1007. Minimum Domino Rotations For Equal Row $\\star\\star$"},{"location":"cpp/1001-1100/1001-1010/#1008-construct-binary-search-tree-from-preorder-traversal-starstar","text":"","title":"1008. Construct Binary Search Tree from Preorder Traversal $\\star\\star$"},{"location":"cpp/1001-1100/1001-1010/#1009-complement-of-base-10-integer-star","text":"class Solution { public : int bitwiseComplement ( int N ) { int mask = 1 ; while ( mask < N ) mask = ( mask << 1 ) + 1 ; return mask ^ N ; } };","title":"1009. Complement of Base 10 Integer $\\star$"},{"location":"cpp/1001-1100/1001-1010/#1010-pairs-of-songs-with-total-durations-divisible-by-60-star","text":"class Solution { public : int numPairsDivisibleBy60 ( vector < int >& time ) { int ans = 0 ; vector < int > count ( 60 ); for ( int t : time ) { t %= 60 ; ans += count [( 60 - t ) % 60 ]; ++ count [ t ]; } return ans ; } };","title":"1010. Pairs of Songs With Total Durations Divisible by 60 $\\star$"},{"location":"cpp/1001-1100/1011-1020/","text":"1011. Capacity To Ship Packages Within D Days $\\star\\star$ class Solution { public : int shipWithinDays ( vector < int >& weights , int D ) { int l = * max_element ( begin ( weights ), end ( weights )); int r = accumulate ( begin ( weights ), end ( weights ), 0 ); while ( l < r ) { int m = l + ( r - l ) / 2 ; int day = 1 ; int capacity = 0 ; for ( int weight : weights ) { if ( capacity + weight > m ) { ++ day ; capacity = weight ; } else capacity += weight ; } if ( day <= D ) r = m ; else l = m + 1 ; } return l ; } }; 1012. Numbers With Repeated Digits $\\star\\star\\star$ class Solution { public : int numDupDigitsAtMostN ( int N ) { dfs ( N , 0 , 0 ); return N - uniqueDigits + 1 ; } private : int uniqueDigits = 0 ; void dfs ( int N , int mask , long path ) { if ( path > N ) return ; ++ uniqueDigits ; for ( int digit = 0 ; digit < 10 ; ++ digit ) { if ( mask == 0 && digit == 0 ) continue ; if ( mask & ( 1 << digit )) continue ; dfs ( N , mask | ( 1 << digit ), path * 10 + digit ); } } }; 1013. Partition Array Into Three Parts With Equal Sum $\\star$ class Solution { public : bool canThreePartsEqualSum ( vector < int >& A ) { int sum = accumulate ( begin ( A ), end ( A ), 0 ); int prefixSum = 0 ; int parts = 1 ; for ( int a : A ) { prefixSum += a ; if ( prefixSum == sum * parts / 3 ) ++ parts ; } return sum % 3 == 0 && parts >= 3 ; } }; 1014. Best Sightseeing Pair $\\star\\star$ class Solution { public : int maxScoreSightseeingPair ( vector < int >& A ) { int ans = 0 ; int bestPrev = 0 ; for ( int a : A ) { ans = max ( ans , a + bestPrev ); bestPrev = max ( bestPrev , a ) - 1 ; } return ans ; } }; 1015. Smallest Integer Divisible by K $\\star\\star$ class Solution { public : int smallestRepunitDivByK ( int K ) { if ( K % 10 != 1 && K % 10 != 3 && K % 10 != 7 && K % 10 != 9 ) return - 1 ; unordered_set < int > seen ; int N = 0 ; for ( int length = 1 ; length <= K ; ++ length ) { N = ( N * 10 + 1 ) % K ; if ( N == 0 ) return length ; if ( seen . count ( N )) return - 1 ; seen . insert ( N ); } return - 1 ; } }; 1016. Binary String With Substrings Representing 1 To N $\\star\\star$ class Solution { public : bool queryString ( string S , int N ) { if ( N > 1511 ) return false ; for ( int i = N ; i > N / 2 ; -- i ) { string binary = bitset < 32 > ( i ). to_string (); binary = binary . substr ( binary . find ( \"1\" )); if ( S . find ( binary ) == string :: npos ) return false ; } return true ; } }; 1017. Convert to Base -2 $\\star\\star$ class Solution { public : string baseNeg2 ( int N ) { string ans ; while ( N ) { ans = to_string ( N & 1 ) + ans ; N = - ( N >> 1 ); } return ans == \"\" ? \"0\" : ans ; } }; 1018. Binary Prefix Divisible By 5 $\\star$ class Solution { public : vector < bool > prefixesDivBy5 ( vector < int >& A ) { vector < bool > ans ; int num = 0 ; for ( int a : A ) { num = ( num * 2 + a ) % 5 ; ans . push_back ( num % 5 == 0 ); } return ans ; } }; 1019. Next Greater Node In Linked List $\\star\\star$ class Solution { public : vector < int > nextLargerNodes ( ListNode * head ) { vector < int > ans ; stack < int > stack ; for (; head ; head = head -> next ) { while ( ! stack . empty () && head -> val > ans [ stack . top ()]) { int index = stack . top (); stack . pop (); ans [ index ] = head -> val ; } stack . push ( ans . size ()); ans . push_back ( head -> val ); } for (; ! stack . empty (); stack . pop ()) ans [ stack . top ()] = 0 ; return ans ; } }; 1020. Number of Enclaves $\\star\\star$","title":"1011-1020"},{"location":"cpp/1001-1100/1011-1020/#1011-capacity-to-ship-packages-within-d-days-starstar","text":"class Solution { public : int shipWithinDays ( vector < int >& weights , int D ) { int l = * max_element ( begin ( weights ), end ( weights )); int r = accumulate ( begin ( weights ), end ( weights ), 0 ); while ( l < r ) { int m = l + ( r - l ) / 2 ; int day = 1 ; int capacity = 0 ; for ( int weight : weights ) { if ( capacity + weight > m ) { ++ day ; capacity = weight ; } else capacity += weight ; } if ( day <= D ) r = m ; else l = m + 1 ; } return l ; } };","title":"1011. Capacity To Ship Packages Within D Days $\\star\\star$"},{"location":"cpp/1001-1100/1011-1020/#1012-numbers-with-repeated-digits-starstarstar","text":"class Solution { public : int numDupDigitsAtMostN ( int N ) { dfs ( N , 0 , 0 ); return N - uniqueDigits + 1 ; } private : int uniqueDigits = 0 ; void dfs ( int N , int mask , long path ) { if ( path > N ) return ; ++ uniqueDigits ; for ( int digit = 0 ; digit < 10 ; ++ digit ) { if ( mask == 0 && digit == 0 ) continue ; if ( mask & ( 1 << digit )) continue ; dfs ( N , mask | ( 1 << digit ), path * 10 + digit ); } } };","title":"1012. Numbers With Repeated Digits $\\star\\star\\star$"},{"location":"cpp/1001-1100/1011-1020/#1013-partition-array-into-three-parts-with-equal-sum-star","text":"class Solution { public : bool canThreePartsEqualSum ( vector < int >& A ) { int sum = accumulate ( begin ( A ), end ( A ), 0 ); int prefixSum = 0 ; int parts = 1 ; for ( int a : A ) { prefixSum += a ; if ( prefixSum == sum * parts / 3 ) ++ parts ; } return sum % 3 == 0 && parts >= 3 ; } };","title":"1013. Partition Array Into Three Parts With Equal Sum $\\star$"},{"location":"cpp/1001-1100/1011-1020/#1014-best-sightseeing-pair-starstar","text":"class Solution { public : int maxScoreSightseeingPair ( vector < int >& A ) { int ans = 0 ; int bestPrev = 0 ; for ( int a : A ) { ans = max ( ans , a + bestPrev ); bestPrev = max ( bestPrev , a ) - 1 ; } return ans ; } };","title":"1014. Best Sightseeing Pair $\\star\\star$"},{"location":"cpp/1001-1100/1011-1020/#1015-smallest-integer-divisible-by-k-starstar","text":"class Solution { public : int smallestRepunitDivByK ( int K ) { if ( K % 10 != 1 && K % 10 != 3 && K % 10 != 7 && K % 10 != 9 ) return - 1 ; unordered_set < int > seen ; int N = 0 ; for ( int length = 1 ; length <= K ; ++ length ) { N = ( N * 10 + 1 ) % K ; if ( N == 0 ) return length ; if ( seen . count ( N )) return - 1 ; seen . insert ( N ); } return - 1 ; } };","title":"1015. Smallest Integer Divisible by K $\\star\\star$"},{"location":"cpp/1001-1100/1011-1020/#1016-binary-string-with-substrings-representing-1-to-n-starstar","text":"class Solution { public : bool queryString ( string S , int N ) { if ( N > 1511 ) return false ; for ( int i = N ; i > N / 2 ; -- i ) { string binary = bitset < 32 > ( i ). to_string (); binary = binary . substr ( binary . find ( \"1\" )); if ( S . find ( binary ) == string :: npos ) return false ; } return true ; } };","title":"1016. Binary String With Substrings Representing 1 To N $\\star\\star$"},{"location":"cpp/1001-1100/1011-1020/#1017-convert-to-base-2-starstar","text":"class Solution { public : string baseNeg2 ( int N ) { string ans ; while ( N ) { ans = to_string ( N & 1 ) + ans ; N = - ( N >> 1 ); } return ans == \"\" ? \"0\" : ans ; } };","title":"1017. Convert to Base -2 $\\star\\star$"},{"location":"cpp/1001-1100/1011-1020/#1018-binary-prefix-divisible-by-5-star","text":"class Solution { public : vector < bool > prefixesDivBy5 ( vector < int >& A ) { vector < bool > ans ; int num = 0 ; for ( int a : A ) { num = ( num * 2 + a ) % 5 ; ans . push_back ( num % 5 == 0 ); } return ans ; } };","title":"1018. Binary Prefix Divisible By 5 $\\star$"},{"location":"cpp/1001-1100/1011-1020/#1019-next-greater-node-in-linked-list-starstar","text":"class Solution { public : vector < int > nextLargerNodes ( ListNode * head ) { vector < int > ans ; stack < int > stack ; for (; head ; head = head -> next ) { while ( ! stack . empty () && head -> val > ans [ stack . top ()]) { int index = stack . top (); stack . pop (); ans [ index ] = head -> val ; } stack . push ( ans . size ()); ans . push_back ( head -> val ); } for (; ! stack . empty (); stack . pop ()) ans [ stack . top ()] = 0 ; return ans ; } };","title":"1019. Next Greater Node In Linked List $\\star\\star$"},{"location":"cpp/1001-1100/1011-1020/#1020-number-of-enclaves-starstar","text":"","title":"1020. Number of Enclaves $\\star\\star$"},{"location":"cpp/1001-1100/1021-1030/","text":"1021. Remove Outermost Parentheses $\\star$ 1022. Sum of Root To Leaf Binary Numbers $\\star$ 1023. Camelcase Matching $\\star\\star$ class Solution { public : vector < bool > camelMatch ( vector < string >& queries , string pattern ) { vector < bool > ans ; for ( const string & query : queries ) ans . push_back ( isMatch ( query , pattern )); return ans ; } private : bool isMatch ( const string & query , const string & pattern ) { int j = 0 ; for ( int i = 0 ; i < query . length (); ++ i ) if ( j < pattern . length () && query [ i ] == pattern [ j ]) ++ j ; else if ( isupper ( query [ i ])) return false ; return j == pattern . length (); } }; 1024. Video Stitching $\\star\\star$ class Solution { public : int videoStitching ( vector < vector < int >>& clips , int T ) { int ans = 0 ; int end = 0 ; int farthest = 0 ; sort ( begin ( clips ), end ( clips )); int i = 0 ; while ( farthest < T ) { while ( i < clips . size () && clips [ i ][ 0 ] <= end ) farthest = max ( farthest , clips [ i ++ ][ 1 ]); if ( end == farthest ) return - 1 ; ++ ans ; end = farthest ; } return ans ; } }; 1025. Divisor Game $\\star$ class Solution { public : bool divisorGame ( int N ) { return N % 2 == 0 ; } }; 1026. Maximum Difference Between Node and Ancestor $\\star\\star$ 1027. Longest Arithmetic Sequence $\\star\\star$ 1028. Recover a Tree From Preorder Traversal $\\star\\star\\star$ 1029. Two City Scheduling $\\star$ 1030. Matrix Cells in Distance Order $\\star$","title":"1021-1030"},{"location":"cpp/1001-1100/1021-1030/#1021-remove-outermost-parentheses-star","text":"","title":"1021. Remove Outermost Parentheses $\\star$"},{"location":"cpp/1001-1100/1021-1030/#1022-sum-of-root-to-leaf-binary-numbers-star","text":"","title":"1022. Sum of Root To Leaf Binary Numbers $\\star$"},{"location":"cpp/1001-1100/1021-1030/#1023-camelcase-matching-starstar","text":"class Solution { public : vector < bool > camelMatch ( vector < string >& queries , string pattern ) { vector < bool > ans ; for ( const string & query : queries ) ans . push_back ( isMatch ( query , pattern )); return ans ; } private : bool isMatch ( const string & query , const string & pattern ) { int j = 0 ; for ( int i = 0 ; i < query . length (); ++ i ) if ( j < pattern . length () && query [ i ] == pattern [ j ]) ++ j ; else if ( isupper ( query [ i ])) return false ; return j == pattern . length (); } };","title":"1023. Camelcase Matching $\\star\\star$"},{"location":"cpp/1001-1100/1021-1030/#1024-video-stitching-starstar","text":"class Solution { public : int videoStitching ( vector < vector < int >>& clips , int T ) { int ans = 0 ; int end = 0 ; int farthest = 0 ; sort ( begin ( clips ), end ( clips )); int i = 0 ; while ( farthest < T ) { while ( i < clips . size () && clips [ i ][ 0 ] <= end ) farthest = max ( farthest , clips [ i ++ ][ 1 ]); if ( end == farthest ) return - 1 ; ++ ans ; end = farthest ; } return ans ; } };","title":"1024. Video Stitching $\\star\\star$"},{"location":"cpp/1001-1100/1021-1030/#1025-divisor-game-star","text":"class Solution { public : bool divisorGame ( int N ) { return N % 2 == 0 ; } };","title":"1025. Divisor Game $\\star$"},{"location":"cpp/1001-1100/1021-1030/#1026-maximum-difference-between-node-and-ancestor-starstar","text":"","title":"1026. Maximum Difference Between Node and Ancestor $\\star\\star$"},{"location":"cpp/1001-1100/1021-1030/#1027-longest-arithmetic-sequence-starstar","text":"","title":"1027. Longest Arithmetic Sequence $\\star\\star$"},{"location":"cpp/1001-1100/1021-1030/#1028-recover-a-tree-from-preorder-traversal-starstarstar","text":"","title":"1028. Recover a Tree From Preorder Traversal $\\star\\star\\star$"},{"location":"cpp/1001-1100/1021-1030/#1029-two-city-scheduling-star","text":"","title":"1029. Two City Scheduling $\\star$"},{"location":"cpp/1001-1100/1021-1030/#1030-matrix-cells-in-distance-order-star","text":"","title":"1030. Matrix Cells in Distance Order $\\star$"},{"location":"cpp/1001-1100/1031-1040/","text":"1031. Maximum Sum of Two Non-Overlapping Subarrays $\\star\\star$ class Solution { public : int maxSumTwoNoOverlap ( vector < int >& A , int L , int M ) { return max ( helper ( A , L , M ), helper ( A , M , L )); } private : int helper ( vector < int >& A , int l , int r ) { const int n = A . size (); vector < int > left ( n ); int sum = 0 ; for ( int i = 0 ; i < n ; ++ i ) { sum += A [ i ]; if ( i >= l ) sum -= A [ i - l ]; if ( i >= l - 1 ) left [ i ] = i > 0 ? max ( left [ i - 1 ], sum ) : sum ; } vector < int > right ( n ); sum = 0 ; for ( int i = n - 1 ; i >= 0 ; -- i ) { sum += A [ i ]; if ( i <= n - r - 1 ) sum -= A [ i + r ]; if ( i <= n - r ) right [ i ] = i < n - 1 ? max ( right [ i + 1 ], sum ) : sum ; } int ans = 0 ; for ( int i = 0 ; i < n - 1 ; ++ i ) ans = max ( ans , left [ i ] + right [ i + 1 ]); return ans ; } }; 1032. Stream of Characters $\\star\\star\\star$ 1033. Moving Stones Until Consecutive $\\star$ class Solution { public : vector < int > numMovesStones ( int a , int b , int c ) { vector < int > nums = { a , b , c }; sort ( begin ( nums ), end ( nums )); if ( nums [ 2 ] - nums [ 0 ] == 2 ) return { 0 , 0 }; return { min ( nums [ 1 ] - nums [ 0 ], nums [ 2 ] - nums [ 1 ]) <= 2 ? 1 : 2 , nums [ 2 ] - nums [ 0 ] - 2 }; } }; 1034. Coloring A Border $\\star\\star$ class Solution { public : vector < vector < int >> colorBorder ( vector < vector < int >>& grid , int r0 , int c0 , int color ) { dfs ( grid , r0 , c0 , grid [ r0 ][ c0 ]); for ( int i = 0 ; i < grid . size (); ++ i ) for ( int j = 0 ; j < grid [ 0 ]. size (); ++ j ) if ( grid [ i ][ j ] < 0 ) grid [ i ][ j ] = color ; return grid ; } private : void dfs ( vector < vector < int >>& grid , int i , int j , int originalColor ) { if ( i < 0 || i >= grid . size () || j < 0 || j >= grid [ 0 ]. size () || grid [ i ][ j ] != originalColor ) return ; grid [ i ][ j ] = - originalColor ; dfs ( grid , i + 1 , j , originalColor ); dfs ( grid , i - 1 , j , originalColor ); dfs ( grid , i , j + 1 , originalColor ); dfs ( grid , i , j - 1 , originalColor ); if ( i > 0 && i + 1 < grid . size () && j > 0 && j + 1 < grid [ 0 ]. size () && abs ( grid [ i + 1 ][ j ]) == originalColor && abs ( grid [ i - 1 ][ j ]) == originalColor && abs ( grid [ i ][ j + 1 ]) == originalColor && abs ( grid [ i ][ j - 1 ]) == originalColor ) grid [ i ][ j ] = originalColor ; } }; 1035. Uncrossed Lines $\\star\\star$ class Solution { public : int maxUncrossedLines ( vector < int >& A , vector < int >& B ) { const int m = A . size (); const int n = B . size (); vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 )); for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) dp [ i ][ j ] = A [ i - 1 ] == B [ j - 1 ] ? dp [ i - 1 ][ j - 1 ] + 1 : max ( dp [ i - 1 ][ j ], dp [ i ][ j - 1 ]); return dp [ m ][ n ]; } }; 1036. Escape a Large Maze $\\star\\star\\star$ class Solution { public : bool isEscapePossible ( vector < vector < int >>& blocked , vector < int >& source , vector < int >& target ) { unordered_set < long > blockedSet ; for ( vector < int >& b : blocked ) blockedSet . insert ( hash ( b [ 0 ], b [ 1 ])); unordered_set < long > visited1 ; unordered_set < long > visited2 ; return dfs ( blockedSet , source [ 0 ], source [ 1 ], hash ( target [ 0 ], target [ 1 ]), visited1 ) && dfs ( blockedSet , target [ 0 ], target [ 1 ], hash ( source [ 0 ], source [ 1 ]), visited2 ); } private : bool dfs ( unordered_set < long >& blockedSet , int i , int j , long target , unordered_set < long >& visited ) { if ( i < 0 || i >= 1e6 || j < 0 || j >= 1e6 || blockedSet . count ( hash ( i , j )) || visited . count ( hash ( i , j ))) return false ; visited . insert ( hash ( i , j )); if ( visited . size () > ( 1 + 199 ) * 199 / 2 || hash ( i , j ) == target ) return true ; return dfs ( blockedSet , i + 1 , j , target , visited ) || dfs ( blockedSet , i - 1 , j , target , visited ) || dfs ( blockedSet , i , j + 1 , target , visited ) || dfs ( blockedSet , i , j - 1 , target , visited ); } long hash ( int i , int j ) { return (( long ) i << 16 ) + j ; } }; 1037. Valid Boomerang $\\star$ class Solution { public : bool isBoomerang ( vector < vector < int >>& points ) { return ( points [ 1 ][ 0 ] - points [ 0 ][ 0 ]) * ( points [ 2 ][ 1 ] - points [ 1 ][ 1 ]) != ( points [ 1 ][ 1 ] - points [ 0 ][ 1 ]) * ( points [ 2 ][ 0 ] - points [ 1 ][ 0 ]); } }; 1038. Binary Search Tree to Greater Sum Tree $\\star\\star$ 1039. Minimum Score Triangulation of Polygon $\\star\\star$ 1040. Moving Stones Until Consecutive II $\\star\\star$ class Solution { public : vector < int > numMovesStonesII ( vector < int >& stones ) { const int n = stones . size (); int minMoves = n ; sort ( begin ( stones ), end ( stones )); for ( int l = 0 , r = 0 ; r < n ; ++ r ) { while ( stones [ r ] - stones [ l ] + 1 > n ) ++ l ; int alreadyStored = r - l + 1 ; if ( alreadyStored == n - 1 && stones [ r ] - stones [ l ] + 1 == n - 1 ) minMoves = min ( minMoves , 2 ); else minMoves = min ( minMoves , n - alreadyStored ); } return { minMoves , max ( stones [ n - 1 ] - stones [ 1 ] - n + 2 , stones [ n - 2 ] - stones [ 0 ] - n + 2 )}; } };","title":"1031-1040"},{"location":"cpp/1001-1100/1031-1040/#1031-maximum-sum-of-two-non-overlapping-subarrays-starstar","text":"class Solution { public : int maxSumTwoNoOverlap ( vector < int >& A , int L , int M ) { return max ( helper ( A , L , M ), helper ( A , M , L )); } private : int helper ( vector < int >& A , int l , int r ) { const int n = A . size (); vector < int > left ( n ); int sum = 0 ; for ( int i = 0 ; i < n ; ++ i ) { sum += A [ i ]; if ( i >= l ) sum -= A [ i - l ]; if ( i >= l - 1 ) left [ i ] = i > 0 ? max ( left [ i - 1 ], sum ) : sum ; } vector < int > right ( n ); sum = 0 ; for ( int i = n - 1 ; i >= 0 ; -- i ) { sum += A [ i ]; if ( i <= n - r - 1 ) sum -= A [ i + r ]; if ( i <= n - r ) right [ i ] = i < n - 1 ? max ( right [ i + 1 ], sum ) : sum ; } int ans = 0 ; for ( int i = 0 ; i < n - 1 ; ++ i ) ans = max ( ans , left [ i ] + right [ i + 1 ]); return ans ; } };","title":"1031. Maximum Sum of Two Non-Overlapping Subarrays $\\star\\star$"},{"location":"cpp/1001-1100/1031-1040/#1032-stream-of-characters-starstarstar","text":"","title":"1032. Stream of Characters $\\star\\star\\star$"},{"location":"cpp/1001-1100/1031-1040/#1033-moving-stones-until-consecutive-star","text":"class Solution { public : vector < int > numMovesStones ( int a , int b , int c ) { vector < int > nums = { a , b , c }; sort ( begin ( nums ), end ( nums )); if ( nums [ 2 ] - nums [ 0 ] == 2 ) return { 0 , 0 }; return { min ( nums [ 1 ] - nums [ 0 ], nums [ 2 ] - nums [ 1 ]) <= 2 ? 1 : 2 , nums [ 2 ] - nums [ 0 ] - 2 }; } };","title":"1033. Moving Stones Until Consecutive $\\star$"},{"location":"cpp/1001-1100/1031-1040/#1034-coloring-a-border-starstar","text":"class Solution { public : vector < vector < int >> colorBorder ( vector < vector < int >>& grid , int r0 , int c0 , int color ) { dfs ( grid , r0 , c0 , grid [ r0 ][ c0 ]); for ( int i = 0 ; i < grid . size (); ++ i ) for ( int j = 0 ; j < grid [ 0 ]. size (); ++ j ) if ( grid [ i ][ j ] < 0 ) grid [ i ][ j ] = color ; return grid ; } private : void dfs ( vector < vector < int >>& grid , int i , int j , int originalColor ) { if ( i < 0 || i >= grid . size () || j < 0 || j >= grid [ 0 ]. size () || grid [ i ][ j ] != originalColor ) return ; grid [ i ][ j ] = - originalColor ; dfs ( grid , i + 1 , j , originalColor ); dfs ( grid , i - 1 , j , originalColor ); dfs ( grid , i , j + 1 , originalColor ); dfs ( grid , i , j - 1 , originalColor ); if ( i > 0 && i + 1 < grid . size () && j > 0 && j + 1 < grid [ 0 ]. size () && abs ( grid [ i + 1 ][ j ]) == originalColor && abs ( grid [ i - 1 ][ j ]) == originalColor && abs ( grid [ i ][ j + 1 ]) == originalColor && abs ( grid [ i ][ j - 1 ]) == originalColor ) grid [ i ][ j ] = originalColor ; } };","title":"1034. Coloring A Border $\\star\\star$"},{"location":"cpp/1001-1100/1031-1040/#1035-uncrossed-lines-starstar","text":"class Solution { public : int maxUncrossedLines ( vector < int >& A , vector < int >& B ) { const int m = A . size (); const int n = B . size (); vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 )); for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) dp [ i ][ j ] = A [ i - 1 ] == B [ j - 1 ] ? dp [ i - 1 ][ j - 1 ] + 1 : max ( dp [ i - 1 ][ j ], dp [ i ][ j - 1 ]); return dp [ m ][ n ]; } };","title":"1035. Uncrossed Lines $\\star\\star$"},{"location":"cpp/1001-1100/1031-1040/#1036-escape-a-large-maze-starstarstar","text":"class Solution { public : bool isEscapePossible ( vector < vector < int >>& blocked , vector < int >& source , vector < int >& target ) { unordered_set < long > blockedSet ; for ( vector < int >& b : blocked ) blockedSet . insert ( hash ( b [ 0 ], b [ 1 ])); unordered_set < long > visited1 ; unordered_set < long > visited2 ; return dfs ( blockedSet , source [ 0 ], source [ 1 ], hash ( target [ 0 ], target [ 1 ]), visited1 ) && dfs ( blockedSet , target [ 0 ], target [ 1 ], hash ( source [ 0 ], source [ 1 ]), visited2 ); } private : bool dfs ( unordered_set < long >& blockedSet , int i , int j , long target , unordered_set < long >& visited ) { if ( i < 0 || i >= 1e6 || j < 0 || j >= 1e6 || blockedSet . count ( hash ( i , j )) || visited . count ( hash ( i , j ))) return false ; visited . insert ( hash ( i , j )); if ( visited . size () > ( 1 + 199 ) * 199 / 2 || hash ( i , j ) == target ) return true ; return dfs ( blockedSet , i + 1 , j , target , visited ) || dfs ( blockedSet , i - 1 , j , target , visited ) || dfs ( blockedSet , i , j + 1 , target , visited ) || dfs ( blockedSet , i , j - 1 , target , visited ); } long hash ( int i , int j ) { return (( long ) i << 16 ) + j ; } };","title":"1036. Escape a Large Maze $\\star\\star\\star$"},{"location":"cpp/1001-1100/1031-1040/#1037-valid-boomerang-star","text":"class Solution { public : bool isBoomerang ( vector < vector < int >>& points ) { return ( points [ 1 ][ 0 ] - points [ 0 ][ 0 ]) * ( points [ 2 ][ 1 ] - points [ 1 ][ 1 ]) != ( points [ 1 ][ 1 ] - points [ 0 ][ 1 ]) * ( points [ 2 ][ 0 ] - points [ 1 ][ 0 ]); } };","title":"1037. Valid Boomerang $\\star$"},{"location":"cpp/1001-1100/1031-1040/#1038-binary-search-tree-to-greater-sum-tree-starstar","text":"","title":"1038. Binary Search Tree to Greater Sum Tree $\\star\\star$"},{"location":"cpp/1001-1100/1031-1040/#1039-minimum-score-triangulation-of-polygon-starstar","text":"","title":"1039. Minimum Score Triangulation of Polygon $\\star\\star$"},{"location":"cpp/1001-1100/1031-1040/#1040-moving-stones-until-consecutive-ii-starstar","text":"class Solution { public : vector < int > numMovesStonesII ( vector < int >& stones ) { const int n = stones . size (); int minMoves = n ; sort ( begin ( stones ), end ( stones )); for ( int l = 0 , r = 0 ; r < n ; ++ r ) { while ( stones [ r ] - stones [ l ] + 1 > n ) ++ l ; int alreadyStored = r - l + 1 ; if ( alreadyStored == n - 1 && stones [ r ] - stones [ l ] + 1 == n - 1 ) minMoves = min ( minMoves , 2 ); else minMoves = min ( minMoves , n - alreadyStored ); } return { minMoves , max ( stones [ n - 1 ] - stones [ 1 ] - n + 2 , stones [ n - 2 ] - stones [ 0 ] - n + 2 )}; } };","title":"1040. Moving Stones Until Consecutive II $\\star\\star$"},{"location":"cpp/1001-1100/1041-1050/","text":"1041. Robot Bounded In Circle $\\star\\star$ class Solution { public : bool isRobotBounded ( string instructions ) { int x = 0 ; int y = 0 ; int d = 0 ; vector < vector < int >> directions {{ 0 , 1 }, { 1 , 0 }, { 0 , - 1 }, { - 1 , 0 }}; for ( char instruction : instructions ) { if ( instruction == 'G' ) { x += directions [ d ][ 0 ]; y += directions [ d ][ 1 ]; } else if ( instruction == 'L' ) d = ( d + 3 ) % 4 ; else d = ( d + 1 ) % 4 ; } return x == 0 && y == 0 || d > 0 ; } }; 1042. Flower Planting With No Adjacent $\\star$ 1043. Partition Array for Maximum Sum $\\star\\star$ class Solution { public : int maxSumAfterPartitioning ( vector < int >& A , int K ) { const int n = A . size (); vector < int > dp ( n + 1 ); for ( int i = 1 ; i <= n ; ++ i ) { int min = INT_MIN ; for ( int j = 1 ; j <= std :: min ( i , K ); ++ j ) { min = max ( min , A [ i - j ]); dp [ i ] = max ( dp [ i ], dp [ i - j ] + min * j ); } } return dp [ n ]; } }; 1044. Longest Duplicate Substring $\\star\\star\\star$ 1045. Customers Who Bought All Products $\\star\\star$ \ud83d\udd12 1046. Last Stone Weight $\\star$ 1047. Remove All Adjacent Duplicates In String $\\star$ 1048. Longest String Chain $\\star\\star$ class Solution { public : int longestStrChain ( vector < string >& words ) { int ans = 0 ; unordered_map < string , int > dp ; sort ( begin ( words ), end ( words ), []( const auto & a , const auto & b ) { return a . length () < b . length (); }); for ( const string & word : words ) { for ( int i = 0 ; i < word . length (); ++ i ) { string pred = word . substr ( 0 , i ) + word . substr ( i + 1 ); dp [ word ] = max ( dp [ word ], dp [ pred ] + 1 ); } ans = max ( ans , dp [ word ]); } return ans ; } }; 1049. Last Stone Weight II $\\star\\star$ class Solution { public : int lastStoneWeightII ( vector < int >& stones ) { const int sum = accumulate ( begin ( stones ), end ( stones ), 0 ); vector < bool > dp ( sum + 1 ); dp [ 0 ] = true ; int s = 0 ; for ( int stone : stones ) for ( int w = sum / 2 ; w > 0 ; -- w ) { if ( w >= stone ) dp [ w ] = dp [ w ] || dp [ w - stone ]; if ( dp [ w ]) s = max ( s , w ); } return sum - 2 * s ; } }; 1050. Actors and Directors Who Cooperated At Least Three Times $\\star$ \ud83d\udd12","title":"1041-1050"},{"location":"cpp/1001-1100/1041-1050/#1041-robot-bounded-in-circle-starstar","text":"class Solution { public : bool isRobotBounded ( string instructions ) { int x = 0 ; int y = 0 ; int d = 0 ; vector < vector < int >> directions {{ 0 , 1 }, { 1 , 0 }, { 0 , - 1 }, { - 1 , 0 }}; for ( char instruction : instructions ) { if ( instruction == 'G' ) { x += directions [ d ][ 0 ]; y += directions [ d ][ 1 ]; } else if ( instruction == 'L' ) d = ( d + 3 ) % 4 ; else d = ( d + 1 ) % 4 ; } return x == 0 && y == 0 || d > 0 ; } };","title":"1041. Robot Bounded In Circle $\\star\\star$"},{"location":"cpp/1001-1100/1041-1050/#1042-flower-planting-with-no-adjacent-star","text":"","title":"1042. Flower Planting With No Adjacent $\\star$"},{"location":"cpp/1001-1100/1041-1050/#1043-partition-array-for-maximum-sum-starstar","text":"class Solution { public : int maxSumAfterPartitioning ( vector < int >& A , int K ) { const int n = A . size (); vector < int > dp ( n + 1 ); for ( int i = 1 ; i <= n ; ++ i ) { int min = INT_MIN ; for ( int j = 1 ; j <= std :: min ( i , K ); ++ j ) { min = max ( min , A [ i - j ]); dp [ i ] = max ( dp [ i ], dp [ i - j ] + min * j ); } } return dp [ n ]; } };","title":"1043. Partition Array for Maximum Sum $\\star\\star$"},{"location":"cpp/1001-1100/1041-1050/#1044-longest-duplicate-substring-starstarstar","text":"","title":"1044. Longest Duplicate Substring $\\star\\star\\star$"},{"location":"cpp/1001-1100/1041-1050/#1045-customers-who-bought-all-products-starstar","text":"","title":"1045. Customers Who Bought All Products $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1001-1100/1041-1050/#1046-last-stone-weight-star","text":"","title":"1046. Last Stone Weight $\\star$"},{"location":"cpp/1001-1100/1041-1050/#1047-remove-all-adjacent-duplicates-in-string-star","text":"","title":"1047. Remove All Adjacent Duplicates In String $\\star$"},{"location":"cpp/1001-1100/1041-1050/#1048-longest-string-chain-starstar","text":"class Solution { public : int longestStrChain ( vector < string >& words ) { int ans = 0 ; unordered_map < string , int > dp ; sort ( begin ( words ), end ( words ), []( const auto & a , const auto & b ) { return a . length () < b . length (); }); for ( const string & word : words ) { for ( int i = 0 ; i < word . length (); ++ i ) { string pred = word . substr ( 0 , i ) + word . substr ( i + 1 ); dp [ word ] = max ( dp [ word ], dp [ pred ] + 1 ); } ans = max ( ans , dp [ word ]); } return ans ; } };","title":"1048. Longest String Chain $\\star\\star$"},{"location":"cpp/1001-1100/1041-1050/#1049-last-stone-weight-ii-starstar","text":"class Solution { public : int lastStoneWeightII ( vector < int >& stones ) { const int sum = accumulate ( begin ( stones ), end ( stones ), 0 ); vector < bool > dp ( sum + 1 ); dp [ 0 ] = true ; int s = 0 ; for ( int stone : stones ) for ( int w = sum / 2 ; w > 0 ; -- w ) { if ( w >= stone ) dp [ w ] = dp [ w ] || dp [ w - stone ]; if ( dp [ w ]) s = max ( s , w ); } return sum - 2 * s ; } };","title":"1049. Last Stone Weight II $\\star\\star$"},{"location":"cpp/1001-1100/1041-1050/#1050-actors-and-directors-who-cooperated-at-least-three-times-star","text":"","title":"1050. Actors and Directors Who Cooperated At Least Three Times $\\star$ \ud83d\udd12"},{"location":"cpp/1001-1100/1051-1060/","text":"1051. Height Checker $\\star$ class Solution { public : int heightChecker ( vector < int >& heights ) { int ans = 0 ; int currentHeight = 1 ; vector < int > count ( 101 ); for ( int height : heights ) ++ count [ height ]; for ( int height : heights ) { while ( count [ currentHeight ] == 0 ) ++ currentHeight ; if ( height != currentHeight ) ++ ans ; -- count [ currentHeight ]; } return ans ; } }; 1052. Grumpy Bookstore Owner $\\star\\star$ class Solution { public : int maxSatisfied ( vector < int >& customers , vector < int >& grumpy , int X ) { int satisfied = 0 ; int madeSatisfied = 0 ; int windowSatisfied = 0 ; for ( int i = 0 ; i < customers . size (); ++ i ) { if ( grumpy [ i ] == 0 ) satisfied += customers [ i ]; else windowSatisfied += customers [ i ]; if ( i >= X && grumpy [ i - X ] == 1 ) windowSatisfied -= customers [ i - X ]; madeSatisfied = max ( madeSatisfied , windowSatisfied ); } return satisfied + madeSatisfied ; } }; 1053. Previous Permutation With One Swap $\\star\\star$ class Solution { public : vector < int > prevPermOpt1 ( vector < int >& A ) { const int n = A . size (); int l = n - 2 ; int r = n - 1 ; while ( l >= 0 && A [ l ] <= A [ l + 1 ]) l -- ; if ( l < 0 ) return A ; while ( A [ r ] >= A [ l ] || A [ r ] == A [ r - 1 ]) r -- ; swap ( A [ l ], A [ r ]); return A ; } }; 1054. Distant Barcodes $\\star\\star$ 1055. Shortest Way to Form String $\\star\\star$ \ud83d\udd12 1056. Confusing Number $\\star$ \ud83d\udd12 1057. Campus Bikes $\\star\\star$ \ud83d\udd12 1058. Minimize Rounding Error to Meet Target $\\star\\star$ \ud83d\udd12 1059. All Paths from Source Lead to Destination $\\star\\star$ \ud83d\udd12 1060. Missing Element in Sorted Array $\\star\\star$ \ud83d\udd12","title":"1051-1060"},{"location":"cpp/1001-1100/1051-1060/#1051-height-checker-star","text":"class Solution { public : int heightChecker ( vector < int >& heights ) { int ans = 0 ; int currentHeight = 1 ; vector < int > count ( 101 ); for ( int height : heights ) ++ count [ height ]; for ( int height : heights ) { while ( count [ currentHeight ] == 0 ) ++ currentHeight ; if ( height != currentHeight ) ++ ans ; -- count [ currentHeight ]; } return ans ; } };","title":"1051. Height Checker $\\star$"},{"location":"cpp/1001-1100/1051-1060/#1052-grumpy-bookstore-owner-starstar","text":"class Solution { public : int maxSatisfied ( vector < int >& customers , vector < int >& grumpy , int X ) { int satisfied = 0 ; int madeSatisfied = 0 ; int windowSatisfied = 0 ; for ( int i = 0 ; i < customers . size (); ++ i ) { if ( grumpy [ i ] == 0 ) satisfied += customers [ i ]; else windowSatisfied += customers [ i ]; if ( i >= X && grumpy [ i - X ] == 1 ) windowSatisfied -= customers [ i - X ]; madeSatisfied = max ( madeSatisfied , windowSatisfied ); } return satisfied + madeSatisfied ; } };","title":"1052. Grumpy Bookstore Owner $\\star\\star$"},{"location":"cpp/1001-1100/1051-1060/#1053-previous-permutation-with-one-swap-starstar","text":"class Solution { public : vector < int > prevPermOpt1 ( vector < int >& A ) { const int n = A . size (); int l = n - 2 ; int r = n - 1 ; while ( l >= 0 && A [ l ] <= A [ l + 1 ]) l -- ; if ( l < 0 ) return A ; while ( A [ r ] >= A [ l ] || A [ r ] == A [ r - 1 ]) r -- ; swap ( A [ l ], A [ r ]); return A ; } };","title":"1053. Previous Permutation With One Swap $\\star\\star$"},{"location":"cpp/1001-1100/1051-1060/#1054-distant-barcodes-starstar","text":"","title":"1054. Distant Barcodes $\\star\\star$"},{"location":"cpp/1001-1100/1051-1060/#1055-shortest-way-to-form-string-starstar","text":"","title":"1055. Shortest Way to Form String $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1001-1100/1051-1060/#1056-confusing-number-star","text":"","title":"1056. Confusing Number $\\star$ \ud83d\udd12"},{"location":"cpp/1001-1100/1051-1060/#1057-campus-bikes-starstar","text":"","title":"1057. Campus Bikes $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1001-1100/1051-1060/#1058-minimize-rounding-error-to-meet-target-starstar","text":"","title":"1058. Minimize Rounding Error to Meet Target $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1001-1100/1051-1060/#1059-all-paths-from-source-lead-to-destination-starstar","text":"","title":"1059. All Paths from Source Lead to Destination $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1001-1100/1051-1060/#1060-missing-element-in-sorted-array-starstar","text":"","title":"1060. Missing Element in Sorted Array $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1001-1100/1061-1070/","text":"1061. Lexicographically Smallest Equivalent String $\\star\\star$ \ud83d\udd12 1062. Longest Repeating Substring $\\star\\star$ \ud83d\udd12 1063. Number of Valid Subarrays $\\star\\star\\star$ \ud83d\udd12 1064. Fixed Point $\\star$ \ud83d\udd12 1065. Index Pairs of a String $\\star$ \ud83d\udd12 1066. Campus Bikes II $\\star\\star$ \ud83d\udd12 1067. Digit Count in Range $\\star\\star\\star$ \ud83d\udd12 1068. Product Sales Analysis I $\\star$ \ud83d\udd12 1069. Product Sales Analysis II $\\star$ \ud83d\udd12 1070. Product Sales Analysis III $\\star\\star$ \ud83d\udd12","title":"1061-1070"},{"location":"cpp/1001-1100/1061-1070/#1061-lexicographically-smallest-equivalent-string-starstar","text":"","title":"1061. Lexicographically Smallest Equivalent String $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1001-1100/1061-1070/#1062-longest-repeating-substring-starstar","text":"","title":"1062. Longest Repeating Substring $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1001-1100/1061-1070/#1063-number-of-valid-subarrays-starstarstar","text":"","title":"1063. Number of Valid Subarrays $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/1001-1100/1061-1070/#1064-fixed-point-star","text":"","title":"1064. Fixed Point $\\star$ \ud83d\udd12"},{"location":"cpp/1001-1100/1061-1070/#1065-index-pairs-of-a-string-star","text":"","title":"1065. Index Pairs of a String $\\star$ \ud83d\udd12"},{"location":"cpp/1001-1100/1061-1070/#1066-campus-bikes-ii-starstar","text":"","title":"1066. Campus Bikes II $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1001-1100/1061-1070/#1067-digit-count-in-range-starstarstar","text":"","title":"1067. Digit Count in Range $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/1001-1100/1061-1070/#1068-product-sales-analysis-i-star","text":"","title":"1068. Product Sales Analysis I $\\star$ \ud83d\udd12"},{"location":"cpp/1001-1100/1061-1070/#1069-product-sales-analysis-ii-star","text":"","title":"1069. Product Sales Analysis II $\\star$ \ud83d\udd12"},{"location":"cpp/1001-1100/1061-1070/#1070-product-sales-analysis-iii-starstar","text":"","title":"1070. Product Sales Analysis III $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1001-1100/1071-1080/","text":"1071. Greatest Common Divisor of Strings $\\star$ class Solution { public : string gcdOfStrings ( string str1 , string str2 ) { if ( str1 . length () < str2 . length ()) return gcdOfStrings ( str2 , str1 ); if ( str1 . find ( str2 ) == string :: npos ) return \"\" ; if ( str2 . empty ()) return str1 ; return gcdOfStrings ( str2 , mod ( str1 , str2 )); } private : string mod ( string & s1 , const string & s2 ) { while ( s1 . find ( s2 ) == 0 ) s1 = s1 . substr ( s2 . length ()); return s1 ; } }; 1072. Flip Columns For Maximum Number of Equal Rows $\\star\\star$ class Solution { public : int maxEqualRowsAfterFlips ( vector < vector < int >>& matrix ) { const int m = matrix . size (); const int n = matrix [ 0 ]. size (); int ans = 0 ; vector < int > flip ( n ); unordered_set < int > seen ; for ( int i = 0 ; i < m ; ++ i ) { if ( seen . count ( i )) continue ; int count = 0 ; for ( int j = 0 ; j < n ; ++ j ) flip [ j ] = 1 ^ matrix [ i ][ j ]; for ( int k = 0 ; k < m ; ++ k ) if ( matrix [ k ] == matrix [ i ] || matrix [ k ] == flip ) { seen . insert ( k ); ++ count ; } ans = max ( ans , count ); } return ans ; } }; 1073. Adding Two Negabinary Numbers $\\star\\star$ class Solution { public : vector < int > addNegabinary ( vector < int >& arr1 , vector < int >& arr2 ) { deque < int > ans ; int carry = 0 ; int i = arr1 . size () - 1 ; int j = arr2 . size () - 1 ; while ( carry || i >= 0 || j >= 0 ) { if ( i >= 0 ) carry += arr1 [ i -- ]; if ( j >= 0 ) carry += arr2 [ j -- ]; ans . push_front ( carry & 1 ); carry = - ( carry >> 1 ); } while ( ans . size () > 1 && ans . front () == 0 ) ans . pop_front (); return { begin ( ans ), end ( ans )}; } }; 1074. Number of Submatrices That Sum to Target $\\star\\star\\star$ class Solution { public : int numSubmatrixSumTarget ( vector < vector < int >>& matrix , int target ) { int ans = 0 ; for ( vector < int >& row : matrix ) for ( int i = 1 ; i < row . size (); ++ i ) row [ i ] += row [ i - 1 ]; for ( int baseCol = 0 ; baseCol < matrix [ 0 ]. size (); ++ baseCol ) for ( int j = baseCol ; j < matrix [ 0 ]. size (); ++ j ) { unordered_map < int , int > prefixSumCount {{ 0 , 1 }}; int sum = 0 ; for ( int i = 0 ; i < matrix . size (); ++ i ) { if ( baseCol > 0 ) sum -= matrix [ i ][ baseCol - 1 ]; sum += matrix [ i ][ j ]; if ( prefixSumCount . count ( sum - target )) ans += prefixSumCount [ sum - target ]; ++ prefixSumCount [ sum ]; } } return ans ; } }; 1075. Project Employees I $\\star$ \ud83d\udd12 1076. Project Employees II $\\star$ \ud83d\udd12 1077. Project Employees III $\\star\\star$ \ud83d\udd12 1078. Occurrences After Bigram $\\star$ class Solution { public : vector < string > findOcurrences ( string text , string first , string second ) { vector < string > ans ; stringstream ss ( text ); for ( string prev2 , prev , word ; ss >> word ;) { if ( prev2 == first && prev == second ) ans . push_back ( word ); prev2 = prev ; prev = word ; } return ans ; } }; 1079. Letter Tile Possibilities $\\star\\star$ 1080. Insufficient Nodes in Root to Leaf Paths $\\star\\star$","title":"1071-1080"},{"location":"cpp/1001-1100/1071-1080/#1071-greatest-common-divisor-of-strings-star","text":"class Solution { public : string gcdOfStrings ( string str1 , string str2 ) { if ( str1 . length () < str2 . length ()) return gcdOfStrings ( str2 , str1 ); if ( str1 . find ( str2 ) == string :: npos ) return \"\" ; if ( str2 . empty ()) return str1 ; return gcdOfStrings ( str2 , mod ( str1 , str2 )); } private : string mod ( string & s1 , const string & s2 ) { while ( s1 . find ( s2 ) == 0 ) s1 = s1 . substr ( s2 . length ()); return s1 ; } };","title":"1071. Greatest Common Divisor of Strings $\\star$"},{"location":"cpp/1001-1100/1071-1080/#1072-flip-columns-for-maximum-number-of-equal-rows-starstar","text":"class Solution { public : int maxEqualRowsAfterFlips ( vector < vector < int >>& matrix ) { const int m = matrix . size (); const int n = matrix [ 0 ]. size (); int ans = 0 ; vector < int > flip ( n ); unordered_set < int > seen ; for ( int i = 0 ; i < m ; ++ i ) { if ( seen . count ( i )) continue ; int count = 0 ; for ( int j = 0 ; j < n ; ++ j ) flip [ j ] = 1 ^ matrix [ i ][ j ]; for ( int k = 0 ; k < m ; ++ k ) if ( matrix [ k ] == matrix [ i ] || matrix [ k ] == flip ) { seen . insert ( k ); ++ count ; } ans = max ( ans , count ); } return ans ; } };","title":"1072. Flip Columns For Maximum Number of Equal Rows $\\star\\star$"},{"location":"cpp/1001-1100/1071-1080/#1073-adding-two-negabinary-numbers-starstar","text":"class Solution { public : vector < int > addNegabinary ( vector < int >& arr1 , vector < int >& arr2 ) { deque < int > ans ; int carry = 0 ; int i = arr1 . size () - 1 ; int j = arr2 . size () - 1 ; while ( carry || i >= 0 || j >= 0 ) { if ( i >= 0 ) carry += arr1 [ i -- ]; if ( j >= 0 ) carry += arr2 [ j -- ]; ans . push_front ( carry & 1 ); carry = - ( carry >> 1 ); } while ( ans . size () > 1 && ans . front () == 0 ) ans . pop_front (); return { begin ( ans ), end ( ans )}; } };","title":"1073. Adding Two Negabinary Numbers $\\star\\star$"},{"location":"cpp/1001-1100/1071-1080/#1074-number-of-submatrices-that-sum-to-target-starstarstar","text":"class Solution { public : int numSubmatrixSumTarget ( vector < vector < int >>& matrix , int target ) { int ans = 0 ; for ( vector < int >& row : matrix ) for ( int i = 1 ; i < row . size (); ++ i ) row [ i ] += row [ i - 1 ]; for ( int baseCol = 0 ; baseCol < matrix [ 0 ]. size (); ++ baseCol ) for ( int j = baseCol ; j < matrix [ 0 ]. size (); ++ j ) { unordered_map < int , int > prefixSumCount {{ 0 , 1 }}; int sum = 0 ; for ( int i = 0 ; i < matrix . size (); ++ i ) { if ( baseCol > 0 ) sum -= matrix [ i ][ baseCol - 1 ]; sum += matrix [ i ][ j ]; if ( prefixSumCount . count ( sum - target )) ans += prefixSumCount [ sum - target ]; ++ prefixSumCount [ sum ]; } } return ans ; } };","title":"1074. Number of Submatrices That Sum to Target $\\star\\star\\star$"},{"location":"cpp/1001-1100/1071-1080/#1075-project-employees-i-star","text":"","title":"1075. Project Employees I $\\star$ \ud83d\udd12"},{"location":"cpp/1001-1100/1071-1080/#1076-project-employees-ii-star","text":"","title":"1076. Project Employees II $\\star$ \ud83d\udd12"},{"location":"cpp/1001-1100/1071-1080/#1077-project-employees-iii-starstar","text":"","title":"1077. Project Employees III $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1001-1100/1071-1080/#1078-occurrences-after-bigram-star","text":"class Solution { public : vector < string > findOcurrences ( string text , string first , string second ) { vector < string > ans ; stringstream ss ( text ); for ( string prev2 , prev , word ; ss >> word ;) { if ( prev2 == first && prev == second ) ans . push_back ( word ); prev2 = prev ; prev = word ; } return ans ; } };","title":"1078. Occurrences After Bigram $\\star$"},{"location":"cpp/1001-1100/1071-1080/#1079-letter-tile-possibilities-starstar","text":"","title":"1079. Letter Tile Possibilities $\\star\\star$"},{"location":"cpp/1001-1100/1071-1080/#1080-insufficient-nodes-in-root-to-leaf-paths-starstar","text":"","title":"1080. Insufficient Nodes in Root to Leaf Paths $\\star\\star$"},{"location":"cpp/1001-1100/1081-1090/","text":"1081. Smallest Subsequence of Distinct Characters $\\star\\star$ class Solution { public : string smallestSubsequence ( string text ) { string ans ; vector < int > count ( 26 ); vector < bool > used ( 26 ); for ( char c : text ) ++ count [ c - 'a' ]; for ( char c : text ) { -- count [ c - 'a' ]; if ( used [ c - 'a' ]) continue ; while ( ! ans . empty () && ans . back () > c && count [ ans . back () - 'a' ] > 0 ) { used [ ans . back () - 'a' ] = false ; ans . pop_back (); } ans += c ; used [ c - 'a' ] = true ; } return ans ; } }; 1082. Sales Analysis I $\\star$ \ud83d\udd12 1083. Sales Analysis II $\\star$ \ud83d\udd12 1084. Sales Analysis III $\\star$ \ud83d\udd12 1085. Sum of Digits in the Minimum Number $\\star$ \ud83d\udd12 1086. High Five $\\star$ \ud83d\udd12 1087. Brace Expansion $\\star\\star$ \ud83d\udd12 1088. Confusing Number II $\\star\\star\\star$ \ud83d\udd12 1089. Duplicate Zeros $\\star$ class Solution { public : void duplicateZeros ( vector < int >& arr ) { int zeros = count_if ( begin ( arr ), end ( arr ), []( int a ) { return a == 0 ; }); for ( int i = arr . size () - 1 , j = arr . size () + zeros - 1 ; i < j ; -- i , -- j ) { if ( j < arr . size ()) arr [ j ] = arr [ i ]; if ( arr [ i ] == 0 ) if ( -- j < arr . size ()) arr [ j ] = arr [ i ]; } } }; 1090. Largest Values From Labels $\\star\\star$","title":"1081-1090"},{"location":"cpp/1001-1100/1081-1090/#1081-smallest-subsequence-of-distinct-characters-starstar","text":"class Solution { public : string smallestSubsequence ( string text ) { string ans ; vector < int > count ( 26 ); vector < bool > used ( 26 ); for ( char c : text ) ++ count [ c - 'a' ]; for ( char c : text ) { -- count [ c - 'a' ]; if ( used [ c - 'a' ]) continue ; while ( ! ans . empty () && ans . back () > c && count [ ans . back () - 'a' ] > 0 ) { used [ ans . back () - 'a' ] = false ; ans . pop_back (); } ans += c ; used [ c - 'a' ] = true ; } return ans ; } };","title":"1081. Smallest Subsequence of Distinct Characters $\\star\\star$"},{"location":"cpp/1001-1100/1081-1090/#1082-sales-analysis-i-star","text":"","title":"1082. Sales Analysis I $\\star$ \ud83d\udd12"},{"location":"cpp/1001-1100/1081-1090/#1083-sales-analysis-ii-star","text":"","title":"1083. Sales Analysis II $\\star$ \ud83d\udd12"},{"location":"cpp/1001-1100/1081-1090/#1084-sales-analysis-iii-star","text":"","title":"1084. Sales Analysis III $\\star$ \ud83d\udd12"},{"location":"cpp/1001-1100/1081-1090/#1085-sum-of-digits-in-the-minimum-number-star","text":"","title":"1085. Sum of Digits in the Minimum Number $\\star$ \ud83d\udd12"},{"location":"cpp/1001-1100/1081-1090/#1086-high-five-star","text":"","title":"1086. High Five $\\star$ \ud83d\udd12"},{"location":"cpp/1001-1100/1081-1090/#1087-brace-expansion-starstar","text":"","title":"1087. Brace Expansion $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1001-1100/1081-1090/#1088-confusing-number-ii-starstarstar","text":"","title":"1088. Confusing Number II $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/1001-1100/1081-1090/#1089-duplicate-zeros-star","text":"class Solution { public : void duplicateZeros ( vector < int >& arr ) { int zeros = count_if ( begin ( arr ), end ( arr ), []( int a ) { return a == 0 ; }); for ( int i = arr . size () - 1 , j = arr . size () + zeros - 1 ; i < j ; -- i , -- j ) { if ( j < arr . size ()) arr [ j ] = arr [ i ]; if ( arr [ i ] == 0 ) if ( -- j < arr . size ()) arr [ j ] = arr [ i ]; } } };","title":"1089. Duplicate Zeros $\\star$"},{"location":"cpp/1001-1100/1081-1090/#1090-largest-values-from-labels-starstar","text":"","title":"1090. Largest Values From Labels $\\star\\star$"},{"location":"cpp/1001-1100/1091-1100/","text":"1091. Shortest Path in Binary Matrix $\\star\\star$ 1092. Shortest Common Supersequence $\\star\\star\\star$ 1093. Statistics from a Large Sample $\\star\\star$ class Solution { public : vector < double > sampleStats ( vector < int >& count ) { double minimum = 0 ; double maximum = 0 ; double mean = 0 ; double leftMedian = 0 ; double rightMedian = 0 ; double mode = - 1 ; int numCount = accumulate ( begin ( count ), end ( count ), 0 ); int newNumCount = 0 ; int maxCount = 0 ; for ( int i = 0 ; i < count . size (); ++ i ) if ( count [ i ] > 0 ) { minimum = i ; break ; } for ( int i = count . size () - 1 ; i >= 0 ; -- i ) if ( count [ i ] > 0 ) { maximum = i ; break ; } for ( int i = 0 ; i < count . size (); ++ i ) mean += ( i * count [ i ]) / ( double ) numCount ; for ( int i = 0 ; i < count . size (); ++ i ) { newNumCount += count [ i ]; if ( newNumCount >= numCount / 2 ) { leftMedian = i ; break ; } } newNumCount = 0 ; for ( int i = count . size () - 1 ; i >= 0 ; -- i ) { newNumCount += count [ i ]; if ( newNumCount >= numCount / 2 ) { rightMedian = i ; break ; } } for ( int i = 0 ; i < count . size (); ++ i ) if ( count [ i ] > maxCount ) { maxCount = count [ i ]; mode = i ; } return { minimum , maximum , mean , ( leftMedian + rightMedian ) / 2.0 , mode }; } }; 1094. Car Pooling $\\star\\star$ 1095. Find in Mountain Array $\\star\\star\\star$ 1096. Brace Expansion II $\\star\\star\\star$ class Solution { public : vector < string > braceExpansionII ( string expression ) { return dfs ( expression , 0 , expression . length () - 1 ); } private : vector < string > dfs ( const string & expression , int s , int e ) { set < string > ans ; vector < vector < string >> groups {{}}; int layer = 0 ; int left = 0 ; for ( int i = s ; i <= e ; ++ i ) if ( expression [ i ] == '{' && ++ layer == 1 ) left = i + 1 ; else if ( expression [ i ] == '}' && -- layer == 0 ) merge ( groups , dfs ( expression , left , i - 1 )); else if ( expression [ i ] == ',' && layer == 0 ) groups . push_back ({}); else if ( layer == 0 ) merge ( groups , { string ( 1 , expression [ i ])}); for ( const vector < string >& group : groups ) for ( const string & word : group ) ans . insert ( word ); return { begin ( ans ), end ( ans )}; } void merge ( vector < vector < string >>& groups , const vector < string > group ) { if ( groups . back (). empty ()) { groups [ groups . size () - 1 ] = group ; return ; } vector < string > mergedGroup ; for ( auto & word1 : groups . back ()) for ( auto & word2 : group ) mergedGroup . push_back ( word1 + word2 ); groups [ groups . size () - 1 ] = mergedGroup ; } }; 1097. Game Play Analysis V $\\star\\star\\star$ \ud83d\udd12 1098. Unpopular Books $\\star\\star$ \ud83d\udd12 1099. Two Sum Less Than K $\\star$ \ud83d\udd12 1100. Find K-Length Substrings With No Repeated Characters $\\star\\star$ \ud83d\udd12","title":"1091-1100"},{"location":"cpp/1001-1100/1091-1100/#1091-shortest-path-in-binary-matrix-starstar","text":"","title":"1091. Shortest Path in Binary Matrix $\\star\\star$"},{"location":"cpp/1001-1100/1091-1100/#1092-shortest-common-supersequence-starstarstar","text":"","title":"1092. Shortest Common Supersequence  $\\star\\star\\star$"},{"location":"cpp/1001-1100/1091-1100/#1093-statistics-from-a-large-sample-starstar","text":"class Solution { public : vector < double > sampleStats ( vector < int >& count ) { double minimum = 0 ; double maximum = 0 ; double mean = 0 ; double leftMedian = 0 ; double rightMedian = 0 ; double mode = - 1 ; int numCount = accumulate ( begin ( count ), end ( count ), 0 ); int newNumCount = 0 ; int maxCount = 0 ; for ( int i = 0 ; i < count . size (); ++ i ) if ( count [ i ] > 0 ) { minimum = i ; break ; } for ( int i = count . size () - 1 ; i >= 0 ; -- i ) if ( count [ i ] > 0 ) { maximum = i ; break ; } for ( int i = 0 ; i < count . size (); ++ i ) mean += ( i * count [ i ]) / ( double ) numCount ; for ( int i = 0 ; i < count . size (); ++ i ) { newNumCount += count [ i ]; if ( newNumCount >= numCount / 2 ) { leftMedian = i ; break ; } } newNumCount = 0 ; for ( int i = count . size () - 1 ; i >= 0 ; -- i ) { newNumCount += count [ i ]; if ( newNumCount >= numCount / 2 ) { rightMedian = i ; break ; } } for ( int i = 0 ; i < count . size (); ++ i ) if ( count [ i ] > maxCount ) { maxCount = count [ i ]; mode = i ; } return { minimum , maximum , mean , ( leftMedian + rightMedian ) / 2.0 , mode }; } };","title":"1093. Statistics from a Large Sample $\\star\\star$"},{"location":"cpp/1001-1100/1091-1100/#1094-car-pooling-starstar","text":"","title":"1094. Car Pooling $\\star\\star$"},{"location":"cpp/1001-1100/1091-1100/#1095-find-in-mountain-array-starstarstar","text":"","title":"1095. Find in Mountain Array $\\star\\star\\star$"},{"location":"cpp/1001-1100/1091-1100/#1096-brace-expansion-ii-starstarstar","text":"class Solution { public : vector < string > braceExpansionII ( string expression ) { return dfs ( expression , 0 , expression . length () - 1 ); } private : vector < string > dfs ( const string & expression , int s , int e ) { set < string > ans ; vector < vector < string >> groups {{}}; int layer = 0 ; int left = 0 ; for ( int i = s ; i <= e ; ++ i ) if ( expression [ i ] == '{' && ++ layer == 1 ) left = i + 1 ; else if ( expression [ i ] == '}' && -- layer == 0 ) merge ( groups , dfs ( expression , left , i - 1 )); else if ( expression [ i ] == ',' && layer == 0 ) groups . push_back ({}); else if ( layer == 0 ) merge ( groups , { string ( 1 , expression [ i ])}); for ( const vector < string >& group : groups ) for ( const string & word : group ) ans . insert ( word ); return { begin ( ans ), end ( ans )}; } void merge ( vector < vector < string >>& groups , const vector < string > group ) { if ( groups . back (). empty ()) { groups [ groups . size () - 1 ] = group ; return ; } vector < string > mergedGroup ; for ( auto & word1 : groups . back ()) for ( auto & word2 : group ) mergedGroup . push_back ( word1 + word2 ); groups [ groups . size () - 1 ] = mergedGroup ; } };","title":"1096. Brace Expansion II $\\star\\star\\star$"},{"location":"cpp/1001-1100/1091-1100/#1097-game-play-analysis-v-starstarstar","text":"","title":"1097. Game Play Analysis V $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/1001-1100/1091-1100/#1098-unpopular-books-starstar","text":"","title":"1098. Unpopular Books $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1001-1100/1091-1100/#1099-two-sum-less-than-k-star","text":"","title":"1099. Two Sum Less Than K $\\star$ \ud83d\udd12"},{"location":"cpp/1001-1100/1091-1100/#1100-find-k-length-substrings-with-no-repeated-characters-starstar","text":"","title":"1100. Find K-Length Substrings With No Repeated Characters $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1101-1110/","text":"1101. The Earliest Moment When Everyone Become Friends $\\star\\star$ \ud83d\udd12 1102. Path With Maximum Minimum Value $\\star\\star$ \ud83d\udd12 1103. Distribute Candies to People $\\star$ class Solution { public : vector < int > distributeCandies ( int candies , long n ) { vector < int > ans ( n ); int rows = ( - n + sqrt ( n * n + 8 * n * n * candies )) / ( 2 * n * n ); int accumN = rows * ( rows - 1 ) * n / 2 ; for ( int i = 0 ; i < n ; ++ i ) ans [ i ] = accumN + rows * ( i + 1 ); int givenCandies = ( n * n * rows * rows + n * rows ) / 2 ; candies -= givenCandies ; for ( int i = 0 , lastGiven = rows * n + 1 ; candies > 0 ; ++ i , ++ lastGiven ) { int actualGiven = min ( lastGiven , candies ); candies -= actualGiven ; ans [ i ] += actualGiven ; } return ans ; } }; 1104. Path In Zigzag Labelled Binary Tree $\\star\\star$ class Solution { public : vector < int > pathInZigZagTree ( int label ) { deque < int > ans ; int level ; for ( int l = 0 ; l < 21 ; ++ l ) if ( pow ( 2 , l ) > label ) { level = l - 1 ; break ; } if ( level & 1 ) label = boundarySum ( level ) - label ; for ( int l = level ; l >= 0 ; -- l ) { ans . push_front ( l & 1 ? boundarySum ( l ) - label : label ); label /= 2 ; } return { begin ( ans ), end ( ans )}; } private : int boundarySum ( int level ) { return pow ( 2 , level ) + pow ( 2 , level + 1 ) - 1 ; } }; 1105. Filling Bookcase Shelves $\\star\\star$ 1106. Parsing A Boolean Expression $\\star\\star\\star$ class Solution { public : bool parseBoolExpr ( string expression ) { int i = 0 ; return parse ( expression , i ); } private : bool parse ( const string & exp , int & i ) { if ( exp [ i ] == 't' ) { ++ i ; return true ; } if ( exp [ i ] == 'f' ) { ++ i ; return false ; } if ( exp [ i ] == '!' ) { i += 2 ; bool ans = ! parse ( exp , i ); ++ i ; return ans ; } bool isAnd = exp [ i ] == '&' ; bool ans = isAnd ; i += 2 ; while ( exp [ i ] != ')' ) { bool parsed = parse ( exp , i ); if ( isAnd ) ans &= parsed ; else ans |= parsed ; if ( exp [ i ] == ',' ) ++ i ; } ++ i ; return ans ; } }; 1107. New Users Daily Count $\\star\\star$ \ud83d\udd12 1108. Defanging an IP Address $\\star$ class Solution { public : string defangIPaddr ( string address ) { return regex_replace ( address , regex ( \"[.]\" ), \"[.]\" ); } }; 1109. Corporate Flight Bookings $\\star\\star$ class Solution { public : vector < int > corpFlightBookings ( vector < vector < int >>& bookings , int n ) { vector < int > ans ( n ); for ( vector < int >& booking : bookings ) { ans [ booking [ 0 ] - 1 ] += booking [ 2 ]; if ( booking [ 1 ] < n ) ans [ booking [ 1 ]] -= booking [ 2 ]; } for ( int i = 1 ; i < n ; ++ i ) ans [ i ] += ans [ i - 1 ]; return ans ; } }; 1110. Delete Nodes And Return Forest $\\star\\star$","title":"1101-1110"},{"location":"cpp/1101-1200/1101-1110/#1101-the-earliest-moment-when-everyone-become-friends-starstar","text":"","title":"1101. The Earliest Moment When Everyone Become Friends $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1101-1110/#1102-path-with-maximum-minimum-value-starstar","text":"","title":"1102. Path With Maximum Minimum Value $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1101-1110/#1103-distribute-candies-to-people-star","text":"class Solution { public : vector < int > distributeCandies ( int candies , long n ) { vector < int > ans ( n ); int rows = ( - n + sqrt ( n * n + 8 * n * n * candies )) / ( 2 * n * n ); int accumN = rows * ( rows - 1 ) * n / 2 ; for ( int i = 0 ; i < n ; ++ i ) ans [ i ] = accumN + rows * ( i + 1 ); int givenCandies = ( n * n * rows * rows + n * rows ) / 2 ; candies -= givenCandies ; for ( int i = 0 , lastGiven = rows * n + 1 ; candies > 0 ; ++ i , ++ lastGiven ) { int actualGiven = min ( lastGiven , candies ); candies -= actualGiven ; ans [ i ] += actualGiven ; } return ans ; } };","title":"1103. Distribute Candies to People $\\star$"},{"location":"cpp/1101-1200/1101-1110/#1104-path-in-zigzag-labelled-binary-tree-starstar","text":"class Solution { public : vector < int > pathInZigZagTree ( int label ) { deque < int > ans ; int level ; for ( int l = 0 ; l < 21 ; ++ l ) if ( pow ( 2 , l ) > label ) { level = l - 1 ; break ; } if ( level & 1 ) label = boundarySum ( level ) - label ; for ( int l = level ; l >= 0 ; -- l ) { ans . push_front ( l & 1 ? boundarySum ( l ) - label : label ); label /= 2 ; } return { begin ( ans ), end ( ans )}; } private : int boundarySum ( int level ) { return pow ( 2 , level ) + pow ( 2 , level + 1 ) - 1 ; } };","title":"1104. Path In Zigzag Labelled Binary Tree $\\star\\star$"},{"location":"cpp/1101-1200/1101-1110/#1105-filling-bookcase-shelves-starstar","text":"","title":"1105. Filling Bookcase Shelves $\\star\\star$"},{"location":"cpp/1101-1200/1101-1110/#1106-parsing-a-boolean-expression-starstarstar","text":"class Solution { public : bool parseBoolExpr ( string expression ) { int i = 0 ; return parse ( expression , i ); } private : bool parse ( const string & exp , int & i ) { if ( exp [ i ] == 't' ) { ++ i ; return true ; } if ( exp [ i ] == 'f' ) { ++ i ; return false ; } if ( exp [ i ] == '!' ) { i += 2 ; bool ans = ! parse ( exp , i ); ++ i ; return ans ; } bool isAnd = exp [ i ] == '&' ; bool ans = isAnd ; i += 2 ; while ( exp [ i ] != ')' ) { bool parsed = parse ( exp , i ); if ( isAnd ) ans &= parsed ; else ans |= parsed ; if ( exp [ i ] == ',' ) ++ i ; } ++ i ; return ans ; } };","title":"1106. Parsing A Boolean Expression $\\star\\star\\star$"},{"location":"cpp/1101-1200/1101-1110/#1107-new-users-daily-count-starstar","text":"","title":"1107. New Users Daily Count $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1101-1110/#1108-defanging-an-ip-address-star","text":"class Solution { public : string defangIPaddr ( string address ) { return regex_replace ( address , regex ( \"[.]\" ), \"[.]\" ); } };","title":"1108. Defanging an IP Address $\\star$"},{"location":"cpp/1101-1200/1101-1110/#1109-corporate-flight-bookings-starstar","text":"class Solution { public : vector < int > corpFlightBookings ( vector < vector < int >>& bookings , int n ) { vector < int > ans ( n ); for ( vector < int >& booking : bookings ) { ans [ booking [ 0 ] - 1 ] += booking [ 2 ]; if ( booking [ 1 ] < n ) ans [ booking [ 1 ]] -= booking [ 2 ]; } for ( int i = 1 ; i < n ; ++ i ) ans [ i ] += ans [ i - 1 ]; return ans ; } };","title":"1109. Corporate Flight Bookings $\\star\\star$"},{"location":"cpp/1101-1200/1101-1110/#1110-delete-nodes-and-return-forest-starstar","text":"","title":"1110. Delete Nodes And Return Forest $\\star\\star$"},{"location":"cpp/1101-1200/1111-1120/","text":"1111. Maximum Nesting Depth of Two Valid Parentheses Strings $\\star\\star$ 1112. Highest Grade For Each Student $\\star\\star$ \ud83d\udd12 1113. Reported Posts $\\star$ \ud83d\udd12 1114. Print in Order $\\star$ class Foo { public : Foo () { mutex2 . lock (); mutex3 . lock (); } void first ( function < void () > printFirst ) { printFirst (); mutex2 . unlock (); } void second ( function < void () > printSecond ) { mutex2 . lock (); printSecond (); mutex3 . unlock (); } void third ( function < void () > printThird ) { mutex3 . lock (); printThird (); } private : mutex mutex2 ; mutex mutex3 ; }; 1115. Print FooBar Alternately $\\star\\star$ 1116. Print Zero Even Odd $\\star\\star$ 1117. Building H2O $\\star\\star$ 1118. Number of Days in a Month $\\star$ \ud83d\udd12 1119. Remove Vowels from a String $\\star$ \ud83d\udd12 1120. Maximum Average Subtree $\\star\\star$ \ud83d\udd12","title":"1111-1120"},{"location":"cpp/1101-1200/1111-1120/#1111-maximum-nesting-depth-of-two-valid-parentheses-strings-starstar","text":"","title":"1111. Maximum Nesting Depth of Two Valid Parentheses Strings $\\star\\star$"},{"location":"cpp/1101-1200/1111-1120/#1112-highest-grade-for-each-student-starstar","text":"","title":"1112. Highest Grade For Each Student $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1111-1120/#1113-reported-posts-star","text":"","title":"1113. Reported Posts $\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1111-1120/#1114-print-in-order-star","text":"class Foo { public : Foo () { mutex2 . lock (); mutex3 . lock (); } void first ( function < void () > printFirst ) { printFirst (); mutex2 . unlock (); } void second ( function < void () > printSecond ) { mutex2 . lock (); printSecond (); mutex3 . unlock (); } void third ( function < void () > printThird ) { mutex3 . lock (); printThird (); } private : mutex mutex2 ; mutex mutex3 ; };","title":"1114. Print in Order $\\star$"},{"location":"cpp/1101-1200/1111-1120/#1115-print-foobar-alternately-starstar","text":"","title":"1115. Print FooBar Alternately $\\star\\star$"},{"location":"cpp/1101-1200/1111-1120/#1116-print-zero-even-odd-starstar","text":"","title":"1116. Print Zero Even Odd $\\star\\star$"},{"location":"cpp/1101-1200/1111-1120/#1117-building-h2o-starstar","text":"","title":"1117. Building H2O $\\star\\star$"},{"location":"cpp/1101-1200/1111-1120/#1118-number-of-days-in-a-month-star","text":"","title":"1118. Number of Days in a Month $\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1111-1120/#1119-remove-vowels-from-a-string-star","text":"","title":"1119. Remove Vowels from a String $\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1111-1120/#1120-maximum-average-subtree-starstar","text":"","title":"1120. Maximum Average Subtree $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1121-1130/","text":"1121. Divide Array Into Increasing Sequences $\\star\\star\\star$ \ud83d\udd12 1122. Relative Sort Array $\\star$ class Solution { public : vector < int > relativeSortArray ( vector < int >& arr1 , vector < int >& arr2 ) { vector < int > ans ; vector < int > count ( 1001 ); for ( int a : arr1 ) ++ count [ a ]; for ( int a : arr2 ) while ( count [ a ] -- > 0 ) ans . push_back ( a ); for ( int num = 0 ; num < 1001 ; ++ num ) while ( count [ num ] -- > 0 ) ans . push_back ( num ); return ans ; } }; 1123. Lowest Common Ancestor of Deepest Leaves $\\star\\star$ 1124. Longest Well-Performing Interval $\\star\\star$ class Solution { public : int longestWPI ( vector < int >& hours ) { int ans = 0 ; int prefixSum = 0 ; unordered_map < int , int > map ; for ( int i = 0 ; i < hours . size (); ++ i ) { prefixSum += hours [ i ] > 8 ? 1 : - 1 ; if ( prefixSum > 0 ) { ans = i + 1 ; } else { if ( ! map . count ( prefixSum )) map [ prefixSum ] = i ; if ( map . count ( prefixSum - 1 )) ans = max ( ans , i - map [ prefixSum - 1 ]); } } return ans ; } }; 1125. Smallest Sufficient Team $\\star\\star\\star$ 1126. Active Businesses $\\star\\star$ \ud83d\udd12 1127. User Purchase Platform $\\star\\star\\star$ \ud83d\udd12 1128. Number of Equivalent Domino Pairs $\\star$ class Solution { public : int numEquivDominoPairs ( vector < vector < int >>& dominoes ) { int ans = 0 ; unordered_map < int , int > count ; for ( vector < int >& domino : dominoes ) { int key = min ( domino [ 0 ], domino [ 1 ]) * 10 + max ( domino [ 0 ], domino [ 1 ]); ans += count [ key ]; ++ count [ key ]; } return ans ; } }; 1129. Shortest Path with Alternating Colors $\\star\\star$ 1130. Minimum Cost Tree From Leaf Values $\\star\\star$","title":"1121-1130"},{"location":"cpp/1101-1200/1121-1130/#1121-divide-array-into-increasing-sequences-starstarstar","text":"","title":"1121. Divide Array Into Increasing Sequences $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1121-1130/#1122-relative-sort-array-star","text":"class Solution { public : vector < int > relativeSortArray ( vector < int >& arr1 , vector < int >& arr2 ) { vector < int > ans ; vector < int > count ( 1001 ); for ( int a : arr1 ) ++ count [ a ]; for ( int a : arr2 ) while ( count [ a ] -- > 0 ) ans . push_back ( a ); for ( int num = 0 ; num < 1001 ; ++ num ) while ( count [ num ] -- > 0 ) ans . push_back ( num ); return ans ; } };","title":"1122. Relative Sort Array $\\star$"},{"location":"cpp/1101-1200/1121-1130/#1123-lowest-common-ancestor-of-deepest-leaves-starstar","text":"","title":"1123. Lowest Common Ancestor of Deepest Leaves $\\star\\star$"},{"location":"cpp/1101-1200/1121-1130/#1124-longest-well-performing-interval-starstar","text":"class Solution { public : int longestWPI ( vector < int >& hours ) { int ans = 0 ; int prefixSum = 0 ; unordered_map < int , int > map ; for ( int i = 0 ; i < hours . size (); ++ i ) { prefixSum += hours [ i ] > 8 ? 1 : - 1 ; if ( prefixSum > 0 ) { ans = i + 1 ; } else { if ( ! map . count ( prefixSum )) map [ prefixSum ] = i ; if ( map . count ( prefixSum - 1 )) ans = max ( ans , i - map [ prefixSum - 1 ]); } } return ans ; } };","title":"1124. Longest Well-Performing Interval $\\star\\star$"},{"location":"cpp/1101-1200/1121-1130/#1125-smallest-sufficient-team-starstarstar","text":"","title":"1125. Smallest Sufficient Team $\\star\\star\\star$"},{"location":"cpp/1101-1200/1121-1130/#1126-active-businesses-starstar","text":"","title":"1126. Active Businesses $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1121-1130/#1127-user-purchase-platform-starstarstar","text":"","title":"1127. User Purchase Platform $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1121-1130/#1128-number-of-equivalent-domino-pairs-star","text":"class Solution { public : int numEquivDominoPairs ( vector < vector < int >>& dominoes ) { int ans = 0 ; unordered_map < int , int > count ; for ( vector < int >& domino : dominoes ) { int key = min ( domino [ 0 ], domino [ 1 ]) * 10 + max ( domino [ 0 ], domino [ 1 ]); ans += count [ key ]; ++ count [ key ]; } return ans ; } };","title":"1128. Number of Equivalent Domino Pairs $\\star$"},{"location":"cpp/1101-1200/1121-1130/#1129-shortest-path-with-alternating-colors-starstar","text":"","title":"1129. Shortest Path with Alternating Colors $\\star\\star$"},{"location":"cpp/1101-1200/1121-1130/#1130-minimum-cost-tree-from-leaf-values-starstar","text":"","title":"1130. Minimum Cost Tree From Leaf Values $\\star\\star$"},{"location":"cpp/1101-1200/1131-1140/","text":"1131. Maximum of Absolute Value Expression $\\star\\star$ class Solution { public : int maxAbsValExpr ( vector < int >& arr1 , vector < int >& arr2 ) { const int n = arr1 . size (); vector < int > a ( n ); vector < int > b ( n ); vector < int > c ( n ); vector < int > d ( n ); for ( int i = 0 ; i < n ; ++ i ) { a [ i ] = arr1 [ i ] + arr2 [ i ] + i ; b [ i ] = arr1 [ i ] + arr2 [ i ] - i ; c [ i ] = arr1 [ i ] - arr2 [ i ] + i ; d [ i ] = arr1 [ i ] - arr2 [ i ] - i ; } return max ( max ( diff ( a ), diff ( b )), max ( diff ( c ), diff ( d ))); } private : int diff ( vector < int >& nums ) { const int min = * min_element ( begin ( nums ), end ( nums )); const int max = * max_element ( begin ( nums ), end ( nums )); return max - min ; } }; 1132. Reported Posts II $\\star\\star$ \ud83d\udd12 1133. Largest Unique Number $\\star$ \ud83d\udd12 1134. Armstrong Number $\\star$ \ud83d\udd12 1135. Connecting Cities With Minimum Cost $\\star\\star$ \ud83d\udd12 1136. Parallel Courses $\\star\\star\\star$ \ud83d\udd12 1137. N-th Tribonacci Number $\\star$ 1138. Alphabet Board Path $\\star\\star$ 1139. Largest 1-Bordered Square $\\star\\star$ 1140. Stone Game II $\\star\\star$","title":"1131-1140"},{"location":"cpp/1101-1200/1131-1140/#1131-maximum-of-absolute-value-expression-starstar","text":"class Solution { public : int maxAbsValExpr ( vector < int >& arr1 , vector < int >& arr2 ) { const int n = arr1 . size (); vector < int > a ( n ); vector < int > b ( n ); vector < int > c ( n ); vector < int > d ( n ); for ( int i = 0 ; i < n ; ++ i ) { a [ i ] = arr1 [ i ] + arr2 [ i ] + i ; b [ i ] = arr1 [ i ] + arr2 [ i ] - i ; c [ i ] = arr1 [ i ] - arr2 [ i ] + i ; d [ i ] = arr1 [ i ] - arr2 [ i ] - i ; } return max ( max ( diff ( a ), diff ( b )), max ( diff ( c ), diff ( d ))); } private : int diff ( vector < int >& nums ) { const int min = * min_element ( begin ( nums ), end ( nums )); const int max = * max_element ( begin ( nums ), end ( nums )); return max - min ; } };","title":"1131. Maximum of Absolute Value Expression $\\star\\star$"},{"location":"cpp/1101-1200/1131-1140/#1132-reported-posts-ii-starstar","text":"","title":"1132. Reported Posts II $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1131-1140/#1133-largest-unique-number-star","text":"","title":"1133. Largest Unique Number $\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1131-1140/#1134-armstrong-number-star","text":"","title":"1134. Armstrong Number $\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1131-1140/#1135-connecting-cities-with-minimum-cost-starstar","text":"","title":"1135. Connecting Cities With Minimum Cost $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1131-1140/#1136-parallel-courses-starstarstar","text":"","title":"1136. Parallel Courses $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1131-1140/#1137-n-th-tribonacci-number-star","text":"","title":"1137. N-th Tribonacci Number $\\star$"},{"location":"cpp/1101-1200/1131-1140/#1138-alphabet-board-path-starstar","text":"","title":"1138. Alphabet Board Path $\\star\\star$"},{"location":"cpp/1101-1200/1131-1140/#1139-largest-1-bordered-square-starstar","text":"","title":"1139. Largest 1-Bordered Square $\\star\\star$"},{"location":"cpp/1101-1200/1131-1140/#1140-stone-game-ii-starstar","text":"","title":"1140. Stone Game II $\\star\\star$"},{"location":"cpp/1101-1200/1141-1150/","text":"1141. User Activity for the Past 30 Days I $\\star$ \ud83d\udd12 1142. User Activity for the Past 30 Days II $\\star$ \ud83d\udd12 1143. Longest Common Subsequence $\\star\\star$ 1144. Decrease Elements To Make Array Zigzag $\\star\\star$ class Solution { public : int movesToMakeZigzag ( vector < int >& nums ) { vector < int > decreasing ( 2 ); for ( int i = 0 ; i < nums . size (); ++ i ) { int l = i > 0 ? nums [ i - 1 ] : 1001 ; int r = i + 1 < nums . size () ? nums [ i + 1 ] : 1001 ; decreasing [ i % 2 ] += max ( 0 , nums [ i ] - min ( l , r ) + 1 ); } return min ( decreasing [ 0 ], decreasing [ 1 ]); } }; 1145. Binary Tree Coloring Game $\\star\\star$ 1146. Snapshot Array $\\star\\star$ class SnapshotArray { public : SnapshotArray ( int length ) { map = vector < std :: map < int , int >> ( length ); for ( int i = 0 ; i < length ; ++ i ) map [ i ][ 0 ] = 0 ; } void set ( int index , int val ) { map [ index ][ snap_id ] = val ; } int snap () { return snap_id ++ ; } int get ( int index , int snap_id ) { auto it = map [ index ]. upper_bound ( snap_id ); return prev ( it ) -> second ; } private : vector < std :: map < int , int >> map ; int snap_id = 0 ; }; 1147. Longest Chunked Palindrome Decomposition $\\star\\star\\star$ 1148. Article Views I $\\star$ \ud83d\udd12 1149. Article Views II $\\star\\star$ \ud83d\udd12 1150. Check If a Number Is Majority Element in a Sorted Array $\\star$ \ud83d\udd12","title":"1141-1150"},{"location":"cpp/1101-1200/1141-1150/#1141-user-activity-for-the-past-30-days-i-star","text":"","title":"1141. User Activity for the Past 30 Days I $\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1141-1150/#1142-user-activity-for-the-past-30-days-ii-star","text":"","title":"1142. User Activity for the Past 30 Days II $\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1141-1150/#1143-longest-common-subsequence-starstar","text":"","title":"1143. Longest Common Subsequence $\\star\\star$"},{"location":"cpp/1101-1200/1141-1150/#1144-decrease-elements-to-make-array-zigzag-starstar","text":"class Solution { public : int movesToMakeZigzag ( vector < int >& nums ) { vector < int > decreasing ( 2 ); for ( int i = 0 ; i < nums . size (); ++ i ) { int l = i > 0 ? nums [ i - 1 ] : 1001 ; int r = i + 1 < nums . size () ? nums [ i + 1 ] : 1001 ; decreasing [ i % 2 ] += max ( 0 , nums [ i ] - min ( l , r ) + 1 ); } return min ( decreasing [ 0 ], decreasing [ 1 ]); } };","title":"1144. Decrease Elements To Make Array Zigzag $\\star\\star$"},{"location":"cpp/1101-1200/1141-1150/#1145-binary-tree-coloring-game-starstar","text":"","title":"1145. Binary Tree Coloring Game $\\star\\star$"},{"location":"cpp/1101-1200/1141-1150/#1146-snapshot-array-starstar","text":"class SnapshotArray { public : SnapshotArray ( int length ) { map = vector < std :: map < int , int >> ( length ); for ( int i = 0 ; i < length ; ++ i ) map [ i ][ 0 ] = 0 ; } void set ( int index , int val ) { map [ index ][ snap_id ] = val ; } int snap () { return snap_id ++ ; } int get ( int index , int snap_id ) { auto it = map [ index ]. upper_bound ( snap_id ); return prev ( it ) -> second ; } private : vector < std :: map < int , int >> map ; int snap_id = 0 ; };","title":"1146. Snapshot Array $\\star\\star$"},{"location":"cpp/1101-1200/1141-1150/#1147-longest-chunked-palindrome-decomposition-starstarstar","text":"","title":"1147. Longest Chunked Palindrome Decomposition $\\star\\star\\star$"},{"location":"cpp/1101-1200/1141-1150/#1148-article-views-i-star","text":"","title":"1148. Article Views I $\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1141-1150/#1149-article-views-ii-starstar","text":"","title":"1149. Article Views II $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1141-1150/#1150-check-if-a-number-is-majority-element-in-a-sorted-array-star","text":"","title":"1150. Check If a Number Is Majority Element in a Sorted Array $\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1151-1160/","text":"1151. Minimum Swaps to Group All 1's Together $\\star\\star$ \ud83d\udd12 1152. Analyze User Website Visit Pattern $\\star\\star$ \ud83d\udd12 1153. String Transforms Into Another String $\\star\\star\\star$ \ud83d\udd12 1154. Day of the Year $\\star$ class Solution { public : int dayOfYear ( string date ) { int year = stoi ( date . substr ( 0 , 4 )); int month = stoi ( date . substr ( 5 , 2 )); int day = stoi ( date . substr ( 8 )); vector < int > days = { 31 , isLeapYear ( year ) ? 29 : 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 }; return accumulate ( begin ( days ), begin ( days ) + month - 1 , 0 ) + day ; } private : bool isLeapYear ( int year ) { return ( year % 4 == 0 && year % 100 != 0 ) || year % 400 == 0 ; } }; 1155. Number of Dice Rolls With Target Sum $\\star\\star$ class Solution { public : int numRollsToTarget ( int d , int f , int target ) { const int kMod = 1e9 + 7 ; vector < int > dp ( target + 1 ); dp [ 0 ] = 1 ; while ( d -- ) { // d dices vector < int > newDp ( target + 1 ); for ( int i = 1 ; i <= f ; ++ i ) // number 1, 2, ..., f for ( int t = i ; t <= target ; ++ t ) // possible targets newDp [ t ] = ( newDp [ t ] + dp [ t - i ]) % kMod ; swap ( dp , newDp ); } return dp [ target ]; } }; 1156. Swap For Longest Repeated Character Substring $\\star\\star$ class Solution { public : int maxRepOpt1 ( string text ) { int ans = 0 ; vector < int > count ( 26 ); vector < pair < char , int >> groups {{ text [ 0 ], 1 }}; for ( char c : text ) ++ count [ c - 'a' ]; for ( int i = 1 ; i < text . length (); ++ i ) if ( text [ i ] == text [ i - 1 ]) ++ groups [ groups . size () - 1 ]. second ; else groups . push_back ({ text [ i ], 1 }); for ( const auto & [ c , length ] : groups ) ans = max ( ans , min ( length + 1 , count [ c - 'a' ])); for ( int i = 1 ; i + 1 < groups . size (); ++ i ) if ( groups [ i - 1 ]. first == groups [ i + 1 ]. first && groups [ i ]. second == 1 ) ans = max ( ans , min ( groups [ i - 1 ]. second + groups [ i + 1 ]. second + 1 , count [ groups [ i - 1 ]. first - 'a' ])); return ans ; } }; 1157. Online Majority Element In Subarray $\\star\\star\\star$ class MajorityChecker { public : MajorityChecker ( vector < int >& arr ) { for ( int i = 0 ; i < arr . size (); ++ i ) map [ arr [ i ]]. push_back ( i ); } int query ( int left , int right , int threshold ) { for ( auto & [ num , indices ] : map ) { if ( indices . size () < threshold ) continue ; auto it1 = lower_bound ( indices . begin (), indices . end (), left ); auto it2 = upper_bound ( indices . begin (), indices . end (), right ); if ( it2 - it1 >= threshold ) return num ; } return - 1 ; } private : unordered_map < int , vector < int >> map ; }; 1158. Market Analysis I $\\star\\star$ \ud83d\udd12 1159. Market Analysis II $\\star\\star\\star$ \ud83d\udd12 1160. Find Words That Can Be Formed by Characters $\\star$ class Solution { public : int countCharacters ( vector < string >& words , string chars ) { int ans = 0 ; vector < int > count ( 26 ); for ( char c : chars ) ++ count [ c - 'a' ]; for ( const string & word : words ) { vector < int > tempCount = count ; for ( char c : word ) if ( -- tempCount [ c - 'a' ] < 0 ) { ans -= word . length (); break ; } ans += word . length (); } return ans ; } };","title":"1151-1160"},{"location":"cpp/1101-1200/1151-1160/#1151-minimum-swaps-to-group-all-1s-together-starstar","text":"","title":"1151. Minimum Swaps to Group All 1's Together $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1151-1160/#1152-analyze-user-website-visit-pattern-starstar","text":"","title":"1152. Analyze User Website Visit Pattern $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1151-1160/#1153-string-transforms-into-another-string-starstarstar","text":"","title":"1153. String Transforms Into Another String $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1151-1160/#1154-day-of-the-year-star","text":"class Solution { public : int dayOfYear ( string date ) { int year = stoi ( date . substr ( 0 , 4 )); int month = stoi ( date . substr ( 5 , 2 )); int day = stoi ( date . substr ( 8 )); vector < int > days = { 31 , isLeapYear ( year ) ? 29 : 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 }; return accumulate ( begin ( days ), begin ( days ) + month - 1 , 0 ) + day ; } private : bool isLeapYear ( int year ) { return ( year % 4 == 0 && year % 100 != 0 ) || year % 400 == 0 ; } };","title":"1154. Day of the Year $\\star$"},{"location":"cpp/1101-1200/1151-1160/#1155-number-of-dice-rolls-with-target-sum-starstar","text":"class Solution { public : int numRollsToTarget ( int d , int f , int target ) { const int kMod = 1e9 + 7 ; vector < int > dp ( target + 1 ); dp [ 0 ] = 1 ; while ( d -- ) { // d dices vector < int > newDp ( target + 1 ); for ( int i = 1 ; i <= f ; ++ i ) // number 1, 2, ..., f for ( int t = i ; t <= target ; ++ t ) // possible targets newDp [ t ] = ( newDp [ t ] + dp [ t - i ]) % kMod ; swap ( dp , newDp ); } return dp [ target ]; } };","title":"1155. Number of Dice Rolls With Target Sum $\\star\\star$"},{"location":"cpp/1101-1200/1151-1160/#1156-swap-for-longest-repeated-character-substring-starstar","text":"class Solution { public : int maxRepOpt1 ( string text ) { int ans = 0 ; vector < int > count ( 26 ); vector < pair < char , int >> groups {{ text [ 0 ], 1 }}; for ( char c : text ) ++ count [ c - 'a' ]; for ( int i = 1 ; i < text . length (); ++ i ) if ( text [ i ] == text [ i - 1 ]) ++ groups [ groups . size () - 1 ]. second ; else groups . push_back ({ text [ i ], 1 }); for ( const auto & [ c , length ] : groups ) ans = max ( ans , min ( length + 1 , count [ c - 'a' ])); for ( int i = 1 ; i + 1 < groups . size (); ++ i ) if ( groups [ i - 1 ]. first == groups [ i + 1 ]. first && groups [ i ]. second == 1 ) ans = max ( ans , min ( groups [ i - 1 ]. second + groups [ i + 1 ]. second + 1 , count [ groups [ i - 1 ]. first - 'a' ])); return ans ; } };","title":"1156. Swap For Longest Repeated Character Substring $\\star\\star$"},{"location":"cpp/1101-1200/1151-1160/#1157-online-majority-element-in-subarray-starstarstar","text":"class MajorityChecker { public : MajorityChecker ( vector < int >& arr ) { for ( int i = 0 ; i < arr . size (); ++ i ) map [ arr [ i ]]. push_back ( i ); } int query ( int left , int right , int threshold ) { for ( auto & [ num , indices ] : map ) { if ( indices . size () < threshold ) continue ; auto it1 = lower_bound ( indices . begin (), indices . end (), left ); auto it2 = upper_bound ( indices . begin (), indices . end (), right ); if ( it2 - it1 >= threshold ) return num ; } return - 1 ; } private : unordered_map < int , vector < int >> map ; };","title":"1157. Online Majority Element In Subarray $\\star\\star\\star$"},{"location":"cpp/1101-1200/1151-1160/#1158-market-analysis-i-starstar","text":"","title":"1158. Market Analysis I $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1151-1160/#1159-market-analysis-ii-starstarstar","text":"","title":"1159. Market Analysis II $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1151-1160/#1160-find-words-that-can-be-formed-by-characters-star","text":"class Solution { public : int countCharacters ( vector < string >& words , string chars ) { int ans = 0 ; vector < int > count ( 26 ); for ( char c : chars ) ++ count [ c - 'a' ]; for ( const string & word : words ) { vector < int > tempCount = count ; for ( char c : word ) if ( -- tempCount [ c - 'a' ] < 0 ) { ans -= word . length (); break ; } ans += word . length (); } return ans ; } };","title":"1160. Find Words That Can Be Formed by Characters $\\star$"},{"location":"cpp/1101-1200/1161-1170/","text":"1161. Maximum Level Sum of a Binary Tree $\\star\\star$ 1162. As Far from Land as Possible $\\star\\star$ 1163. Last Substring in Lexicographical Order $\\star\\star\\star$ 1164. Product Price at a Given Date $\\star\\star$ \ud83d\udd12 1165. Single-Row Keyboard $\\star$ \ud83d\udd12 1166. Design File System $\\star\\star$ \ud83d\udd12 1167. Minimum Cost to Connect Sticks $\\star\\star$ \ud83d\udd12 1168. Optimize Water Distribution in a Village $\\star\\star\\star$ \ud83d\udd12 1169. Invalid Transactions $\\star\\star$ class Solution { public : vector < string > invalidTransactions ( vector < string >& transactions ) { unordered_set < string > ans ; unordered_map < string , vector < vector < string >>> nameToTransactions ; for ( const string & transaction : transactions ) { istringstream ss ( transaction ); vector < string > token ( 4 , \"\" ); for ( int i = 0 ; getline ( ss , token [ i ++ ], ',' );) ; if ( stoi ( token [ 2 ]) > 1000 ) ans . insert ( transaction ); for ( const auto & val : nameToTransactions [ token [ 0 ]]) if ( abs ( stoi ( val [ 1 ]) - stoi ( token [ 1 ])) <= 60 && val [ 3 ] != token [ 3 ]) { ans . insert ( transaction ); ans . insert ( val [ 0 ] + \",\" + val [ 1 ] + \",\" + val [ 2 ] + \",\" + val [ 3 ]); } nameToTransactions [ token [ 0 ]]. push_back ( { token [ 0 ], token [ 1 ], token [ 2 ], token [ 3 ]}); } return { begin ( ans ), end ( ans )}; } }; 1170. Compare Strings by Frequency of the Smallest Character $\\star$ class Solution { public : vector < int > numSmallerByFrequency ( vector < string >& queries , vector < string >& words ) { vector < int > ans ; vector < int > wordsFreq ; for ( const string & word : words ) wordsFreq . push_back ( f ( word )); sort ( begin ( wordsFreq ), end ( wordsFreq )); for ( const string & query : queries ) { int freq = f ( query ); ans . push_back ( end ( wordsFreq ) - upper_bound ( begin ( wordsFreq ), end ( wordsFreq ), freq )); } return ans ; } private : int f ( const string & word ) { int count = 0 ; char currentChar = 'z' + 1 ; for ( char c : word ) if ( c < currentChar ) { currentChar = c ; count = 1 ; } else if ( c == currentChar ) ++ count ; return count ; } };","title":"1161-1170"},{"location":"cpp/1101-1200/1161-1170/#1161-maximum-level-sum-of-a-binary-tree-starstar","text":"","title":"1161. Maximum Level Sum of a Binary Tree $\\star\\star$"},{"location":"cpp/1101-1200/1161-1170/#1162-as-far-from-land-as-possible-starstar","text":"","title":"1162. As Far from Land as Possible $\\star\\star$"},{"location":"cpp/1101-1200/1161-1170/#1163-last-substring-in-lexicographical-order-starstarstar","text":"","title":"1163. Last Substring in Lexicographical Order $\\star\\star\\star$"},{"location":"cpp/1101-1200/1161-1170/#1164-product-price-at-a-given-date-starstar","text":"","title":"1164. Product Price at a Given Date $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1161-1170/#1165-single-row-keyboard-star","text":"","title":"1165. Single-Row Keyboard $\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1161-1170/#1166-design-file-system-starstar","text":"","title":"1166. Design File System $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1161-1170/#1167-minimum-cost-to-connect-sticks-starstar","text":"","title":"1167. Minimum Cost to Connect Sticks $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1161-1170/#1168-optimize-water-distribution-in-a-village-starstarstar","text":"","title":"1168. Optimize Water Distribution in a Village $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1161-1170/#1169-invalid-transactions-starstar","text":"class Solution { public : vector < string > invalidTransactions ( vector < string >& transactions ) { unordered_set < string > ans ; unordered_map < string , vector < vector < string >>> nameToTransactions ; for ( const string & transaction : transactions ) { istringstream ss ( transaction ); vector < string > token ( 4 , \"\" ); for ( int i = 0 ; getline ( ss , token [ i ++ ], ',' );) ; if ( stoi ( token [ 2 ]) > 1000 ) ans . insert ( transaction ); for ( const auto & val : nameToTransactions [ token [ 0 ]]) if ( abs ( stoi ( val [ 1 ]) - stoi ( token [ 1 ])) <= 60 && val [ 3 ] != token [ 3 ]) { ans . insert ( transaction ); ans . insert ( val [ 0 ] + \",\" + val [ 1 ] + \",\" + val [ 2 ] + \",\" + val [ 3 ]); } nameToTransactions [ token [ 0 ]]. push_back ( { token [ 0 ], token [ 1 ], token [ 2 ], token [ 3 ]}); } return { begin ( ans ), end ( ans )}; } };","title":"1169. Invalid Transactions $\\star\\star$"},{"location":"cpp/1101-1200/1161-1170/#1170-compare-strings-by-frequency-of-the-smallest-character-star","text":"class Solution { public : vector < int > numSmallerByFrequency ( vector < string >& queries , vector < string >& words ) { vector < int > ans ; vector < int > wordsFreq ; for ( const string & word : words ) wordsFreq . push_back ( f ( word )); sort ( begin ( wordsFreq ), end ( wordsFreq )); for ( const string & query : queries ) { int freq = f ( query ); ans . push_back ( end ( wordsFreq ) - upper_bound ( begin ( wordsFreq ), end ( wordsFreq ), freq )); } return ans ; } private : int f ( const string & word ) { int count = 0 ; char currentChar = 'z' + 1 ; for ( char c : word ) if ( c < currentChar ) { currentChar = c ; count = 1 ; } else if ( c == currentChar ) ++ count ; return count ; } };","title":"1170. Compare Strings by Frequency of the Smallest Character $\\star$"},{"location":"cpp/1101-1200/1171-1180/","text":"1171. Remove Zero Sum Consecutive Nodes from Linked List $\\star\\star$ class Solution { public : ListNode * removeZeroSumSublists ( ListNode * head ) { ListNode dummy ( 0 ); dummy . next = head ; int prefixSum = 0 ; unordered_map < int , ListNode *> prefixSumToNode ; prefixSumToNode [ 0 ] = & dummy ; for (; head ; head = head -> next ) { prefixSum += head -> val ; prefixSumToNode [ prefixSum ] = head ; } prefixSum = 0 ; for ( head = & dummy ; head ; head = head -> next ) { prefixSum += head -> val ; head -> next = prefixSumToNode [ prefixSum ] -> next ; } return dummy . next ; } }; 1172. Dinner Plate Stacks $\\star\\star\\star$ 1173. Immediate Food Delivery I $\\star$ \ud83d\udd12 1174. Immediate Food Delivery II $\\star\\star$ \ud83d\udd12 1175. Prime Arrangements $\\star$ class Solution { public : int numPrimeArrangements ( int n ) { const int kMod = 1e9 + 7 ; int count = countPrimes ( n ); return ( factorial ( count , kMod ) * factorial ( n - count , kMod )) % kMod ; } private : int countPrimes ( int n ) { vector < bool > prime ( n + 1 , true ); prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int i = 0 ; i <= sqrt ( n ); ++ i ) if ( prime [ i ]) for ( int j = i * i ; j <= n ; j += i ) prime [ j ] = false ; return count ( begin ( prime ), end ( prime ), true ); } long factorial ( int n , const int kMod ) { long fact = 1 ; for ( int i = 1 ; i <= n ; ++ i ) fact = fact * i % kMod ; return fact ; } }; 1176. Diet Plan Performance $\\star$ \ud83d\udd12 1177. Can Make Palindrome from Substring $\\star\\star$ class Solution { public : vector < bool > canMakePaliQueries ( string s , vector < vector < int >>& queries ) { vector < bool > ans ; vector < int > dp ( s . length () + 1 ); for ( int i = 1 ; i <= s . length (); ++ i ) dp [ i ] = dp [ i - 1 ] ^ ( 1 << s [ i - 1 ] - 'a' ); for ( vector < int >& query : queries ) { int odds = __builtin_popcount ( dp [ query [ 1 ] + 1 ] ^ dp [ query [ 0 ]]); ans . push_back ( odds / 2 <= query [ 2 ]); } return ans ; } }; 1178. Number of Valid Words for Each Puzzle $\\star\\star\\star$ class Solution { public : vector < int > findNumOfValidWords ( vector < string >& words , vector < string >& puzzles ) { vector < int > ans ; unordered_map < int , int > binaryCount ; for ( const string & word : words ) { int mask = 0 ; for ( char c : word ) mask |= 1 << ( c - 'a' ); ++ binaryCount [ mask ]; } for ( const string & puzzle : puzzles ) { int valid = 0 ; const int n = puzzle . length () - 1 ; for ( int i = 0 ; i < ( 1 << n ); ++ i ) { int mask = 1 << ( puzzle [ 0 ] - 'a' ); for ( int j = 0 ; j < n ; ++ j ) if ( i & ( 1 << j )) mask |= 1 << ( puzzle [ j + 1 ] - 'a' ); if ( binaryCount . count ( mask )) valid += binaryCount [ mask ]; } ans . push_back ( valid ); } return ans ; } }; 1179. Reformat Department Table $\\star$ 1180. Count Substrings with Only One Distinct Letter $\\star$ \ud83d\udd12","title":"1171-1180"},{"location":"cpp/1101-1200/1171-1180/#1171-remove-zero-sum-consecutive-nodes-from-linked-list-starstar","text":"class Solution { public : ListNode * removeZeroSumSublists ( ListNode * head ) { ListNode dummy ( 0 ); dummy . next = head ; int prefixSum = 0 ; unordered_map < int , ListNode *> prefixSumToNode ; prefixSumToNode [ 0 ] = & dummy ; for (; head ; head = head -> next ) { prefixSum += head -> val ; prefixSumToNode [ prefixSum ] = head ; } prefixSum = 0 ; for ( head = & dummy ; head ; head = head -> next ) { prefixSum += head -> val ; head -> next = prefixSumToNode [ prefixSum ] -> next ; } return dummy . next ; } };","title":"1171. Remove Zero Sum Consecutive Nodes from Linked List $\\star\\star$"},{"location":"cpp/1101-1200/1171-1180/#1172-dinner-plate-stacks-starstarstar","text":"","title":"1172. Dinner Plate Stacks $\\star\\star\\star$"},{"location":"cpp/1101-1200/1171-1180/#1173-immediate-food-delivery-i-star","text":"","title":"1173. Immediate Food Delivery I $\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1171-1180/#1174-immediate-food-delivery-ii-starstar","text":"","title":"1174. Immediate Food Delivery II $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1171-1180/#1175-prime-arrangements-star","text":"class Solution { public : int numPrimeArrangements ( int n ) { const int kMod = 1e9 + 7 ; int count = countPrimes ( n ); return ( factorial ( count , kMod ) * factorial ( n - count , kMod )) % kMod ; } private : int countPrimes ( int n ) { vector < bool > prime ( n + 1 , true ); prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int i = 0 ; i <= sqrt ( n ); ++ i ) if ( prime [ i ]) for ( int j = i * i ; j <= n ; j += i ) prime [ j ] = false ; return count ( begin ( prime ), end ( prime ), true ); } long factorial ( int n , const int kMod ) { long fact = 1 ; for ( int i = 1 ; i <= n ; ++ i ) fact = fact * i % kMod ; return fact ; } };","title":"1175. Prime Arrangements $\\star$"},{"location":"cpp/1101-1200/1171-1180/#1176-diet-plan-performance-star","text":"","title":"1176. Diet Plan Performance $\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1171-1180/#1177-can-make-palindrome-from-substring-starstar","text":"class Solution { public : vector < bool > canMakePaliQueries ( string s , vector < vector < int >>& queries ) { vector < bool > ans ; vector < int > dp ( s . length () + 1 ); for ( int i = 1 ; i <= s . length (); ++ i ) dp [ i ] = dp [ i - 1 ] ^ ( 1 << s [ i - 1 ] - 'a' ); for ( vector < int >& query : queries ) { int odds = __builtin_popcount ( dp [ query [ 1 ] + 1 ] ^ dp [ query [ 0 ]]); ans . push_back ( odds / 2 <= query [ 2 ]); } return ans ; } };","title":"1177. Can Make Palindrome from Substring $\\star\\star$"},{"location":"cpp/1101-1200/1171-1180/#1178-number-of-valid-words-for-each-puzzle-starstarstar","text":"class Solution { public : vector < int > findNumOfValidWords ( vector < string >& words , vector < string >& puzzles ) { vector < int > ans ; unordered_map < int , int > binaryCount ; for ( const string & word : words ) { int mask = 0 ; for ( char c : word ) mask |= 1 << ( c - 'a' ); ++ binaryCount [ mask ]; } for ( const string & puzzle : puzzles ) { int valid = 0 ; const int n = puzzle . length () - 1 ; for ( int i = 0 ; i < ( 1 << n ); ++ i ) { int mask = 1 << ( puzzle [ 0 ] - 'a' ); for ( int j = 0 ; j < n ; ++ j ) if ( i & ( 1 << j )) mask |= 1 << ( puzzle [ j + 1 ] - 'a' ); if ( binaryCount . count ( mask )) valid += binaryCount [ mask ]; } ans . push_back ( valid ); } return ans ; } };","title":"1178. Number of Valid Words for Each Puzzle $\\star\\star\\star$"},{"location":"cpp/1101-1200/1171-1180/#1179-reformat-department-table-star","text":"","title":"1179. Reformat Department Table $\\star$"},{"location":"cpp/1101-1200/1171-1180/#1180-count-substrings-with-only-one-distinct-letter-star","text":"","title":"1180. Count Substrings with Only One Distinct Letter $\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1181-1190/","text":"1181. Before and After Puzzle $\\star\\star$ \ud83d\udd12 1182. Shortest Distance to Target Color $\\star\\star$ \ud83d\udd12 1183. Maximum Number of Ones $\\star\\star\\star$ \ud83d\udd12 1184. Distance Between Bus Stops $\\star$ class Solution { public : int distanceBetweenBusStops ( vector < int >& distance , int start , int destination ) { int clockwise = 0 ; int counterclockwise = 0 ; if ( start > destination ) swap ( start , destination ); for ( int i = 0 ; i < distance . size (); ++ i ) { if ( i >= start && i < destination ) clockwise += distance [ i ]; else counterclockwise += distance [ i ]; } return min ( clockwise , counterclockwise ); } }; 1185. Day of the Week $\\star$ class Solution { public : string dayOfTheWeek ( int day , int month , int year ) { vector < string > week = { \"Sunday\" , \"Monday\" , \"Tuesday\" , \"Wednesday\" , \"Thursday\" , \"Friday\" , \"Saturday\" }; vector < int > days = { 31 , isLeapYear ( year ) ? 29 : 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 }; int count = 0 ; for ( int i = 1971 ; i < year ; ++ i ) count += i % 4 == 0 ? 366 : 365 ; for ( int i = 0 ; i < month - 1 ; ++ i ) count += days [ i ]; count += day ; return week [( count + 4 ) % 7 ]; } private : bool isLeapYear ( int year ) { return ( year % 4 == 0 && year % 100 != 0 ) || year % 400 == 0 ; } }; 1186. Maximum Subarray Sum with One Deletion $\\star\\star$ 1187. Make Array Strictly Increasing $\\star\\star\\star$ 1188. Design Bounded Blocking Queue $\\star\\star$ \ud83d\udd12 1189. Maximum Number of Balloons $\\star$ class Solution { public : int maxNumberOfBalloons ( string text ) { int ans = INT_MAX ; vector < int > count ( 26 ); for ( char c : text ) ++ count [ c - 'a' ]; for ( char c : string ( \"ban\" )) ans = min ( ans , count [ c - 'a' ]); for ( char c : string ( \"lo\" )) ans = min ( ans , count [ c - 'a' ] / 2 ); return ans ; } }; 1190. Reverse Substrings Between Each Pair of Parentheses $\\star\\star$","title":"1181-1190"},{"location":"cpp/1101-1200/1181-1190/#1181-before-and-after-puzzle-starstar","text":"","title":"1181. Before and After Puzzle $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1181-1190/#1182-shortest-distance-to-target-color-starstar","text":"","title":"1182. Shortest Distance to Target Color $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1181-1190/#1183-maximum-number-of-ones-starstarstar","text":"","title":"1183. Maximum Number of Ones $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1181-1190/#1184-distance-between-bus-stops-star","text":"class Solution { public : int distanceBetweenBusStops ( vector < int >& distance , int start , int destination ) { int clockwise = 0 ; int counterclockwise = 0 ; if ( start > destination ) swap ( start , destination ); for ( int i = 0 ; i < distance . size (); ++ i ) { if ( i >= start && i < destination ) clockwise += distance [ i ]; else counterclockwise += distance [ i ]; } return min ( clockwise , counterclockwise ); } };","title":"1184. Distance Between Bus Stops $\\star$"},{"location":"cpp/1101-1200/1181-1190/#1185-day-of-the-week-star","text":"class Solution { public : string dayOfTheWeek ( int day , int month , int year ) { vector < string > week = { \"Sunday\" , \"Monday\" , \"Tuesday\" , \"Wednesday\" , \"Thursday\" , \"Friday\" , \"Saturday\" }; vector < int > days = { 31 , isLeapYear ( year ) ? 29 : 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 }; int count = 0 ; for ( int i = 1971 ; i < year ; ++ i ) count += i % 4 == 0 ? 366 : 365 ; for ( int i = 0 ; i < month - 1 ; ++ i ) count += days [ i ]; count += day ; return week [( count + 4 ) % 7 ]; } private : bool isLeapYear ( int year ) { return ( year % 4 == 0 && year % 100 != 0 ) || year % 400 == 0 ; } };","title":"1185. Day of the Week $\\star$"},{"location":"cpp/1101-1200/1181-1190/#1186-maximum-subarray-sum-with-one-deletion-starstar","text":"","title":"1186. Maximum Subarray Sum with One Deletion $\\star\\star$"},{"location":"cpp/1101-1200/1181-1190/#1187-make-array-strictly-increasing-starstarstar","text":"","title":"1187. Make Array Strictly Increasing $\\star\\star\\star$"},{"location":"cpp/1101-1200/1181-1190/#1188-design-bounded-blocking-queue-starstar","text":"","title":"1188. Design Bounded Blocking Queue $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1181-1190/#1189-maximum-number-of-balloons-star","text":"class Solution { public : int maxNumberOfBalloons ( string text ) { int ans = INT_MAX ; vector < int > count ( 26 ); for ( char c : text ) ++ count [ c - 'a' ]; for ( char c : string ( \"ban\" )) ans = min ( ans , count [ c - 'a' ]); for ( char c : string ( \"lo\" )) ans = min ( ans , count [ c - 'a' ] / 2 ); return ans ; } };","title":"1189. Maximum Number of Balloons $\\star$"},{"location":"cpp/1101-1200/1181-1190/#1190-reverse-substrings-between-each-pair-of-parentheses-starstar","text":"","title":"1190. Reverse Substrings Between Each Pair of Parentheses $\\star\\star$"},{"location":"cpp/1101-1200/1191-1200/","text":"1191. K-Concatenation Maximum Sum $\\star\\star$ 1192. Critical Connections in a Network $\\star\\star\\star$ 1193. Monthly Transactions I $\\star\\star$ \ud83d\udd12 1194. Tournament Winners $\\star\\star\\star$ \ud83d\udd12 1195. Fizz Buzz Multithreaded $\\star\\star$ 1196. How Many Apples Can You Put into the Basket $\\star$ \ud83d\udd12 1197. Minimum Knight Moves $\\star\\star$ \ud83d\udd12 1198. Find Smallest Common Element in All Rows $\\star\\star$ \ud83d\udd12 1199. Minimum Time to Build Blocks $\\star\\star\\star$ \ud83d\udd12 1200. Minimum Absolute Difference $\\star$ class Solution { public : vector < vector < int >> minimumAbsDifference ( vector < int >& arr ) { vector < vector < int >> ans ; int min = INT_MAX ; sort ( begin ( arr ), end ( arr )); for ( int i = 0 ; i + 1 < arr . size (); ++ i ) { int diff = arr [ i + 1 ] - arr [ i ]; if ( diff < min ) { min = diff ; ans . clear (); } if ( diff == min ) ans . push_back ({ arr [ i ], arr [ i + 1 ]}); } return ans ; } };","title":"1191-1200"},{"location":"cpp/1101-1200/1191-1200/#1191-k-concatenation-maximum-sum-starstar","text":"","title":"1191. K-Concatenation Maximum Sum $\\star\\star$"},{"location":"cpp/1101-1200/1191-1200/#1192-critical-connections-in-a-network-starstarstar","text":"","title":"1192. Critical Connections in a Network $\\star\\star\\star$"},{"location":"cpp/1101-1200/1191-1200/#1193-monthly-transactions-i-starstar","text":"","title":"1193. Monthly Transactions I $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1191-1200/#1194-tournament-winners-starstarstar","text":"","title":"1194. Tournament Winners $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1191-1200/#1195-fizz-buzz-multithreaded-starstar","text":"","title":"1195. Fizz Buzz Multithreaded $\\star\\star$"},{"location":"cpp/1101-1200/1191-1200/#1196-how-many-apples-can-you-put-into-the-basket-star","text":"","title":"1196. How Many Apples Can You Put into the Basket $\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1191-1200/#1197-minimum-knight-moves-starstar","text":"","title":"1197. Minimum Knight Moves $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1191-1200/#1198-find-smallest-common-element-in-all-rows-starstar","text":"","title":"1198. Find Smallest Common Element in All Rows $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1191-1200/#1199-minimum-time-to-build-blocks-starstarstar","text":"","title":"1199. Minimum Time to Build Blocks $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/1101-1200/1191-1200/#1200-minimum-absolute-difference-star","text":"class Solution { public : vector < vector < int >> minimumAbsDifference ( vector < int >& arr ) { vector < vector < int >> ans ; int min = INT_MAX ; sort ( begin ( arr ), end ( arr )); for ( int i = 0 ; i + 1 < arr . size (); ++ i ) { int diff = arr [ i + 1 ] - arr [ i ]; if ( diff < min ) { min = diff ; ans . clear (); } if ( diff == min ) ans . push_back ({ arr [ i ], arr [ i + 1 ]}); } return ans ; } };","title":"1200. Minimum Absolute Difference $\\star$"},{"location":"cpp/1201-1300/1201-1210/","text":"1201. Ugly Number III $\\star\\star$ class Solution { public : int nthUglyNumber ( int n , long a , long b , long c ) { long ab = a * b / __gcd ( a , b ); long ac = a * c / __gcd ( a , c ); long bc = b * c / __gcd ( b , c ); long abc = a * bc / __gcd ( a , bc ); int l = 1 ; int r = ( int ) 2 * 1e9 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( m / a + m / b + m / c - m / ab - m / ac - m / bc + m / abc < n ) l = m + 1 ; else r = m ; } return l ; } }; 1202. Smallest String With Swaps $\\star\\star$ class Solution { public : string smallestStringWithSwaps ( string s , vector < vector < int >>& pairs ) { string ans ; UF uf ( s . length ()); unordered_map < int , priority_queue < char , vector < char > , compare >> map ; for ( vector < int >& pair : pairs ) uf . union_ ( pair [ 0 ], pair [ 1 ]); for ( int i = 0 ; i < s . length (); ++ i ) map [ uf . find ( i )]. push ( s [ i ]); for ( int i = 0 ; i < s . length (); ++ i ) ans += map [ uf . find ( i )]. top (), map [ uf . find ( i )]. pop (); return ans ; } private : class UF { public : UF ( int n ) : size ( n ), id ( n ) { for ( int i = 0 ; i < n ; ++ i ) { size [ i ] = 1 ; id [ i ] = i ; } } void union_ ( int p , int q ) { int i = find ( p ); int j = find ( q ); if ( i == j ) return ; if ( size [ i ] < size [ j ]) { id [ i ] = j ; size [ j ] += size [ i ]; } else { id [ j ] = i ; size [ i ] += size [ j ]; } } int find ( int i ) { while ( i != id [ i ]) { id [ i ] = id [ id [ i ]]; i = id [ i ]; } return i ; } private : vector < int > size ; vector < int > id ; }; struct compare { bool operator ()( const char a , const char b ) { return a > b ; } }; }; 1203. Sort Items by Groups Respecting Dependencies $\\star\\star\\star$ 1204. Last Person to Fit in the Elevator $\\star\\star$ \ud83d\udd12 1205. Monthly Transactions II $\\star\\star$ \ud83d\udd12 1206. Design Skiplist $\\star\\star\\star$ 1207. Unique Number of Occurrences $\\star$ class Solution { public : bool uniqueOccurrences ( vector < int >& arr ) { unordered_map < int , int > count ; unordered_set < int > occurrences ; for ( int a : arr ) ++ count [ a ]; for ( auto && [ _ , value ] : count ) if ( ! occurrences . insert ( value ). second ) return false ; return true ; } }; 1208. Get Equal Substrings Within Budget $\\star\\star$ class Solution { public : int equalSubstring ( string s , string t , int maxCost ) { int j = 0 ; for ( int i = 0 ; i < s . length (); ++ i ) { maxCost -= abs ( s [ i ] - t [ i ]); if ( maxCost < 0 ) maxCost += abs ( s [ j ] - t [ j ++ ]); } return s . length () - j ; } }; 1209. Remove All Adjacent Duplicates in String II $\\star\\star$ 1210. Minimum Moves to Reach Target with Rotations $\\star\\star\\star$","title":"1201-1210"},{"location":"cpp/1201-1300/1201-1210/#1201-ugly-number-iii-starstar","text":"class Solution { public : int nthUglyNumber ( int n , long a , long b , long c ) { long ab = a * b / __gcd ( a , b ); long ac = a * c / __gcd ( a , c ); long bc = b * c / __gcd ( b , c ); long abc = a * bc / __gcd ( a , bc ); int l = 1 ; int r = ( int ) 2 * 1e9 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( m / a + m / b + m / c - m / ab - m / ac - m / bc + m / abc < n ) l = m + 1 ; else r = m ; } return l ; } };","title":"1201. Ugly Number III $\\star\\star$"},{"location":"cpp/1201-1300/1201-1210/#1202-smallest-string-with-swaps-starstar","text":"class Solution { public : string smallestStringWithSwaps ( string s , vector < vector < int >>& pairs ) { string ans ; UF uf ( s . length ()); unordered_map < int , priority_queue < char , vector < char > , compare >> map ; for ( vector < int >& pair : pairs ) uf . union_ ( pair [ 0 ], pair [ 1 ]); for ( int i = 0 ; i < s . length (); ++ i ) map [ uf . find ( i )]. push ( s [ i ]); for ( int i = 0 ; i < s . length (); ++ i ) ans += map [ uf . find ( i )]. top (), map [ uf . find ( i )]. pop (); return ans ; } private : class UF { public : UF ( int n ) : size ( n ), id ( n ) { for ( int i = 0 ; i < n ; ++ i ) { size [ i ] = 1 ; id [ i ] = i ; } } void union_ ( int p , int q ) { int i = find ( p ); int j = find ( q ); if ( i == j ) return ; if ( size [ i ] < size [ j ]) { id [ i ] = j ; size [ j ] += size [ i ]; } else { id [ j ] = i ; size [ i ] += size [ j ]; } } int find ( int i ) { while ( i != id [ i ]) { id [ i ] = id [ id [ i ]]; i = id [ i ]; } return i ; } private : vector < int > size ; vector < int > id ; }; struct compare { bool operator ()( const char a , const char b ) { return a > b ; } }; };","title":"1202. Smallest String With Swaps $\\star\\star$"},{"location":"cpp/1201-1300/1201-1210/#1203-sort-items-by-groups-respecting-dependencies-starstarstar","text":"","title":"1203. Sort Items by Groups Respecting Dependencies $\\star\\star\\star$"},{"location":"cpp/1201-1300/1201-1210/#1204-last-person-to-fit-in-the-elevator-starstar","text":"","title":"1204. Last Person to Fit in the Elevator $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1201-1300/1201-1210/#1205-monthly-transactions-ii-starstar","text":"","title":"1205. Monthly Transactions II $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1201-1300/1201-1210/#1206-design-skiplist-starstarstar","text":"","title":"1206. Design Skiplist $\\star\\star\\star$"},{"location":"cpp/1201-1300/1201-1210/#1207-unique-number-of-occurrences-star","text":"class Solution { public : bool uniqueOccurrences ( vector < int >& arr ) { unordered_map < int , int > count ; unordered_set < int > occurrences ; for ( int a : arr ) ++ count [ a ]; for ( auto && [ _ , value ] : count ) if ( ! occurrences . insert ( value ). second ) return false ; return true ; } };","title":"1207. Unique Number of Occurrences $\\star$"},{"location":"cpp/1201-1300/1201-1210/#1208-get-equal-substrings-within-budget-starstar","text":"class Solution { public : int equalSubstring ( string s , string t , int maxCost ) { int j = 0 ; for ( int i = 0 ; i < s . length (); ++ i ) { maxCost -= abs ( s [ i ] - t [ i ]); if ( maxCost < 0 ) maxCost += abs ( s [ j ] - t [ j ++ ]); } return s . length () - j ; } };","title":"1208. Get Equal Substrings Within Budget $\\star\\star$"},{"location":"cpp/1201-1300/1201-1210/#1209-remove-all-adjacent-duplicates-in-string-ii-starstar","text":"","title":"1209. Remove All Adjacent Duplicates in String II $\\star\\star$"},{"location":"cpp/1201-1300/1201-1210/#1210-minimum-moves-to-reach-target-with-rotations-starstarstar","text":"","title":"1210. Minimum Moves to Reach Target with Rotations $\\star\\star\\star$"},{"location":"cpp/1201-1300/1211-1220/","text":"1211. Queries Quality and Percentage $\\star$ \ud83d\udd12 1212. Team Scores in Football Tournament $\\star\\star$ \ud83d\udd12 1213. Intersection of Three Sorted Arrays $\\star$ \ud83d\udd12 1214. Two Sum BSTs $\\star\\star$ \ud83d\udd12 1215. Stepping Numbers $\\star\\star$ \ud83d\udd12 1216. Valid Palindrome III $\\star\\star\\star$ \ud83d\udd12 1217. Play with Chips $\\star$ class Solution { public : int minCostToMoveChips ( vector < int >& chips ) { vector < int > count ( 2 ); for ( int chip : chips ) ++ count [ chip % 2 ]; return min ( count [ 0 ], count [ 1 ]); } }; 1218. Longest Arithmetic Subsequence of Given Difference $\\star\\star$ class Solution { public : int longestSubsequence ( vector < int >& arr , int difference ) { int ans = 0 ; unordered_map < int , int > lengthAt ; for ( int a : arr ) { if ( lengthAt . count ( a - difference )) lengthAt [ a ] = lengthAt [ a - difference ] + 1 ; else lengthAt [ a ] = 1 ; ans = max ( ans , lengthAt [ a ]); } return ans ; } }; 1219. Path with Maximum Gold $\\star\\star$ 1220. Count Vowels Permutation $\\star\\star\\star$","title":"1211-1220"},{"location":"cpp/1201-1300/1211-1220/#1211-queries-quality-and-percentage-star","text":"","title":"1211. Queries Quality and Percentage $\\star$ \ud83d\udd12"},{"location":"cpp/1201-1300/1211-1220/#1212-team-scores-in-football-tournament-starstar","text":"","title":"1212. Team Scores in Football Tournament $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1201-1300/1211-1220/#1213-intersection-of-three-sorted-arrays-star","text":"","title":"1213. Intersection of Three Sorted Arrays $\\star$ \ud83d\udd12"},{"location":"cpp/1201-1300/1211-1220/#1214-two-sum-bsts-starstar","text":"","title":"1214. Two Sum BSTs $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1201-1300/1211-1220/#1215-stepping-numbers-starstar","text":"","title":"1215. Stepping Numbers $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1201-1300/1211-1220/#1216-valid-palindrome-iii-starstarstar","text":"","title":"1216. Valid Palindrome III $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/1201-1300/1211-1220/#1217-play-with-chips-star","text":"class Solution { public : int minCostToMoveChips ( vector < int >& chips ) { vector < int > count ( 2 ); for ( int chip : chips ) ++ count [ chip % 2 ]; return min ( count [ 0 ], count [ 1 ]); } };","title":"1217. Play with Chips $\\star$"},{"location":"cpp/1201-1300/1211-1220/#1218-longest-arithmetic-subsequence-of-given-difference-starstar","text":"class Solution { public : int longestSubsequence ( vector < int >& arr , int difference ) { int ans = 0 ; unordered_map < int , int > lengthAt ; for ( int a : arr ) { if ( lengthAt . count ( a - difference )) lengthAt [ a ] = lengthAt [ a - difference ] + 1 ; else lengthAt [ a ] = 1 ; ans = max ( ans , lengthAt [ a ]); } return ans ; } };","title":"1218. Longest Arithmetic Subsequence of Given Difference $\\star\\star$"},{"location":"cpp/1201-1300/1211-1220/#1219-path-with-maximum-gold-starstar","text":"","title":"1219. Path with Maximum Gold $\\star\\star$"},{"location":"cpp/1201-1300/1211-1220/#1220-count-vowels-permutation-starstarstar","text":"","title":"1220. Count Vowels Permutation $\\star\\star\\star$"},{"location":"cpp/1201-1300/1221-1230/","text":"1221. Split a String in Balanced Strings $\\star$ 1222. Queens That Can Attack the King $\\star\\star$ class Solution { public : vector < vector < int >> queensAttacktheKing ( vector < vector < int >>& queens , vector < int >& king ) { vector < vector < int >> ans ; unordered_set < int > queensSet ; for ( vector < int >& queen : queens ) queensSet . insert ( hash ( queen [ 0 ], queen [ 1 ])); vector < vector < int >> directions = {{ - 1 , - 1 }, { - 1 , 0 }, { - 1 , 1 }, { 0 , - 1 }, { 0 , 1 }, { 1 , - 1 }, { 1 , 0 }, { 1 , 1 }}; for ( vector < int > d : directions ) for ( int i = king [ 0 ] + d [ 0 ], j = king [ 1 ] + d [ 1 ]; 0 <= i && i < 8 && 0 <= j && j < 8 ; i += d [ 0 ], j += d [ 1 ]) if ( queensSet . count ( hash ( i , j ))) { ans . push_back ({ i , j }); break ; } return ans ; } private : int hash ( int i , int j ) { return i * 8 + j ; } }; 1223. Dice Roll Simulation $\\star\\star$ 1224. Maximum Equal Frequency $\\star\\star\\star$ class Solution { public : int maxEqualFreq ( vector < int >& nums ) { int ans = 0 ; int maxFreq = 0 ; unordered_map < int , int > count ; unordered_map < int , int > freq ; for ( int i = 0 ; i < nums . size (); ++ i ) { int num = nums [ i ]; -- freq [ count [ num ]]; ++ count [ num ]; ++ freq [ count [ num ]]; maxFreq = max ( maxFreq , count [ num ]); if ( maxFreq == 1 || maxFreq * freq [ maxFreq ] == i || ( maxFreq - 1 ) * ( freq [ maxFreq - 1 ] + 1 ) == i ) ans = i + 1 ; } return ans ; } }; 1225. Report Contiguous Dates $\\star\\star\\star$ \ud83d\udd12 1226. The Dining Philosophers $\\star\\star$ 1227. Airplane Seat Assignment Probability $\\star\\star$ class Solution { public : double nthPersonGetsNthSeat ( int n ) { return n == 1 ? 1 : 0.5 ; } }; 1228. Missing Number In Arithmetic Progression $\\star$ \ud83d\udd12 1229. Meeting Scheduler $\\star\\star$ \ud83d\udd12 1230. Toss Strange Coins $\\star\\star$ \ud83d\udd12","title":"1221-1230"},{"location":"cpp/1201-1300/1221-1230/#1221-split-a-string-in-balanced-strings-star","text":"","title":"1221. Split a String in Balanced Strings $\\star$"},{"location":"cpp/1201-1300/1221-1230/#1222-queens-that-can-attack-the-king-starstar","text":"class Solution { public : vector < vector < int >> queensAttacktheKing ( vector < vector < int >>& queens , vector < int >& king ) { vector < vector < int >> ans ; unordered_set < int > queensSet ; for ( vector < int >& queen : queens ) queensSet . insert ( hash ( queen [ 0 ], queen [ 1 ])); vector < vector < int >> directions = {{ - 1 , - 1 }, { - 1 , 0 }, { - 1 , 1 }, { 0 , - 1 }, { 0 , 1 }, { 1 , - 1 }, { 1 , 0 }, { 1 , 1 }}; for ( vector < int > d : directions ) for ( int i = king [ 0 ] + d [ 0 ], j = king [ 1 ] + d [ 1 ]; 0 <= i && i < 8 && 0 <= j && j < 8 ; i += d [ 0 ], j += d [ 1 ]) if ( queensSet . count ( hash ( i , j ))) { ans . push_back ({ i , j }); break ; } return ans ; } private : int hash ( int i , int j ) { return i * 8 + j ; } };","title":"1222. Queens That Can Attack the King $\\star\\star$"},{"location":"cpp/1201-1300/1221-1230/#1223-dice-roll-simulation-starstar","text":"","title":"1223. Dice Roll Simulation $\\star\\star$"},{"location":"cpp/1201-1300/1221-1230/#1224-maximum-equal-frequency-starstarstar","text":"class Solution { public : int maxEqualFreq ( vector < int >& nums ) { int ans = 0 ; int maxFreq = 0 ; unordered_map < int , int > count ; unordered_map < int , int > freq ; for ( int i = 0 ; i < nums . size (); ++ i ) { int num = nums [ i ]; -- freq [ count [ num ]]; ++ count [ num ]; ++ freq [ count [ num ]]; maxFreq = max ( maxFreq , count [ num ]); if ( maxFreq == 1 || maxFreq * freq [ maxFreq ] == i || ( maxFreq - 1 ) * ( freq [ maxFreq - 1 ] + 1 ) == i ) ans = i + 1 ; } return ans ; } };","title":"1224. Maximum Equal Frequency $\\star\\star\\star$"},{"location":"cpp/1201-1300/1221-1230/#1225-report-contiguous-dates-starstarstar","text":"","title":"1225. Report Contiguous Dates $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/1201-1300/1221-1230/#1226-the-dining-philosophers-starstar","text":"","title":"1226. The Dining Philosophers $\\star\\star$"},{"location":"cpp/1201-1300/1221-1230/#1227-airplane-seat-assignment-probability-starstar","text":"class Solution { public : double nthPersonGetsNthSeat ( int n ) { return n == 1 ? 1 : 0.5 ; } };","title":"1227. Airplane Seat Assignment Probability $\\star\\star$"},{"location":"cpp/1201-1300/1221-1230/#1228-missing-number-in-arithmetic-progression-star","text":"","title":"1228. Missing Number In Arithmetic Progression $\\star$ \ud83d\udd12"},{"location":"cpp/1201-1300/1221-1230/#1229-meeting-scheduler-starstar","text":"","title":"1229. Meeting Scheduler $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1201-1300/1221-1230/#1230-toss-strange-coins-starstar","text":"","title":"1230. Toss Strange Coins $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1201-1300/1231-1240/","text":"1231. Divide Chocolate $\\star\\star\\star$ \ud83d\udd12 1232. Check If It Is a Straight Line $\\star$ class Solution { public : bool checkStraightLine ( vector < vector < int >>& coordinates ) { int x0 = coordinates [ 0 ][ 0 ]; int y0 = coordinates [ 0 ][ 1 ]; int x1 = coordinates [ 1 ][ 0 ]; int y1 = coordinates [ 1 ][ 1 ]; int dx = x1 - x0 ; int dy = y1 - y0 ; for ( int i = 2 ; i < coordinates . size (); ++ i ) { int x = coordinates [ i ][ 0 ]; int y = coordinates [ i ][ 1 ]; if (( x - x0 ) * dy != ( y - y0 ) * dx ) return false ; } return true ; } }; 1233. Remove Sub-Folders from the Filesystem $\\star\\star$ class Solution { public : vector < string > removeSubfolders ( vector < string >& folder ) { vector < string > ans ; string prev ; sort ( begin ( folder ), end ( folder )); for ( const string & f : folder ) { if ( prev . length () > 0 && f . find ( prev ) == 0 && f [ prev . length ()] == '/' ) continue ; ans . push_back ( f ); prev = f ; } return ans ; } }; 1234. Replace the Substring for Balanced String $\\star\\star$ class Solution { public : int balancedString ( string s ) { const int n = s . length (); const int k = n / 4 ; int ans = n ; vector < int > count ( 128 ); for ( char c : s ) ++ count [ c ]; for ( int i = 0 , j = 0 ; i < n ; ++ i ) { -- count [ s [ i ]]; while ( j < n && count [ 'Q' ] <= k && count [ 'W' ] <= k && count [ 'E' ] <= k && count [ 'R' ] <= k ) { ans = min ( ans , i - j + 1 ); ++ count [ s [ j ]]; ++ j ; } } return ans ; } }; 1235. Maximum Profit in Job Scheduling $\\star\\star\\star$ 1236. Web Crawler $\\star\\star$ \ud83d\udd12 1237. Find Positive Integer Solution for a Given Equation $\\star$ class Solution { public : vector < vector < int >> findSolution ( CustomFunction & customfunction , int z ) { vector < vector < int >> ans ; int x = 1 ; int y = 1000 ; while ( x <= 1000 && y >= 1 ) { int f = customfunction . f ( x , y ); if ( f < z ) ++ x ; else if ( f > z ) -- y ; else ans . push_back ({ x ++ , y -- }); } return ans ; } }; 1238. Circular Permutation in Binary Representation $\\star\\star$ class Solution { public : vector < int > circularPermutation ( int n , int start ) { vector < int > ans ; for ( int i = 0 ; i < 1 << n ; ++ i ) ans . push_back ( start ^ i ^ i >> 1 ); return ans ; } }; 1239. Maximum Length of a Concatenated String with Unique Characters $\\star\\star$ 1240. Tiling a Rectangle with the Fewest Squares $\\star\\star\\star$","title":"1231-1240"},{"location":"cpp/1201-1300/1231-1240/#1231-divide-chocolate-starstarstar","text":"","title":"1231. Divide Chocolate $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/1201-1300/1231-1240/#1232-check-if-it-is-a-straight-line-star","text":"class Solution { public : bool checkStraightLine ( vector < vector < int >>& coordinates ) { int x0 = coordinates [ 0 ][ 0 ]; int y0 = coordinates [ 0 ][ 1 ]; int x1 = coordinates [ 1 ][ 0 ]; int y1 = coordinates [ 1 ][ 1 ]; int dx = x1 - x0 ; int dy = y1 - y0 ; for ( int i = 2 ; i < coordinates . size (); ++ i ) { int x = coordinates [ i ][ 0 ]; int y = coordinates [ i ][ 1 ]; if (( x - x0 ) * dy != ( y - y0 ) * dx ) return false ; } return true ; } };","title":"1232. Check If It Is a Straight Line $\\star$"},{"location":"cpp/1201-1300/1231-1240/#1233-remove-sub-folders-from-the-filesystem-starstar","text":"class Solution { public : vector < string > removeSubfolders ( vector < string >& folder ) { vector < string > ans ; string prev ; sort ( begin ( folder ), end ( folder )); for ( const string & f : folder ) { if ( prev . length () > 0 && f . find ( prev ) == 0 && f [ prev . length ()] == '/' ) continue ; ans . push_back ( f ); prev = f ; } return ans ; } };","title":"1233. Remove Sub-Folders from the Filesystem $\\star\\star$"},{"location":"cpp/1201-1300/1231-1240/#1234-replace-the-substring-for-balanced-string-starstar","text":"class Solution { public : int balancedString ( string s ) { const int n = s . length (); const int k = n / 4 ; int ans = n ; vector < int > count ( 128 ); for ( char c : s ) ++ count [ c ]; for ( int i = 0 , j = 0 ; i < n ; ++ i ) { -- count [ s [ i ]]; while ( j < n && count [ 'Q' ] <= k && count [ 'W' ] <= k && count [ 'E' ] <= k && count [ 'R' ] <= k ) { ans = min ( ans , i - j + 1 ); ++ count [ s [ j ]]; ++ j ; } } return ans ; } };","title":"1234. Replace the Substring for Balanced String $\\star\\star$"},{"location":"cpp/1201-1300/1231-1240/#1235-maximum-profit-in-job-scheduling-starstarstar","text":"","title":"1235. Maximum Profit in Job Scheduling $\\star\\star\\star$"},{"location":"cpp/1201-1300/1231-1240/#1236-web-crawler-starstar","text":"","title":"1236. Web Crawler $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1201-1300/1231-1240/#1237-find-positive-integer-solution-for-a-given-equation-star","text":"class Solution { public : vector < vector < int >> findSolution ( CustomFunction & customfunction , int z ) { vector < vector < int >> ans ; int x = 1 ; int y = 1000 ; while ( x <= 1000 && y >= 1 ) { int f = customfunction . f ( x , y ); if ( f < z ) ++ x ; else if ( f > z ) -- y ; else ans . push_back ({ x ++ , y -- }); } return ans ; } };","title":"1237. Find Positive Integer Solution for a Given Equation $\\star$"},{"location":"cpp/1201-1300/1231-1240/#1238-circular-permutation-in-binary-representation-starstar","text":"class Solution { public : vector < int > circularPermutation ( int n , int start ) { vector < int > ans ; for ( int i = 0 ; i < 1 << n ; ++ i ) ans . push_back ( start ^ i ^ i >> 1 ); return ans ; } };","title":"1238. Circular Permutation in Binary Representation $\\star\\star$"},{"location":"cpp/1201-1300/1231-1240/#1239-maximum-length-of-a-concatenated-string-with-unique-characters-starstar","text":"","title":"1239. Maximum Length of a Concatenated String with Unique Characters $\\star\\star$"},{"location":"cpp/1201-1300/1231-1240/#1240-tiling-a-rectangle-with-the-fewest-squares-starstarstar","text":"","title":"1240. Tiling a Rectangle with the Fewest Squares $\\star\\star\\star$"},{"location":"cpp/1201-1300/1241-1250/","text":"1241. Number of Comments per Post $\\star$ \ud83d\udd12 1242. Web Crawler Multithreaded $\\star\\star$ \ud83d\udd12 1243. Array Transformation $\\star$ \ud83d\udd12 1244. Design A Leaderboard $\\star\\star$ \ud83d\udd12 1245. Tree Diameter $\\star\\star$ \ud83d\udd12 1246. Palindrome Removal $\\star\\star\\star$ \ud83d\udd12 1247. Minimum Swaps to Make Strings Equal $\\star\\star$ 1248. Count Number of Nice Subarrays $\\star\\star$ class Solution { public : int numberOfSubarrays ( vector < int >& nums , int k ) { return numberOfSubarraysAtMost ( nums , k ) - numberOfSubarraysAtMost ( nums , k - 1 ); } private : int numberOfSubarraysAtMost ( vector < int >& nums , int k ) { int ans = 0 ; for ( int l = 0 , r = 0 ; r <= nums . size ();) if ( k >= 0 ) { ans += r - l ; if ( r == nums . size ()) break ; if ( nums [ r ] & 1 ) -- k ; ++ r ; } else { if ( nums [ l ] & 1 ) ++ k ; ++ l ; } return ans ; } }; 1249. Minimum Remove to Make Valid Parentheses $\\star\\star$ 1250. Check If It Is a Good Array $\\star\\star\\star$","title":"1241-1250"},{"location":"cpp/1201-1300/1241-1250/#1241-number-of-comments-per-post-star","text":"","title":"1241. Number of Comments per Post $\\star$ \ud83d\udd12"},{"location":"cpp/1201-1300/1241-1250/#1242-web-crawler-multithreaded-starstar","text":"","title":"1242. Web Crawler Multithreaded $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1201-1300/1241-1250/#1243-array-transformation-star","text":"","title":"1243. Array Transformation $\\star$ \ud83d\udd12"},{"location":"cpp/1201-1300/1241-1250/#1244-design-a-leaderboard-starstar","text":"","title":"1244. Design A Leaderboard $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1201-1300/1241-1250/#1245-tree-diameter-starstar","text":"","title":"1245. Tree Diameter $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1201-1300/1241-1250/#1246-palindrome-removal-starstarstar","text":"","title":"1246. Palindrome Removal $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/1201-1300/1241-1250/#1247-minimum-swaps-to-make-strings-equal-starstar","text":"","title":"1247. Minimum Swaps to Make Strings Equal $\\star\\star$"},{"location":"cpp/1201-1300/1241-1250/#1248-count-number-of-nice-subarrays-starstar","text":"class Solution { public : int numberOfSubarrays ( vector < int >& nums , int k ) { return numberOfSubarraysAtMost ( nums , k ) - numberOfSubarraysAtMost ( nums , k - 1 ); } private : int numberOfSubarraysAtMost ( vector < int >& nums , int k ) { int ans = 0 ; for ( int l = 0 , r = 0 ; r <= nums . size ();) if ( k >= 0 ) { ans += r - l ; if ( r == nums . size ()) break ; if ( nums [ r ] & 1 ) -- k ; ++ r ; } else { if ( nums [ l ] & 1 ) ++ k ; ++ l ; } return ans ; } };","title":"1248. Count Number of Nice Subarrays $\\star\\star$"},{"location":"cpp/1201-1300/1241-1250/#1249-minimum-remove-to-make-valid-parentheses-starstar","text":"","title":"1249. Minimum Remove to Make Valid Parentheses $\\star\\star$"},{"location":"cpp/1201-1300/1241-1250/#1250-check-if-it-is-a-good-array-starstarstar","text":"","title":"1250. Check If It Is a Good Array $\\star\\star\\star$"},{"location":"cpp/1201-1300/1251-1260/","text":"1251. Average Selling Price $\\star$ \ud83d\udd12 1252. Cells with Odd Values in a Matrix $\\star$ class Solution { public : int oddCells ( int n , int m , vector < vector < int >>& indices ) { int ans = 0 ; vector < int > rows ( n ); vector < int > cols ( m ); for ( vector < int >& indice : indices ) { rows [ indice [ 0 ]] ^= 1 ; cols [ indice [ 1 ]] ^= 1 ; } for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < m ; ++ j ) ans += rows [ i ] ^ cols [ j ]; return ans ; } }; 1253. Reconstruct a 2-Row Binary Matrix $\\star\\star$ class Solution { public : vector < vector < int >> reconstructMatrix ( int upper , int lower , vector < int >& colsum ) { if ( upper + lower != accumulate ( begin ( colsum ), end ( colsum ), 0 )) return {}; if ( min ( upper , lower ) < count_if ( begin ( colsum ), end ( colsum ), []( int c ) { return c == 2 ; })) return {}; vector < vector < int >> ans ( 2 , vector < int > ( colsum . size ())); for ( int j = 0 ; j < colsum . size (); ++ j ) if ( colsum [ j ] == 2 ) { ans [ 0 ][ j ] = 1 ; ans [ 1 ][ j ] = 1 ; -- upper ; -- lower ; } for ( int j = 0 ; j < colsum . size (); ++ j ) { if ( colsum [ j ] == 1 && upper > 0 ) { ans [ 0 ][ j ] = 1 ; -- colsum [ j ]; -- upper ; } if ( colsum [ j ] == 1 && lower > 0 ) { ans [ 1 ][ j ] = 1 ; -- lower ; } } return ans ; } }; 1254. Number of Closed Islands $\\star\\star$ 1255. Maximum Score Words Formed by Letters $\\star\\star\\star$ 1256. Encode Number $\\star\\star$ \ud83d\udd12 1257. Smallest Common Region $\\star\\star$ \ud83d\udd12 1258. Synonymous Sentences $\\star\\star$ \ud83d\udd12 1259. Handshakes That Don't Cross $\\star\\star\\star$ \ud83d\udd12 1260. Shift 2D Grid $\\star$ class Solution { public : vector < vector < int >> shiftGrid ( vector < vector < int >>& grid , int k ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); vector < vector < int >> ans ( m , vector < int > ( n )); k %= m * n ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int index = ( i * n + j + k ) % ( m * n ); int x = index / n ; int y = index % n ; ans [ x ][ y ] = grid [ i ][ j ]; } return ans ; } };","title":"1251-1260"},{"location":"cpp/1201-1300/1251-1260/#1251-average-selling-price-star","text":"","title":"1251. Average Selling Price $\\star$ \ud83d\udd12"},{"location":"cpp/1201-1300/1251-1260/#1252-cells-with-odd-values-in-a-matrix-star","text":"class Solution { public : int oddCells ( int n , int m , vector < vector < int >>& indices ) { int ans = 0 ; vector < int > rows ( n ); vector < int > cols ( m ); for ( vector < int >& indice : indices ) { rows [ indice [ 0 ]] ^= 1 ; cols [ indice [ 1 ]] ^= 1 ; } for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < m ; ++ j ) ans += rows [ i ] ^ cols [ j ]; return ans ; } };","title":"1252. Cells with Odd Values in a Matrix $\\star$"},{"location":"cpp/1201-1300/1251-1260/#1253-reconstruct-a-2-row-binary-matrix-starstar","text":"class Solution { public : vector < vector < int >> reconstructMatrix ( int upper , int lower , vector < int >& colsum ) { if ( upper + lower != accumulate ( begin ( colsum ), end ( colsum ), 0 )) return {}; if ( min ( upper , lower ) < count_if ( begin ( colsum ), end ( colsum ), []( int c ) { return c == 2 ; })) return {}; vector < vector < int >> ans ( 2 , vector < int > ( colsum . size ())); for ( int j = 0 ; j < colsum . size (); ++ j ) if ( colsum [ j ] == 2 ) { ans [ 0 ][ j ] = 1 ; ans [ 1 ][ j ] = 1 ; -- upper ; -- lower ; } for ( int j = 0 ; j < colsum . size (); ++ j ) { if ( colsum [ j ] == 1 && upper > 0 ) { ans [ 0 ][ j ] = 1 ; -- colsum [ j ]; -- upper ; } if ( colsum [ j ] == 1 && lower > 0 ) { ans [ 1 ][ j ] = 1 ; -- lower ; } } return ans ; } };","title":"1253. Reconstruct a 2-Row Binary Matrix $\\star\\star$"},{"location":"cpp/1201-1300/1251-1260/#1254-number-of-closed-islands-starstar","text":"","title":"1254. Number of Closed Islands $\\star\\star$"},{"location":"cpp/1201-1300/1251-1260/#1255-maximum-score-words-formed-by-letters-starstarstar","text":"","title":"1255. Maximum Score Words Formed by Letters $\\star\\star\\star$"},{"location":"cpp/1201-1300/1251-1260/#1256-encode-number-starstar","text":"","title":"1256. Encode Number $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1201-1300/1251-1260/#1257-smallest-common-region-starstar","text":"","title":"1257. Smallest Common Region $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1201-1300/1251-1260/#1258-synonymous-sentences-starstar","text":"","title":"1258. Synonymous Sentences $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1201-1300/1251-1260/#1259-handshakes-that-dont-cross-starstarstar","text":"","title":"1259. Handshakes That Don't Cross $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/1201-1300/1251-1260/#1260-shift-2d-grid-star","text":"class Solution { public : vector < vector < int >> shiftGrid ( vector < vector < int >>& grid , int k ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); vector < vector < int >> ans ( m , vector < int > ( n )); k %= m * n ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int index = ( i * n + j + k ) % ( m * n ); int x = index / n ; int y = index % n ; ans [ x ][ y ] = grid [ i ][ j ]; } return ans ; } };","title":"1260. Shift 2D Grid $\\star$"},{"location":"cpp/1201-1300/1261-1270/","text":"1261. Find Elements in a Contaminated Binary Tree $\\star\\star$ class FindElements { public : FindElements ( TreeNode * root ) { dfs ( root , 0 ); } bool find ( int target ) { return vals . count ( target ); } private : unordered_set < int > vals ; void dfs ( TreeNode * root , int val ) { if ( ! root ) return ; root -> val = val ; vals . insert ( val ); dfs ( root -> left , val * 2 + 1 ); dfs ( root -> right , val * 2 + 2 ); } }; 1262. Greatest Sum Divisible by Three $\\star\\star$ 1263. Minimum Moves to Move a Box to Their Target Location $\\star\\star\\star$ 1264. Page Recommendations $\\star\\star$ \ud83d\udd12 1265. Print Immutable Linked List in Reverse $\\star\\star$ \ud83d\udd12 1266. Minimum Time Visiting All Points $\\star$ class Solution { public : int minTimeToVisitAllPoints ( vector < vector < int >>& points ) { int ans = 0 ; for ( int i = 1 ; i < points . size (); ++ i ) ans += max ( abs ( points [ i ][ 0 ] - points [ i - 1 ][ 0 ]), abs ( points [ i ][ 1 ] - points [ i - 1 ][ 1 ])); return ans ; } }; 1267. Count Servers that Communicate $\\star\\star$ class Solution { public : int countServers ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); int ans = 0 ; vector < int > rows ( m ); vector < int > cols ( n ); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ][ j ] == 1 ) { ++ rows [ i ]; ++ cols [ j ]; } for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ][ j ] == 1 && ( rows [ i ] > 1 || cols [ j ] > 1 )) ++ ans ; return ans ; } }; 1268. Search Suggestions System $\\star\\star$ 1269. Number of Ways to Stay in the Same Place After Some Steps $\\star\\star\\star$ 1270. All People Report to the Given Manager $\\star\\star$ \ud83d\udd12","title":"1261-1270"},{"location":"cpp/1201-1300/1261-1270/#1261-find-elements-in-a-contaminated-binary-tree-starstar","text":"class FindElements { public : FindElements ( TreeNode * root ) { dfs ( root , 0 ); } bool find ( int target ) { return vals . count ( target ); } private : unordered_set < int > vals ; void dfs ( TreeNode * root , int val ) { if ( ! root ) return ; root -> val = val ; vals . insert ( val ); dfs ( root -> left , val * 2 + 1 ); dfs ( root -> right , val * 2 + 2 ); } };","title":"1261. Find Elements in a Contaminated Binary Tree $\\star\\star$"},{"location":"cpp/1201-1300/1261-1270/#1262-greatest-sum-divisible-by-three-starstar","text":"","title":"1262. Greatest Sum Divisible by Three $\\star\\star$"},{"location":"cpp/1201-1300/1261-1270/#1263-minimum-moves-to-move-a-box-to-their-target-location-starstarstar","text":"","title":"1263. Minimum Moves to Move a Box to Their Target Location $\\star\\star\\star$"},{"location":"cpp/1201-1300/1261-1270/#1264-page-recommendations-starstar","text":"","title":"1264. Page Recommendations $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1201-1300/1261-1270/#1265-print-immutable-linked-list-in-reverse-starstar","text":"","title":"1265. Print Immutable Linked List in Reverse $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1201-1300/1261-1270/#1266-minimum-time-visiting-all-points-star","text":"class Solution { public : int minTimeToVisitAllPoints ( vector < vector < int >>& points ) { int ans = 0 ; for ( int i = 1 ; i < points . size (); ++ i ) ans += max ( abs ( points [ i ][ 0 ] - points [ i - 1 ][ 0 ]), abs ( points [ i ][ 1 ] - points [ i - 1 ][ 1 ])); return ans ; } };","title":"1266. Minimum Time Visiting All Points $\\star$"},{"location":"cpp/1201-1300/1261-1270/#1267-count-servers-that-communicate-starstar","text":"class Solution { public : int countServers ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); int ans = 0 ; vector < int > rows ( m ); vector < int > cols ( n ); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ][ j ] == 1 ) { ++ rows [ i ]; ++ cols [ j ]; } for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ][ j ] == 1 && ( rows [ i ] > 1 || cols [ j ] > 1 )) ++ ans ; return ans ; } };","title":"1267. Count Servers that Communicate $\\star\\star$"},{"location":"cpp/1201-1300/1261-1270/#1268-search-suggestions-system-starstar","text":"","title":"1268. Search Suggestions System $\\star\\star$"},{"location":"cpp/1201-1300/1261-1270/#1269-number-of-ways-to-stay-in-the-same-place-after-some-steps-starstarstar","text":"","title":"1269. Number of Ways to Stay in the Same Place After Some Steps $\\star\\star\\star$"},{"location":"cpp/1201-1300/1261-1270/#1270-all-people-report-to-the-given-manager-starstar","text":"","title":"1270. All People Report to the Given Manager $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1201-1300/1271-1280/","text":"1271. Hexspeak $\\star$ \ud83d\udd12 1272. Remove Interval $\\star\\star$ \ud83d\udd12 1273. Delete Tree Nodes $\\star\\star$ \ud83d\udd12 1274. Number of Ships in a Rectangle $\\star\\star\\star$ \ud83d\udd12 1275. Find Winner on a Tic Tac Toe Game $\\star$ class Solution { public : string tictactoe ( vector < vector < int >>& moves ) { vector < vector < int >> row ( 2 , vector < int > ( 3 )); vector < vector < int >> col ( 2 , vector < int > ( 3 )); vector < int > diag1 ( 2 ); vector < int > diag2 ( 2 ); for ( int i = 0 ; i < moves . size (); ++ i ) { int r = moves [ i ][ 0 ]; int c = moves [ i ][ 1 ]; int j = i % 2 ; if ( ++ row [ j ][ r ] == 3 || ++ col [ j ][ c ] == 3 || r == c && ++ diag1 [ j ] == 3 || r + c == 2 && ++ diag2 [ j ] == 3 ) return j == 0 ? \"A\" : \"B\" ; } return moves . size () == 9 ? \"Draw\" : \"Pending\" ; } }; 1276. Number of Burgers with No Waste of Ingredients $\\star\\star$ class Solution { public : vector < int > numOfBurgers ( int tomatoSlices , int cheeseSlices ) { if ( tomatoSlices % 2 == 1 || tomatoSlices < 2 * cheeseSlices || tomatoSlices > cheeseSlices * 4 ) return {}; int jumboBurgers = ( tomatoSlices - 2 * cheeseSlices ) / 2 ; return { jumboBurgers , cheeseSlices - jumboBurgers }; } }; 1277. Count Square Submatrices with All Ones $\\star\\star$ class Solution { public : int countSquares ( vector < vector < int >>& matrix ) { int ans = 0 ; for ( int i = 0 ; i < matrix . size (); ++ i ) for ( int j = 0 ; j < matrix [ 0 ]. size (); ++ j ) { if ( matrix [ i ][ j ] == 1 && i > 0 && j > 0 ) matrix [ i ][ j ] += min ({ matrix [ i - 1 ][ j - 1 ], matrix [ i - 1 ][ j ], matrix [ i ][ j - 1 ]}); ans += matrix [ i ][ j ]; } return ans ; } }; 1278. Palindrome Partitioning III $\\star\\star\\star$ class Solution { public : int palindromePartition ( string s , int K ) { const int n = s . length (); vector < vector < int >> cost ( n , vector < int > ( n )); vector < vector < int >> dp ( K + 1 , vector < int > ( n + 1 , n )); for ( int length = 2 ; length <= n ; ++ length ) for ( int i = 0 , j = length - 1 ; j < n ; ++ i , ++ j ) cost [ i ][ j ] = ( s [ i ] != s [ j ]) + cost [ i + 1 ][ j - 1 ]; for ( int i = 1 ; i <= n ; ++ i ) dp [ 1 ][ i ] = cost [ 0 ][ i - 1 ]; for ( int k = 2 ; k <= K ; ++ k ) for ( int i = k ; i <= n ; ++ i ) for ( int j = k - 1 ; j < i ; ++ j ) dp [ k ][ i ] = min ( dp [ k ][ i ], dp [ k - 1 ][ j ] + cost [ j ][ i - 1 ]); return dp [ K ][ n ]; } }; 1279. Traffic Light Controlled Intersection $\\star$ \ud83d\udd12 1280. Students and Examinations $\\star$ \ud83d\udd12","title":"1271-1280"},{"location":"cpp/1201-1300/1271-1280/#1271-hexspeak-star","text":"","title":"1271. Hexspeak $\\star$ \ud83d\udd12"},{"location":"cpp/1201-1300/1271-1280/#1272-remove-interval-starstar","text":"","title":"1272. Remove Interval $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1201-1300/1271-1280/#1273-delete-tree-nodes-starstar","text":"","title":"1273. Delete Tree Nodes $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1201-1300/1271-1280/#1274-number-of-ships-in-a-rectangle-starstarstar","text":"","title":"1274. Number of Ships in a Rectangle $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/1201-1300/1271-1280/#1275-find-winner-on-a-tic-tac-toe-game-star","text":"class Solution { public : string tictactoe ( vector < vector < int >>& moves ) { vector < vector < int >> row ( 2 , vector < int > ( 3 )); vector < vector < int >> col ( 2 , vector < int > ( 3 )); vector < int > diag1 ( 2 ); vector < int > diag2 ( 2 ); for ( int i = 0 ; i < moves . size (); ++ i ) { int r = moves [ i ][ 0 ]; int c = moves [ i ][ 1 ]; int j = i % 2 ; if ( ++ row [ j ][ r ] == 3 || ++ col [ j ][ c ] == 3 || r == c && ++ diag1 [ j ] == 3 || r + c == 2 && ++ diag2 [ j ] == 3 ) return j == 0 ? \"A\" : \"B\" ; } return moves . size () == 9 ? \"Draw\" : \"Pending\" ; } };","title":"1275. Find Winner on a Tic Tac Toe Game $\\star$"},{"location":"cpp/1201-1300/1271-1280/#1276-number-of-burgers-with-no-waste-of-ingredients-starstar","text":"class Solution { public : vector < int > numOfBurgers ( int tomatoSlices , int cheeseSlices ) { if ( tomatoSlices % 2 == 1 || tomatoSlices < 2 * cheeseSlices || tomatoSlices > cheeseSlices * 4 ) return {}; int jumboBurgers = ( tomatoSlices - 2 * cheeseSlices ) / 2 ; return { jumboBurgers , cheeseSlices - jumboBurgers }; } };","title":"1276. Number of Burgers with No Waste of Ingredients $\\star\\star$"},{"location":"cpp/1201-1300/1271-1280/#1277-count-square-submatrices-with-all-ones-starstar","text":"class Solution { public : int countSquares ( vector < vector < int >>& matrix ) { int ans = 0 ; for ( int i = 0 ; i < matrix . size (); ++ i ) for ( int j = 0 ; j < matrix [ 0 ]. size (); ++ j ) { if ( matrix [ i ][ j ] == 1 && i > 0 && j > 0 ) matrix [ i ][ j ] += min ({ matrix [ i - 1 ][ j - 1 ], matrix [ i - 1 ][ j ], matrix [ i ][ j - 1 ]}); ans += matrix [ i ][ j ]; } return ans ; } };","title":"1277. Count Square Submatrices with All Ones $\\star\\star$"},{"location":"cpp/1201-1300/1271-1280/#1278-palindrome-partitioning-iii-starstarstar","text":"class Solution { public : int palindromePartition ( string s , int K ) { const int n = s . length (); vector < vector < int >> cost ( n , vector < int > ( n )); vector < vector < int >> dp ( K + 1 , vector < int > ( n + 1 , n )); for ( int length = 2 ; length <= n ; ++ length ) for ( int i = 0 , j = length - 1 ; j < n ; ++ i , ++ j ) cost [ i ][ j ] = ( s [ i ] != s [ j ]) + cost [ i + 1 ][ j - 1 ]; for ( int i = 1 ; i <= n ; ++ i ) dp [ 1 ][ i ] = cost [ 0 ][ i - 1 ]; for ( int k = 2 ; k <= K ; ++ k ) for ( int i = k ; i <= n ; ++ i ) for ( int j = k - 1 ; j < i ; ++ j ) dp [ k ][ i ] = min ( dp [ k ][ i ], dp [ k - 1 ][ j ] + cost [ j ][ i - 1 ]); return dp [ K ][ n ]; } };","title":"1278. Palindrome Partitioning III $\\star\\star\\star$"},{"location":"cpp/1201-1300/1271-1280/#1279-traffic-light-controlled-intersection-star","text":"","title":"1279. Traffic Light Controlled Intersection $\\star$ \ud83d\udd12"},{"location":"cpp/1201-1300/1271-1280/#1280-students-and-examinations-star","text":"","title":"1280. Students and Examinations $\\star$ \ud83d\udd12"},{"location":"cpp/1201-1300/1281-1290/","text":"1281. Subtract the Product and Sum of Digits of an Integer $\\star$ class Solution { public : int subtractProductAndSum ( int n ) { int prod = 1 ; int summ = 0 ; for (; n > 0 ; n /= 10 ) { prod *= n % 10 ; summ += n % 10 ; } return prod - summ ; } }; 1282. Group the People Given the Group Size They Belong To $\\star\\star$ 1283. Find the Smallest Divisor Given a Threshold $\\star\\star$ 1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix $\\star\\star\\star$ 1285. Find the Start and End Number of Continuous Ranges $\\star\\star$ \ud83d\udd12 1286. Iterator for Combination $\\star\\star$ 1287. Element Appearing More Than 25% In Sorted Array $\\star$ class Solution { public : int findSpecialInteger ( vector < int >& arr ) { const int n = arr . size (); const int quarter = n / 4 ; for ( int i = 0 ; i < n - quarter ; ++ i ) if ( arr [ i ] == arr [ i + quarter ]) return arr [ i ]; throw ; } }; 1288. Remove Covered Intervals $\\star\\star$ 1289. Minimum Falling Path Sum II $\\star\\star\\star$ 1290. Convert Binary Number in a Linked List to Integer $\\star$ class Solution { public : int getDecimalValue ( ListNode * head ) { int ans = 0 ; for (; head ; head = head -> next ) ans = ans * 2 + head -> val ; return ans ; } };","title":"1281-1290"},{"location":"cpp/1201-1300/1281-1290/#1281-subtract-the-product-and-sum-of-digits-of-an-integer-star","text":"class Solution { public : int subtractProductAndSum ( int n ) { int prod = 1 ; int summ = 0 ; for (; n > 0 ; n /= 10 ) { prod *= n % 10 ; summ += n % 10 ; } return prod - summ ; } };","title":"1281. Subtract the Product and Sum of Digits of an Integer $\\star$"},{"location":"cpp/1201-1300/1281-1290/#1282-group-the-people-given-the-group-size-they-belong-to-starstar","text":"","title":"1282. Group the People Given the Group Size They Belong To $\\star\\star$"},{"location":"cpp/1201-1300/1281-1290/#1283-find-the-smallest-divisor-given-a-threshold-starstar","text":"","title":"1283. Find the Smallest Divisor Given a Threshold $\\star\\star$"},{"location":"cpp/1201-1300/1281-1290/#1284-minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix-starstarstar","text":"","title":"1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix $\\star\\star\\star$"},{"location":"cpp/1201-1300/1281-1290/#1285-find-the-start-and-end-number-of-continuous-ranges-starstar","text":"","title":"1285. Find the Start and End Number of Continuous Ranges $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1201-1300/1281-1290/#1286-iterator-for-combination-starstar","text":"","title":"1286. Iterator for Combination $\\star\\star$"},{"location":"cpp/1201-1300/1281-1290/#1287-element-appearing-more-than-25-in-sorted-array-star","text":"class Solution { public : int findSpecialInteger ( vector < int >& arr ) { const int n = arr . size (); const int quarter = n / 4 ; for ( int i = 0 ; i < n - quarter ; ++ i ) if ( arr [ i ] == arr [ i + quarter ]) return arr [ i ]; throw ; } };","title":"1287. Element Appearing More Than 25% In Sorted Array $\\star$"},{"location":"cpp/1201-1300/1281-1290/#1288-remove-covered-intervals-starstar","text":"","title":"1288. Remove Covered Intervals $\\star\\star$"},{"location":"cpp/1201-1300/1281-1290/#1289-minimum-falling-path-sum-ii-starstarstar","text":"","title":"1289. Minimum Falling Path Sum II $\\star\\star\\star$"},{"location":"cpp/1201-1300/1281-1290/#1290-convert-binary-number-in-a-linked-list-to-integer-star","text":"class Solution { public : int getDecimalValue ( ListNode * head ) { int ans = 0 ; for (; head ; head = head -> next ) ans = ans * 2 + head -> val ; return ans ; } };","title":"1290. Convert Binary Number in a Linked List to Integer $\\star$"},{"location":"cpp/1201-1300/1291-1300/","text":"1291. Sequential Digits $\\star\\star$ 1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold $\\star\\star$ class Solution { public : int maxSideLength ( vector < vector < int >>& mat , int threshold ) { const int m = mat . size (); const int n = mat [ 0 ]. size (); int ans = 0 ; vector < vector < int >> prefixSum ( m + 1 , vector < int > ( n + 1 )); for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) prefixSum [ i ][ j ] = mat [ i - 1 ][ j - 1 ] + prefixSum [ i ][ j - 1 ] + prefixSum [ i - 1 ][ j ] - prefixSum [ i - 1 ][ j - 1 ]; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) for ( int length = ans ; length < min ( m - i , n - j ); ++ length ) { if ( squareSum ( prefixSum , i , j , i + length , j + length ) > threshold ) break ; ans = max ( ans , length + 1 ); } return ans ; } private : int squareSum ( vector < vector < int >>& prefixSum , int r1 , int c1 , int r2 , int c2 ) { return prefixSum [ r2 + 1 ][ c2 + 1 ] - prefixSum [ r1 ][ c2 + 1 ] - prefixSum [ r2 + 1 ][ c1 ] + prefixSum [ r1 ][ c1 ]; } }; 1293. Shortest Path in a Grid with Obstacles Elimination $\\star\\star\\star$ 1294. Weather Type in Each Country $\\star$ \ud83d\udd12 1295. Find Numbers with Even Number of Digits $\\star$ class Solution { public : int findNumbers ( vector < int >& nums ) { int ans = 0 ; for ( int num : nums ) if ( 9 < num && num < 100 || 999 < num && num < 10000 || num == 100000 ) ++ ans ; return ans ; } }; 1296. Divide Array in Sets of K Consecutive Numbers $\\star\\star$ class Solution { public : bool isPossibleDivide ( vector < int >& nums , int k ) { map < int , int > count ; for ( int num : nums ) ++ count [ num ]; for ( const auto & [ key , _ ] : count ) { int value = count [ key ]; if ( value > 0 ) for ( int i = key ; i < key + k ; ++ i ) { count [ i ] -= value ; if ( count [ i ] < 0 ) return false ; } } return true ; } }; 1297. Maximum Number of Occurrences of a Substring $\\star\\star$ 1298. Maximum Candies You Can Get from Boxes $\\star\\star\\star$ 1299. Replace Elements with Greatest Element on Right Side $\\star$ class Solution { public : vector < int > replaceElements ( vector < int >& arr ) { int maxOfRight = - 1 ; for ( int i = arr . size () - 1 ; i >= 0 ; -- i ) maxOfRight = max ( maxOfRight , exchange ( arr [ i ], maxOfRight )); return arr ; } }; 1300. Sum of Mutated Array Closest to Target $\\star\\star$ class Solution { public : int findBestValue ( vector < int >& arr , int target ) { const int n = arr . size (); const double err = 1e-9 ; int prefixSum = 0 ; sort ( begin ( arr ), end ( arr )); for ( int i = 0 ; i < n ; ++ i ) { int ans = round (( target - prefixSum - err ) / ( double )( n - i )); if ( ans <= arr [ i ]) return ans ; prefixSum += arr [ i ]; } return arr . back (); } };","title":"1291-1300"},{"location":"cpp/1201-1300/1291-1300/#1291-sequential-digits-starstar","text":"","title":"1291. Sequential Digits $\\star\\star$"},{"location":"cpp/1201-1300/1291-1300/#1292-maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold-starstar","text":"class Solution { public : int maxSideLength ( vector < vector < int >>& mat , int threshold ) { const int m = mat . size (); const int n = mat [ 0 ]. size (); int ans = 0 ; vector < vector < int >> prefixSum ( m + 1 , vector < int > ( n + 1 )); for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) prefixSum [ i ][ j ] = mat [ i - 1 ][ j - 1 ] + prefixSum [ i ][ j - 1 ] + prefixSum [ i - 1 ][ j ] - prefixSum [ i - 1 ][ j - 1 ]; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) for ( int length = ans ; length < min ( m - i , n - j ); ++ length ) { if ( squareSum ( prefixSum , i , j , i + length , j + length ) > threshold ) break ; ans = max ( ans , length + 1 ); } return ans ; } private : int squareSum ( vector < vector < int >>& prefixSum , int r1 , int c1 , int r2 , int c2 ) { return prefixSum [ r2 + 1 ][ c2 + 1 ] - prefixSum [ r1 ][ c2 + 1 ] - prefixSum [ r2 + 1 ][ c1 ] + prefixSum [ r1 ][ c1 ]; } };","title":"1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold $\\star\\star$"},{"location":"cpp/1201-1300/1291-1300/#1293-shortest-path-in-a-grid-with-obstacles-elimination-starstarstar","text":"","title":"1293. Shortest Path in a Grid with Obstacles Elimination $\\star\\star\\star$"},{"location":"cpp/1201-1300/1291-1300/#1294-weather-type-in-each-country-star","text":"","title":"1294. Weather Type in Each Country $\\star$ \ud83d\udd12"},{"location":"cpp/1201-1300/1291-1300/#1295-find-numbers-with-even-number-of-digits-star","text":"class Solution { public : int findNumbers ( vector < int >& nums ) { int ans = 0 ; for ( int num : nums ) if ( 9 < num && num < 100 || 999 < num && num < 10000 || num == 100000 ) ++ ans ; return ans ; } };","title":"1295. Find Numbers with Even Number of Digits $\\star$"},{"location":"cpp/1201-1300/1291-1300/#1296-divide-array-in-sets-of-k-consecutive-numbers-starstar","text":"class Solution { public : bool isPossibleDivide ( vector < int >& nums , int k ) { map < int , int > count ; for ( int num : nums ) ++ count [ num ]; for ( const auto & [ key , _ ] : count ) { int value = count [ key ]; if ( value > 0 ) for ( int i = key ; i < key + k ; ++ i ) { count [ i ] -= value ; if ( count [ i ] < 0 ) return false ; } } return true ; } };","title":"1296. Divide Array in Sets of K Consecutive Numbers $\\star\\star$"},{"location":"cpp/1201-1300/1291-1300/#1297-maximum-number-of-occurrences-of-a-substring-starstar","text":"","title":"1297. Maximum Number of Occurrences of a Substring $\\star\\star$"},{"location":"cpp/1201-1300/1291-1300/#1298-maximum-candies-you-can-get-from-boxes-starstarstar","text":"","title":"1298. Maximum Candies You Can Get from Boxes $\\star\\star\\star$"},{"location":"cpp/1201-1300/1291-1300/#1299-replace-elements-with-greatest-element-on-right-side-star","text":"class Solution { public : vector < int > replaceElements ( vector < int >& arr ) { int maxOfRight = - 1 ; for ( int i = arr . size () - 1 ; i >= 0 ; -- i ) maxOfRight = max ( maxOfRight , exchange ( arr [ i ], maxOfRight )); return arr ; } };","title":"1299. Replace Elements with Greatest Element on Right Side $\\star$"},{"location":"cpp/1201-1300/1291-1300/#1300-sum-of-mutated-array-closest-to-target-starstar","text":"class Solution { public : int findBestValue ( vector < int >& arr , int target ) { const int n = arr . size (); const double err = 1e-9 ; int prefixSum = 0 ; sort ( begin ( arr ), end ( arr )); for ( int i = 0 ; i < n ; ++ i ) { int ans = round (( target - prefixSum - err ) / ( double )( n - i )); if ( ans <= arr [ i ]) return ans ; prefixSum += arr [ i ]; } return arr . back (); } };","title":"1300. Sum of Mutated Array Closest to Target $\\star\\star$"},{"location":"cpp/1301-1400/1301-1310/","text":"1301. Number of Paths with Max Score $\\star\\star\\star$ 1302. Deepest Leaves Sum $\\star\\star$ 1303. Find the Team Size $\\star$ \ud83d\udd12 1304. Find N Unique Integers Sum up to Zero $\\star$ class Solution { public : vector < int > sumZero ( int n ) { vector < int > ans ( n ); for ( int i = 0 ; i < n ; ++ i ) ans [ i ] = i * 2 - n + 1 ; return ans ; } }; 1305. All Elements in Two Binary Search Trees $\\star\\star$ 1306. Jump Game III $\\star\\star$ 1307. Verbal Arithmetic Puzzle $\\star\\star\\star$ class Solution { public : bool isSolvable ( vector < string >& words , string result ) { usedDigit = vector < bool > ( 10 , false ); words . push_back ( result ); rows = words . size (); for ( const string & word : words ) cols = max ( cols , ( int ) word . length ()); return dfs ( words , 0 , 0 , 0 ); } private : unordered_map < char , int > letterToDigit ; vector < bool > usedDigit ; int rows ; int cols ; bool dfs ( vector < string >& words , int row , int col , int sum ) { if ( col == cols ) return sum == 0 ; if ( row == rows ) return sum % 10 == 0 && dfs ( words , 0 , col + 1 , sum / 10 ); string word = words [ row ]; if ( col >= word . length ()) return dfs ( words , row + 1 , col , sum ); char letter = word [ word . length () - col - 1 ]; int sign = row == rows - 1 ? - 1 : 1 ; if ( letterToDigit . count ( letter ) && ( letterToDigit [ letter ] > 0 || col < word . length () - 1 )) return dfs ( words , row + 1 , col , sum + sign * letterToDigit [ letter ]); for ( int digit = 0 ; digit < 10 ; ++ digit ) if ( ! usedDigit [ digit ] && ( digit > 0 || col + 1 < word . length ())) { letterToDigit [ letter ] = digit ; usedDigit [ digit ] = true ; if ( dfs ( words , row + 1 , col , sum + sign * digit )) return true ; usedDigit [ digit ] = false ; letterToDigit . erase ( letter ); } return false ; } }; 1308. Running Total for Different Genders $\\star\\star$ \ud83d\udd12 1309. Decrypt String from Alphabet to Integer Mapping $\\star$ class Solution { public : string freqAlphabets ( string s ) { string ans ; for ( int i = 0 ; i < s . length ();) { if ( i + 2 < s . length () && s [ i + 2 ] == '#' ) { ans += stoi ( s . substr ( i , 2 )) + 'a' - 1 ; i += 3 ; } else { ans += ( s [ i ] - '0' ) + 'a' - 1 ; i += 1 ; } } return ans ; } }; 1310. XOR Queries of a Subarray $\\star\\star$ class Solution { public : vector < int > xorQueries ( vector < int >& arr , vector < vector < int >>& queries ) { vector < int > ans ; vector < int > xors ( arr . size () + 1 ); for ( int i = 0 ; i < arr . size (); ++ i ) xors [ i + 1 ] ^= xors [ i ] ^ arr [ i ]; for ( vector < int >& query : queries ) ans . push_back ( xors [ query [ 0 ]] ^ xors [ query [ 1 ] + 1 ]); return ans ; } };","title":"1301-1310"},{"location":"cpp/1301-1400/1301-1310/#1301-number-of-paths-with-max-score-starstarstar","text":"","title":"1301. Number of Paths with Max Score $\\star\\star\\star$"},{"location":"cpp/1301-1400/1301-1310/#1302-deepest-leaves-sum-starstar","text":"","title":"1302. Deepest Leaves Sum $\\star\\star$"},{"location":"cpp/1301-1400/1301-1310/#1303-find-the-team-size-star","text":"","title":"1303. Find the Team Size $\\star$ \ud83d\udd12"},{"location":"cpp/1301-1400/1301-1310/#1304-find-n-unique-integers-sum-up-to-zero-star","text":"class Solution { public : vector < int > sumZero ( int n ) { vector < int > ans ( n ); for ( int i = 0 ; i < n ; ++ i ) ans [ i ] = i * 2 - n + 1 ; return ans ; } };","title":"1304. Find N Unique Integers Sum up to Zero $\\star$"},{"location":"cpp/1301-1400/1301-1310/#1305-all-elements-in-two-binary-search-trees-starstar","text":"","title":"1305. All Elements in Two Binary Search Trees $\\star\\star$"},{"location":"cpp/1301-1400/1301-1310/#1306-jump-game-iii-starstar","text":"","title":"1306. Jump Game III $\\star\\star$"},{"location":"cpp/1301-1400/1301-1310/#1307-verbal-arithmetic-puzzle-starstarstar","text":"class Solution { public : bool isSolvable ( vector < string >& words , string result ) { usedDigit = vector < bool > ( 10 , false ); words . push_back ( result ); rows = words . size (); for ( const string & word : words ) cols = max ( cols , ( int ) word . length ()); return dfs ( words , 0 , 0 , 0 ); } private : unordered_map < char , int > letterToDigit ; vector < bool > usedDigit ; int rows ; int cols ; bool dfs ( vector < string >& words , int row , int col , int sum ) { if ( col == cols ) return sum == 0 ; if ( row == rows ) return sum % 10 == 0 && dfs ( words , 0 , col + 1 , sum / 10 ); string word = words [ row ]; if ( col >= word . length ()) return dfs ( words , row + 1 , col , sum ); char letter = word [ word . length () - col - 1 ]; int sign = row == rows - 1 ? - 1 : 1 ; if ( letterToDigit . count ( letter ) && ( letterToDigit [ letter ] > 0 || col < word . length () - 1 )) return dfs ( words , row + 1 , col , sum + sign * letterToDigit [ letter ]); for ( int digit = 0 ; digit < 10 ; ++ digit ) if ( ! usedDigit [ digit ] && ( digit > 0 || col + 1 < word . length ())) { letterToDigit [ letter ] = digit ; usedDigit [ digit ] = true ; if ( dfs ( words , row + 1 , col , sum + sign * digit )) return true ; usedDigit [ digit ] = false ; letterToDigit . erase ( letter ); } return false ; } };","title":"1307. Verbal Arithmetic Puzzle $\\star\\star\\star$"},{"location":"cpp/1301-1400/1301-1310/#1308-running-total-for-different-genders-starstar","text":"","title":"1308. Running Total for Different Genders $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1301-1400/1301-1310/#1309-decrypt-string-from-alphabet-to-integer-mapping-star","text":"class Solution { public : string freqAlphabets ( string s ) { string ans ; for ( int i = 0 ; i < s . length ();) { if ( i + 2 < s . length () && s [ i + 2 ] == '#' ) { ans += stoi ( s . substr ( i , 2 )) + 'a' - 1 ; i += 3 ; } else { ans += ( s [ i ] - '0' ) + 'a' - 1 ; i += 1 ; } } return ans ; } };","title":"1309. Decrypt String from Alphabet to Integer Mapping $\\star$"},{"location":"cpp/1301-1400/1301-1310/#1310-xor-queries-of-a-subarray-starstar","text":"class Solution { public : vector < int > xorQueries ( vector < int >& arr , vector < vector < int >>& queries ) { vector < int > ans ; vector < int > xors ( arr . size () + 1 ); for ( int i = 0 ; i < arr . size (); ++ i ) xors [ i + 1 ] ^= xors [ i ] ^ arr [ i ]; for ( vector < int >& query : queries ) ans . push_back ( xors [ query [ 0 ]] ^ xors [ query [ 1 ] + 1 ]); return ans ; } };","title":"1310. XOR Queries of a Subarray $\\star\\star$"},{"location":"cpp/1301-1400/1311-1320/","text":"1311. Get Watched Videos by Your Friends $\\star\\star$ class Solution { public : vector < string > watchedVideosByFriends ( vector < vector < string >>& watchedVideos , vector < vector < int >>& friends , int id , int level ) { vector < string > ans ; vector < bool > visited ( friends . size ()); visited [ id ] = true ; queue < int > queue {{ id }}; unordered_map < string , int > count ; set < pair < int , string >> freqAndVideo ; for ( int i = 0 ; i < level ; ++ i ) for ( int j = queue . size (); j > 0 ; -- j ) { for ( int f : friends [ queue . front ()]) if ( visited [ f ] == false ) { visited [ f ] = true ; queue . push ( f ); } queue . pop (); } for ( int i = queue . size (); i > 0 ; -- i ) { for ( const string & video : watchedVideos [ queue . front ()]) ++ count [ video ]; queue . pop (); } for ( const auto & [ video , freq ] : count ) freqAndVideo . insert ({ freq , video }); for ( const auto & [ _ , video ] : freqAndVideo ) ans . push_back ( video ); return ans ; } }; 1312. Minimum Insertion Steps to Make a String Palindrome $\\star\\star\\star$ 1313. Decompress Run-Length Encoded List $\\star$ class Solution { public : vector < int > decompressRLElist ( vector < int >& nums ) { vector < int > ans ; for ( int i = 0 ; i < nums . size (); i += 2 ) ans . insert ( end ( ans ), nums [ i ], nums [ i + 1 ]); return ans ; } }; 1314. Matrix Block Sum $\\star\\star$ 1315. Sum of Nodes with Even-Valued Grandparent $\\star\\star$ 1316. Distinct Echo Substrings $\\star\\star\\star$ 1317. Convert Integer to the Sum of Two No-Zero Integers $\\star$ class Solution { public : vector < int > getNoZeroIntegers ( int n ) { for ( int A = 1 ; A < n ; ++ A ) { int B = n - A ; if ( to_string ( A ). find ( '0' ) == string :: npos && to_string ( B ). find ( '0' ) == string :: npos ) return { A , B }; } throw ; } }; 1318. Minimum Flips to Make a OR b Equal to c $\\star\\star$ 1319. Number of Operations to Make Network Connected $\\star\\star$ 1320. Minimum Distance to Type a Word Using Two Fingers $\\star\\star\\star$","title":"1311-1320"},{"location":"cpp/1301-1400/1311-1320/#1311-get-watched-videos-by-your-friends-starstar","text":"class Solution { public : vector < string > watchedVideosByFriends ( vector < vector < string >>& watchedVideos , vector < vector < int >>& friends , int id , int level ) { vector < string > ans ; vector < bool > visited ( friends . size ()); visited [ id ] = true ; queue < int > queue {{ id }}; unordered_map < string , int > count ; set < pair < int , string >> freqAndVideo ; for ( int i = 0 ; i < level ; ++ i ) for ( int j = queue . size (); j > 0 ; -- j ) { for ( int f : friends [ queue . front ()]) if ( visited [ f ] == false ) { visited [ f ] = true ; queue . push ( f ); } queue . pop (); } for ( int i = queue . size (); i > 0 ; -- i ) { for ( const string & video : watchedVideos [ queue . front ()]) ++ count [ video ]; queue . pop (); } for ( const auto & [ video , freq ] : count ) freqAndVideo . insert ({ freq , video }); for ( const auto & [ _ , video ] : freqAndVideo ) ans . push_back ( video ); return ans ; } };","title":"1311. Get Watched Videos by Your Friends $\\star\\star$"},{"location":"cpp/1301-1400/1311-1320/#1312-minimum-insertion-steps-to-make-a-string-palindrome-starstarstar","text":"","title":"1312. Minimum Insertion Steps to Make a String Palindrome $\\star\\star\\star$"},{"location":"cpp/1301-1400/1311-1320/#1313-decompress-run-length-encoded-list-star","text":"class Solution { public : vector < int > decompressRLElist ( vector < int >& nums ) { vector < int > ans ; for ( int i = 0 ; i < nums . size (); i += 2 ) ans . insert ( end ( ans ), nums [ i ], nums [ i + 1 ]); return ans ; } };","title":"1313. Decompress Run-Length Encoded List $\\star$"},{"location":"cpp/1301-1400/1311-1320/#1314-matrix-block-sum-starstar","text":"","title":"1314. Matrix Block Sum $\\star\\star$"},{"location":"cpp/1301-1400/1311-1320/#1315-sum-of-nodes-with-even-valued-grandparent-starstar","text":"","title":"1315. Sum of Nodes with Even-Valued Grandparent $\\star\\star$"},{"location":"cpp/1301-1400/1311-1320/#1316-distinct-echo-substrings-starstarstar","text":"","title":"1316. Distinct Echo Substrings $\\star\\star\\star$"},{"location":"cpp/1301-1400/1311-1320/#1317-convert-integer-to-the-sum-of-two-no-zero-integers-star","text":"class Solution { public : vector < int > getNoZeroIntegers ( int n ) { for ( int A = 1 ; A < n ; ++ A ) { int B = n - A ; if ( to_string ( A ). find ( '0' ) == string :: npos && to_string ( B ). find ( '0' ) == string :: npos ) return { A , B }; } throw ; } };","title":"1317. Convert Integer to the Sum of Two No-Zero Integers $\\star$"},{"location":"cpp/1301-1400/1311-1320/#1318-minimum-flips-to-make-a-or-b-equal-to-c-starstar","text":"","title":"1318. Minimum Flips to Make a OR b Equal to c $\\star\\star$"},{"location":"cpp/1301-1400/1311-1320/#1319-number-of-operations-to-make-network-connected-starstar","text":"","title":"1319. Number of Operations to Make Network Connected $\\star\\star$"},{"location":"cpp/1301-1400/1311-1320/#1320-minimum-distance-to-type-a-word-using-two-fingers-starstarstar","text":"","title":"1320. Minimum Distance to Type a Word Using Two Fingers $\\star\\star\\star$"},{"location":"cpp/1301-1400/1321-1330/","text":"1321. Restaurant Growth $\\star\\star$ \ud83d\udd12 1322. Ads Performance $\\star$ \ud83d\udd12 1323. Maximum 69 Number $\\star$ class Solution { public : int maximum69Number ( int num ) { string ans = to_string ( num ); for ( char & c : ans ) if ( c == '6' ) { c = '9' ; break ; } return stoi ( ans ); } }; 1324. Print Words Vertically $\\star\\star$ 1325. Delete Leaves With a Given Value $\\star\\star$ 1326. Minimum Number of Taps to Open to Water a Garden $\\star\\star\\star$ class Solution { public : int minTaps ( int n , vector < int >& ranges ) { vector < int > nums ( n + 1 ); for ( int i = 0 ; i <= n ; ++ i ) { int l = max ( 0 , i - ranges [ i ]); int r = min ( n , i + ranges [ i ]); nums [ l ] = max ( nums [ l ], r - l ); } int ans = 0 ; int end = 0 ; int farthest = 0 ; for ( int i = 0 ; i < n ; i ++ ) { farthest = max ( farthest , i + nums [ i ]); if ( i == end ) { ++ ans ; end = farthest ; } } return end == n ? ans : - 1 ; } }; 1327. List the Products Ordered in a Period $\\star$ \ud83d\udd12 1328. Break a Palindrome $\\star\\star$ 1329. Sort the Matrix Diagonally $\\star\\star$ class Solution { public : vector < vector < int >> diagonalSort ( vector < vector < int >>& mat ) { const int m = mat . size (); const int n = mat [ 0 ]. size (); unordered_map < int , priority_queue < int >> count ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) count [ i - j ]. push ( mat [ i ][ j ]); for ( int i = m - 1 ; i >= 0 ; -- i ) for ( int j = n - 1 ; j >= 0 ; -- j ) mat [ i ][ j ] = count [ i - j ]. top (), count [ i - j ]. pop (); return mat ; } }; 1330. Reverse Subarray To Maximize Array Value $\\star\\star\\star$ class Solution { public : int maxValueAfterReverse ( vector < int >& nums ) { int total = 0 ; int min = INT_MAX ; int max = INT_MIN ; for ( int i = 0 ; i + 1 < nums . size (); ++ i ) { int a = nums [ i ]; int b = nums [ i + 1 ]; total += abs ( a - b ); min = std :: min ( min , std :: max ( a , b )); max = std :: max ( max , std :: min ( a , b )); } int diff = std :: max ( 0 , ( max - min ) * 2 ); for ( int i = 0 ; i + 1 < nums . size (); ++ i ) { int a = nums [ i ]; int b = nums [ i + 1 ]; int headDiff = - abs ( a - b ) + abs ( nums . front () - b ); int tailDiff = - abs ( a - b ) + abs ( nums . back () - a ); diff = std :: max ({ diff , headDiff , tailDiff }); } return total + diff ; } };","title":"1321-1330"},{"location":"cpp/1301-1400/1321-1330/#1321-restaurant-growth-starstar","text":"","title":"1321. Restaurant Growth $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1301-1400/1321-1330/#1322-ads-performance-star","text":"","title":"1322. Ads Performance $\\star$ \ud83d\udd12"},{"location":"cpp/1301-1400/1321-1330/#1323-maximum-69-number-star","text":"class Solution { public : int maximum69Number ( int num ) { string ans = to_string ( num ); for ( char & c : ans ) if ( c == '6' ) { c = '9' ; break ; } return stoi ( ans ); } };","title":"1323. Maximum 69 Number $\\star$"},{"location":"cpp/1301-1400/1321-1330/#1324-print-words-vertically-starstar","text":"","title":"1324. Print Words Vertically $\\star\\star$"},{"location":"cpp/1301-1400/1321-1330/#1325-delete-leaves-with-a-given-value-starstar","text":"","title":"1325. Delete Leaves With a Given Value $\\star\\star$"},{"location":"cpp/1301-1400/1321-1330/#1326-minimum-number-of-taps-to-open-to-water-a-garden-starstarstar","text":"class Solution { public : int minTaps ( int n , vector < int >& ranges ) { vector < int > nums ( n + 1 ); for ( int i = 0 ; i <= n ; ++ i ) { int l = max ( 0 , i - ranges [ i ]); int r = min ( n , i + ranges [ i ]); nums [ l ] = max ( nums [ l ], r - l ); } int ans = 0 ; int end = 0 ; int farthest = 0 ; for ( int i = 0 ; i < n ; i ++ ) { farthest = max ( farthest , i + nums [ i ]); if ( i == end ) { ++ ans ; end = farthest ; } } return end == n ? ans : - 1 ; } };","title":"1326. Minimum Number of Taps to Open to Water a Garden $\\star\\star\\star$"},{"location":"cpp/1301-1400/1321-1330/#1327-list-the-products-ordered-in-a-period-star","text":"","title":"1327. List the Products Ordered in a Period $\\star$ \ud83d\udd12"},{"location":"cpp/1301-1400/1321-1330/#1328-break-a-palindrome-starstar","text":"","title":"1328. Break a Palindrome $\\star\\star$"},{"location":"cpp/1301-1400/1321-1330/#1329-sort-the-matrix-diagonally-starstar","text":"class Solution { public : vector < vector < int >> diagonalSort ( vector < vector < int >>& mat ) { const int m = mat . size (); const int n = mat [ 0 ]. size (); unordered_map < int , priority_queue < int >> count ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) count [ i - j ]. push ( mat [ i ][ j ]); for ( int i = m - 1 ; i >= 0 ; -- i ) for ( int j = n - 1 ; j >= 0 ; -- j ) mat [ i ][ j ] = count [ i - j ]. top (), count [ i - j ]. pop (); return mat ; } };","title":"1329. Sort the Matrix Diagonally $\\star\\star$"},{"location":"cpp/1301-1400/1321-1330/#1330-reverse-subarray-to-maximize-array-value-starstarstar","text":"class Solution { public : int maxValueAfterReverse ( vector < int >& nums ) { int total = 0 ; int min = INT_MAX ; int max = INT_MIN ; for ( int i = 0 ; i + 1 < nums . size (); ++ i ) { int a = nums [ i ]; int b = nums [ i + 1 ]; total += abs ( a - b ); min = std :: min ( min , std :: max ( a , b )); max = std :: max ( max , std :: min ( a , b )); } int diff = std :: max ( 0 , ( max - min ) * 2 ); for ( int i = 0 ; i + 1 < nums . size (); ++ i ) { int a = nums [ i ]; int b = nums [ i + 1 ]; int headDiff = - abs ( a - b ) + abs ( nums . front () - b ); int tailDiff = - abs ( a - b ) + abs ( nums . back () - a ); diff = std :: max ({ diff , headDiff , tailDiff }); } return total + diff ; } };","title":"1330. Reverse Subarray To Maximize Array Value $\\star\\star\\star$"},{"location":"cpp/1301-1400/1331-1340/","text":"1331. Rank Transform of an Array $\\star$ class Solution { public : vector < int > arrayRankTransform ( vector < int >& arr ) { vector < int > sortedArr ( arr ); unordered_map < int , int > rank ; sort ( begin ( sortedArr ), end ( sortedArr )); for ( int a : sortedArr ) if ( ! rank . count ( a )) rank [ a ] = rank . size () + 1 ; for ( int & a : arr ) a = rank [ a ]; return arr ; } }; 1332. Remove Palindromic Subsequences $\\star$ 1333. Filter Restaurants by Vegan-Friendly, Price and Distance $\\star\\star$ class Solution { public : vector < int > filterRestaurants ( vector < vector < int >>& restaurants , int veganFriendly , int maxPrice , int maxDistance ) { vector < int > ans ; vector < vector < int >> filtered ; for ( vector < int >& restaurant : restaurants ) if ( restaurant [ 2 ] >= veganFriendly && restaurant [ 3 ] <= maxPrice && restaurant [ 4 ] <= maxDistance ) filtered . push_back ( restaurant ); sort ( begin ( filtered ), end ( filtered ), []( const auto & a , const auto & b ) { return a [ 1 ] == b [ 1 ] ? a [ 0 ] > b [ 0 ] : a [ 1 ] > b [ 1 ]; }); for ( vector < int >& f : filtered ) ans . push_back ( f [ 0 ]); return ans ; } }; 1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance $\\star\\star$ 1335. Minimum Difficulty of a Job Schedule $\\star\\star\\star$ class Solution { public : int minDifficulty ( vector < int >& jobDifficulty , int d ) { const int n = jobDifficulty . size (); if ( n < d ) return - 1 ; vector < vector < int >> dp ( n + 1 , vector < int > ( d + 1 , INT_MAX / 2 )); dp [ 0 ][ 0 ] = 0 ; for ( int i = 1 ; i <= n ; ++ i ) for ( int k = 1 ; k <= d ; ++ k ) { int maxDifficulty = 0 ; for ( int j = i ; j >= k ; -- j ) { maxDifficulty = max ( maxDifficulty , jobDifficulty [ j - 1 ]); dp [ i ][ k ] = min ( dp [ i ][ k ], dp [ j - 1 ][ k - 1 ] + maxDifficulty ); } } return dp [ n ][ d ]; } }; 1336. Number of Transactions per Visit $\\star\\star\\star$ \ud83d\udd12 1337. The K Weakest Rows in a Matrix $\\star$ class Solution { public : vector < int > kWeakestRows ( vector < vector < int >>& mat , int k ) { vector < int > ans ; vector < vector < int >> rowSum ; for ( int i = 0 ; i < mat . size (); ++ i ) rowSum . push_back ({ accumulate ( begin ( mat [ i ]), end ( mat [ i ]), 0 ), i }); sort ( begin ( rowSum ), end ( rowSum ), []( const auto & a , const auto & b ) { return a [ 0 ] == b [ 0 ] ? a [ 1 ] < b [ 1 ] : a [ 0 ] < b [ 0 ]; }); for ( int i = 0 ; i < k ; ++ i ) ans . push_back ( rowSum [ i ][ 1 ]); return ans ; } }; 1338. Reduce Array Size to The Half $\\star\\star$ class Solution { public : int minSetSize ( vector < int >& arr ) { const int n = arr . size (); int sum = 0 ; unordered_map < int , int > map ; vector < pair < int , int >> count ; for ( int a : arr ) ++ map [ a ]; for ( const auto & [ a , freq ] : map ) count . push_back ( make_pair ( a , freq )); sort ( begin ( count ), end ( count ), []( const auto & a , const auto & b ) { return a . second > b . second ; }); for ( int i = 0 ; i < count . size (); ++ i ) { sum += count [ i ]. second ; if ( sum >= n / 2 ) return i + 1 ; } throw ; } }; 1339. Maximum Product of Splitted Binary Tree $\\star\\star$ 1340. Jump Game V $\\star\\star\\star$","title":"1331-1340"},{"location":"cpp/1301-1400/1331-1340/#1331-rank-transform-of-an-array-star","text":"class Solution { public : vector < int > arrayRankTransform ( vector < int >& arr ) { vector < int > sortedArr ( arr ); unordered_map < int , int > rank ; sort ( begin ( sortedArr ), end ( sortedArr )); for ( int a : sortedArr ) if ( ! rank . count ( a )) rank [ a ] = rank . size () + 1 ; for ( int & a : arr ) a = rank [ a ]; return arr ; } };","title":"1331. Rank Transform of an Array $\\star$"},{"location":"cpp/1301-1400/1331-1340/#1332-remove-palindromic-subsequences-star","text":"","title":"1332. Remove Palindromic Subsequences $\\star$"},{"location":"cpp/1301-1400/1331-1340/#1333-filter-restaurants-by-vegan-friendly-price-and-distance-starstar","text":"class Solution { public : vector < int > filterRestaurants ( vector < vector < int >>& restaurants , int veganFriendly , int maxPrice , int maxDistance ) { vector < int > ans ; vector < vector < int >> filtered ; for ( vector < int >& restaurant : restaurants ) if ( restaurant [ 2 ] >= veganFriendly && restaurant [ 3 ] <= maxPrice && restaurant [ 4 ] <= maxDistance ) filtered . push_back ( restaurant ); sort ( begin ( filtered ), end ( filtered ), []( const auto & a , const auto & b ) { return a [ 1 ] == b [ 1 ] ? a [ 0 ] > b [ 0 ] : a [ 1 ] > b [ 1 ]; }); for ( vector < int >& f : filtered ) ans . push_back ( f [ 0 ]); return ans ; } };","title":"1333. Filter Restaurants by Vegan-Friendly, Price and Distance $\\star\\star$"},{"location":"cpp/1301-1400/1331-1340/#1334-find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance-starstar","text":"","title":"1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance $\\star\\star$"},{"location":"cpp/1301-1400/1331-1340/#1335-minimum-difficulty-of-a-job-schedule-starstarstar","text":"class Solution { public : int minDifficulty ( vector < int >& jobDifficulty , int d ) { const int n = jobDifficulty . size (); if ( n < d ) return - 1 ; vector < vector < int >> dp ( n + 1 , vector < int > ( d + 1 , INT_MAX / 2 )); dp [ 0 ][ 0 ] = 0 ; for ( int i = 1 ; i <= n ; ++ i ) for ( int k = 1 ; k <= d ; ++ k ) { int maxDifficulty = 0 ; for ( int j = i ; j >= k ; -- j ) { maxDifficulty = max ( maxDifficulty , jobDifficulty [ j - 1 ]); dp [ i ][ k ] = min ( dp [ i ][ k ], dp [ j - 1 ][ k - 1 ] + maxDifficulty ); } } return dp [ n ][ d ]; } };","title":"1335. Minimum Difficulty of a Job Schedule $\\star\\star\\star$"},{"location":"cpp/1301-1400/1331-1340/#1336-number-of-transactions-per-visit-starstarstar","text":"","title":"1336. Number of Transactions per Visit $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/1301-1400/1331-1340/#1337-the-k-weakest-rows-in-a-matrix-star","text":"class Solution { public : vector < int > kWeakestRows ( vector < vector < int >>& mat , int k ) { vector < int > ans ; vector < vector < int >> rowSum ; for ( int i = 0 ; i < mat . size (); ++ i ) rowSum . push_back ({ accumulate ( begin ( mat [ i ]), end ( mat [ i ]), 0 ), i }); sort ( begin ( rowSum ), end ( rowSum ), []( const auto & a , const auto & b ) { return a [ 0 ] == b [ 0 ] ? a [ 1 ] < b [ 1 ] : a [ 0 ] < b [ 0 ]; }); for ( int i = 0 ; i < k ; ++ i ) ans . push_back ( rowSum [ i ][ 1 ]); return ans ; } };","title":"1337. The K Weakest Rows in a Matrix $\\star$"},{"location":"cpp/1301-1400/1331-1340/#1338-reduce-array-size-to-the-half-starstar","text":"class Solution { public : int minSetSize ( vector < int >& arr ) { const int n = arr . size (); int sum = 0 ; unordered_map < int , int > map ; vector < pair < int , int >> count ; for ( int a : arr ) ++ map [ a ]; for ( const auto & [ a , freq ] : map ) count . push_back ( make_pair ( a , freq )); sort ( begin ( count ), end ( count ), []( const auto & a , const auto & b ) { return a . second > b . second ; }); for ( int i = 0 ; i < count . size (); ++ i ) { sum += count [ i ]. second ; if ( sum >= n / 2 ) return i + 1 ; } throw ; } };","title":"1338. Reduce Array Size to The Half $\\star\\star$"},{"location":"cpp/1301-1400/1331-1340/#1339-maximum-product-of-splitted-binary-tree-starstar","text":"","title":"1339. Maximum Product of Splitted Binary Tree $\\star\\star$"},{"location":"cpp/1301-1400/1331-1340/#1340-jump-game-v-starstarstar","text":"","title":"1340. Jump Game V $\\star\\star\\star$"},{"location":"cpp/1301-1400/1341-1350/","text":"1341. Movie Rating $\\star\\star$ \ud83d\udd12 1342. Number of Steps to Reduce a Number to Zero $\\star$ 1343. Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold $\\star\\star$ 1344. Angle Between Hands of a Clock $\\star\\star$ class Solution { public : double angleClock ( int hour , int minutes ) { double hourAngle = ( hour % 12 ) * 30 + minutes * 0.5 ; double minuteAngle = minutes * 6 ; double ans = abs ( hourAngle - minuteAngle ); return min ( ans , 360 - ans ); } }; 1345. Jump Game IV $\\star\\star\\star$ 1346. Check If N and Its Double Exist $\\star$ 1347. Minimum Number of Steps to Make Two Strings Anagram $\\star\\star$ 1348. Tweet Counts Per Frequency $\\star\\star$ 1349. Maximum Students Taking Exam $\\star\\star\\star$ 1350. Students With Invalid Departments $\\star$ \ud83d\udd12","title":"1341-1350"},{"location":"cpp/1301-1400/1341-1350/#1341-movie-rating-starstar","text":"","title":"1341. Movie Rating $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1301-1400/1341-1350/#1342-number-of-steps-to-reduce-a-number-to-zero-star","text":"","title":"1342. Number of Steps to Reduce a Number to Zero $\\star$"},{"location":"cpp/1301-1400/1341-1350/#1343-number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold-starstar","text":"","title":"1343. Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold $\\star\\star$"},{"location":"cpp/1301-1400/1341-1350/#1344-angle-between-hands-of-a-clock-starstar","text":"class Solution { public : double angleClock ( int hour , int minutes ) { double hourAngle = ( hour % 12 ) * 30 + minutes * 0.5 ; double minuteAngle = minutes * 6 ; double ans = abs ( hourAngle - minuteAngle ); return min ( ans , 360 - ans ); } };","title":"1344. Angle Between Hands of a Clock $\\star\\star$"},{"location":"cpp/1301-1400/1341-1350/#1345-jump-game-iv-starstarstar","text":"","title":"1345. Jump Game IV $\\star\\star\\star$"},{"location":"cpp/1301-1400/1341-1350/#1346-check-if-n-and-its-double-exist-star","text":"","title":"1346. Check If N and Its Double Exist $\\star$"},{"location":"cpp/1301-1400/1341-1350/#1347-minimum-number-of-steps-to-make-two-strings-anagram-starstar","text":"","title":"1347. Minimum Number of Steps to Make Two Strings Anagram $\\star\\star$"},{"location":"cpp/1301-1400/1341-1350/#1348-tweet-counts-per-frequency-starstar","text":"","title":"1348. Tweet Counts Per Frequency $\\star\\star$"},{"location":"cpp/1301-1400/1341-1350/#1349-maximum-students-taking-exam-starstarstar","text":"","title":"1349. Maximum Students Taking Exam $\\star\\star\\star$"},{"location":"cpp/1301-1400/1341-1350/#1350-students-with-invalid-departments-star","text":"","title":"1350. Students With Invalid Departments $\\star$ \ud83d\udd12"},{"location":"cpp/1301-1400/1351-1360/","text":"1351. Count Negative Numbers in a Sorted Matrix $\\star$ 1352. Product of the Last K Numbers $\\star\\star$ 1353. Maximum Number of Events That Can Be Attended $\\star\\star$ 1354. Construct Target Array With Multiple Sums $\\star\\star\\star$ 1355. Activity Participants $\\star\\star$ \ud83d\udd12 1356. Sort Integers by The Number of 1 Bits $\\star$ 1357. Apply Discount Every n Orders $\\star\\star$ 1358. Number of Substrings Containing All Three Characters $\\star\\star$ 1359. Count All Valid Pickup and Delivery Options $\\star\\star\\star$ class Solution { public : int countOrders ( int n ) { const int kMod = 1e9 + 7 ; long ans = 1 ; for ( int i = 1 ; i <= n ; ++ i ) ans = ans * i * ( i * 2 - 1 ) % kMod ; return ans ; } }; 1360. Number of Days Between Two Dates $\\star$","title":"1351-1360"},{"location":"cpp/1301-1400/1351-1360/#1351-count-negative-numbers-in-a-sorted-matrix-star","text":"","title":"1351. Count Negative Numbers in a Sorted Matrix $\\star$"},{"location":"cpp/1301-1400/1351-1360/#1352-product-of-the-last-k-numbers-starstar","text":"","title":"1352. Product of the Last K Numbers $\\star\\star$"},{"location":"cpp/1301-1400/1351-1360/#1353-maximum-number-of-events-that-can-be-attended-starstar","text":"","title":"1353. Maximum Number of Events That Can Be Attended $\\star\\star$"},{"location":"cpp/1301-1400/1351-1360/#1354-construct-target-array-with-multiple-sums-starstarstar","text":"","title":"1354. Construct Target Array With Multiple Sums $\\star\\star\\star$"},{"location":"cpp/1301-1400/1351-1360/#1355-activity-participants-starstar","text":"","title":"1355. Activity Participants $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1301-1400/1351-1360/#1356-sort-integers-by-the-number-of-1-bits-star","text":"","title":"1356. Sort Integers by The Number of 1 Bits $\\star$"},{"location":"cpp/1301-1400/1351-1360/#1357-apply-discount-every-n-orders-starstar","text":"","title":"1357. Apply Discount Every n Orders $\\star\\star$"},{"location":"cpp/1301-1400/1351-1360/#1358-number-of-substrings-containing-all-three-characters-starstar","text":"","title":"1358. Number of Substrings Containing All Three Characters $\\star\\star$"},{"location":"cpp/1301-1400/1351-1360/#1359-count-all-valid-pickup-and-delivery-options-starstarstar","text":"class Solution { public : int countOrders ( int n ) { const int kMod = 1e9 + 7 ; long ans = 1 ; for ( int i = 1 ; i <= n ; ++ i ) ans = ans * i * ( i * 2 - 1 ) % kMod ; return ans ; } };","title":"1359. Count All Valid Pickup and Delivery Options $\\star\\star\\star$"},{"location":"cpp/1301-1400/1351-1360/#1360-number-of-days-between-two-dates-star","text":"","title":"1360. Number of Days Between Two Dates $\\star$"},{"location":"cpp/1301-1400/1361-1370/","text":"1361. Validate Binary Tree Nodes $\\star\\star$ 1362. Closest Divisors $\\star\\star$ class Solution { public : vector < int > closestDivisors ( int num ) { for ( int root = sqrt ( num + 2 ); root > 0 ; -- root ) for ( int cand : { num + 1 , num + 2 }) if ( cand % root == 0 ) return { root , cand / root }; throw ; } }; 1363. Largest Multiple of Three $\\star\\star\\star$ class Solution { public : string largestMultipleOfThree ( vector < int >& digits ) { string ans ; vector < int > mod1 { 1 , 4 , 7 , 2 , 5 , 8 }; vector < int > mod2 { 2 , 5 , 8 , 1 , 4 , 7 }; vector < int > count ( 10 ); int sum = accumulate ( begin ( digits ), end ( digits ), 0 ); for ( int digit : digits ) ++ count [ digit ]; while ( sum % 3 != 0 ) for ( int i : sum % 3 == 1 ? mod1 : mod2 ) if ( count [ i ]) { -- count [ i ]; sum -= i ; break ; } for ( int digit = 9 ; digit >= 0 ; -- digit ) ans += string ( count [ digit ], '0' + digit ); return ans . size () && ans [ 0 ] == '0' ? \"0\" : ans ; } }; 1364. Number of Trusted Contacts of a Customer $\\star\\star$ \ud83d\udd12 1365. How Many Numbers Are Smaller Than the Current Number $\\star$ 1366. Rank Teams by Votes $\\star\\star$ 1367. Linked List in Binary Tree $\\star\\star$ 1368. Minimum Cost to Make at Least One Valid Path in a Grid $\\star\\star\\star$ 1369. Get the Second Most Recent Activity $\\star\\star\\star$ \ud83d\udd12 1370. Increasing Decreasing String $\\star$","title":"1361-1370"},{"location":"cpp/1301-1400/1361-1370/#1361-validate-binary-tree-nodes-starstar","text":"","title":"1361. Validate Binary Tree Nodes $\\star\\star$"},{"location":"cpp/1301-1400/1361-1370/#1362-closest-divisors-starstar","text":"class Solution { public : vector < int > closestDivisors ( int num ) { for ( int root = sqrt ( num + 2 ); root > 0 ; -- root ) for ( int cand : { num + 1 , num + 2 }) if ( cand % root == 0 ) return { root , cand / root }; throw ; } };","title":"1362. Closest Divisors $\\star\\star$"},{"location":"cpp/1301-1400/1361-1370/#1363-largest-multiple-of-three-starstarstar","text":"class Solution { public : string largestMultipleOfThree ( vector < int >& digits ) { string ans ; vector < int > mod1 { 1 , 4 , 7 , 2 , 5 , 8 }; vector < int > mod2 { 2 , 5 , 8 , 1 , 4 , 7 }; vector < int > count ( 10 ); int sum = accumulate ( begin ( digits ), end ( digits ), 0 ); for ( int digit : digits ) ++ count [ digit ]; while ( sum % 3 != 0 ) for ( int i : sum % 3 == 1 ? mod1 : mod2 ) if ( count [ i ]) { -- count [ i ]; sum -= i ; break ; } for ( int digit = 9 ; digit >= 0 ; -- digit ) ans += string ( count [ digit ], '0' + digit ); return ans . size () && ans [ 0 ] == '0' ? \"0\" : ans ; } };","title":"1363. Largest Multiple of Three $\\star\\star\\star$"},{"location":"cpp/1301-1400/1361-1370/#1364-number-of-trusted-contacts-of-a-customer-starstar","text":"","title":"1364. Number of Trusted Contacts of a Customer $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1301-1400/1361-1370/#1365-how-many-numbers-are-smaller-than-the-current-number-star","text":"","title":"1365. How Many Numbers Are Smaller Than the Current Number $\\star$"},{"location":"cpp/1301-1400/1361-1370/#1366-rank-teams-by-votes-starstar","text":"","title":"1366. Rank Teams by Votes $\\star\\star$"},{"location":"cpp/1301-1400/1361-1370/#1367-linked-list-in-binary-tree-starstar","text":"","title":"1367. Linked List in Binary Tree $\\star\\star$"},{"location":"cpp/1301-1400/1361-1370/#1368-minimum-cost-to-make-at-least-one-valid-path-in-a-grid-starstarstar","text":"","title":"1368. Minimum Cost to Make at Least One Valid Path in a Grid $\\star\\star\\star$"},{"location":"cpp/1301-1400/1361-1370/#1369-get-the-second-most-recent-activity-starstarstar","text":"","title":"1369. Get the Second Most Recent Activity $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/1301-1400/1361-1370/#1370-increasing-decreasing-string-star","text":"","title":"1370. Increasing Decreasing String $\\star$"},{"location":"cpp/1301-1400/1371-1380/","text":"1371. Find the Longest Substring Containing Vowels in Even Counts $\\star\\star$ 1372. Longest ZigZag Path in a Binary Tree $\\star\\star$ 1373. Maximum Sum BST in Binary Tree $\\star\\star\\star$ class Solution { public : int maxSumBST ( TreeNode * root ) { int ans = 0 ; dfs ( root , ans ); return ans ; } private : tuple < int , int , int , bool > dfs ( TreeNode * root , int & ans ) { if ( ! root ) return { INT_MAX , INT_MIN , 0 , true }; auto [ leftMin , leftMax , leftSum , leftValid ] = dfs ( root -> left , ans ); auto [ rightMin , rightMax , rightSum , rightValid ] = dfs ( root -> right , ans ); bool valid = leftValid && rightValid && root -> val > leftMax && root -> val < rightMin ; int sum = valid ? root -> val + leftSum + rightSum : - 1 ; ans = max ( ans , sum ); return { min ( root -> val , leftMin ), max ( root -> val , rightMax ), sum , valid }; } }; 1374. Generate a String With Characters That Have Odd Counts $\\star$ 1375. Bulb Switcher III $\\star\\star$ 1376. Time Needed to Inform All Employees $\\star\\star$ 1377. Frog Position After T Seconds $\\star\\star\\star$ class Solution { public : double frogPosition ( int n , vector < vector < int >>& edges , int t , int target ) { vector < double > prob ( n + 1 ); vector < bool > visited ( n + 1 ); queue < int > queue {{ 1 }}; vector < vector < int >> graph ( n + 1 ); prob [ 1 ] = 1.0 ; visited [ 1 ] = true ; for ( vector < int >& edge : edges ) { graph [ edge [ 0 ]]. push_back ( edge [ 1 ]); graph [ edge [ 1 ]]. push_back ( edge [ 0 ]); } for ( int i = 0 ; i < t ; ++ i ) for ( int j = queue . size (); j > 0 ; -- j ) { int curr = queue . front (); queue . pop (); int children = count_if ( begin ( graph [ curr ]), end ( graph [ curr ]), [ & visited ]( int child ) { return ! visited [ child ]; }); for ( int child : graph [ curr ]) if ( ! visited [ child ]) { visited [ child ] = true ; prob [ child ] = prob [ curr ] / children ; queue . push ( child ); } if ( children > 0 ) prob [ curr ] = 0.0 ; } return prob [ target ]; } }; 1378. Replace Employee ID With The Unique Identifier $\\star$ \ud83d\udd12 1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree $\\star\\star$ 1380. Lucky Numbers in a Matrix $\\star$","title":"1371-1380"},{"location":"cpp/1301-1400/1371-1380/#1371-find-the-longest-substring-containing-vowels-in-even-counts-starstar","text":"","title":"1371. Find the Longest Substring Containing Vowels in Even Counts $\\star\\star$"},{"location":"cpp/1301-1400/1371-1380/#1372-longest-zigzag-path-in-a-binary-tree-starstar","text":"","title":"1372. Longest ZigZag Path in a Binary Tree $\\star\\star$"},{"location":"cpp/1301-1400/1371-1380/#1373-maximum-sum-bst-in-binary-tree-starstarstar","text":"class Solution { public : int maxSumBST ( TreeNode * root ) { int ans = 0 ; dfs ( root , ans ); return ans ; } private : tuple < int , int , int , bool > dfs ( TreeNode * root , int & ans ) { if ( ! root ) return { INT_MAX , INT_MIN , 0 , true }; auto [ leftMin , leftMax , leftSum , leftValid ] = dfs ( root -> left , ans ); auto [ rightMin , rightMax , rightSum , rightValid ] = dfs ( root -> right , ans ); bool valid = leftValid && rightValid && root -> val > leftMax && root -> val < rightMin ; int sum = valid ? root -> val + leftSum + rightSum : - 1 ; ans = max ( ans , sum ); return { min ( root -> val , leftMin ), max ( root -> val , rightMax ), sum , valid }; } };","title":"1373. Maximum Sum BST in Binary Tree $\\star\\star\\star$"},{"location":"cpp/1301-1400/1371-1380/#1374-generate-a-string-with-characters-that-have-odd-counts-star","text":"","title":"1374. Generate a String With Characters That Have Odd Counts $\\star$"},{"location":"cpp/1301-1400/1371-1380/#1375-bulb-switcher-iii-starstar","text":"","title":"1375. Bulb Switcher III $\\star\\star$"},{"location":"cpp/1301-1400/1371-1380/#1376-time-needed-to-inform-all-employees-starstar","text":"","title":"1376. Time Needed to Inform All Employees $\\star\\star$"},{"location":"cpp/1301-1400/1371-1380/#1377-frog-position-after-t-seconds-starstarstar","text":"class Solution { public : double frogPosition ( int n , vector < vector < int >>& edges , int t , int target ) { vector < double > prob ( n + 1 ); vector < bool > visited ( n + 1 ); queue < int > queue {{ 1 }}; vector < vector < int >> graph ( n + 1 ); prob [ 1 ] = 1.0 ; visited [ 1 ] = true ; for ( vector < int >& edge : edges ) { graph [ edge [ 0 ]]. push_back ( edge [ 1 ]); graph [ edge [ 1 ]]. push_back ( edge [ 0 ]); } for ( int i = 0 ; i < t ; ++ i ) for ( int j = queue . size (); j > 0 ; -- j ) { int curr = queue . front (); queue . pop (); int children = count_if ( begin ( graph [ curr ]), end ( graph [ curr ]), [ & visited ]( int child ) { return ! visited [ child ]; }); for ( int child : graph [ curr ]) if ( ! visited [ child ]) { visited [ child ] = true ; prob [ child ] = prob [ curr ] / children ; queue . push ( child ); } if ( children > 0 ) prob [ curr ] = 0.0 ; } return prob [ target ]; } };","title":"1377. Frog Position After T Seconds $\\star\\star\\star$"},{"location":"cpp/1301-1400/1371-1380/#1378-replace-employee-id-with-the-unique-identifier-star","text":"","title":"1378. Replace Employee ID With The Unique Identifier $\\star$ \ud83d\udd12"},{"location":"cpp/1301-1400/1371-1380/#1379-find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree-starstar","text":"","title":"1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree $\\star\\star$"},{"location":"cpp/1301-1400/1371-1380/#1380-lucky-numbers-in-a-matrix-star","text":"","title":"1380. Lucky Numbers in a Matrix $\\star$"},{"location":"cpp/1301-1400/1381-1390/","text":"1381. Design a Stack With Increment Operation $\\star\\star$ 1382. Balance a Binary Search Tree $\\star\\star$ 1383. Maximum Performance of a Team $\\star\\star\\star$ 1384. Total Sales Amount by Year $\\star\\star\\star$ \ud83d\udd12 1385. Find the Distance Value Between Two Arrays $\\star$ 1386. Cinema Seat Allocation $\\star\\star$ 1387. Sort Integers by The Power Value $\\star\\star$ 1388. Pizza With 3n Slices $\\star\\star\\star$ 1389. Create Target Array in the Given Order $\\star$ 1390. Four Divisors $\\star\\star$ class Solution { public : int sumFourDivisors ( vector < int >& nums ) { int ans = 0 ; for ( int num : nums ) { int divisor = 0 ; for ( int i = 2 ; i * i <= num ; ++ i ) if ( num % i == 0 ) { if ( divisor == 0 ) divisor = i ; else { divisor = 0 ; break ; } } if ( divisor > 0 && divisor * divisor < num ) ans += 1 + num + divisor + num / divisor ; } return ans ; } };","title":"1381-1390"},{"location":"cpp/1301-1400/1381-1390/#1381-design-a-stack-with-increment-operation-starstar","text":"","title":"1381. Design a Stack With Increment Operation $\\star\\star$"},{"location":"cpp/1301-1400/1381-1390/#1382-balance-a-binary-search-tree-starstar","text":"","title":"1382. Balance a Binary Search Tree $\\star\\star$"},{"location":"cpp/1301-1400/1381-1390/#1383-maximum-performance-of-a-team-starstarstar","text":"","title":"1383. Maximum Performance of a Team $\\star\\star\\star$"},{"location":"cpp/1301-1400/1381-1390/#1384-total-sales-amount-by-year-starstarstar","text":"","title":"1384. Total Sales Amount by Year $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/1301-1400/1381-1390/#1385-find-the-distance-value-between-two-arrays-star","text":"","title":"1385. Find the Distance Value Between Two Arrays $\\star$"},{"location":"cpp/1301-1400/1381-1390/#1386-cinema-seat-allocation-starstar","text":"","title":"1386. Cinema Seat Allocation $\\star\\star$"},{"location":"cpp/1301-1400/1381-1390/#1387-sort-integers-by-the-power-value-starstar","text":"","title":"1387. Sort Integers by The Power Value $\\star\\star$"},{"location":"cpp/1301-1400/1381-1390/#1388-pizza-with-3n-slices-starstarstar","text":"","title":"1388. Pizza With 3n Slices $\\star\\star\\star$"},{"location":"cpp/1301-1400/1381-1390/#1389-create-target-array-in-the-given-order-star","text":"","title":"1389. Create Target Array in the Given Order $\\star$"},{"location":"cpp/1301-1400/1381-1390/#1390-four-divisors-starstar","text":"class Solution { public : int sumFourDivisors ( vector < int >& nums ) { int ans = 0 ; for ( int num : nums ) { int divisor = 0 ; for ( int i = 2 ; i * i <= num ; ++ i ) if ( num % i == 0 ) { if ( divisor == 0 ) divisor = i ; else { divisor = 0 ; break ; } } if ( divisor > 0 && divisor * divisor < num ) ans += 1 + num + divisor + num / divisor ; } return ans ; } };","title":"1390. Four Divisors $\\star\\star$"},{"location":"cpp/1301-1400/1391-1400/","text":"1391. Check if There is a Valid Path in a Grid $\\star\\star$ 1392. Longest Happy Prefix $\\star\\star\\star$ 1393. Capital Gain/Loss $\\star\\star$ \ud83d\udd12 1394. Find Lucky Integer in an Array $\\star$ 1395. Count Number of Teams $\\star\\star$ 1396. Design Underground System $\\star\\star$ 1397. Find All Good Strings $\\star\\star\\star$ 1398. Customers Who Bought Products A and B but Not C $\\star\\star$ \ud83d\udd12 1399. Count Largest Group $\\star$ 1400. Construct K Palindrome Strings $\\star\\star$","title":"1391-1400"},{"location":"cpp/1301-1400/1391-1400/#1391-check-if-there-is-a-valid-path-in-a-grid-starstar","text":"","title":"1391. Check if There is a Valid Path in a Grid $\\star\\star$"},{"location":"cpp/1301-1400/1391-1400/#1392-longest-happy-prefix-starstarstar","text":"","title":"1392. Longest Happy Prefix $\\star\\star\\star$"},{"location":"cpp/1301-1400/1391-1400/#1393-capital-gainloss-starstar","text":"","title":"1393. Capital Gain/Loss $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1301-1400/1391-1400/#1394-find-lucky-integer-in-an-array-star","text":"","title":"1394. Find Lucky Integer in an Array $\\star$"},{"location":"cpp/1301-1400/1391-1400/#1395-count-number-of-teams-starstar","text":"","title":"1395. Count Number of Teams $\\star\\star$"},{"location":"cpp/1301-1400/1391-1400/#1396-design-underground-system-starstar","text":"","title":"1396. Design Underground System $\\star\\star$"},{"location":"cpp/1301-1400/1391-1400/#1397-find-all-good-strings-starstarstar","text":"","title":"1397. Find All Good Strings $\\star\\star\\star$"},{"location":"cpp/1301-1400/1391-1400/#1398-customers-who-bought-products-a-and-b-but-not-c-starstar","text":"","title":"1398. Customers Who Bought Products A and B but Not C $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1301-1400/1391-1400/#1399-count-largest-group-star","text":"","title":"1399. Count Largest Group $\\star$"},{"location":"cpp/1301-1400/1391-1400/#1400-construct-k-palindrome-strings-starstar","text":"","title":"1400. Construct K Palindrome Strings $\\star\\star$"},{"location":"cpp/1401-1500/1401-1410/","text":"1401. Circle and Rectangle Overlapping $\\star\\star$ Time: $O(1)$ Space: $O(1)$ class Solution { public : bool checkOverlap ( int radius , int x_center , int y_center , int x1 , int y1 , int x2 , int y2 ) { auto clamp = [ & ]( int center , int mini , int maxi ) { return max ( mini , min ( maxi , center )); }; // the closest point to the circle within the rectangle int closestX = clamp ( x_center , x1 , x2 ); int closestY = clamp ( y_center , y1 , y2 ); // the distance between the circle's center and this closest point int distanceX = x_center - closestX ; int distanceY = y_center - closestY ; // if the distance is less than the circle's radius, an intersection occurs return ( distanceX * distanceX ) + ( distanceY * distanceY ) <= ( radius * radius ); } }; 1402. Reducing Dishes $\\star\\star\\star$ 1403. Minimum Subsequence in Non-Increasing Order $\\star$ 1404. Number of Steps to Reduce a Number in Binary Representation to One $\\star\\star$ 1405. Longest Happy String $\\star\\star$ 1406. Stone Game III $\\star\\star\\star$ class Solution { public : string stoneGameIII ( vector < int >& stoneValue ) { const int n = stoneValue . size (); vector < int > dp ( n + 1 , - 1e9 ); dp . back () = 0 ; for ( int i = n - 1 ; i >= 0 ; -- i ) { int sum = 0 ; for ( int j = i ; j < i + 3 && j < n ; ++ j ) { sum += stoneValue [ j ]; dp [ i ] = max ( dp [ i ], sum - dp [ j + 1 ]); } } return dp [ 0 ] > 0 ? \"Alice\" : dp [ 0 ] < 0 ? \"Bob\" : \"Tie\" ; } }; 1407. Top Travellers $\\star$ \ud83d\udd12 1408. String Matching in an Array $\\star$ 1409. Queries on a Permutation With Key $\\star\\star$ 1410. HTML Entity Parser $\\star\\star$","title":"1401-1410"},{"location":"cpp/1401-1500/1401-1410/#1401-circle-and-rectangle-overlapping-starstar","text":"Time: $O(1)$ Space: $O(1)$ class Solution { public : bool checkOverlap ( int radius , int x_center , int y_center , int x1 , int y1 , int x2 , int y2 ) { auto clamp = [ & ]( int center , int mini , int maxi ) { return max ( mini , min ( maxi , center )); }; // the closest point to the circle within the rectangle int closestX = clamp ( x_center , x1 , x2 ); int closestY = clamp ( y_center , y1 , y2 ); // the distance between the circle's center and this closest point int distanceX = x_center - closestX ; int distanceY = y_center - closestY ; // if the distance is less than the circle's radius, an intersection occurs return ( distanceX * distanceX ) + ( distanceY * distanceY ) <= ( radius * radius ); } };","title":"1401. Circle and Rectangle Overlapping $\\star\\star$"},{"location":"cpp/1401-1500/1401-1410/#1402-reducing-dishes-starstarstar","text":"","title":"1402. Reducing Dishes $\\star\\star\\star$"},{"location":"cpp/1401-1500/1401-1410/#1403-minimum-subsequence-in-non-increasing-order-star","text":"","title":"1403. Minimum Subsequence in Non-Increasing Order $\\star$"},{"location":"cpp/1401-1500/1401-1410/#1404-number-of-steps-to-reduce-a-number-in-binary-representation-to-one-starstar","text":"","title":"1404. Number of Steps to Reduce a Number in Binary Representation to One $\\star\\star$"},{"location":"cpp/1401-1500/1401-1410/#1405-longest-happy-string-starstar","text":"","title":"1405. Longest Happy String $\\star\\star$"},{"location":"cpp/1401-1500/1401-1410/#1406-stone-game-iii-starstarstar","text":"class Solution { public : string stoneGameIII ( vector < int >& stoneValue ) { const int n = stoneValue . size (); vector < int > dp ( n + 1 , - 1e9 ); dp . back () = 0 ; for ( int i = n - 1 ; i >= 0 ; -- i ) { int sum = 0 ; for ( int j = i ; j < i + 3 && j < n ; ++ j ) { sum += stoneValue [ j ]; dp [ i ] = max ( dp [ i ], sum - dp [ j + 1 ]); } } return dp [ 0 ] > 0 ? \"Alice\" : dp [ 0 ] < 0 ? \"Bob\" : \"Tie\" ; } };","title":"1406. Stone Game III $\\star\\star\\star$"},{"location":"cpp/1401-1500/1401-1410/#1407-top-travellers-star","text":"","title":"1407. Top Travellers $\\star$ \ud83d\udd12"},{"location":"cpp/1401-1500/1401-1410/#1408-string-matching-in-an-array-star","text":"","title":"1408. String Matching in an Array $\\star$"},{"location":"cpp/1401-1500/1401-1410/#1409-queries-on-a-permutation-with-key-starstar","text":"","title":"1409. Queries on a Permutation With Key $\\star\\star$"},{"location":"cpp/1401-1500/1401-1410/#1410-html-entity-parser-starstar","text":"","title":"1410. HTML Entity Parser $\\star\\star$"},{"location":"cpp/1401-1500/1411-1420/","text":"1411. Number of Ways to Paint N \u00d7 3 Grid $\\star\\star\\star$ 1412. Find the Quiet Students in All Exams $\\star\\star\\star$ \ud83d\udd12 1413. Minimum Value to Get Positive Step by Step Sum $\\star$ 1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K $\\star\\star$ 1415. The k-th Lexicographical String of All Happy Strings of Length n $\\star\\star$ 1416. Restore The Array $\\star\\star\\star$ class Solution { public : int numberOfArrays ( string s , int k ) { constexpr int kMod = 1e9 + 7 ; const int n = s . length (); vector < int > dp ( n + 1 ); dp . back () = 1 ; for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( s [ i ] == '0' ) continue ; for ( int j = i + 1 ; j <= n ; ++ j ) { long num = stol ( s . substr ( i , j - i )); if ( num > k ) break ; dp [ i ] = ( dp [ i ] + dp [ j ]) % kMod ; } } return dp [ 0 ]; } }; 1417. Reformat The String $\\star$ 1418. Display Table of Food Orders in a Restaurant $\\star\\star$ 1419. Minimum Number of Frogs Croaking $\\star\\star$ 1420. Build Array Where You Can Find The Maximum Exactly K Comparisons $\\star\\star\\star$","title":"1411-1420"},{"location":"cpp/1401-1500/1411-1420/#1411-number-of-ways-to-paint-n-3-grid-starstarstar","text":"","title":"1411. Number of Ways to Paint N \u00d7 3 Grid $\\star\\star\\star$"},{"location":"cpp/1401-1500/1411-1420/#1412-find-the-quiet-students-in-all-exams-starstarstar","text":"","title":"1412. Find the Quiet Students in All Exams $\\star\\star\\star$ \ud83d\udd12"},{"location":"cpp/1401-1500/1411-1420/#1413-minimum-value-to-get-positive-step-by-step-sum-star","text":"","title":"1413. Minimum Value to Get Positive Step by Step Sum $\\star$"},{"location":"cpp/1401-1500/1411-1420/#1414-find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k-starstar","text":"","title":"1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K $\\star\\star$"},{"location":"cpp/1401-1500/1411-1420/#1415-the-k-th-lexicographical-string-of-all-happy-strings-of-length-n-starstar","text":"","title":"1415. The k-th Lexicographical String of All Happy Strings of Length n $\\star\\star$"},{"location":"cpp/1401-1500/1411-1420/#1416-restore-the-array-starstarstar","text":"class Solution { public : int numberOfArrays ( string s , int k ) { constexpr int kMod = 1e9 + 7 ; const int n = s . length (); vector < int > dp ( n + 1 ); dp . back () = 1 ; for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( s [ i ] == '0' ) continue ; for ( int j = i + 1 ; j <= n ; ++ j ) { long num = stol ( s . substr ( i , j - i )); if ( num > k ) break ; dp [ i ] = ( dp [ i ] + dp [ j ]) % kMod ; } } return dp [ 0 ]; } };","title":"1416. Restore The Array $\\star\\star\\star$"},{"location":"cpp/1401-1500/1411-1420/#1417-reformat-the-string-star","text":"","title":"1417. Reformat The String $\\star$"},{"location":"cpp/1401-1500/1411-1420/#1418-display-table-of-food-orders-in-a-restaurant-starstar","text":"","title":"1418. Display Table of Food Orders in a Restaurant $\\star\\star$"},{"location":"cpp/1401-1500/1411-1420/#1419-minimum-number-of-frogs-croaking-starstar","text":"","title":"1419. Minimum Number of Frogs Croaking $\\star\\star$"},{"location":"cpp/1401-1500/1411-1420/#1420-build-array-where-you-can-find-the-maximum-exactly-k-comparisons-starstarstar","text":"","title":"1420. Build Array Where You Can Find The Maximum Exactly K Comparisons $\\star\\star\\star$"},{"location":"cpp/1401-1500/1421-1430/","text":"1421. NPV Queries $\\star\\star$ \ud83d\udd12 1422. Maximum Score After Splitting a String $\\star$ 1423. Maximum Points You Can Obtain from Cards $\\star\\star$ 1424. Diagonal Traverse II $\\star\\star$ 1425. Constrained Subsequence Sum $\\star\\star\\star$ class Solution { public : int constrainedSubsetSum ( vector < int >& nums , int k ) { int ans = INT_MIN ; vector < int > dp ( nums . size ()); deque < int > q ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( q . empty ()) dp [ i ] = nums [ i ]; else dp [ i ] = max ( q . front (), 0 ) + nums [ i ]; ans = max ( ans , dp [ i ]); while ( ! q . empty () && q . back () < dp [ i ]) q . pop_back (); q . push_back ( dp [ i ]); if ( i >= k && dp [ i - k ] == q . front ()) q . pop_front (); } return ans ; } }; 1426. Counting Elements $\\star$ \ud83d\udd12 1427. Perform String Shifts $\\star$ \ud83d\udd12 1428. Leftmost Column with at Least a One $\\star\\star$ \ud83d\udd12 1429. First Unique Number $\\star\\star$ \ud83d\udd12 1430. Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree $\\star\\star$ \ud83d\udd12","title":"1421-1430"},{"location":"cpp/1401-1500/1421-1430/#1421-npv-queries-starstar","text":"","title":"1421. NPV Queries $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1401-1500/1421-1430/#1422-maximum-score-after-splitting-a-string-star","text":"","title":"1422. Maximum Score After Splitting a String $\\star$"},{"location":"cpp/1401-1500/1421-1430/#1423-maximum-points-you-can-obtain-from-cards-starstar","text":"","title":"1423. Maximum Points You Can Obtain from Cards $\\star\\star$"},{"location":"cpp/1401-1500/1421-1430/#1424-diagonal-traverse-ii-starstar","text":"","title":"1424. Diagonal Traverse II $\\star\\star$"},{"location":"cpp/1401-1500/1421-1430/#1425-constrained-subsequence-sum-starstarstar","text":"class Solution { public : int constrainedSubsetSum ( vector < int >& nums , int k ) { int ans = INT_MIN ; vector < int > dp ( nums . size ()); deque < int > q ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( q . empty ()) dp [ i ] = nums [ i ]; else dp [ i ] = max ( q . front (), 0 ) + nums [ i ]; ans = max ( ans , dp [ i ]); while ( ! q . empty () && q . back () < dp [ i ]) q . pop_back (); q . push_back ( dp [ i ]); if ( i >= k && dp [ i - k ] == q . front ()) q . pop_front (); } return ans ; } };","title":"1425. Constrained Subsequence Sum $\\star\\star\\star$"},{"location":"cpp/1401-1500/1421-1430/#1426-counting-elements-star","text":"","title":"1426. Counting Elements $\\star$ \ud83d\udd12"},{"location":"cpp/1401-1500/1421-1430/#1427-perform-string-shifts-star","text":"","title":"1427. Perform String Shifts $\\star$ \ud83d\udd12"},{"location":"cpp/1401-1500/1421-1430/#1428-leftmost-column-with-at-least-a-one-starstar","text":"","title":"1428. Leftmost Column with at Least a One $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1401-1500/1421-1430/#1429-first-unique-number-starstar","text":"","title":"1429. First Unique Number $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1401-1500/1421-1430/#1430-check-if-a-string-is-a-valid-sequence-from-root-to-leaves-path-in-a-binary-tree-starstar","text":"","title":"1430. Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1401-1500/1431-1440/","text":"1431. Kids With the Greatest Number of Candies $\\star$ 1432. Max Difference You Can Get From Changing an Integer $\\star\\star$ 1433. Check If a String Can Break Another String $\\star\\star$ 1434. Number of Ways to Wear Different Hats to Each Other $\\star\\star\\star$ 1435. Create a Session Bar Chart $\\star$ \ud83d\udd12 1436. Destination City $\\star$ 1437. Check If All 1's Are at Least Length K Places Away $\\star\\star$ 1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit $\\star\\star$ 1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows $\\star\\star\\star$ 1440. Evaluate Boolean Expression $\\star\\star$ \ud83d\udd12","title":"1431-1440"},{"location":"cpp/1401-1500/1431-1440/#1431-kids-with-the-greatest-number-of-candies-star","text":"","title":"1431. Kids With the Greatest Number of Candies $\\star$"},{"location":"cpp/1401-1500/1431-1440/#1432-max-difference-you-can-get-from-changing-an-integer-starstar","text":"","title":"1432. Max Difference You Can Get From Changing an Integer $\\star\\star$"},{"location":"cpp/1401-1500/1431-1440/#1433-check-if-a-string-can-break-another-string-starstar","text":"","title":"1433. Check If a String Can Break Another String $\\star\\star$"},{"location":"cpp/1401-1500/1431-1440/#1434-number-of-ways-to-wear-different-hats-to-each-other-starstarstar","text":"","title":"1434. Number of Ways to Wear Different Hats to Each Other $\\star\\star\\star$"},{"location":"cpp/1401-1500/1431-1440/#1435-create-a-session-bar-chart-star","text":"","title":"1435. Create a Session Bar Chart $\\star$ \ud83d\udd12"},{"location":"cpp/1401-1500/1431-1440/#1436-destination-city-star","text":"","title":"1436. Destination City $\\star$"},{"location":"cpp/1401-1500/1431-1440/#1437-check-if-all-1s-are-at-least-length-k-places-away-starstar","text":"","title":"1437. Check If All 1's Are at Least Length K Places Away $\\star\\star$"},{"location":"cpp/1401-1500/1431-1440/#1438-longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit-starstar","text":"","title":"1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit $\\star\\star$"},{"location":"cpp/1401-1500/1431-1440/#1439-find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows-starstarstar","text":"","title":"1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows $\\star\\star\\star$"},{"location":"cpp/1401-1500/1431-1440/#1440-evaluate-boolean-expression-starstar","text":"","title":"1440. Evaluate Boolean Expression $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1401-1500/1441-1450/","text":"1441. Build an Array With Stack Operations $\\star$ 1442. Count Triplets That Can Form Two Arrays of Equal XOR $\\star\\star$ 1443. Minimum Time to Collect All Apples in a Tree $\\star\\star$ 1444. Number of Ways of Cutting a Pizza $\\star\\star\\star$ 1445. Apples & Oranges $\\star\\star$ \ud83d\udd12 1446. Consecutive Characters $\\star$ 1447. Simplified Fractions $\\star\\star$ 1448. Count Good Nodes in Binary Tree $\\star\\star$ 1449. Form Largest Integer With Digits That Add up to Target $\\star\\star\\star$ 1450. Number of Students Doing Homework at a Given Time $\\star$","title":"1441-1450"},{"location":"cpp/1401-1500/1441-1450/#1441-build-an-array-with-stack-operations-star","text":"","title":"1441. Build an Array With Stack Operations $\\star$"},{"location":"cpp/1401-1500/1441-1450/#1442-count-triplets-that-can-form-two-arrays-of-equal-xor-starstar","text":"","title":"1442. Count Triplets That Can Form Two Arrays of Equal XOR $\\star\\star$"},{"location":"cpp/1401-1500/1441-1450/#1443-minimum-time-to-collect-all-apples-in-a-tree-starstar","text":"","title":"1443. Minimum Time to Collect All Apples in a Tree $\\star\\star$"},{"location":"cpp/1401-1500/1441-1450/#1444-number-of-ways-of-cutting-a-pizza-starstarstar","text":"","title":"1444. Number of Ways of Cutting a Pizza $\\star\\star\\star$"},{"location":"cpp/1401-1500/1441-1450/#1445-apples-oranges-starstar","text":"","title":"1445. Apples &amp; Oranges $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1401-1500/1441-1450/#1446-consecutive-characters-star","text":"","title":"1446. Consecutive Characters $\\star$"},{"location":"cpp/1401-1500/1441-1450/#1447-simplified-fractions-starstar","text":"","title":"1447. Simplified Fractions $\\star\\star$"},{"location":"cpp/1401-1500/1441-1450/#1448-count-good-nodes-in-binary-tree-starstar","text":"","title":"1448. Count Good Nodes in Binary Tree $\\star\\star$"},{"location":"cpp/1401-1500/1441-1450/#1449-form-largest-integer-with-digits-that-add-up-to-target-starstarstar","text":"","title":"1449. Form Largest Integer With Digits That Add up to Target $\\star\\star\\star$"},{"location":"cpp/1401-1500/1441-1450/#1450-number-of-students-doing-homework-at-a-given-time-star","text":"","title":"1450. Number of Students Doing Homework at a Given Time $\\star$"},{"location":"cpp/1401-1500/1451-1460/","text":"1451. Rearrange Words in a Sentence $\\star\\star$ 1452. People Whose List of Favorite Companies Is Not a Subset of Another List $\\star\\star$ 1453. Maximum Number of Darts Inside of a Circular Dartboard $\\star\\star\\star$ 1454. Active Users $\\star\\star$ \ud83d\udd12 1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence $\\star$ 1456. Maximum Number of Vowels in a Substring of Given Length $\\star\\star$ 1457. Pseudo-Palindromic Paths in a Binary Tree $\\star\\star$ 1458. Max Dot Product of Two Subsequences $\\star\\star\\star$","title":"1451-1460"},{"location":"cpp/1401-1500/1451-1460/#1451-rearrange-words-in-a-sentence-starstar","text":"","title":"1451. Rearrange Words in a Sentence $\\star\\star$"},{"location":"cpp/1401-1500/1451-1460/#1452-people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list-starstar","text":"","title":"1452. People Whose List of Favorite Companies Is Not a Subset of Another List $\\star\\star$"},{"location":"cpp/1401-1500/1451-1460/#1453-maximum-number-of-darts-inside-of-a-circular-dartboard-starstarstar","text":"","title":"1453. Maximum Number of Darts Inside of a Circular Dartboard $\\star\\star\\star$"},{"location":"cpp/1401-1500/1451-1460/#1454-active-users-starstar","text":"","title":"1454. Active Users $\\star\\star$ \ud83d\udd12"},{"location":"cpp/1401-1500/1451-1460/#1455-check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence-star","text":"","title":"1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence $\\star$"},{"location":"cpp/1401-1500/1451-1460/#1456-maximum-number-of-vowels-in-a-substring-of-given-length-starstar","text":"","title":"1456. Maximum Number of Vowels in a Substring of Given Length $\\star\\star$"},{"location":"cpp/1401-1500/1451-1460/#1457-pseudo-palindromic-paths-in-a-binary-tree-starstar","text":"","title":"1457. Pseudo-Palindromic Paths in a Binary Tree $\\star\\star$"},{"location":"cpp/1401-1500/1451-1460/#1458-max-dot-product-of-two-subsequences-starstarstar","text":"","title":"1458. Max Dot Product of Two Subsequences $\\star\\star\\star$"},{"location":"java/","text":"LeetCode in Java Java code is formatted by Language Support for Java(TM) by Red Hat . Capable of being compiled with Java 8. It's sad that LeetCode doesn't support Java 13 in this moment. When dealing with string concatenation, use StringBuilder over String for better performance.","title":"Preface"},{"location":"java/#leetcode-in-java","text":"Java code is formatted by Language Support for Java(TM) by Red Hat . Capable of being compiled with Java 8. It's sad that LeetCode doesn't support Java 13 in this moment. When dealing with string concatenation, use StringBuilder over String for better performance.","title":"LeetCode in Java"},{"location":"java/0001-0100/0001-0010/","text":"1. Two Sum $\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public int [] twoSum ( int [] nums , int target ) { Map < Integer , Integer > numToIndex = new HashMap <> (); for ( int i = 0 ; i < nums . length ; ++ i ) { if ( numToIndex . containsKey ( target - nums [ i ] )) return new int [] { numToIndex . get ( target - nums [ i ] ), i }; numToIndex . put ( nums [ i ] , i ); } throw new IllegalArgumentException (); } } 2. Add Two Numbers $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public ListNode addTwoNumbers ( ListNode l1 , ListNode l2 ) { ListNode dummy = new ListNode ( 0 ); ListNode curr = dummy ; int carry = 0 ; while ( carry > 0 || l1 != null || l2 != null ) { carry += ( l1 == null ? 0 : l1 . val ) + ( l2 == null ? 0 : l2 . val ); curr . next = new ListNode ( carry % 10 ); curr = curr . next ; carry /= 10 ; if ( l1 != null ) l1 = l1 . next ; if ( l2 != null ) l2 = l2 . next ; } return dummy . next ; } } 3. Longest Substring Without Repeating Characters $\\star\\star$ Time: $O(n)$ Space: $O(128)$ class Solution { public int lengthOfLongestSubstring ( String s ) { int ans = 0 ; int [] count = new int [ 128 ] ; for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { ++ count [ s . charAt ( r ) ] ; while ( count [ s . charAt ( r ) ] > 1 ) -- count [ s . charAt ( l ++ ) ] ; ans = Math . max ( ans , r - l + 1 ); } return ans ; } } 4. Median of Two Sorted Arrays $\\star\\star\\star$ Time: $O(\\log\\min(m, n))$ Space: $O(1)$ class Solution { public double findMedianSortedArrays ( int [] nums1 , int [] nums2 ) { final int n1 = nums1 . length ; final int n2 = nums2 . length ; if ( n1 > n2 ) return findMedianSortedArrays ( nums2 , nums1 ); int l = 0 ; int r = n1 ; while ( l <= r ) { int partition1 = l + ( r - l ) / 2 ; int partition2 = ( n1 + n2 + 1 ) / 2 - partition1 ; int maxLeft1 = partition1 == 0 ? Integer . MIN_VALUE : nums1 [ partition1 - 1 ] ; int maxLeft2 = partition2 == 0 ? Integer . MIN_VALUE : nums2 [ partition2 - 1 ] ; int minRight1 = partition1 == n1 ? Integer . MAX_VALUE : nums1 [ partition1 ] ; int minRight2 = partition2 == n2 ? Integer . MAX_VALUE : nums2 [ partition2 ] ; if ( maxLeft1 <= minRight2 && maxLeft2 <= minRight1 ) return ( n1 + n2 ) % 2 == 0 ? ( Math . max ( maxLeft1 , maxLeft2 ) + Math . min ( minRight1 , minRight2 )) * 0.5 : Math . max ( maxLeft1 , maxLeft2 ); else if ( maxLeft1 > minRight2 ) r = partition1 - 1 ; else l = partition1 + 1 ; } throw new IllegalArgumentException (); } } 5. Longest Palindromic Substring $\\star\\star$ 6. ZigZag Conversion $\\star\\star$ 7. Reverse Integer $\\star$ Time: $O(\\log x)$ Space: $O(1)$ class Solution { public int reverse ( int x ) { long ans = 0 ; while ( x != 0 ) { ans = ans * 10 + x % 10 ; x /= 10 ; } return ( ans < Integer . MIN_VALUE || ans > Integer . MAX_VALUE ) ? 0 : ( int ) ans ; } } 8. String to Integer (atoi) $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public int myAtoi ( String str ) { long ans = 0 ; str = str . strip (); if ( str . isEmpty ()) return 0 ; boolean isNegative = str . charAt ( 0 ) == '-' ; if ( str . charAt ( 0 ) == '-' || str . charAt ( 0 ) == '+' ) str = str . substring ( 1 , str . length ()); for ( char c : str . toCharArray ()) { if ( ! Character . isDigit ( c )) break ; ans = ans * 10 + ( c - '0' ); if ( isNegative && - ans <= Integer . MIN_VALUE ) return Integer . MIN_VALUE ; if ( ! isNegative && ans >= Integer . MAX_VALUE ) return Integer . MAX_VALUE ; } return isNegative ? ( int ) - ans : ( int ) ans ; } } 9. Palindrome Number $\\star$ Time: $O\\log x)$ Space: $O(1)$ class Solution { public boolean isPalindrome ( int x ) { if ( x < 0 ) return false ; long ans = 0 ; int y = x ; while ( y > 0 ) { ans = ans * 10 + y % 10 ; y /= 10 ; } return ( int ) ans == x ; } } 10. Regular Expression Matching $\\star\\star\\star$","title":"0001-0010"},{"location":"java/0001-0100/0001-0010/#1-two-sum-star","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public int [] twoSum ( int [] nums , int target ) { Map < Integer , Integer > numToIndex = new HashMap <> (); for ( int i = 0 ; i < nums . length ; ++ i ) { if ( numToIndex . containsKey ( target - nums [ i ] )) return new int [] { numToIndex . get ( target - nums [ i ] ), i }; numToIndex . put ( nums [ i ] , i ); } throw new IllegalArgumentException (); } }","title":"1. Two Sum $\\star$"},{"location":"java/0001-0100/0001-0010/#2-add-two-numbers-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public ListNode addTwoNumbers ( ListNode l1 , ListNode l2 ) { ListNode dummy = new ListNode ( 0 ); ListNode curr = dummy ; int carry = 0 ; while ( carry > 0 || l1 != null || l2 != null ) { carry += ( l1 == null ? 0 : l1 . val ) + ( l2 == null ? 0 : l2 . val ); curr . next = new ListNode ( carry % 10 ); curr = curr . next ; carry /= 10 ; if ( l1 != null ) l1 = l1 . next ; if ( l2 != null ) l2 = l2 . next ; } return dummy . next ; } }","title":"2. Add Two Numbers $\\star\\star$"},{"location":"java/0001-0100/0001-0010/#3-longest-substring-without-repeating-characters-starstar","text":"Time: $O(n)$ Space: $O(128)$ class Solution { public int lengthOfLongestSubstring ( String s ) { int ans = 0 ; int [] count = new int [ 128 ] ; for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { ++ count [ s . charAt ( r ) ] ; while ( count [ s . charAt ( r ) ] > 1 ) -- count [ s . charAt ( l ++ ) ] ; ans = Math . max ( ans , r - l + 1 ); } return ans ; } }","title":"3. Longest Substring Without Repeating Characters $\\star\\star$"},{"location":"java/0001-0100/0001-0010/#4-median-of-two-sorted-arrays-starstarstar","text":"Time: $O(\\log\\min(m, n))$ Space: $O(1)$ class Solution { public double findMedianSortedArrays ( int [] nums1 , int [] nums2 ) { final int n1 = nums1 . length ; final int n2 = nums2 . length ; if ( n1 > n2 ) return findMedianSortedArrays ( nums2 , nums1 ); int l = 0 ; int r = n1 ; while ( l <= r ) { int partition1 = l + ( r - l ) / 2 ; int partition2 = ( n1 + n2 + 1 ) / 2 - partition1 ; int maxLeft1 = partition1 == 0 ? Integer . MIN_VALUE : nums1 [ partition1 - 1 ] ; int maxLeft2 = partition2 == 0 ? Integer . MIN_VALUE : nums2 [ partition2 - 1 ] ; int minRight1 = partition1 == n1 ? Integer . MAX_VALUE : nums1 [ partition1 ] ; int minRight2 = partition2 == n2 ? Integer . MAX_VALUE : nums2 [ partition2 ] ; if ( maxLeft1 <= minRight2 && maxLeft2 <= minRight1 ) return ( n1 + n2 ) % 2 == 0 ? ( Math . max ( maxLeft1 , maxLeft2 ) + Math . min ( minRight1 , minRight2 )) * 0.5 : Math . max ( maxLeft1 , maxLeft2 ); else if ( maxLeft1 > minRight2 ) r = partition1 - 1 ; else l = partition1 + 1 ; } throw new IllegalArgumentException (); } }","title":"4. Median of Two Sorted Arrays $\\star\\star\\star$"},{"location":"java/0001-0100/0001-0010/#5-longest-palindromic-substring-starstar","text":"","title":"5. Longest Palindromic Substring $\\star\\star$"},{"location":"java/0001-0100/0001-0010/#6-zigzag-conversion-starstar","text":"","title":"6. ZigZag Conversion $\\star\\star$"},{"location":"java/0001-0100/0001-0010/#7-reverse-integer-star","text":"Time: $O(\\log x)$ Space: $O(1)$ class Solution { public int reverse ( int x ) { long ans = 0 ; while ( x != 0 ) { ans = ans * 10 + x % 10 ; x /= 10 ; } return ( ans < Integer . MIN_VALUE || ans > Integer . MAX_VALUE ) ? 0 : ( int ) ans ; } }","title":"7. Reverse Integer $\\star$"},{"location":"java/0001-0100/0001-0010/#8-string-to-integer-atoi-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public int myAtoi ( String str ) { long ans = 0 ; str = str . strip (); if ( str . isEmpty ()) return 0 ; boolean isNegative = str . charAt ( 0 ) == '-' ; if ( str . charAt ( 0 ) == '-' || str . charAt ( 0 ) == '+' ) str = str . substring ( 1 , str . length ()); for ( char c : str . toCharArray ()) { if ( ! Character . isDigit ( c )) break ; ans = ans * 10 + ( c - '0' ); if ( isNegative && - ans <= Integer . MIN_VALUE ) return Integer . MIN_VALUE ; if ( ! isNegative && ans >= Integer . MAX_VALUE ) return Integer . MAX_VALUE ; } return isNegative ? ( int ) - ans : ( int ) ans ; } }","title":"8. String to Integer (atoi) $\\star\\star$"},{"location":"java/0001-0100/0001-0010/#9-palindrome-number-star","text":"Time: $O\\log x)$ Space: $O(1)$ class Solution { public boolean isPalindrome ( int x ) { if ( x < 0 ) return false ; long ans = 0 ; int y = x ; while ( y > 0 ) { ans = ans * 10 + y % 10 ; y /= 10 ; } return ( int ) ans == x ; } }","title":"9. Palindrome Number $\\star$"},{"location":"java/0001-0100/0001-0010/#10-regular-expression-matching-starstarstar","text":"","title":"10. Regular Expression Matching $\\star\\star\\star$"},{"location":"java/0001-0100/0011-0020/","text":"11. Container With Most Water $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public int maxArea ( int [] height ) { int ans = 0 ; int l = 0 ; int r = height . length - 1 ; while ( l < r ) { int h = Math . min ( height [ l ] , height [ r ] ); ans = Math . max ( ans , ( r - l ) * h ); while ( height [ l ] <= h && l < r ) ++ l ; while ( height [ r ] <= h && l < r ) -- r ; } return ans ; } } 12. Integer to Roman $\\star\\star$ Time: $O(1)$ Space: $O(k)$ class Solution { public String intToRoman ( int num ) { String [] M = new String [] { \"\" , \"M\" , \"MM\" , \"MMM\" }; String [] C = new String [] { \"\" , \"C\" , \"CC\" , \"CCC\" , \"CD\" , \"D\" , \"DC\" , \"DCC\" , \"DCCC\" , \"CM\" }; String [] X = new String [] { \"\" , \"X\" , \"XX\" , \"XXX\" , \"XL\" , \"L\" , \"LX\" , \"LXX\" , \"LXXX\" , \"XC\" }; String [] I = new String [] { \"\" , \"I\" , \"II\" , \"III\" , \"IV\" , \"V\" , \"VI\" , \"VII\" , \"VIII\" , \"IX\" }; return M [ num / 1000 ] + C [ num % 1000 / 100 ] + X [ num % 100 / 10 ] + I [ num % 10 ] ; } } 13. Roman to Integer $\\star$ Time: $O(n)$ Space: $O(24)$ class Solution { public int romanToInt ( String s ) { int ans = 0 ; int [] roman = new int [ 24 ] ; roman [ 'I' - 'A' ] = 1 ; roman [ 'V' - 'A' ] = 5 ; roman [ 'X' - 'A' ] = 10 ; roman [ 'L' - 'A' ] = 50 ; roman [ 'C' - 'A' ] = 100 ; roman [ 'D' - 'A' ] = 500 ; roman [ 'M' - 'A' ] = 1000 ; for ( int i = 0 ; i + 1 < s . length (); ++ i ) { if ( roman [ s . charAt ( i ) - 'A' ] < roman [ s . charAt ( i + 1 ) - 'A' ] ) ans -= roman [ s . charAt ( i ) - 'A' ] ; else ans += roman [ s . charAt ( i ) - 'A' ] ; } return ans + roman [ s . charAt ( s . length () - 1 ) - 'A' ] ; } } 14. Longest Common Prefix $\\star$ 15. 3Sum $\\star\\star$ Time: $O(n^2)$ Space: $O(1)$ class Solution { public List < List < Integer >> threeSum ( int [] nums ) { List < List < Integer >> ans = new ArrayList <> (); Arrays . sort ( nums ); for ( int i = 0 ; i + 2 < nums . length ; ++ i ) { if ( i > 0 && nums [ i ] == nums [ i - 1 ] ) continue ; int l = i + 1 ; int r = nums . length - 1 ; while ( l < r ) { int sum = nums [ i ] + nums [ l ] + nums [ r ] ; if ( sum == 0 ) { ans . add ( Arrays . asList ( nums [ i ] , nums [ l ] , nums [ r ] )); ++ l ; -- r ; while ( nums [ l ] == nums [ l - 1 ] && l < r ) ++ l ; while ( nums [ r ] == nums [ r + 1 ] && l < r ) -- r ; } else if ( sum < 0 ) { ++ l ; } else { -- r ; } } } return ans ; } } 16. 3Sum Closest $\\star\\star$ Time: $O(n^2)$ Space: $O(1)$ class Solution { public int threeSumClosest ( int [] nums , int target ) { int ans = nums [ 0 ] + nums [ 1 ] + nums [ 2 ] ; Arrays . sort ( nums ); for ( int i = 0 ; i + 2 < nums . length ; ++ i ) { int l = i + 1 ; int r = nums . length - 1 ; while ( l < r ) { int sum = nums [ i ] + nums [ l ] + nums [ r ] ; if ( sum == target ) return sum ; if ( Math . abs ( sum - target ) < Math . abs ( ans - target )) ans = sum ; if ( sum < target ) ++ l ; else -- r ; } } return ans ; } } 17. Letter Combinations of a Phone Number $\\star\\star$ 18. 4Sum $\\star\\star$ Time: $O(n^3)$ Space: $O(1)$ class Solution { public List < List < Integer >> fourSum ( int [] nums , int target ) { List < List < Integer >> ans = new ArrayList <> (); Arrays . sort ( nums ); nSum ( nums , target , 0 , nums . length - 1 , 4 , new ArrayList <> (), ans ); return ans ; } private void nSum ( int [] nums , int target , int l , int r , int n , List < Integer > path , List < List < Integer >> ans ) { if ( r - l + 1 < n || n < 2 || target < nums [ l ] * n || target > nums [ r ] * n ) return ; if ( n == 2 ) { while ( l < r ) { int sum = nums [ l ] + nums [ r ] ; if ( sum == target ) { path . add ( nums [ l ] ); path . add ( nums [ r ] ); ans . add ( new ArrayList <> ( path )); path . remove ( path . size () - 1 ); path . remove ( path . size () - 1 ); ++ l ; while ( nums [ l ] == nums [ l - 1 ] && l < r ) ++ l ; } else if ( sum < target ) { ++ l ; } else { -- r ; } } return ; } for ( int i = l ; i <= r ; ++ i ) { if ( i > l && nums [ i ] == nums [ i - 1 ] ) continue ; path . add ( nums [ i ] ); nSum ( nums , target - nums [ i ] , i + 1 , r , n - 1 , path , ans ); path . remove ( path . size () - 1 ); } } } 19. Remove Nth Node From End of List $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public ListNode removeNthFromEnd ( ListNode head , int n ) { ListNode slow = head ; ListNode fast = head ; while ( n -- > 0 ) fast = fast . next ; if ( fast == null ) return head . next ; while ( fast . next != null ) { slow = slow . next ; fast = fast . next ; } slow . next = slow . next . next ; return head ; } } 20. Valid Parentheses $\\star$","title":"0011-0020"},{"location":"java/0001-0100/0011-0020/#11-container-with-most-water-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public int maxArea ( int [] height ) { int ans = 0 ; int l = 0 ; int r = height . length - 1 ; while ( l < r ) { int h = Math . min ( height [ l ] , height [ r ] ); ans = Math . max ( ans , ( r - l ) * h ); while ( height [ l ] <= h && l < r ) ++ l ; while ( height [ r ] <= h && l < r ) -- r ; } return ans ; } }","title":"11. Container With Most Water $\\star\\star$"},{"location":"java/0001-0100/0011-0020/#12-integer-to-roman-starstar","text":"Time: $O(1)$ Space: $O(k)$ class Solution { public String intToRoman ( int num ) { String [] M = new String [] { \"\" , \"M\" , \"MM\" , \"MMM\" }; String [] C = new String [] { \"\" , \"C\" , \"CC\" , \"CCC\" , \"CD\" , \"D\" , \"DC\" , \"DCC\" , \"DCCC\" , \"CM\" }; String [] X = new String [] { \"\" , \"X\" , \"XX\" , \"XXX\" , \"XL\" , \"L\" , \"LX\" , \"LXX\" , \"LXXX\" , \"XC\" }; String [] I = new String [] { \"\" , \"I\" , \"II\" , \"III\" , \"IV\" , \"V\" , \"VI\" , \"VII\" , \"VIII\" , \"IX\" }; return M [ num / 1000 ] + C [ num % 1000 / 100 ] + X [ num % 100 / 10 ] + I [ num % 10 ] ; } }","title":"12. Integer to Roman $\\star\\star$"},{"location":"java/0001-0100/0011-0020/#13-roman-to-integer-star","text":"Time: $O(n)$ Space: $O(24)$ class Solution { public int romanToInt ( String s ) { int ans = 0 ; int [] roman = new int [ 24 ] ; roman [ 'I' - 'A' ] = 1 ; roman [ 'V' - 'A' ] = 5 ; roman [ 'X' - 'A' ] = 10 ; roman [ 'L' - 'A' ] = 50 ; roman [ 'C' - 'A' ] = 100 ; roman [ 'D' - 'A' ] = 500 ; roman [ 'M' - 'A' ] = 1000 ; for ( int i = 0 ; i + 1 < s . length (); ++ i ) { if ( roman [ s . charAt ( i ) - 'A' ] < roman [ s . charAt ( i + 1 ) - 'A' ] ) ans -= roman [ s . charAt ( i ) - 'A' ] ; else ans += roman [ s . charAt ( i ) - 'A' ] ; } return ans + roman [ s . charAt ( s . length () - 1 ) - 'A' ] ; } }","title":"13. Roman to Integer $\\star$"},{"location":"java/0001-0100/0011-0020/#14-longest-common-prefix-star","text":"","title":"14. Longest Common Prefix $\\star$"},{"location":"java/0001-0100/0011-0020/#15-3sum-starstar","text":"Time: $O(n^2)$ Space: $O(1)$ class Solution { public List < List < Integer >> threeSum ( int [] nums ) { List < List < Integer >> ans = new ArrayList <> (); Arrays . sort ( nums ); for ( int i = 0 ; i + 2 < nums . length ; ++ i ) { if ( i > 0 && nums [ i ] == nums [ i - 1 ] ) continue ; int l = i + 1 ; int r = nums . length - 1 ; while ( l < r ) { int sum = nums [ i ] + nums [ l ] + nums [ r ] ; if ( sum == 0 ) { ans . add ( Arrays . asList ( nums [ i ] , nums [ l ] , nums [ r ] )); ++ l ; -- r ; while ( nums [ l ] == nums [ l - 1 ] && l < r ) ++ l ; while ( nums [ r ] == nums [ r + 1 ] && l < r ) -- r ; } else if ( sum < 0 ) { ++ l ; } else { -- r ; } } } return ans ; } }","title":"15. 3Sum $\\star\\star$"},{"location":"java/0001-0100/0011-0020/#16-3sum-closest-starstar","text":"Time: $O(n^2)$ Space: $O(1)$ class Solution { public int threeSumClosest ( int [] nums , int target ) { int ans = nums [ 0 ] + nums [ 1 ] + nums [ 2 ] ; Arrays . sort ( nums ); for ( int i = 0 ; i + 2 < nums . length ; ++ i ) { int l = i + 1 ; int r = nums . length - 1 ; while ( l < r ) { int sum = nums [ i ] + nums [ l ] + nums [ r ] ; if ( sum == target ) return sum ; if ( Math . abs ( sum - target ) < Math . abs ( ans - target )) ans = sum ; if ( sum < target ) ++ l ; else -- r ; } } return ans ; } }","title":"16. 3Sum Closest $\\star\\star$"},{"location":"java/0001-0100/0011-0020/#17-letter-combinations-of-a-phone-number-starstar","text":"","title":"17. Letter Combinations of a Phone Number $\\star\\star$"},{"location":"java/0001-0100/0011-0020/#18-4sum-starstar","text":"Time: $O(n^3)$ Space: $O(1)$ class Solution { public List < List < Integer >> fourSum ( int [] nums , int target ) { List < List < Integer >> ans = new ArrayList <> (); Arrays . sort ( nums ); nSum ( nums , target , 0 , nums . length - 1 , 4 , new ArrayList <> (), ans ); return ans ; } private void nSum ( int [] nums , int target , int l , int r , int n , List < Integer > path , List < List < Integer >> ans ) { if ( r - l + 1 < n || n < 2 || target < nums [ l ] * n || target > nums [ r ] * n ) return ; if ( n == 2 ) { while ( l < r ) { int sum = nums [ l ] + nums [ r ] ; if ( sum == target ) { path . add ( nums [ l ] ); path . add ( nums [ r ] ); ans . add ( new ArrayList <> ( path )); path . remove ( path . size () - 1 ); path . remove ( path . size () - 1 ); ++ l ; while ( nums [ l ] == nums [ l - 1 ] && l < r ) ++ l ; } else if ( sum < target ) { ++ l ; } else { -- r ; } } return ; } for ( int i = l ; i <= r ; ++ i ) { if ( i > l && nums [ i ] == nums [ i - 1 ] ) continue ; path . add ( nums [ i ] ); nSum ( nums , target - nums [ i ] , i + 1 , r , n - 1 , path , ans ); path . remove ( path . size () - 1 ); } } }","title":"18. 4Sum $\\star\\star$"},{"location":"java/0001-0100/0011-0020/#19-remove-nth-node-from-end-of-list-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public ListNode removeNthFromEnd ( ListNode head , int n ) { ListNode slow = head ; ListNode fast = head ; while ( n -- > 0 ) fast = fast . next ; if ( fast == null ) return head . next ; while ( fast . next != null ) { slow = slow . next ; fast = fast . next ; } slow . next = slow . next . next ; return head ; } }","title":"19. Remove Nth Node From End of List $\\star\\star$"},{"location":"java/0001-0100/0011-0020/#20-valid-parentheses-star","text":"","title":"20. Valid Parentheses $\\star$"},{"location":"java/0001-0100/0021-0030/","text":"21. Merge Two Sorted Lists $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public ListNode mergeTwoLists ( ListNode l1 , ListNode l2 ) { if ( l1 == null || l2 == null ) return l1 == null ? l2 : l1 ; if ( l1 . val > l2 . val ) { ListNode temp = l1 ; l1 = l2 ; l2 = temp ; } l1 . next = mergeTwoLists ( l1 . next , l2 ); return l1 ; } } 22. Generate Parentheses $\\star\\star$ 23. Merge k Sorted Lists $\\star\\star\\star$ Time: $O(n\\log k)$, where $n$ is # of nodes Space: $O(n)$ class Solution { public ListNode mergeKLists ( ListNode [] lists ) { ListNode dummy = new ListNode ( 0 ); ListNode curr = dummy ; Queue < ListNode > pq = new PriorityQueue <> (( l1 , l2 ) -> l1 . val - l2 . val ); for ( ListNode list : lists ) if ( list != null ) pq . add ( list ); while ( ! pq . isEmpty ()) { curr . next = pq . poll (); curr = curr . next ; if ( curr . next != null ) pq . add ( curr . next ); } return dummy . next ; } } 24. Swap Nodes in Pairs $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public ListNode swapPairs ( ListNode head ) { ListNode dummy = new ListNode ( 0 ); dummy . next = head ; int length = 0 ; for ( ListNode curr = head ; curr != null ; curr = curr . next ) ++ length ; ListNode prev = dummy ; ListNode curr = head ; for ( int i = 0 ; i < length / 2 ; ++ i ) { ListNode next = curr . next ; curr . next = next . next ; next . next = curr ; prev . next = next ; prev = curr ; curr = curr . next ; } return dummy . next ; } } 25. Reverse Nodes in k-Group $\\star\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public ListNode reverseKGroup ( ListNode head , int k ) { if ( head == null || k == 1 ) return head ; ListNode dummy = new ListNode ( 0 ); dummy . next = head ; int length = 0 ; for ( ListNode curr = head ; curr != null ; curr = curr . next ) ++ length ; ListNode prev = dummy ; ListNode curr = head ; for ( int i = 0 ; i < length / k ; ++ i ) { for ( int j = 0 ; j < k - 1 ; ++ j ) { ListNode next = curr . next ; curr . next = next . next ; next . next = prev . next ; prev . next = next ; } prev = curr ; curr = curr . next ; } return dummy . next ; } } 26. Remove Duplicates from Sorted Array $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public int removeDuplicates ( int [] nums ) { int j = 0 ; for ( int i = 1 ; i < nums . length ; ++ i ) if ( nums [ i ] != nums [ j ] ) nums [++ j ] = nums [ i ] ; return j + 1 ; } } 27. Remove Element $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public int removeElement ( int [] nums , int val ) { int i = 0 ; for ( int num : nums ) if ( num != val ) nums [ i ++] = num ; return i ; } } 28. Implement strStr() $\\star$ 29. Divide Two Integers $\\star\\star$ Time: $O(\\log^2 n)$ Space: $O(1)$ class Solution { public int divide ( int dividend , int divisor ) { if ( dividend == Integer . MIN_VALUE && divisor == - 1 ) return Integer . MAX_VALUE ; long ans = 0 ; long dvd = Math . abs (( long ) dividend ); long dvs = Math . abs (( long ) divisor ); int sign = dividend > 0 ^ divisor > 0 ? - 1 : 1 ; while ( dvd >= dvs ) { long m = 1 ; long temp = dvs ; while ( temp << 1 <= dvd ) { m <<= 1 ; temp <<= 1 ; } dvd -= temp ; ans += m ; } return sign * ( int ) ans ; } } 30. Substring with Concatenation of All Words $\\star\\star\\star$ Time: $O(nk)$, where n = len(word) and k = len(s) Space: $O(n)$ class Solution { public List < Integer > findSubstring ( String s , String [] words ) { if ( s . isEmpty () || words . length == 0 ) return new ArrayList <> (); final int n = words [ 0 ] . length (); List < Integer > ans = new ArrayList <> (); Map < String , Integer > count = new HashMap <> (); for ( String word : words ) count . put ( word , count . getOrDefault ( word , 0 ) + 1 ); for ( int i = 0 ; i <= s . length () - words . length * n ; ++ i ) { Map < String , Integer > seen = new HashMap <> (); int j = 0 ; for (; j < words . length ; ++ j ) { String word = s . substring ( i + j * n , i + j * n + n ); seen . put ( word , seen . getOrDefault ( word , 0 ) + 1 ); if ( seen . get ( word ) > count . getOrDefault ( word , 0 )) break ; } if ( j == words . length ) ans . add ( i ); } return ans ; } }","title":"0021-0030"},{"location":"java/0001-0100/0021-0030/#21-merge-two-sorted-lists-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public ListNode mergeTwoLists ( ListNode l1 , ListNode l2 ) { if ( l1 == null || l2 == null ) return l1 == null ? l2 : l1 ; if ( l1 . val > l2 . val ) { ListNode temp = l1 ; l1 = l2 ; l2 = temp ; } l1 . next = mergeTwoLists ( l1 . next , l2 ); return l1 ; } }","title":"21. Merge Two Sorted Lists $\\star$"},{"location":"java/0001-0100/0021-0030/#22-generate-parentheses-starstar","text":"","title":"22. Generate Parentheses $\\star\\star$"},{"location":"java/0001-0100/0021-0030/#23-merge-k-sorted-lists-starstarstar","text":"Time: $O(n\\log k)$, where $n$ is # of nodes Space: $O(n)$ class Solution { public ListNode mergeKLists ( ListNode [] lists ) { ListNode dummy = new ListNode ( 0 ); ListNode curr = dummy ; Queue < ListNode > pq = new PriorityQueue <> (( l1 , l2 ) -> l1 . val - l2 . val ); for ( ListNode list : lists ) if ( list != null ) pq . add ( list ); while ( ! pq . isEmpty ()) { curr . next = pq . poll (); curr = curr . next ; if ( curr . next != null ) pq . add ( curr . next ); } return dummy . next ; } }","title":"23. Merge k Sorted Lists $\\star\\star\\star$"},{"location":"java/0001-0100/0021-0030/#24-swap-nodes-in-pairs-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public ListNode swapPairs ( ListNode head ) { ListNode dummy = new ListNode ( 0 ); dummy . next = head ; int length = 0 ; for ( ListNode curr = head ; curr != null ; curr = curr . next ) ++ length ; ListNode prev = dummy ; ListNode curr = head ; for ( int i = 0 ; i < length / 2 ; ++ i ) { ListNode next = curr . next ; curr . next = next . next ; next . next = curr ; prev . next = next ; prev = curr ; curr = curr . next ; } return dummy . next ; } }","title":"24. Swap Nodes in Pairs $\\star\\star$"},{"location":"java/0001-0100/0021-0030/#25-reverse-nodes-in-k-group-starstarstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public ListNode reverseKGroup ( ListNode head , int k ) { if ( head == null || k == 1 ) return head ; ListNode dummy = new ListNode ( 0 ); dummy . next = head ; int length = 0 ; for ( ListNode curr = head ; curr != null ; curr = curr . next ) ++ length ; ListNode prev = dummy ; ListNode curr = head ; for ( int i = 0 ; i < length / k ; ++ i ) { for ( int j = 0 ; j < k - 1 ; ++ j ) { ListNode next = curr . next ; curr . next = next . next ; next . next = prev . next ; prev . next = next ; } prev = curr ; curr = curr . next ; } return dummy . next ; } }","title":"25. Reverse Nodes in k-Group $\\star\\star\\star$"},{"location":"java/0001-0100/0021-0030/#26-remove-duplicates-from-sorted-array-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public int removeDuplicates ( int [] nums ) { int j = 0 ; for ( int i = 1 ; i < nums . length ; ++ i ) if ( nums [ i ] != nums [ j ] ) nums [++ j ] = nums [ i ] ; return j + 1 ; } }","title":"26. Remove Duplicates from Sorted Array $\\star$"},{"location":"java/0001-0100/0021-0030/#27-remove-element-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public int removeElement ( int [] nums , int val ) { int i = 0 ; for ( int num : nums ) if ( num != val ) nums [ i ++] = num ; return i ; } }","title":"27. Remove Element $\\star$"},{"location":"java/0001-0100/0021-0030/#28-implement-strstr-star","text":"","title":"28. Implement strStr() $\\star$"},{"location":"java/0001-0100/0021-0030/#29-divide-two-integers-starstar","text":"Time: $O(\\log^2 n)$ Space: $O(1)$ class Solution { public int divide ( int dividend , int divisor ) { if ( dividend == Integer . MIN_VALUE && divisor == - 1 ) return Integer . MAX_VALUE ; long ans = 0 ; long dvd = Math . abs (( long ) dividend ); long dvs = Math . abs (( long ) divisor ); int sign = dividend > 0 ^ divisor > 0 ? - 1 : 1 ; while ( dvd >= dvs ) { long m = 1 ; long temp = dvs ; while ( temp << 1 <= dvd ) { m <<= 1 ; temp <<= 1 ; } dvd -= temp ; ans += m ; } return sign * ( int ) ans ; } }","title":"29. Divide Two Integers $\\star\\star$"},{"location":"java/0001-0100/0021-0030/#30-substring-with-concatenation-of-all-words-starstarstar","text":"Time: $O(nk)$, where n = len(word) and k = len(s) Space: $O(n)$ class Solution { public List < Integer > findSubstring ( String s , String [] words ) { if ( s . isEmpty () || words . length == 0 ) return new ArrayList <> (); final int n = words [ 0 ] . length (); List < Integer > ans = new ArrayList <> (); Map < String , Integer > count = new HashMap <> (); for ( String word : words ) count . put ( word , count . getOrDefault ( word , 0 ) + 1 ); for ( int i = 0 ; i <= s . length () - words . length * n ; ++ i ) { Map < String , Integer > seen = new HashMap <> (); int j = 0 ; for (; j < words . length ; ++ j ) { String word = s . substring ( i + j * n , i + j * n + n ); seen . put ( word , seen . getOrDefault ( word , 0 ) + 1 ); if ( seen . get ( word ) > count . getOrDefault ( word , 0 )) break ; } if ( j == words . length ) ans . add ( i ); } return ans ; } }","title":"30. Substring with Concatenation of All Words $\\star\\star\\star$"},{"location":"java/0001-0100/0031-0040/","text":"31. Next Permutation $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public void nextPermutation ( int [] nums ) { int i ; for ( i = nums . length - 2 ; i >= 0 ; -- i ) if ( nums [ i ] < nums [ i + 1 ] ) break ; if ( i >= 0 ) { int j ; for ( j = nums . length - 1 ; j > i ; -- j ) if ( nums [ j ] > nums [ i ] ) break ; swap ( nums , i , j ); } reverse ( nums , i + 1 , nums . length - 1 ); } private void reverse ( int [] nums , int l , int r ) { while ( l < r ) swap ( nums , l ++ , r -- ); } private void swap ( int [] nums , int i , int j ) { int temp = nums [ i ] ; nums [ i ] = nums [ j ] ; nums [ j ] = temp ; } } 32. Longest Valid Parentheses $\\star\\star\\star$ 33. Search in Rotated Sorted Array $\\star\\star$ Time: $O(\\log n)$ Space: $O(1)$ class Solution { public int search ( int [] nums , int target ) { int l = 0 ; int r = nums . length - 1 ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return m ; if ( nums [ l ] <= nums [ m ] ) { if ( nums [ l ] <= target && target < nums [ m ] ) r = m - 1 ; else l = m + 1 ; } else { if ( nums [ m ] < target && target <= nums [ r ] ) l = m + 1 ; else r = m - 1 ; } } return - 1 ; } } 34. Find First and Last Position of Element in Sorted Array $\\star\\star$ Time: $O(\\log n)$ Space: $O(1)$ class Solution { public int [] searchRange ( int [] nums , int target ) { int leftIndex = find ( nums , target , true ); if ( leftIndex == nums . length || nums [ leftIndex ] != target ) return new int [] { - 1 , - 1 }; return new int [] { leftIndex , find ( nums , target , false ) - 1 }; } private int find ( int [] nums , int target , boolean isLeft ) { int l = 0 ; int r = nums . length ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] > target || ( isLeft && nums [ m ] == target )) r = m ; else l = m + 1 ; } return l ; } } 35. Search Insert Position $\\star$ Time: $O(\\log n)$ Space: $O(1)$ class Solution { public int searchInsert ( int [] nums , int target ) { int l = 0 ; int r = nums . length ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return m ; if ( nums [ m ] < target ) l = m + 1 ; else r = m ; } return l ; } } 36. Valid Sudoku $\\star\\star$ 37. Sudoku Solver $\\star\\star\\star$ Time: NP-Complete Space: $O(1)$ class Solution { public void solveSudoku ( char [][] board ) { dfs ( 0 , board ); } private boolean dfs ( int s , char [][] board ) { if ( s == 81 ) return true ; int i = s / 9 ; int j = s % 9 ; if ( board [ i ][ j ] != '.' ) return dfs ( s + 1 , board ); for ( char c = '1' ; c <= '9' ; ++ c ) if ( isValid ( i , j , c , board )) { board [ i ][ j ] = c ; if ( dfs ( s + 1 , board )) return true ; board [ i ][ j ] = '.' ; } return false ; } private boolean isValid ( int row , int col , char c , char [][] board ) { for ( int i = 0 ; i < 9 ; ++ i ) if ( board [ i ][ col ] == c || board [ row ][ i ] == c || board [ 3 * ( row / 3 ) + i / 3 ][ 3 * ( col / 3 ) + i % 3 ] == c ) return false ; return true ; } } 38. Count and Say $\\star$ 39. Combination Sum $\\star\\star$ Time: $O(n^{target})$, where n = len(candidates) Space: $O(target)$ class Solution { public List < List < Integer >> combinationSum ( int [] candidates , int target ) { List < List < Integer >> ans = new ArrayList <> (); Arrays . sort ( candidates ); dfs ( candidates , target , 0 , new ArrayList <> (), ans ); return ans ; } private void dfs ( int [] candidates , int target , int s , List < Integer > path , List < List < Integer >> ans ) { if ( target < 0 ) return ; if ( target == 0 ) { ans . add ( new ArrayList <> ( path )); return ; } for ( int i = s ; i < candidates . length ; ++ i ) { path . add ( candidates [ i ] ); dfs ( candidates , target - candidates [ i ] , i , path , ans ); path . remove ( path . size () - 1 ); } } } 40. Combination Sum II $\\star\\star$ Time: $O(2^n)$ Space: $O(n)$ class Solution { public List < List < Integer >> combinationSum2 ( int [] candidates , int target ) { List < List < Integer >> ans = new ArrayList <> (); Arrays . sort ( candidates ); dfs ( candidates , target , 0 , new ArrayList <> (), ans ); return ans ; } private void dfs ( int [] candidates , int target , int s , List < Integer > path , List < List < Integer >> ans ) { if ( target < 0 ) return ; if ( target == 0 ) { ans . add ( new ArrayList <> ( path )); return ; } for ( int i = s ; i < candidates . length ; ++ i ) { if ( i > s && candidates [ i ] == candidates [ i - 1 ] ) continue ; path . add ( candidates [ i ] ); dfs ( candidates , target - candidates [ i ] , i + 1 , path , ans ); path . remove ( path . size () - 1 ); } } }","title":"0031-0040"},{"location":"java/0001-0100/0031-0040/#31-next-permutation-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public void nextPermutation ( int [] nums ) { int i ; for ( i = nums . length - 2 ; i >= 0 ; -- i ) if ( nums [ i ] < nums [ i + 1 ] ) break ; if ( i >= 0 ) { int j ; for ( j = nums . length - 1 ; j > i ; -- j ) if ( nums [ j ] > nums [ i ] ) break ; swap ( nums , i , j ); } reverse ( nums , i + 1 , nums . length - 1 ); } private void reverse ( int [] nums , int l , int r ) { while ( l < r ) swap ( nums , l ++ , r -- ); } private void swap ( int [] nums , int i , int j ) { int temp = nums [ i ] ; nums [ i ] = nums [ j ] ; nums [ j ] = temp ; } }","title":"31. Next Permutation $\\star\\star$"},{"location":"java/0001-0100/0031-0040/#32-longest-valid-parentheses-starstarstar","text":"","title":"32. Longest Valid Parentheses $\\star\\star\\star$"},{"location":"java/0001-0100/0031-0040/#33-search-in-rotated-sorted-array-starstar","text":"Time: $O(\\log n)$ Space: $O(1)$ class Solution { public int search ( int [] nums , int target ) { int l = 0 ; int r = nums . length - 1 ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return m ; if ( nums [ l ] <= nums [ m ] ) { if ( nums [ l ] <= target && target < nums [ m ] ) r = m - 1 ; else l = m + 1 ; } else { if ( nums [ m ] < target && target <= nums [ r ] ) l = m + 1 ; else r = m - 1 ; } } return - 1 ; } }","title":"33. Search in Rotated Sorted Array $\\star\\star$"},{"location":"java/0001-0100/0031-0040/#34-find-first-and-last-position-of-element-in-sorted-array-starstar","text":"Time: $O(\\log n)$ Space: $O(1)$ class Solution { public int [] searchRange ( int [] nums , int target ) { int leftIndex = find ( nums , target , true ); if ( leftIndex == nums . length || nums [ leftIndex ] != target ) return new int [] { - 1 , - 1 }; return new int [] { leftIndex , find ( nums , target , false ) - 1 }; } private int find ( int [] nums , int target , boolean isLeft ) { int l = 0 ; int r = nums . length ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] > target || ( isLeft && nums [ m ] == target )) r = m ; else l = m + 1 ; } return l ; } }","title":"34. Find First and Last Position of Element in Sorted Array $\\star\\star$"},{"location":"java/0001-0100/0031-0040/#35-search-insert-position-star","text":"Time: $O(\\log n)$ Space: $O(1)$ class Solution { public int searchInsert ( int [] nums , int target ) { int l = 0 ; int r = nums . length ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return m ; if ( nums [ m ] < target ) l = m + 1 ; else r = m ; } return l ; } }","title":"35. Search Insert Position $\\star$"},{"location":"java/0001-0100/0031-0040/#36-valid-sudoku-starstar","text":"","title":"36. Valid Sudoku $\\star\\star$"},{"location":"java/0001-0100/0031-0040/#37-sudoku-solver-starstarstar","text":"Time: NP-Complete Space: $O(1)$ class Solution { public void solveSudoku ( char [][] board ) { dfs ( 0 , board ); } private boolean dfs ( int s , char [][] board ) { if ( s == 81 ) return true ; int i = s / 9 ; int j = s % 9 ; if ( board [ i ][ j ] != '.' ) return dfs ( s + 1 , board ); for ( char c = '1' ; c <= '9' ; ++ c ) if ( isValid ( i , j , c , board )) { board [ i ][ j ] = c ; if ( dfs ( s + 1 , board )) return true ; board [ i ][ j ] = '.' ; } return false ; } private boolean isValid ( int row , int col , char c , char [][] board ) { for ( int i = 0 ; i < 9 ; ++ i ) if ( board [ i ][ col ] == c || board [ row ][ i ] == c || board [ 3 * ( row / 3 ) + i / 3 ][ 3 * ( col / 3 ) + i % 3 ] == c ) return false ; return true ; } }","title":"37. Sudoku Solver $\\star\\star\\star$"},{"location":"java/0001-0100/0031-0040/#38-count-and-say-star","text":"","title":"38. Count and Say $\\star$"},{"location":"java/0001-0100/0031-0040/#39-combination-sum-starstar","text":"Time: $O(n^{target})$, where n = len(candidates) Space: $O(target)$ class Solution { public List < List < Integer >> combinationSum ( int [] candidates , int target ) { List < List < Integer >> ans = new ArrayList <> (); Arrays . sort ( candidates ); dfs ( candidates , target , 0 , new ArrayList <> (), ans ); return ans ; } private void dfs ( int [] candidates , int target , int s , List < Integer > path , List < List < Integer >> ans ) { if ( target < 0 ) return ; if ( target == 0 ) { ans . add ( new ArrayList <> ( path )); return ; } for ( int i = s ; i < candidates . length ; ++ i ) { path . add ( candidates [ i ] ); dfs ( candidates , target - candidates [ i ] , i , path , ans ); path . remove ( path . size () - 1 ); } } }","title":"39. Combination Sum $\\star\\star$"},{"location":"java/0001-0100/0031-0040/#40-combination-sum-ii-starstar","text":"Time: $O(2^n)$ Space: $O(n)$ class Solution { public List < List < Integer >> combinationSum2 ( int [] candidates , int target ) { List < List < Integer >> ans = new ArrayList <> (); Arrays . sort ( candidates ); dfs ( candidates , target , 0 , new ArrayList <> (), ans ); return ans ; } private void dfs ( int [] candidates , int target , int s , List < Integer > path , List < List < Integer >> ans ) { if ( target < 0 ) return ; if ( target == 0 ) { ans . add ( new ArrayList <> ( path )); return ; } for ( int i = s ; i < candidates . length ; ++ i ) { if ( i > s && candidates [ i ] == candidates [ i - 1 ] ) continue ; path . add ( candidates [ i ] ); dfs ( candidates , target - candidates [ i ] , i + 1 , path , ans ); path . remove ( path . size () - 1 ); } } }","title":"40. Combination Sum II $\\star\\star$"},{"location":"java/0001-0100/0041-0050/","text":"41. First Missing Positive $\\star\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public int firstMissingPositive ( int [] nums ) { if ( nums . length == 0 ) return 1 ; final int n = nums . length ; for ( int i = 0 ; i < n ; ++ i ) while ( nums [ i ] > 0 && nums [ i ] <= n && nums [ i ] != nums [ nums [ i ] - 1 ] ) swap ( nums , i , nums [ i ] - 1 ); for ( int i = 0 ; i < n ; ++ i ) if ( nums [ i ] != i + 1 ) return i + 1 ; return n + 1 ; } private void swap ( int [] nums , int i , int j ) { int temp = nums [ i ] ; nums [ i ] = nums [ j ] ; nums [ j ] = temp ; } } 42. Trapping Rain Water $\\star\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public int trap ( int [] height ) { int ans = 0 ; int l = 0 ; int r = height . length - 1 ; int maxLeft = 0 ; int maxRight = 0 ; while ( l < r ) { if ( height [ l ] < height [ r ] ) { maxLeft = Math . max ( maxLeft , height [ l ] ); ans += maxLeft - height [ l ] ; ++ l ; } else { maxRight = Math . max ( maxRight , height [ r ] ); ans += maxRight - height [ r ] ; -- r ; } } return ans ; } } 43. Multiply Strings $\\star\\star$ Time: $O(mn)$, where m = len(num1) and n = len(num2) Space: $O(m + n)$ class Solution { public String multiply ( String num1 , String num2 ) { final int m = num1 . length (); final int n = num2 . length (); StringBuilder ans = new StringBuilder (); int [] pos = new int [ m + n ] ; for ( int i = m - 1 ; i >= 0 ; -- i ) for ( int j = n - 1 ; j >= 0 ; -- j ) { int multiply = ( num1 . charAt ( i ) - '0' ) * ( num2 . charAt ( j ) - '0' ); int sum = multiply + pos [ i + j + 1 ] ; pos [ i + j ] += sum / 10 ; pos [ i + j + 1 ] = ( sum ) % 10 ; } for ( int p : pos ) if ( ! ( ans . length () == 0 && p == 0 )) ans . append ( p ); return ans . length () == 0 ? \"0\" : ans . toString (); } } 44. Wildcard Matching $\\star\\star\\star$ 45. Jump Game II $\\star\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public int jump ( int [] nums ) { int ans = 0 ; int end = 0 ; int farthest = 0 ; for ( int i = 0 ; i + 1 < nums . length ; ++ i ) { farthest = Math . max ( farthest , i + nums [ i ] ); if ( i == end ) { ++ ans ; end = farthest ; } } return ans ; } } 46. Permutations $\\star\\star$ Time: $O(n!)$ Space: $O(n)$ class Solution { public List < List < Integer >> permute ( int [] nums ) { List < List < Integer >> ans = new ArrayList <> (); boolean [] used = new boolean [ nums . length ] ; dfs ( nums , used , new ArrayList <> (), ans ); return ans ; } private void dfs ( int [] nums , boolean [] used , List < Integer > path , List < List < Integer >> ans ) { if ( path . size () == nums . length ) { ans . add ( new ArrayList <> ( path )); return ; } for ( int i = 0 ; i < nums . length ; ++ i ) { if ( used [ i ] ) continue ; used [ i ] = true ; path . add ( nums [ i ] ); dfs ( nums , used , path , ans ); path . remove ( path . size () - 1 ); used [ i ] = false ; } } } 47. Permutations II $\\star\\star$ Time: $O(n!)$ Space: $O(n)$ class Solution { public List < List < Integer >> permuteUnique ( int [] nums ) { List < List < Integer >> ans = new ArrayList <> (); boolean [] used = new boolean [ nums . length ] ; Arrays . sort ( nums ); dfs ( nums , used , new ArrayList <> (), ans ); return ans ; } private void dfs ( int [] nums , boolean [] used , List < Integer > path , List < List < Integer >> ans ) { if ( path . size () == nums . length ) { ans . add ( new ArrayList <> ( path )); return ; } for ( int i = 0 ; i < nums . length ; ++ i ) { if ( used [ i ] ) continue ; if ( i > 0 && nums [ i ] == nums [ i - 1 ] && ! used [ i - 1 ] ) continue ; used [ i ] = true ; path . add ( nums [ i ] ); dfs ( nums , used , path , ans ); path . remove ( path . size () - 1 ); used [ i ] = false ; } } } 48. Rotate Image $\\star\\star$ Time: $O(n^2)$ Space: $O(1)$ class Solution { public void rotate ( int [][] matrix ) { for ( int min = 0 ; min < matrix . length / 2 ; ++ min ) { int max = matrix . length - min - 1 ; for ( int i = min ; i < max ; ++ i ) { int offset = i - min ; int top = matrix [ min ][ i ] ; matrix [ min ][ i ] = matrix [ max - offset ][ min ] ; matrix [ max - offset ][ min ] = matrix [ max ][ max - offset ] ; matrix [ max ][ max - offset ] = matrix [ i ][ max ] ; matrix [ i ][ max ] = top ; } } } } 49. Group Anagrams $\\star\\star$ Time: $O(n\\log k)$, where n = len(strs) and k = len(strs[i]) Space: $O(n)$ class Solution { public List < List < String >> groupAnagrams ( String [] strs ) { List < List < String >> ans = new ArrayList <> (); Map < String , List < String >> map = new HashMap <> (); for ( final String str : strs ) { char [] charArray = str . toCharArray (); Arrays . sort ( charArray ); String s = String . valueOf ( charArray ); map . computeIfAbsent ( s , k -> new ArrayList <> ()). add ( str ); } return new ArrayList <> ( map . values ()); } } 50. Pow(x, n) $\\star\\star$ Time: $O(\\log n)$ Space: $O(1)$ class Solution { public double myPow ( double x , long n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 1 / myPow ( x , - n ); if ( n % 2 == 1 ) return x * myPow ( x , n - 1 ); return myPow ( x * x , n / 2 ); } }","title":"0041-0050"},{"location":"java/0001-0100/0041-0050/#41-first-missing-positive-starstarstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public int firstMissingPositive ( int [] nums ) { if ( nums . length == 0 ) return 1 ; final int n = nums . length ; for ( int i = 0 ; i < n ; ++ i ) while ( nums [ i ] > 0 && nums [ i ] <= n && nums [ i ] != nums [ nums [ i ] - 1 ] ) swap ( nums , i , nums [ i ] - 1 ); for ( int i = 0 ; i < n ; ++ i ) if ( nums [ i ] != i + 1 ) return i + 1 ; return n + 1 ; } private void swap ( int [] nums , int i , int j ) { int temp = nums [ i ] ; nums [ i ] = nums [ j ] ; nums [ j ] = temp ; } }","title":"41. First Missing Positive $\\star\\star\\star$"},{"location":"java/0001-0100/0041-0050/#42-trapping-rain-water-starstarstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public int trap ( int [] height ) { int ans = 0 ; int l = 0 ; int r = height . length - 1 ; int maxLeft = 0 ; int maxRight = 0 ; while ( l < r ) { if ( height [ l ] < height [ r ] ) { maxLeft = Math . max ( maxLeft , height [ l ] ); ans += maxLeft - height [ l ] ; ++ l ; } else { maxRight = Math . max ( maxRight , height [ r ] ); ans += maxRight - height [ r ] ; -- r ; } } return ans ; } }","title":"42. Trapping Rain Water $\\star\\star\\star$"},{"location":"java/0001-0100/0041-0050/#43-multiply-strings-starstar","text":"Time: $O(mn)$, where m = len(num1) and n = len(num2) Space: $O(m + n)$ class Solution { public String multiply ( String num1 , String num2 ) { final int m = num1 . length (); final int n = num2 . length (); StringBuilder ans = new StringBuilder (); int [] pos = new int [ m + n ] ; for ( int i = m - 1 ; i >= 0 ; -- i ) for ( int j = n - 1 ; j >= 0 ; -- j ) { int multiply = ( num1 . charAt ( i ) - '0' ) * ( num2 . charAt ( j ) - '0' ); int sum = multiply + pos [ i + j + 1 ] ; pos [ i + j ] += sum / 10 ; pos [ i + j + 1 ] = ( sum ) % 10 ; } for ( int p : pos ) if ( ! ( ans . length () == 0 && p == 0 )) ans . append ( p ); return ans . length () == 0 ? \"0\" : ans . toString (); } }","title":"43. Multiply Strings $\\star\\star$"},{"location":"java/0001-0100/0041-0050/#44-wildcard-matching-starstarstar","text":"","title":"44. Wildcard Matching $\\star\\star\\star$"},{"location":"java/0001-0100/0041-0050/#45-jump-game-ii-starstarstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public int jump ( int [] nums ) { int ans = 0 ; int end = 0 ; int farthest = 0 ; for ( int i = 0 ; i + 1 < nums . length ; ++ i ) { farthest = Math . max ( farthest , i + nums [ i ] ); if ( i == end ) { ++ ans ; end = farthest ; } } return ans ; } }","title":"45. Jump Game II $\\star\\star\\star$"},{"location":"java/0001-0100/0041-0050/#46-permutations-starstar","text":"Time: $O(n!)$ Space: $O(n)$ class Solution { public List < List < Integer >> permute ( int [] nums ) { List < List < Integer >> ans = new ArrayList <> (); boolean [] used = new boolean [ nums . length ] ; dfs ( nums , used , new ArrayList <> (), ans ); return ans ; } private void dfs ( int [] nums , boolean [] used , List < Integer > path , List < List < Integer >> ans ) { if ( path . size () == nums . length ) { ans . add ( new ArrayList <> ( path )); return ; } for ( int i = 0 ; i < nums . length ; ++ i ) { if ( used [ i ] ) continue ; used [ i ] = true ; path . add ( nums [ i ] ); dfs ( nums , used , path , ans ); path . remove ( path . size () - 1 ); used [ i ] = false ; } } }","title":"46. Permutations $\\star\\star$"},{"location":"java/0001-0100/0041-0050/#47-permutations-ii-starstar","text":"Time: $O(n!)$ Space: $O(n)$ class Solution { public List < List < Integer >> permuteUnique ( int [] nums ) { List < List < Integer >> ans = new ArrayList <> (); boolean [] used = new boolean [ nums . length ] ; Arrays . sort ( nums ); dfs ( nums , used , new ArrayList <> (), ans ); return ans ; } private void dfs ( int [] nums , boolean [] used , List < Integer > path , List < List < Integer >> ans ) { if ( path . size () == nums . length ) { ans . add ( new ArrayList <> ( path )); return ; } for ( int i = 0 ; i < nums . length ; ++ i ) { if ( used [ i ] ) continue ; if ( i > 0 && nums [ i ] == nums [ i - 1 ] && ! used [ i - 1 ] ) continue ; used [ i ] = true ; path . add ( nums [ i ] ); dfs ( nums , used , path , ans ); path . remove ( path . size () - 1 ); used [ i ] = false ; } } }","title":"47. Permutations II $\\star\\star$"},{"location":"java/0001-0100/0041-0050/#48-rotate-image-starstar","text":"Time: $O(n^2)$ Space: $O(1)$ class Solution { public void rotate ( int [][] matrix ) { for ( int min = 0 ; min < matrix . length / 2 ; ++ min ) { int max = matrix . length - min - 1 ; for ( int i = min ; i < max ; ++ i ) { int offset = i - min ; int top = matrix [ min ][ i ] ; matrix [ min ][ i ] = matrix [ max - offset ][ min ] ; matrix [ max - offset ][ min ] = matrix [ max ][ max - offset ] ; matrix [ max ][ max - offset ] = matrix [ i ][ max ] ; matrix [ i ][ max ] = top ; } } } }","title":"48. Rotate Image $\\star\\star$"},{"location":"java/0001-0100/0041-0050/#49-group-anagrams-starstar","text":"Time: $O(n\\log k)$, where n = len(strs) and k = len(strs[i]) Space: $O(n)$ class Solution { public List < List < String >> groupAnagrams ( String [] strs ) { List < List < String >> ans = new ArrayList <> (); Map < String , List < String >> map = new HashMap <> (); for ( final String str : strs ) { char [] charArray = str . toCharArray (); Arrays . sort ( charArray ); String s = String . valueOf ( charArray ); map . computeIfAbsent ( s , k -> new ArrayList <> ()). add ( str ); } return new ArrayList <> ( map . values ()); } }","title":"49. Group Anagrams $\\star\\star$"},{"location":"java/0001-0100/0041-0050/#50-powx-n-starstar","text":"Time: $O(\\log n)$ Space: $O(1)$ class Solution { public double myPow ( double x , long n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 1 / myPow ( x , - n ); if ( n % 2 == 1 ) return x * myPow ( x , n - 1 ); return myPow ( x * x , n / 2 ); } }","title":"50. Pow(x, n) $\\star\\star$"},{"location":"java/0001-0100/0051-0060/","text":"51. N-Queens $\\star\\star\\star$ Time: $O(n^n)$ Space: $O(n)$ class Solution { public List < List < String >> solveNQueens ( int n ) { List < List < String >> ans = new ArrayList <> (); char [][] board = new char [ n ][ n ] ; for ( int i = 0 ; i < n ; ++ i ) Arrays . fill ( board [ i ] , '.' ); dfs ( 0 , new boolean [ n ] , new boolean [ 2 * n - 1 ] , new boolean [ 2 * n - 1 ] , board , ans ); return ans ; } private void dfs ( int i , boolean [] cols , boolean [] diag1 , boolean [] diag2 , char [][] board , List < List < String >> ans ) { if ( i == cols . length ) { ans . add ( construct ( board )); return ; } for ( int j = 0 ; j < cols . length ; ++ j ) { if ( cols [ j ] || diag1 [ i + j ] || diag2 [ j - i + cols . length - 1 ] ) continue ; board [ i ][ j ] = 'Q' ; cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + cols . length - 1 ] = true ; dfs ( i + 1 , cols , diag1 , diag2 , board , ans ); cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + cols . length - 1 ] = false ; board [ i ][ j ] = '.' ; } } private List < String > construct ( char [][] board ) { List < String > listBoard = new ArrayList <> (); for ( int i = 0 ; i < board . length ; ++ i ) listBoard . add ( String . valueOf ( board [ i ] )); return listBoard ; } } 52. N-Queens II $\\star\\star\\star$ 53. Maximum Subarray $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public int maxSubArray ( int [] nums ) { int ans = Integer . MIN_VALUE ; int sum = 0 ; for ( int num : nums ) { sum += num ; ans = Math . max ( ans , sum ); sum = Math . max ( sum , 0 ); } return ans ; } } 54. Spiral Matrix $\\star\\star$ Time: $O(mn)$ Space: $O(1)$ class Solution { public List < Integer > spiralOrder ( int [][] matrix ) { if ( matrix . length == 0 ) return new ArrayList <> (); List < Integer > ans = new ArrayList <> (); int r1 = 0 ; int c1 = 0 ; int r2 = matrix . length - 1 ; int c2 = matrix [ 0 ] . length - 1 ; while ( r1 <= r2 && c1 <= c2 ) { for ( int c = c1 ; c <= c2 ; ++ c ) ans . add ( matrix [ r1 ][ c ] ); for ( int r = r1 + 1 ; r <= r2 ; ++ r ) ans . add ( matrix [ r ][ c2 ] ); if ( r1 < r2 && c1 < c2 ) { for ( int c = c2 - 1 ; c > c1 ; -- c ) ans . add ( matrix [ r2 ][ c ] ); for ( int r = r2 ; r > r1 ; -- r ) ans . add ( matrix [ r ][ c1 ] ); } ++ r1 ; ++ c1 ; -- r2 ; -- c2 ; } return ans ; } } 55. Jump Game $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public boolean canJump ( int [] nums ) { int goal = nums . length - 1 ; for ( int i = goal ; i >= 0 ; -- i ) if ( i + nums [ i ] >= goal ) goal = i ; return goal == 0 ; } } 56. Merge Intervals $\\star\\star$ Time: $O(n\\log n)$ Space: $O(1)$ class Solution { public int [][] merge ( int [][] intervals ) { List < int []> ans = new ArrayList <> (); Arrays . sort ( intervals , ( a , b ) -> a [ 0 ] - b [ 0 ] ); for ( int [] interval : intervals ) { if ( ans . isEmpty () || ans . get ( ans . size () - 1 ) [ 1 ] < interval [ 0 ] ) ans . add ( interval ); else ans . get ( ans . size () - 1 ) [ 1 ] = Math . max ( ans . get ( ans . size () - 1 ) [ 1 ] , interval [ 1 ] ); } return ans . toArray ( new int [ ans . size () ][] ); } } 57. Insert Interval $\\star\\star\\star$ Time: $O(n\\log n)$ Space: $O(1)$ class Solution { public int [][] insert ( int [][] intervals , int [] newInterval ) { List < int []> ans = new ArrayList <> (); List < int []> intervalsList = new ArrayList <> ( Arrays . asList ( intervals )); int i = 0 ; for (; i < intervals . length ; ++ i ) if ( intervals [ i ][ 0 ] >= newInterval [ 0 ] ) break ; intervalsList . add ( i , newInterval ); for ( int [] interval : intervalsList ) { if ( ans . isEmpty () || ans . get ( ans . size () - 1 ) [ 1 ] < interval [ 0 ] ) ans . add ( interval ); else ans . get ( ans . size () - 1 ) [ 1 ] = Math . max ( ans . get ( ans . size () - 1 ) [ 1 ] , interval [ 1 ] ); } return ans . toArray ( new int [ ans . size () ][] ); } } 58. Length of Last Word $\\star$ 59. Spiral Matrix II $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public int [][] generateMatrix ( int n ) { int [][] ans = new int [ n ][ n ] ; int count = 1 ; for ( int min = 0 ; min < n / 2 ; ++ min ) { int max = n - min - 1 ; for ( int i = min ; i < max ; ++ i ) ans [ min ][ i ] = count ++ ; for ( int i = min ; i < max ; ++ i ) ans [ i ][ max ] = count ++ ; for ( int i = max ; i > min ; -- i ) ans [ max ][ i ] = count ++ ; for ( int i = max ; i > min ; -- i ) ans [ i ][ min ] = count ++ ; } if ( n % 2 == 1 ) ans [ n / 2 ][ n / 2 ] = count ; return ans ; } } 60. Permutation Sequence $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public String getPermutation ( int n , int k ) { StringBuilder ans = new StringBuilder (); List < Integer > nums = new ArrayList <> (); int [] factorial = new int [ n ] ; for ( int i = 1 ; i <= n ; ++ i ) nums . add ( i ); Arrays . fill ( factorial , 1 ); for ( int i = 1 ; i < n ; ++ i ) factorial [ i ] = factorial [ i - 1 ] * i ; -- k ; for ( int i = n ; i > 0 ; -- i ) { int j = k / factorial [ i - 1 ] ; k %= factorial [ i - 1 ] ; ans . append ( nums . get ( j )); nums . remove ( j ); } return ans . toString (); } }","title":"0051-0060"},{"location":"java/0001-0100/0051-0060/#51-n-queens-starstarstar","text":"Time: $O(n^n)$ Space: $O(n)$ class Solution { public List < List < String >> solveNQueens ( int n ) { List < List < String >> ans = new ArrayList <> (); char [][] board = new char [ n ][ n ] ; for ( int i = 0 ; i < n ; ++ i ) Arrays . fill ( board [ i ] , '.' ); dfs ( 0 , new boolean [ n ] , new boolean [ 2 * n - 1 ] , new boolean [ 2 * n - 1 ] , board , ans ); return ans ; } private void dfs ( int i , boolean [] cols , boolean [] diag1 , boolean [] diag2 , char [][] board , List < List < String >> ans ) { if ( i == cols . length ) { ans . add ( construct ( board )); return ; } for ( int j = 0 ; j < cols . length ; ++ j ) { if ( cols [ j ] || diag1 [ i + j ] || diag2 [ j - i + cols . length - 1 ] ) continue ; board [ i ][ j ] = 'Q' ; cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + cols . length - 1 ] = true ; dfs ( i + 1 , cols , diag1 , diag2 , board , ans ); cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + cols . length - 1 ] = false ; board [ i ][ j ] = '.' ; } } private List < String > construct ( char [][] board ) { List < String > listBoard = new ArrayList <> (); for ( int i = 0 ; i < board . length ; ++ i ) listBoard . add ( String . valueOf ( board [ i ] )); return listBoard ; } }","title":"51. N-Queens $\\star\\star\\star$"},{"location":"java/0001-0100/0051-0060/#52-n-queens-ii-starstarstar","text":"","title":"52. N-Queens II $\\star\\star\\star$"},{"location":"java/0001-0100/0051-0060/#53-maximum-subarray-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public int maxSubArray ( int [] nums ) { int ans = Integer . MIN_VALUE ; int sum = 0 ; for ( int num : nums ) { sum += num ; ans = Math . max ( ans , sum ); sum = Math . max ( sum , 0 ); } return ans ; } }","title":"53. Maximum Subarray $\\star$"},{"location":"java/0001-0100/0051-0060/#54-spiral-matrix-starstar","text":"Time: $O(mn)$ Space: $O(1)$ class Solution { public List < Integer > spiralOrder ( int [][] matrix ) { if ( matrix . length == 0 ) return new ArrayList <> (); List < Integer > ans = new ArrayList <> (); int r1 = 0 ; int c1 = 0 ; int r2 = matrix . length - 1 ; int c2 = matrix [ 0 ] . length - 1 ; while ( r1 <= r2 && c1 <= c2 ) { for ( int c = c1 ; c <= c2 ; ++ c ) ans . add ( matrix [ r1 ][ c ] ); for ( int r = r1 + 1 ; r <= r2 ; ++ r ) ans . add ( matrix [ r ][ c2 ] ); if ( r1 < r2 && c1 < c2 ) { for ( int c = c2 - 1 ; c > c1 ; -- c ) ans . add ( matrix [ r2 ][ c ] ); for ( int r = r2 ; r > r1 ; -- r ) ans . add ( matrix [ r ][ c1 ] ); } ++ r1 ; ++ c1 ; -- r2 ; -- c2 ; } return ans ; } }","title":"54. Spiral Matrix $\\star\\star$"},{"location":"java/0001-0100/0051-0060/#55-jump-game-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public boolean canJump ( int [] nums ) { int goal = nums . length - 1 ; for ( int i = goal ; i >= 0 ; -- i ) if ( i + nums [ i ] >= goal ) goal = i ; return goal == 0 ; } }","title":"55. Jump Game $\\star\\star$"},{"location":"java/0001-0100/0051-0060/#56-merge-intervals-starstar","text":"Time: $O(n\\log n)$ Space: $O(1)$ class Solution { public int [][] merge ( int [][] intervals ) { List < int []> ans = new ArrayList <> (); Arrays . sort ( intervals , ( a , b ) -> a [ 0 ] - b [ 0 ] ); for ( int [] interval : intervals ) { if ( ans . isEmpty () || ans . get ( ans . size () - 1 ) [ 1 ] < interval [ 0 ] ) ans . add ( interval ); else ans . get ( ans . size () - 1 ) [ 1 ] = Math . max ( ans . get ( ans . size () - 1 ) [ 1 ] , interval [ 1 ] ); } return ans . toArray ( new int [ ans . size () ][] ); } }","title":"56. Merge Intervals $\\star\\star$"},{"location":"java/0001-0100/0051-0060/#57-insert-interval-starstarstar","text":"Time: $O(n\\log n)$ Space: $O(1)$ class Solution { public int [][] insert ( int [][] intervals , int [] newInterval ) { List < int []> ans = new ArrayList <> (); List < int []> intervalsList = new ArrayList <> ( Arrays . asList ( intervals )); int i = 0 ; for (; i < intervals . length ; ++ i ) if ( intervals [ i ][ 0 ] >= newInterval [ 0 ] ) break ; intervalsList . add ( i , newInterval ); for ( int [] interval : intervalsList ) { if ( ans . isEmpty () || ans . get ( ans . size () - 1 ) [ 1 ] < interval [ 0 ] ) ans . add ( interval ); else ans . get ( ans . size () - 1 ) [ 1 ] = Math . max ( ans . get ( ans . size () - 1 ) [ 1 ] , interval [ 1 ] ); } return ans . toArray ( new int [ ans . size () ][] ); } }","title":"57. Insert Interval $\\star\\star\\star$"},{"location":"java/0001-0100/0051-0060/#58-length-of-last-word-star","text":"","title":"58. Length of Last Word $\\star$"},{"location":"java/0001-0100/0051-0060/#59-spiral-matrix-ii-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public int [][] generateMatrix ( int n ) { int [][] ans = new int [ n ][ n ] ; int count = 1 ; for ( int min = 0 ; min < n / 2 ; ++ min ) { int max = n - min - 1 ; for ( int i = min ; i < max ; ++ i ) ans [ min ][ i ] = count ++ ; for ( int i = min ; i < max ; ++ i ) ans [ i ][ max ] = count ++ ; for ( int i = max ; i > min ; -- i ) ans [ max ][ i ] = count ++ ; for ( int i = max ; i > min ; -- i ) ans [ i ][ min ] = count ++ ; } if ( n % 2 == 1 ) ans [ n / 2 ][ n / 2 ] = count ; return ans ; } }","title":"59. Spiral Matrix II $\\star\\star$"},{"location":"java/0001-0100/0051-0060/#60-permutation-sequence-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public String getPermutation ( int n , int k ) { StringBuilder ans = new StringBuilder (); List < Integer > nums = new ArrayList <> (); int [] factorial = new int [ n ] ; for ( int i = 1 ; i <= n ; ++ i ) nums . add ( i ); Arrays . fill ( factorial , 1 ); for ( int i = 1 ; i < n ; ++ i ) factorial [ i ] = factorial [ i - 1 ] * i ; -- k ; for ( int i = n ; i > 0 ; -- i ) { int j = k / factorial [ i - 1 ] ; k %= factorial [ i - 1 ] ; ans . append ( nums . get ( j )); nums . remove ( j ); } return ans . toString (); } }","title":"60. Permutation Sequence $\\star\\star$"},{"location":"java/0001-0100/0061-0070/","text":"61. Rotate List $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public ListNode rotateRight ( ListNode head , int k ) { if ( head == null || head . next == null || k == 0 ) return head ; int length = 0 ; for ( ListNode curr = head ; curr != null ; curr = curr . next ) ++ length ; k %= length ; if ( k == 0 ) return head ; ListNode slow = head ; ListNode fast = head ; while ( k -- > 0 ) fast = fast . next ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next ; } ListNode ans = slow . next ; slow . next = null ; fast . next = head ; return ans ; } } 62. Unique Paths $\\star\\star$ Time: $O(mn)$ Space: $O(mn) \\to O(n)$ class Solution { public int uniquePaths ( int m , int n ) { int [] dp = new int [ n ] ; Arrays . fill ( dp , 1 ); for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) dp [ j ] += dp [ j - 1 ] ; return dp [ n - 1 ] ; } } 63. Unique Paths II $\\star\\star$ Time: $O(mn)$ Space: $O(mn) \\to O(n)$ class Solution { public int uniquePathsWithObstacles ( int [][] obstacleGrid ) { final int m = obstacleGrid . length ; final int n = obstacleGrid [ 0 ] . length ; int [] dp = new int [ n ] ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { if ( obstacleGrid [ i ][ j ] == 1 ) dp [ j ] = 0 ; else if ( j > 0 ) dp [ j ] += dp [ j - 1 ] ; } return dp [ n - 1 ] ; } } 64. Minimum Path Sum $\\star\\star$ Time: $O(mn)$ Space: $O(1)$ class Solution { public int minPathSum ( int [][] grid ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; for ( int i = 1 ; i < m ; ++ i ) grid [ i ][ 0 ] += grid [ i - 1 ][ 0 ] ; for ( int j = 1 ; j < n ; ++ j ) grid [ 0 ][ j ] += grid [ 0 ][ j - 1 ] ; for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) grid [ i ][ j ] += Math . min ( grid [ i - 1 ][ j ] , grid [ i ][ j - 1 ] ); return grid [ m - 1 ][ n - 1 ] ; } } 65. Valid Number $\\star\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public boolean isNumber ( String s ) { s = s . trim (); if ( s == null ) return false ; boolean seenNum = false ; boolean seenDot = false ; boolean seenE = false ; for ( int i = 0 ; i < s . length (); ++ i ) { switch ( s . charAt ( i )) { case '.' : if ( seenDot || seenE ) return false ; seenDot = true ; break ; case 'e' : if ( seenE || ! seenNum ) return false ; seenE = true ; seenNum = false ; break ; case '+' : case '-' : if ( i > 0 && s . charAt ( i - 1 ) != 'e' ) return false ; seenNum = false ; break ; default : if ( ! Character . isDigit ( s . charAt ( i ))) return false ; seenNum = true ; } } return seenNum ; } } 66. Plus One $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public int [] plusOne ( int [] digits ) { final int n = digits . length ; for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( digits [ i ] < 9 ) { ++ digits [ i ] ; return digits ; } digits [ i ] = 0 ; } int [] ans = new int [ n + 1 ] ; ans [ 0 ] = 1 ; return ans ; } } 67. Add Binary $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public String addBinary ( String a , String b ) { String ans = \"\" ; int carry = 0 ; int i = a . length () - 1 ; int j = b . length () - 1 ; while ( carry == 1 || i >= 0 || j >= 0 ) { if ( i >= 0 ) carry += a . charAt ( i -- ) - '0' ; if ( j >= 0 ) carry += b . charAt ( j -- ) - '0' ; ans = ( char ) ( carry % 2 + '0' ) + ans ; carry >>= 1 ; } return ans ; } } 68. Text Justification $\\star\\star\\star$ 69. Sqrt(x) $\\star$ Time: $O(\\log x)$ Space: $O(1)$ class Solution { public int mySqrt ( long x ) { long l = 1 ; long r = x + 1 ; while ( l < r ) { long m = l + ( r - l ) / 2 ; if ( m > x / m ) r = m ; else l = m + 1 ; } return ( int ) l - 1 ; } } 70. Climbing Stairs $\\star$ Time: $O(n)$ Space: $O(n) \\to O(1)$ class Solution { public int climbStairs ( int n ) { if ( n == 1 ) return 1 ; int ans = 0 ; int prevTwoStairs = 1 ; int prevOneStair = 1 ; for ( int i = 2 ; i <= n ; ++ i ) { ans = prevTwoStairs + prevOneStair ; prevTwoStairs = prevOneStair ; prevOneStair = ans ; } return ans ; } }","title":"0061-0070"},{"location":"java/0001-0100/0061-0070/#61-rotate-list-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public ListNode rotateRight ( ListNode head , int k ) { if ( head == null || head . next == null || k == 0 ) return head ; int length = 0 ; for ( ListNode curr = head ; curr != null ; curr = curr . next ) ++ length ; k %= length ; if ( k == 0 ) return head ; ListNode slow = head ; ListNode fast = head ; while ( k -- > 0 ) fast = fast . next ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next ; } ListNode ans = slow . next ; slow . next = null ; fast . next = head ; return ans ; } }","title":"61. Rotate List $\\star\\star$"},{"location":"java/0001-0100/0061-0070/#62-unique-paths-starstar","text":"Time: $O(mn)$ Space: $O(mn) \\to O(n)$ class Solution { public int uniquePaths ( int m , int n ) { int [] dp = new int [ n ] ; Arrays . fill ( dp , 1 ); for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) dp [ j ] += dp [ j - 1 ] ; return dp [ n - 1 ] ; } }","title":"62. Unique Paths $\\star\\star$"},{"location":"java/0001-0100/0061-0070/#63-unique-paths-ii-starstar","text":"Time: $O(mn)$ Space: $O(mn) \\to O(n)$ class Solution { public int uniquePathsWithObstacles ( int [][] obstacleGrid ) { final int m = obstacleGrid . length ; final int n = obstacleGrid [ 0 ] . length ; int [] dp = new int [ n ] ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { if ( obstacleGrid [ i ][ j ] == 1 ) dp [ j ] = 0 ; else if ( j > 0 ) dp [ j ] += dp [ j - 1 ] ; } return dp [ n - 1 ] ; } }","title":"63. Unique Paths II $\\star\\star$"},{"location":"java/0001-0100/0061-0070/#64-minimum-path-sum-starstar","text":"Time: $O(mn)$ Space: $O(1)$ class Solution { public int minPathSum ( int [][] grid ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; for ( int i = 1 ; i < m ; ++ i ) grid [ i ][ 0 ] += grid [ i - 1 ][ 0 ] ; for ( int j = 1 ; j < n ; ++ j ) grid [ 0 ][ j ] += grid [ 0 ][ j - 1 ] ; for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) grid [ i ][ j ] += Math . min ( grid [ i - 1 ][ j ] , grid [ i ][ j - 1 ] ); return grid [ m - 1 ][ n - 1 ] ; } }","title":"64. Minimum Path Sum $\\star\\star$"},{"location":"java/0001-0100/0061-0070/#65-valid-number-starstarstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public boolean isNumber ( String s ) { s = s . trim (); if ( s == null ) return false ; boolean seenNum = false ; boolean seenDot = false ; boolean seenE = false ; for ( int i = 0 ; i < s . length (); ++ i ) { switch ( s . charAt ( i )) { case '.' : if ( seenDot || seenE ) return false ; seenDot = true ; break ; case 'e' : if ( seenE || ! seenNum ) return false ; seenE = true ; seenNum = false ; break ; case '+' : case '-' : if ( i > 0 && s . charAt ( i - 1 ) != 'e' ) return false ; seenNum = false ; break ; default : if ( ! Character . isDigit ( s . charAt ( i ))) return false ; seenNum = true ; } } return seenNum ; } }","title":"65. Valid Number $\\star\\star\\star$"},{"location":"java/0001-0100/0061-0070/#66-plus-one-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public int [] plusOne ( int [] digits ) { final int n = digits . length ; for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( digits [ i ] < 9 ) { ++ digits [ i ] ; return digits ; } digits [ i ] = 0 ; } int [] ans = new int [ n + 1 ] ; ans [ 0 ] = 1 ; return ans ; } }","title":"66. Plus One $\\star$"},{"location":"java/0001-0100/0061-0070/#67-add-binary-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public String addBinary ( String a , String b ) { String ans = \"\" ; int carry = 0 ; int i = a . length () - 1 ; int j = b . length () - 1 ; while ( carry == 1 || i >= 0 || j >= 0 ) { if ( i >= 0 ) carry += a . charAt ( i -- ) - '0' ; if ( j >= 0 ) carry += b . charAt ( j -- ) - '0' ; ans = ( char ) ( carry % 2 + '0' ) + ans ; carry >>= 1 ; } return ans ; } }","title":"67. Add Binary $\\star$"},{"location":"java/0001-0100/0061-0070/#68-text-justification-starstarstar","text":"","title":"68. Text Justification $\\star\\star\\star$"},{"location":"java/0001-0100/0061-0070/#69-sqrtx-star","text":"Time: $O(\\log x)$ Space: $O(1)$ class Solution { public int mySqrt ( long x ) { long l = 1 ; long r = x + 1 ; while ( l < r ) { long m = l + ( r - l ) / 2 ; if ( m > x / m ) r = m ; else l = m + 1 ; } return ( int ) l - 1 ; } }","title":"69. Sqrt(x) $\\star$"},{"location":"java/0001-0100/0061-0070/#70-climbing-stairs-star","text":"Time: $O(n)$ Space: $O(n) \\to O(1)$ class Solution { public int climbStairs ( int n ) { if ( n == 1 ) return 1 ; int ans = 0 ; int prevTwoStairs = 1 ; int prevOneStair = 1 ; for ( int i = 2 ; i <= n ; ++ i ) { ans = prevTwoStairs + prevOneStair ; prevTwoStairs = prevOneStair ; prevOneStair = ans ; } return ans ; } }","title":"70. Climbing Stairs $\\star$"},{"location":"java/0001-0100/0071-0080/","text":"71. Simplify Path $\\star\\star$ 72. Edit Distance $\\star\\star\\star$ 73. Set Matrix Zeroes $\\star\\star$ Time: $O(mn)$ Space: $O(1)$ class Solution { public void setZeroes ( int [][] matrix ) { final int m = matrix . length ; final int n = matrix [ 0 ] . length ; boolean isFirstRow = false ; boolean isFirstCol = false ; for ( int j = 0 ; j < n ; ++ j ) if ( matrix [ 0 ][ j ] == 0 ) isFirstRow = true ; for ( int i = 0 ; i < m ; ++ i ) if ( matrix [ i ][ 0 ] == 0 ) isFirstCol = true ; for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) if ( matrix [ i ][ j ] == 0 ) { matrix [ i ][ 0 ] = 0 ; matrix [ 0 ][ j ] = 0 ; } for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) if ( matrix [ i ][ 0 ] == 0 || matrix [ 0 ][ j ] == 0 ) matrix [ i ][ j ] = 0 ; if ( isFirstRow ) for ( int j = 0 ; j < n ; ++ j ) matrix [ 0 ][ j ] = 0 ; if ( isFirstCol ) for ( int i = 0 ; i < m ; ++ i ) matrix [ i ][ 0 ] = 0 ; } } 74. Search a 2D Matrix $\\star\\star$ Time: $O(mn\\log mn)$ Space: $O(1)$ class Solution { public boolean searchMatrix ( int [][] matrix , int target ) { if ( matrix . length == 0 ) return false ; final int m = matrix . length ; final int n = matrix [ 0 ] . length ; int l = 0 ; int r = m * n ; while ( l < r ) { int mid = l + ( r - l ) / 2 ; int i = mid / n ; int j = mid % n ; if ( matrix [ i ][ j ] == target ) return true ; if ( matrix [ i ][ j ] < target ) l = mid + 1 ; else r = mid ; } return false ; } } 75. Sort Colors $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public void sortColors ( int [] nums ) { int zero = - 1 ; int one = - 1 ; int two = - 1 ; for ( int num : nums ) { if ( num == 0 ) { nums [++ two ] = 2 ; nums [++ one ] = 1 ; nums [++ zero ] = 0 ; } else if ( num == 1 ) { nums [++ two ] = 2 ; nums [++ one ] = 1 ; } else { nums [++ two ] = 2 ; } } } } 76. Minimum Window Substring $\\star\\star\\star$ Time: $O(n)$ Space: $O(128)$ class Solution { public String minWindow ( String s , String t ) { int [] count = new int [ 128 ] ; int required = t . length (); int bestLeft = 0 ; int minLength = Integer . MAX_VALUE ; for ( char c : t . toCharArray ()) ++ count [ c ] ; for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { if ( -- count [ s . charAt ( r ) ] >= 0 ) -- required ; while ( required == 0 ) { if ( r - l + 1 < minLength ) { bestLeft = l ; minLength = r - l + 1 ; } if ( ++ count [ s . charAt ( l ++ ) ] > 0 ) ++ required ; } } return minLength == Integer . MAX_VALUE ? \"\" : s . substring ( bestLeft , bestLeft + minLength ); } } 77. Combinations $\\star\\star$ 78. Subsets $\\star\\star$ Time: $O(2^n)$ Space: $O(n)$ class Solution { public List < List < Integer >> subsets ( int [] nums ) { List < List < Integer >> ans = new ArrayList <> (); dfs ( nums , 0 , new ArrayList <> (), ans ); return ans ; } private void dfs ( int [] nums , int s , List < Integer > path , List < List < Integer >> ans ) { ans . add ( new ArrayList <> ( path )); for ( int i = s ; i < nums . length ; ++ i ) { path . add ( nums [ i ] ); dfs ( nums , i + 1 , path , ans ); path . remove ( path . size () - 1 ); } } } 79. Word Search $\\star\\star$ Time: $O(4^l)$, where l = len(word) Space: $O(1)$ class Solution { public boolean exist ( char [][] board , String word ) { if ( board . length == 0 ) return false ; for ( int i = 0 ; i < board . length ; ++ i ) for ( int j = 0 ; j < board [ 0 ] . length ; ++ j ) if ( dfs ( board , word , i , j , 0 )) return true ; return false ; } private boolean dfs ( char [][] board , String word , int i , int j , int pos ) { if ( i < 0 || i >= board . length || j < 0 || j >= board [ 0 ] . length || board [ i ][ j ] != word . charAt ( pos ) || board [ i ][ j ] == '*' ) return false ; if ( pos == word . length () - 1 ) return true ; char c = board [ i ][ j ] ; board [ i ][ j ] = '*' ; boolean flag = dfs ( board , word , i + 1 , j , pos + 1 ) || dfs ( board , word , i - 1 , j , pos + 1 ) || dfs ( board , word , i , j + 1 , pos + 1 ) || dfs ( board , word , i , j - 1 , pos + 1 ); board [ i ][ j ] = c ; return flag ; } } 80. Remove Duplicates from Sorted Array II $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public int removeDuplicates ( int [] nums ) { int i = 0 ; for ( int num : nums ) if ( i < 2 || num != nums [ i - 2 ] ) nums [ i ++] = num ; return i ; } }","title":"0071-0080"},{"location":"java/0001-0100/0071-0080/#71-simplify-path-starstar","text":"","title":"71. Simplify Path $\\star\\star$"},{"location":"java/0001-0100/0071-0080/#72-edit-distance-starstarstar","text":"","title":"72. Edit Distance $\\star\\star\\star$"},{"location":"java/0001-0100/0071-0080/#73-set-matrix-zeroes-starstar","text":"Time: $O(mn)$ Space: $O(1)$ class Solution { public void setZeroes ( int [][] matrix ) { final int m = matrix . length ; final int n = matrix [ 0 ] . length ; boolean isFirstRow = false ; boolean isFirstCol = false ; for ( int j = 0 ; j < n ; ++ j ) if ( matrix [ 0 ][ j ] == 0 ) isFirstRow = true ; for ( int i = 0 ; i < m ; ++ i ) if ( matrix [ i ][ 0 ] == 0 ) isFirstCol = true ; for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) if ( matrix [ i ][ j ] == 0 ) { matrix [ i ][ 0 ] = 0 ; matrix [ 0 ][ j ] = 0 ; } for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) if ( matrix [ i ][ 0 ] == 0 || matrix [ 0 ][ j ] == 0 ) matrix [ i ][ j ] = 0 ; if ( isFirstRow ) for ( int j = 0 ; j < n ; ++ j ) matrix [ 0 ][ j ] = 0 ; if ( isFirstCol ) for ( int i = 0 ; i < m ; ++ i ) matrix [ i ][ 0 ] = 0 ; } }","title":"73. Set Matrix Zeroes $\\star\\star$"},{"location":"java/0001-0100/0071-0080/#74-search-a-2d-matrix-starstar","text":"Time: $O(mn\\log mn)$ Space: $O(1)$ class Solution { public boolean searchMatrix ( int [][] matrix , int target ) { if ( matrix . length == 0 ) return false ; final int m = matrix . length ; final int n = matrix [ 0 ] . length ; int l = 0 ; int r = m * n ; while ( l < r ) { int mid = l + ( r - l ) / 2 ; int i = mid / n ; int j = mid % n ; if ( matrix [ i ][ j ] == target ) return true ; if ( matrix [ i ][ j ] < target ) l = mid + 1 ; else r = mid ; } return false ; } }","title":"74. Search a 2D Matrix $\\star\\star$"},{"location":"java/0001-0100/0071-0080/#75-sort-colors-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public void sortColors ( int [] nums ) { int zero = - 1 ; int one = - 1 ; int two = - 1 ; for ( int num : nums ) { if ( num == 0 ) { nums [++ two ] = 2 ; nums [++ one ] = 1 ; nums [++ zero ] = 0 ; } else if ( num == 1 ) { nums [++ two ] = 2 ; nums [++ one ] = 1 ; } else { nums [++ two ] = 2 ; } } } }","title":"75. Sort Colors $\\star\\star$"},{"location":"java/0001-0100/0071-0080/#76-minimum-window-substring-starstarstar","text":"Time: $O(n)$ Space: $O(128)$ class Solution { public String minWindow ( String s , String t ) { int [] count = new int [ 128 ] ; int required = t . length (); int bestLeft = 0 ; int minLength = Integer . MAX_VALUE ; for ( char c : t . toCharArray ()) ++ count [ c ] ; for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { if ( -- count [ s . charAt ( r ) ] >= 0 ) -- required ; while ( required == 0 ) { if ( r - l + 1 < minLength ) { bestLeft = l ; minLength = r - l + 1 ; } if ( ++ count [ s . charAt ( l ++ ) ] > 0 ) ++ required ; } } return minLength == Integer . MAX_VALUE ? \"\" : s . substring ( bestLeft , bestLeft + minLength ); } }","title":"76. Minimum Window Substring $\\star\\star\\star$"},{"location":"java/0001-0100/0071-0080/#77-combinations-starstar","text":"","title":"77. Combinations $\\star\\star$"},{"location":"java/0001-0100/0071-0080/#78-subsets-starstar","text":"Time: $O(2^n)$ Space: $O(n)$ class Solution { public List < List < Integer >> subsets ( int [] nums ) { List < List < Integer >> ans = new ArrayList <> (); dfs ( nums , 0 , new ArrayList <> (), ans ); return ans ; } private void dfs ( int [] nums , int s , List < Integer > path , List < List < Integer >> ans ) { ans . add ( new ArrayList <> ( path )); for ( int i = s ; i < nums . length ; ++ i ) { path . add ( nums [ i ] ); dfs ( nums , i + 1 , path , ans ); path . remove ( path . size () - 1 ); } } }","title":"78. Subsets $\\star\\star$"},{"location":"java/0001-0100/0071-0080/#79-word-search-starstar","text":"Time: $O(4^l)$, where l = len(word) Space: $O(1)$ class Solution { public boolean exist ( char [][] board , String word ) { if ( board . length == 0 ) return false ; for ( int i = 0 ; i < board . length ; ++ i ) for ( int j = 0 ; j < board [ 0 ] . length ; ++ j ) if ( dfs ( board , word , i , j , 0 )) return true ; return false ; } private boolean dfs ( char [][] board , String word , int i , int j , int pos ) { if ( i < 0 || i >= board . length || j < 0 || j >= board [ 0 ] . length || board [ i ][ j ] != word . charAt ( pos ) || board [ i ][ j ] == '*' ) return false ; if ( pos == word . length () - 1 ) return true ; char c = board [ i ][ j ] ; board [ i ][ j ] = '*' ; boolean flag = dfs ( board , word , i + 1 , j , pos + 1 ) || dfs ( board , word , i - 1 , j , pos + 1 ) || dfs ( board , word , i , j + 1 , pos + 1 ) || dfs ( board , word , i , j - 1 , pos + 1 ); board [ i ][ j ] = c ; return flag ; } }","title":"79. Word Search $\\star\\star$"},{"location":"java/0001-0100/0071-0080/#80-remove-duplicates-from-sorted-array-ii-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public int removeDuplicates ( int [] nums ) { int i = 0 ; for ( int num : nums ) if ( i < 2 || num != nums [ i - 2 ] ) nums [ i ++] = num ; return i ; } }","title":"80. Remove Duplicates from Sorted Array II $\\star\\star$"},{"location":"java/0001-0100/0081-0090/","text":"81. Search in Rotated Sorted Array II $\\star\\star$ Time: $O(\\log n) \\to O(n)$ Space: $O(1)$ class Solution { public boolean search ( int [] nums , int target ) { int l = 0 ; int r = nums . length - 1 ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return true ; if ( nums [ l ] == nums [ m ] && nums [ m ] == nums [ r ] ) { ++ l ; -- r ; } else if ( nums [ l ] <= nums [ m ] ) { if ( nums [ l ] <= target && target < nums [ m ] ) r = m - 1 ; else l = m + 1 ; } else { if ( nums [ m ] < target && target <= nums [ r ] ) l = m + 1 ; else r = m - 1 ; } } return false ; } } 82. Remove Duplicates from Sorted List II $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public ListNode deleteDuplicates ( ListNode head ) { ListNode dummy = new ListNode ( 0 ); dummy . next = head ; ListNode prev = dummy ; while ( head != null ) { while ( head . next != null && head . val == head . next . val ) head = head . next ; if ( prev . next == head ) prev = prev . next ; else prev . next = head . next ; head = head . next ; } return dummy . next ; } } 83. Remove Duplicates from Sorted List $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public ListNode deleteDuplicates ( ListNode head ) { ListNode curr = head ; while ( curr != null ) { while ( curr . next != null && curr . val == curr . next . val ) curr . next = curr . next . next ; curr = curr . next ; } return head ; } } 84. Largest Rectangle in Histogram $\\star\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public int largestRectangleArea ( int [] heights ) { int ans = 0 ; Stack < Integer > stack = new Stack <> (); for ( int i = 0 ; i <= heights . length ; ++ i ) { while ( ! stack . isEmpty () && ( i == heights . length || heights [ i ] < heights [ stack . peek () ] )) { int h = heights [ stack . pop () ] ; int w = stack . isEmpty () ? i : i - stack . peek () - 1 ; ans = Math . max ( ans , h * w ); } stack . push ( i ); } return ans ; } } 85. Maximal Rectangle $\\star\\star\\star$ Time: $O(mn)$, where $m = len(matrix)$ and n = len(matrix[i]) Space: $O(n)$ class Solution { public int maximalRectangle ( char [][] matrix ) { if ( matrix . length == 0 ) return 0 ; int ans = 0 ; int [] temp = new int [ matrix [ 0 ] . length ] ; for ( char [] row : matrix ) { for ( int i = 0 ; i < row . length ; ++ i ) temp [ i ] = row [ i ] == '0' ? 0 : temp [ i ] + 1 ; ans = Math . max ( ans , largestRectangleArea ( temp )); } return ans ; } private int largestRectangleArea ( int [] heights ) { int ans = 0 ; Stack < Integer > stack = new Stack <> (); for ( int i = 0 ; i <= heights . length ; ++ i ) { while ( ! stack . isEmpty () && ( i == heights . length || heights [ i ] < heights [ stack . peek () ] )) { int h = heights [ stack . pop () ] ; int w = stack . isEmpty () ? i : i - stack . peek () - 1 ; ans = Math . max ( ans , h * w ); } stack . push ( i ); } return ans ; } } 86. Partition List $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public ListNode partition ( ListNode head , int x ) { ListNode beforeHead = new ListNode ( 0 ); ListNode afterHead = new ListNode ( 0 ); ListNode before = beforeHead ; ListNode after = afterHead ; for (; head != null ; head = head . next ) { if ( head . val < x ) { before . next = head ; before = head ; } else { after . next = head ; after = head ; } } after . next = null ; before . next = afterHead . next ; return beforeHead . next ; } } 87. Scramble String $\\star\\star\\star$ class Solution { public boolean isScramble ( String s1 , String s2 ) { if ( s1 . equals ( s2 )) return true ; if ( s1 . length () != s2 . length ()) return false ; int [] count = new int [ 26 ] ; for ( int i = 0 ; i < s1 . length (); ++ i ) { ++ count [ s1 . charAt ( i ) - 'a' ] ; -- count [ s2 . charAt ( i ) - 'a' ] ; } for ( int c : count ) if ( c != 0 ) return false ; for ( int i = 1 ; i < s1 . length (); ++ i ) { if ( isScramble ( s1 . substring ( 0 , i ), s2 . substring ( 0 , i )) && isScramble ( s1 . substring ( i ), s2 . substring ( i ))) return true ; if ( isScramble ( s1 . substring ( 0 , i ), s2 . substring ( s2 . length () - i )) && isScramble ( s1 . substring ( i ), s2 . substring ( 0 , s2 . length () - i ))) return true ; } return false ; } } 88. Merge Sorted Array $\\star$ Time: $O(m + n)$ Space: $O(1)$ class Solution { public void merge ( int [] nums1 , int m , int [] nums2 , int n ) { int k = m + n ; while ( n > 0 ) { if ( m > 0 && nums1 [ m - 1 ] > nums2 [ n - 1 ] ) nums1 [-- k ] = nums1 [-- m ] ; else nums1 [-- k ] = nums2 [-- n ] ; } } } 89. Gray Code $\\star\\star$ 90. Subsets II $\\star\\star$ Time: $O(n2^n)$ Space: $O(n)$ class Solution { public List < List < Integer >> subsetsWithDup ( int [] nums ) { List < List < Integer >> ans = new ArrayList <> (); Arrays . sort ( nums ); dfs ( nums , 0 , new ArrayList <> (), ans ); return ans ; } private void dfs ( int [] nums , int s , List < Integer > path , List < List < Integer >> ans ) { ans . add ( new ArrayList <> ( path )); if ( s == nums . length ) return ; for ( int i = s ; i < nums . length ; ++ i ) { if ( i > s && nums [ i ] == nums [ i - 1 ] ) continue ; path . add ( nums [ i ] ); dfs ( nums , i + 1 , path , ans ); path . remove ( path . size () - 1 ); } } }","title":"0081-0090"},{"location":"java/0001-0100/0081-0090/#81-search-in-rotated-sorted-array-ii-starstar","text":"Time: $O(\\log n) \\to O(n)$ Space: $O(1)$ class Solution { public boolean search ( int [] nums , int target ) { int l = 0 ; int r = nums . length - 1 ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return true ; if ( nums [ l ] == nums [ m ] && nums [ m ] == nums [ r ] ) { ++ l ; -- r ; } else if ( nums [ l ] <= nums [ m ] ) { if ( nums [ l ] <= target && target < nums [ m ] ) r = m - 1 ; else l = m + 1 ; } else { if ( nums [ m ] < target && target <= nums [ r ] ) l = m + 1 ; else r = m - 1 ; } } return false ; } }","title":"81. Search in Rotated Sorted Array II $\\star\\star$"},{"location":"java/0001-0100/0081-0090/#82-remove-duplicates-from-sorted-list-ii-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public ListNode deleteDuplicates ( ListNode head ) { ListNode dummy = new ListNode ( 0 ); dummy . next = head ; ListNode prev = dummy ; while ( head != null ) { while ( head . next != null && head . val == head . next . val ) head = head . next ; if ( prev . next == head ) prev = prev . next ; else prev . next = head . next ; head = head . next ; } return dummy . next ; } }","title":"82. Remove Duplicates from Sorted List II $\\star\\star$"},{"location":"java/0001-0100/0081-0090/#83-remove-duplicates-from-sorted-list-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public ListNode deleteDuplicates ( ListNode head ) { ListNode curr = head ; while ( curr != null ) { while ( curr . next != null && curr . val == curr . next . val ) curr . next = curr . next . next ; curr = curr . next ; } return head ; } }","title":"83. Remove Duplicates from Sorted List $\\star$"},{"location":"java/0001-0100/0081-0090/#84-largest-rectangle-in-histogram-starstarstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public int largestRectangleArea ( int [] heights ) { int ans = 0 ; Stack < Integer > stack = new Stack <> (); for ( int i = 0 ; i <= heights . length ; ++ i ) { while ( ! stack . isEmpty () && ( i == heights . length || heights [ i ] < heights [ stack . peek () ] )) { int h = heights [ stack . pop () ] ; int w = stack . isEmpty () ? i : i - stack . peek () - 1 ; ans = Math . max ( ans , h * w ); } stack . push ( i ); } return ans ; } }","title":"84. Largest Rectangle in Histogram $\\star\\star\\star$"},{"location":"java/0001-0100/0081-0090/#85-maximal-rectangle-starstarstar","text":"Time: $O(mn)$, where $m = len(matrix)$ and n = len(matrix[i]) Space: $O(n)$ class Solution { public int maximalRectangle ( char [][] matrix ) { if ( matrix . length == 0 ) return 0 ; int ans = 0 ; int [] temp = new int [ matrix [ 0 ] . length ] ; for ( char [] row : matrix ) { for ( int i = 0 ; i < row . length ; ++ i ) temp [ i ] = row [ i ] == '0' ? 0 : temp [ i ] + 1 ; ans = Math . max ( ans , largestRectangleArea ( temp )); } return ans ; } private int largestRectangleArea ( int [] heights ) { int ans = 0 ; Stack < Integer > stack = new Stack <> (); for ( int i = 0 ; i <= heights . length ; ++ i ) { while ( ! stack . isEmpty () && ( i == heights . length || heights [ i ] < heights [ stack . peek () ] )) { int h = heights [ stack . pop () ] ; int w = stack . isEmpty () ? i : i - stack . peek () - 1 ; ans = Math . max ( ans , h * w ); } stack . push ( i ); } return ans ; } }","title":"85. Maximal Rectangle $\\star\\star\\star$"},{"location":"java/0001-0100/0081-0090/#86-partition-list-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public ListNode partition ( ListNode head , int x ) { ListNode beforeHead = new ListNode ( 0 ); ListNode afterHead = new ListNode ( 0 ); ListNode before = beforeHead ; ListNode after = afterHead ; for (; head != null ; head = head . next ) { if ( head . val < x ) { before . next = head ; before = head ; } else { after . next = head ; after = head ; } } after . next = null ; before . next = afterHead . next ; return beforeHead . next ; } }","title":"86. Partition List $\\star\\star$"},{"location":"java/0001-0100/0081-0090/#87-scramble-string-starstarstar","text":"class Solution { public boolean isScramble ( String s1 , String s2 ) { if ( s1 . equals ( s2 )) return true ; if ( s1 . length () != s2 . length ()) return false ; int [] count = new int [ 26 ] ; for ( int i = 0 ; i < s1 . length (); ++ i ) { ++ count [ s1 . charAt ( i ) - 'a' ] ; -- count [ s2 . charAt ( i ) - 'a' ] ; } for ( int c : count ) if ( c != 0 ) return false ; for ( int i = 1 ; i < s1 . length (); ++ i ) { if ( isScramble ( s1 . substring ( 0 , i ), s2 . substring ( 0 , i )) && isScramble ( s1 . substring ( i ), s2 . substring ( i ))) return true ; if ( isScramble ( s1 . substring ( 0 , i ), s2 . substring ( s2 . length () - i )) && isScramble ( s1 . substring ( i ), s2 . substring ( 0 , s2 . length () - i ))) return true ; } return false ; } }","title":"87. Scramble String $\\star\\star\\star$"},{"location":"java/0001-0100/0081-0090/#88-merge-sorted-array-star","text":"Time: $O(m + n)$ Space: $O(1)$ class Solution { public void merge ( int [] nums1 , int m , int [] nums2 , int n ) { int k = m + n ; while ( n > 0 ) { if ( m > 0 && nums1 [ m - 1 ] > nums2 [ n - 1 ] ) nums1 [-- k ] = nums1 [-- m ] ; else nums1 [-- k ] = nums2 [-- n ] ; } } }","title":"88. Merge Sorted Array $\\star$"},{"location":"java/0001-0100/0081-0090/#89-gray-code-starstar","text":"","title":"89. Gray Code $\\star\\star$"},{"location":"java/0001-0100/0081-0090/#90-subsets-ii-starstar","text":"Time: $O(n2^n)$ Space: $O(n)$ class Solution { public List < List < Integer >> subsetsWithDup ( int [] nums ) { List < List < Integer >> ans = new ArrayList <> (); Arrays . sort ( nums ); dfs ( nums , 0 , new ArrayList <> (), ans ); return ans ; } private void dfs ( int [] nums , int s , List < Integer > path , List < List < Integer >> ans ) { ans . add ( new ArrayList <> ( path )); if ( s == nums . length ) return ; for ( int i = s ; i < nums . length ; ++ i ) { if ( i > s && nums [ i ] == nums [ i - 1 ] ) continue ; path . add ( nums [ i ] ); dfs ( nums , i + 1 , path , ans ); path . remove ( path . size () - 1 ); } } }","title":"90. Subsets II $\\star\\star$"},{"location":"java/0001-0100/0091-0100/","text":"91. Decode Ways $\\star\\star$ 92. Reverse Linked List II $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public ListNode reverseBetween ( ListNode head , int m , int n ) { if ( head == null ) return null ; ListNode prev = null ; ListNode curr = head ; for ( int i = 0 ; i < m - 1 ; ++ i ) { prev = curr ; curr = curr . next ; } ListNode conn = prev ; ListNode tail = curr ; for ( int i = 0 ; i < n - m + 1 ; ++ i ) { ListNode next = curr . next ; curr . next = prev ; prev = curr ; curr = next ; } if ( conn != null ) conn . next = prev ; else head = prev ; tail . next = curr ; return head ; } } 93. Restore IP Addresses $\\star\\star$ Time: $O(3^4)$ Space: $O(1)$ class Solution { public List < String > restoreIpAddresses ( String s ) { List < String > ans = new ArrayList <> (); dfs ( s , 0 , new ArrayList <> (), ans ); return ans ; } private void dfs ( final String s , int index , List < String > path , List < String > ans ) { if ( path . size () == 4 && index == s . length ()) { ans . add ( path . get ( 0 ) + '.' + path . get ( 1 ) + '.' + path . get ( 2 ) + '.' + path . get ( 3 )); return ; } if ( path . size () == 4 || index == s . length ()) return ; for ( int i = 1 ; i <= 3 ; ++ i ) { if ( index + i > s . length ()) return ; if ( i > 1 && s . charAt ( index ) == '0' ) return ; String num = s . substring ( index , index + i ); if ( Integer . valueOf ( num ) > 255 ) return ; path . add ( num ); dfs ( s , index + i , path , ans ); path . remove ( path . size () - 1 ); } } } 94. Binary Tree Inorder Traversal $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public List < Integer > inorderTraversal ( TreeNode root ) { List < Integer > ans = new ArrayList <> (); TreeNode curr = root ; while ( curr != null ) { if ( curr . left == null ) { ans . add ( curr . val ); curr = curr . right ; } else { TreeNode prev = curr . left ; while ( prev . right != null ) prev = prev . right ; prev . right = curr ; TreeNode temp = curr ; curr = curr . left ; temp . left = null ; } } return ans ; } } 95. Unique Binary Search Trees II $\\star\\star$ 96. Unique Binary Search Trees $\\star\\star$ Time: $O(n^2)$ Space: $O(n)$ class Solution { public int numTrees ( int n ) { int [] G = new int [ n + 1 ] ; G [ 0 ] = 1 ; G [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) G [ i ] += G [ j ] * G [ i - j - 1 ] ; return G [ n ] ; } } 97. Interleaving String $\\star\\star\\star$ 98. Validate Binary Search Tree $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public boolean isValidBST ( TreeNode root ) { return dfs ( root , null , null ); } private boolean dfs ( TreeNode root , TreeNode minNode , TreeNode maxNode ) { if ( root == null ) return true ; if ( minNode != null && minNode . val >= root . val || maxNode != null && maxNode . val <= root . val ) return false ; return dfs ( root . left , minNode , root ) && dfs ( root . right , root , maxNode ); } } 99. Recover Binary Search Tree $\\star\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public void recoverTree ( TreeNode root ) { inorder ( root ); int temp = x . val ; x . val = y . val ; y . val = temp ; } private TreeNode x = null ; private TreeNode y = null ; private TreeNode pred = null ; private void inorder ( TreeNode root ) { if ( root == null ) return ; inorder ( root . left ); if ( pred != null && pred . val > root . val ) { y = root ; if ( x == null ) x = pred ; else return ; } pred = root ; inorder ( root . right ); } } 100. Same Tree $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public boolean isSameTree ( TreeNode p , TreeNode q ) { if ( p == null || q == null ) return p == q ; return p . val == q . val && isSameTree ( p . left , q . left ) && isSameTree ( p . right , q . right ); } }","title":"0091-0100"},{"location":"java/0001-0100/0091-0100/#91-decode-ways-starstar","text":"","title":"91. Decode Ways $\\star\\star$"},{"location":"java/0001-0100/0091-0100/#92-reverse-linked-list-ii-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public ListNode reverseBetween ( ListNode head , int m , int n ) { if ( head == null ) return null ; ListNode prev = null ; ListNode curr = head ; for ( int i = 0 ; i < m - 1 ; ++ i ) { prev = curr ; curr = curr . next ; } ListNode conn = prev ; ListNode tail = curr ; for ( int i = 0 ; i < n - m + 1 ; ++ i ) { ListNode next = curr . next ; curr . next = prev ; prev = curr ; curr = next ; } if ( conn != null ) conn . next = prev ; else head = prev ; tail . next = curr ; return head ; } }","title":"92. Reverse Linked List II $\\star\\star$"},{"location":"java/0001-0100/0091-0100/#93-restore-ip-addresses-starstar","text":"Time: $O(3^4)$ Space: $O(1)$ class Solution { public List < String > restoreIpAddresses ( String s ) { List < String > ans = new ArrayList <> (); dfs ( s , 0 , new ArrayList <> (), ans ); return ans ; } private void dfs ( final String s , int index , List < String > path , List < String > ans ) { if ( path . size () == 4 && index == s . length ()) { ans . add ( path . get ( 0 ) + '.' + path . get ( 1 ) + '.' + path . get ( 2 ) + '.' + path . get ( 3 )); return ; } if ( path . size () == 4 || index == s . length ()) return ; for ( int i = 1 ; i <= 3 ; ++ i ) { if ( index + i > s . length ()) return ; if ( i > 1 && s . charAt ( index ) == '0' ) return ; String num = s . substring ( index , index + i ); if ( Integer . valueOf ( num ) > 255 ) return ; path . add ( num ); dfs ( s , index + i , path , ans ); path . remove ( path . size () - 1 ); } } }","title":"93. Restore IP Addresses $\\star\\star$"},{"location":"java/0001-0100/0091-0100/#94-binary-tree-inorder-traversal-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public List < Integer > inorderTraversal ( TreeNode root ) { List < Integer > ans = new ArrayList <> (); TreeNode curr = root ; while ( curr != null ) { if ( curr . left == null ) { ans . add ( curr . val ); curr = curr . right ; } else { TreeNode prev = curr . left ; while ( prev . right != null ) prev = prev . right ; prev . right = curr ; TreeNode temp = curr ; curr = curr . left ; temp . left = null ; } } return ans ; } }","title":"94. Binary Tree Inorder Traversal $\\star\\star$"},{"location":"java/0001-0100/0091-0100/#95-unique-binary-search-trees-ii-starstar","text":"","title":"95. Unique Binary Search Trees II $\\star\\star$"},{"location":"java/0001-0100/0091-0100/#96-unique-binary-search-trees-starstar","text":"Time: $O(n^2)$ Space: $O(n)$ class Solution { public int numTrees ( int n ) { int [] G = new int [ n + 1 ] ; G [ 0 ] = 1 ; G [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) G [ i ] += G [ j ] * G [ i - j - 1 ] ; return G [ n ] ; } }","title":"96. Unique Binary Search Trees $\\star\\star$"},{"location":"java/0001-0100/0091-0100/#97-interleaving-string-starstarstar","text":"","title":"97. Interleaving String $\\star\\star\\star$"},{"location":"java/0001-0100/0091-0100/#98-validate-binary-search-tree-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public boolean isValidBST ( TreeNode root ) { return dfs ( root , null , null ); } private boolean dfs ( TreeNode root , TreeNode minNode , TreeNode maxNode ) { if ( root == null ) return true ; if ( minNode != null && minNode . val >= root . val || maxNode != null && maxNode . val <= root . val ) return false ; return dfs ( root . left , minNode , root ) && dfs ( root . right , root , maxNode ); } }","title":"98. Validate Binary Search Tree $\\star\\star$"},{"location":"java/0001-0100/0091-0100/#99-recover-binary-search-tree-starstarstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public void recoverTree ( TreeNode root ) { inorder ( root ); int temp = x . val ; x . val = y . val ; y . val = temp ; } private TreeNode x = null ; private TreeNode y = null ; private TreeNode pred = null ; private void inorder ( TreeNode root ) { if ( root == null ) return ; inorder ( root . left ); if ( pred != null && pred . val > root . val ) { y = root ; if ( x == null ) x = pred ; else return ; } pred = root ; inorder ( root . right ); } }","title":"99. Recover Binary Search Tree $\\star\\star\\star$"},{"location":"java/0001-0100/0091-0100/#100-same-tree-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public boolean isSameTree ( TreeNode p , TreeNode q ) { if ( p == null || q == null ) return p == q ; return p . val == q . val && isSameTree ( p . left , q . left ) && isSameTree ( p . right , q . right ); } }","title":"100. Same Tree $\\star$"},{"location":"java/0101-0200/0101-0110/","text":"101. Symmetric Tree $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public boolean isSymmetric ( TreeNode root ) { return helper ( root , root ); } private boolean helper ( TreeNode p , TreeNode q ) { if ( p == null || q == null ) return p == q ; return p . val == q . val && helper ( p . left , q . right ) && helper ( p . right , q . left ); } } 102. Binary Tree Level Order Traversal $\\star\\star$ 103. Binary Tree Zigzag Level Order Traversal $\\star\\star$ 104. Maximum Depth of Binary Tree $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public int maxDepth ( TreeNode root ) { if ( root == null ) return 0 ; return 1 + Math . max ( maxDepth ( root . left ), maxDepth ( root . right )); } } 105. Construct Binary Tree from Preorder and Inorder Traversal $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public TreeNode buildTree ( int [] preorder , int [] inorder ) { Map < Integer , Integer > inorderToIndex = new HashMap <> (); for ( int i = 0 ; i < inorder . length ; ++ i ) inorderToIndex . put ( inorder [ i ] , i ); return helper ( preorder , 0 , preorder . length - 1 , inorder , 0 , inorder . length - 1 , inorderToIndex ); } private TreeNode helper ( int [] preorder , int pL , int pR , int [] inorder , int iL , int iR , Map < Integer , Integer > inorderToIndex ) { if ( pL > pR ) return null ; int i = inorderToIndex . get ( preorder [ pL ] ); TreeNode curr = new TreeNode ( preorder [ pL ] ); curr . left = helper ( preorder , pL + 1 , pL + i - iL , inorder , iL , i - 1 , inorderToIndex ); curr . right = helper ( preorder , pL + i - iL + 1 , pR , inorder , i + 1 , iR , inorderToIndex ); return curr ; } } 106. Construct Binary Tree from Inorder and Postorder Traversal $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public TreeNode buildTree ( int [] inorder , int [] postorder ) { Map < Integer , Integer > inorderToIndex = new HashMap <> (); for ( int i = 0 ; i < inorder . length ; ++ i ) inorderToIndex . put ( inorder [ i ] , i ); return helper ( inorder , 0 , inorder . length - 1 , postorder , 0 , postorder . length - 1 , inorderToIndex ); } private TreeNode helper ( int [] inorder , int iL , int iR , int [] postorder , int pL , int pR , Map < Integer , Integer > inorderToIndex ) { if ( iL > iR ) return null ; int i = inorderToIndex . get ( postorder [ pR ] ); TreeNode curr = new TreeNode ( postorder [ pR ] ); curr . left = helper ( inorder , iL , i - 1 , postorder , pL , pL + i - iL - 1 , inorderToIndex ); curr . right = helper ( inorder , i + 1 , iR , postorder , pL + i - iL , pR - 1 , inorderToIndex ); return curr ; } } 107. Binary Tree Level Order Traversal II $\\star$ 108. Convert Sorted Array to Binary Search Tree $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public TreeNode sortedArrayToBST ( int [] nums ) { return helper ( nums , 0 , nums . length - 1 ); } private TreeNode helper ( int nums [] , int l , int r ) { if ( l > r ) return null ; int m = l + ( r - l ) / 2 ; TreeNode root = new TreeNode ( nums [ m ] ); root . left = helper ( nums , l , m - 1 ); root . right = helper ( nums , m + 1 , r ); return root ; } } 109. Convert Sorted List to Binary Search Tree $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public TreeNode sortedListToBST ( ListNode head ) { if ( head == null ) return null ; if ( head . next == null ) return new TreeNode ( head . val ); ListNode mid = findMid ( head ); TreeNode root = new TreeNode ( mid . val ); root . left = sortedListToBST ( head ); root . right = sortedListToBST ( mid . next ); return root ; } private ListNode findMid ( ListNode head ) { ListNode prev = null ; ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { prev = slow ; slow = slow . next ; fast = fast . next . next ; } prev . next = null ; return slow ; } } 110. Balanced Binary Tree $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public boolean isBalanced ( TreeNode root ) { if ( root == null ) return true ; return Math . abs ( maxDepth ( root . left ) - maxDepth ( root . right )) <= 1 && isBalanced ( root . left ) && isBalanced ( root . right ); } private int maxDepth ( TreeNode root ) { if ( root == null ) return 0 ; return 1 + Math . max ( maxDepth ( root . left ), maxDepth ( root . right )); } }","title":"0101-0110"},{"location":"java/0101-0200/0101-0110/#101-symmetric-tree-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public boolean isSymmetric ( TreeNode root ) { return helper ( root , root ); } private boolean helper ( TreeNode p , TreeNode q ) { if ( p == null || q == null ) return p == q ; return p . val == q . val && helper ( p . left , q . right ) && helper ( p . right , q . left ); } }","title":"101. Symmetric Tree $\\star$"},{"location":"java/0101-0200/0101-0110/#102-binary-tree-level-order-traversal-starstar","text":"","title":"102. Binary Tree Level Order Traversal $\\star\\star$"},{"location":"java/0101-0200/0101-0110/#103-binary-tree-zigzag-level-order-traversal-starstar","text":"","title":"103. Binary Tree Zigzag Level Order Traversal $\\star\\star$"},{"location":"java/0101-0200/0101-0110/#104-maximum-depth-of-binary-tree-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public int maxDepth ( TreeNode root ) { if ( root == null ) return 0 ; return 1 + Math . max ( maxDepth ( root . left ), maxDepth ( root . right )); } }","title":"104. Maximum Depth of Binary Tree $\\star$"},{"location":"java/0101-0200/0101-0110/#105-construct-binary-tree-from-preorder-and-inorder-traversal-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public TreeNode buildTree ( int [] preorder , int [] inorder ) { Map < Integer , Integer > inorderToIndex = new HashMap <> (); for ( int i = 0 ; i < inorder . length ; ++ i ) inorderToIndex . put ( inorder [ i ] , i ); return helper ( preorder , 0 , preorder . length - 1 , inorder , 0 , inorder . length - 1 , inorderToIndex ); } private TreeNode helper ( int [] preorder , int pL , int pR , int [] inorder , int iL , int iR , Map < Integer , Integer > inorderToIndex ) { if ( pL > pR ) return null ; int i = inorderToIndex . get ( preorder [ pL ] ); TreeNode curr = new TreeNode ( preorder [ pL ] ); curr . left = helper ( preorder , pL + 1 , pL + i - iL , inorder , iL , i - 1 , inorderToIndex ); curr . right = helper ( preorder , pL + i - iL + 1 , pR , inorder , i + 1 , iR , inorderToIndex ); return curr ; } }","title":"105. Construct Binary Tree from Preorder and Inorder Traversal $\\star\\star$"},{"location":"java/0101-0200/0101-0110/#106-construct-binary-tree-from-inorder-and-postorder-traversal-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public TreeNode buildTree ( int [] inorder , int [] postorder ) { Map < Integer , Integer > inorderToIndex = new HashMap <> (); for ( int i = 0 ; i < inorder . length ; ++ i ) inorderToIndex . put ( inorder [ i ] , i ); return helper ( inorder , 0 , inorder . length - 1 , postorder , 0 , postorder . length - 1 , inorderToIndex ); } private TreeNode helper ( int [] inorder , int iL , int iR , int [] postorder , int pL , int pR , Map < Integer , Integer > inorderToIndex ) { if ( iL > iR ) return null ; int i = inorderToIndex . get ( postorder [ pR ] ); TreeNode curr = new TreeNode ( postorder [ pR ] ); curr . left = helper ( inorder , iL , i - 1 , postorder , pL , pL + i - iL - 1 , inorderToIndex ); curr . right = helper ( inorder , i + 1 , iR , postorder , pL + i - iL , pR - 1 , inorderToIndex ); return curr ; } }","title":"106. Construct Binary Tree from Inorder and Postorder Traversal $\\star\\star$"},{"location":"java/0101-0200/0101-0110/#107-binary-tree-level-order-traversal-ii-star","text":"","title":"107. Binary Tree Level Order Traversal II $\\star$"},{"location":"java/0101-0200/0101-0110/#108-convert-sorted-array-to-binary-search-tree-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public TreeNode sortedArrayToBST ( int [] nums ) { return helper ( nums , 0 , nums . length - 1 ); } private TreeNode helper ( int nums [] , int l , int r ) { if ( l > r ) return null ; int m = l + ( r - l ) / 2 ; TreeNode root = new TreeNode ( nums [ m ] ); root . left = helper ( nums , l , m - 1 ); root . right = helper ( nums , m + 1 , r ); return root ; } }","title":"108. Convert Sorted Array to Binary Search Tree $\\star$"},{"location":"java/0101-0200/0101-0110/#109-convert-sorted-list-to-binary-search-tree-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public TreeNode sortedListToBST ( ListNode head ) { if ( head == null ) return null ; if ( head . next == null ) return new TreeNode ( head . val ); ListNode mid = findMid ( head ); TreeNode root = new TreeNode ( mid . val ); root . left = sortedListToBST ( head ); root . right = sortedListToBST ( mid . next ); return root ; } private ListNode findMid ( ListNode head ) { ListNode prev = null ; ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { prev = slow ; slow = slow . next ; fast = fast . next . next ; } prev . next = null ; return slow ; } }","title":"109. Convert Sorted List to Binary Search Tree $\\star\\star$"},{"location":"java/0101-0200/0101-0110/#110-balanced-binary-tree-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public boolean isBalanced ( TreeNode root ) { if ( root == null ) return true ; return Math . abs ( maxDepth ( root . left ) - maxDepth ( root . right )) <= 1 && isBalanced ( root . left ) && isBalanced ( root . right ); } private int maxDepth ( TreeNode root ) { if ( root == null ) return 0 ; return 1 + Math . max ( maxDepth ( root . left ), maxDepth ( root . right )); } }","title":"110. Balanced Binary Tree $\\star$"},{"location":"java/0101-0200/0111-0120/","text":"111. Minimum Depth of Binary Tree $\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public int minDepth ( TreeNode root ) { if ( root == null ) return 0 ; int ans = 0 ; Queue < TreeNode > queue = new LinkedList <> (); queue . add ( root ); while ( ! queue . isEmpty ()) { ++ ans ; for ( int i = queue . size (); i > 0 ; -- i ) { TreeNode node = queue . poll (); if ( node . left == null && node . right == null ) return ans ; if ( node . left != null ) queue . add ( node . left ); if ( node . right != null ) queue . add ( node . right ); } } throw new IllegalArgumentException (); } } 112. Path Sum $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public boolean hasPathSum ( TreeNode root , int sum ) { if ( root == null ) return false ; if ( root . val == sum && root . left == null && root . right == null ) return true ; return hasPathSum ( root . left , sum - root . val ) || hasPathSum ( root . right , sum - root . val ); } } 113. Path Sum II $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public List < List < Integer >> pathSum ( TreeNode root , int sum ) { List < List < Integer >> ans = new ArrayList <> (); dfs ( root , sum , new ArrayList <> (), ans ); return ans ; } private void dfs ( TreeNode root , int sum , List < Integer > path , List < List < Integer >> ans ) { if ( root == null ) return ; if ( root . val == sum && root . left == null && root . right == null ) { path . add ( root . val ); ans . add ( new ArrayList <> ( path )); path . remove ( path . size () - 1 ); return ; } path . add ( root . val ); dfs ( root . left , sum - root . val , path , ans ); dfs ( root . right , sum - root . val , path , ans ); path . remove ( path . size () - 1 ); } } 114. Flatten Binary Tree to Linked List $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public void flatten ( TreeNode root ) { if ( root == null ) return ; flatten ( root . right ); flatten ( root . left ); root . right = prev ; root . left = null ; prev = root ; } private TreeNode prev = null ; } 115. Distinct Subsequences $\\star\\star\\star$ 116. Populating Next Right Pointers in Each Node $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public Node connect ( Node root ) { Node node = root ; while ( node != null && node . left != null ) { Node cached = node . left ; while ( node != null ) { node . left . next = node . right ; node . right . next = node . next == null ? null : node . next . left ; node = node . next ; } node = cached ; } return root ; } } 117. Populating Next Right Pointers in Each Node II $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public Node connect ( Node root ) { Node node = root ; Node cached = new Node ( 0 ); while ( node != null ) { Node curr = cached ; while ( node != null ) { if ( node . left != null ) { curr . next = node . left ; curr = curr . next ; } if ( node . right != null ) { curr . next = node . right ; curr = curr . next ; } node = node . next ; } node = cached . next ; cached . next = null ; } return root ; } } 118. Pascal's Triangle $\\star$ Time: $O(n^2)$ Space: $O(n^2)$ class Solution { public List < List < Integer >> generate ( int numRows ) { List < List < Integer >> ans = new ArrayList <> (); for ( int i = 0 ; i < numRows ; ++ i ) { Integer [] temp = new Integer [ i + 1 ] ; Arrays . fill ( temp , 1 ); ans . add ( Arrays . asList ( temp )); } for ( int i = 2 ; i < numRows ; ++ i ) for ( int j = 1 ; j < ans . get ( i ). size () - 1 ; ++ j ) ans . get ( i ). set ( j , ans . get ( i - 1 ). get ( j - 1 ) + ans . get ( i - 1 ). get ( j )); return ans ; } } 119. Pascal's Triangle II $\\star$ Time: $O(k^2)$ Space: $O(k)$ class Solution { public List < Integer > getRow ( int rowIndex ) { Integer [] ans = new Integer [ rowIndex + 1 ] ; Arrays . fill ( ans , 1 ); for ( int i = 2 ; i < rowIndex + 1 ; ++ i ) for ( int j = 1 ; j < i ; ++ j ) ans [ i - j ] += ans [ i - j - 1 ] ; return Arrays . asList ( ans ); } } 120. Triangle $\\star\\star$ Time: $O(n^2)$ Space: $O(1)$ class Solution { public int minimumTotal ( List < List < Integer >> triangle ) { for ( int i = triangle . size () - 2 ; i >= 0 ; -- i ) for ( int j = 0 ; j <= i ; ++ j ) triangle . get ( i ). set ( j , triangle . get ( i ). get ( j ) + Math . min ( triangle . get ( i + 1 ). get ( j ), triangle . get ( i + 1 ). get ( j + 1 ))); return triangle . get ( 0 ). get ( 0 ); } }","title":"0111-0120"},{"location":"java/0101-0200/0111-0120/#111-minimum-depth-of-binary-tree-star","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public int minDepth ( TreeNode root ) { if ( root == null ) return 0 ; int ans = 0 ; Queue < TreeNode > queue = new LinkedList <> (); queue . add ( root ); while ( ! queue . isEmpty ()) { ++ ans ; for ( int i = queue . size (); i > 0 ; -- i ) { TreeNode node = queue . poll (); if ( node . left == null && node . right == null ) return ans ; if ( node . left != null ) queue . add ( node . left ); if ( node . right != null ) queue . add ( node . right ); } } throw new IllegalArgumentException (); } }","title":"111. Minimum Depth of Binary Tree $\\star$"},{"location":"java/0101-0200/0111-0120/#112-path-sum-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public boolean hasPathSum ( TreeNode root , int sum ) { if ( root == null ) return false ; if ( root . val == sum && root . left == null && root . right == null ) return true ; return hasPathSum ( root . left , sum - root . val ) || hasPathSum ( root . right , sum - root . val ); } }","title":"112. Path Sum $\\star$"},{"location":"java/0101-0200/0111-0120/#113-path-sum-ii-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public List < List < Integer >> pathSum ( TreeNode root , int sum ) { List < List < Integer >> ans = new ArrayList <> (); dfs ( root , sum , new ArrayList <> (), ans ); return ans ; } private void dfs ( TreeNode root , int sum , List < Integer > path , List < List < Integer >> ans ) { if ( root == null ) return ; if ( root . val == sum && root . left == null && root . right == null ) { path . add ( root . val ); ans . add ( new ArrayList <> ( path )); path . remove ( path . size () - 1 ); return ; } path . add ( root . val ); dfs ( root . left , sum - root . val , path , ans ); dfs ( root . right , sum - root . val , path , ans ); path . remove ( path . size () - 1 ); } }","title":"113. Path Sum II $\\star\\star$"},{"location":"java/0101-0200/0111-0120/#114-flatten-binary-tree-to-linked-list-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public void flatten ( TreeNode root ) { if ( root == null ) return ; flatten ( root . right ); flatten ( root . left ); root . right = prev ; root . left = null ; prev = root ; } private TreeNode prev = null ; }","title":"114. Flatten Binary Tree to Linked List $\\star\\star$"},{"location":"java/0101-0200/0111-0120/#115-distinct-subsequences-starstarstar","text":"","title":"115. Distinct Subsequences $\\star\\star\\star$"},{"location":"java/0101-0200/0111-0120/#116-populating-next-right-pointers-in-each-node-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public Node connect ( Node root ) { Node node = root ; while ( node != null && node . left != null ) { Node cached = node . left ; while ( node != null ) { node . left . next = node . right ; node . right . next = node . next == null ? null : node . next . left ; node = node . next ; } node = cached ; } return root ; } }","title":"116. Populating Next Right Pointers in Each Node $\\star\\star$"},{"location":"java/0101-0200/0111-0120/#117-populating-next-right-pointers-in-each-node-ii-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public Node connect ( Node root ) { Node node = root ; Node cached = new Node ( 0 ); while ( node != null ) { Node curr = cached ; while ( node != null ) { if ( node . left != null ) { curr . next = node . left ; curr = curr . next ; } if ( node . right != null ) { curr . next = node . right ; curr = curr . next ; } node = node . next ; } node = cached . next ; cached . next = null ; } return root ; } }","title":"117. Populating Next Right Pointers in Each Node II $\\star\\star$"},{"location":"java/0101-0200/0111-0120/#118-pascals-triangle-star","text":"Time: $O(n^2)$ Space: $O(n^2)$ class Solution { public List < List < Integer >> generate ( int numRows ) { List < List < Integer >> ans = new ArrayList <> (); for ( int i = 0 ; i < numRows ; ++ i ) { Integer [] temp = new Integer [ i + 1 ] ; Arrays . fill ( temp , 1 ); ans . add ( Arrays . asList ( temp )); } for ( int i = 2 ; i < numRows ; ++ i ) for ( int j = 1 ; j < ans . get ( i ). size () - 1 ; ++ j ) ans . get ( i ). set ( j , ans . get ( i - 1 ). get ( j - 1 ) + ans . get ( i - 1 ). get ( j )); return ans ; } }","title":"118. Pascal's Triangle $\\star$"},{"location":"java/0101-0200/0111-0120/#119-pascals-triangle-ii-star","text":"Time: $O(k^2)$ Space: $O(k)$ class Solution { public List < Integer > getRow ( int rowIndex ) { Integer [] ans = new Integer [ rowIndex + 1 ] ; Arrays . fill ( ans , 1 ); for ( int i = 2 ; i < rowIndex + 1 ; ++ i ) for ( int j = 1 ; j < i ; ++ j ) ans [ i - j ] += ans [ i - j - 1 ] ; return Arrays . asList ( ans ); } }","title":"119. Pascal's Triangle II $\\star$"},{"location":"java/0101-0200/0111-0120/#120-triangle-starstar","text":"Time: $O(n^2)$ Space: $O(1)$ class Solution { public int minimumTotal ( List < List < Integer >> triangle ) { for ( int i = triangle . size () - 2 ; i >= 0 ; -- i ) for ( int j = 0 ; j <= i ; ++ j ) triangle . get ( i ). set ( j , triangle . get ( i ). get ( j ) + Math . min ( triangle . get ( i + 1 ). get ( j ), triangle . get ( i + 1 ). get ( j + 1 ))); return triangle . get ( 0 ). get ( 0 ); } }","title":"120. Triangle $\\star\\star$"},{"location":"java/0101-0200/0121-0130/","text":"121. Best Time to Buy and Sell Stock $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public int maxProfit ( int [] prices ) { int sellOne = 0 ; int holdOne = Integer . MIN_VALUE ; for ( int price : prices ) { sellOne = Math . max ( sellOne , holdOne + price ); holdOne = Math . max ( holdOne , - price ); } return sellOne ; } } 122. Best Time to Buy and Sell Stock II $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public int maxProfit ( int [] prices ) { int sell = 0 ; int hold = Integer . MIN_VALUE ; for ( int price : prices ) { sell = Math . max ( sell , hold + price ); hold = Math . max ( hold , sell - price ); } return sell ; } } 123. Best Time to Buy and Sell Stock III $\\star\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public int maxProfit ( int [] prices ) { int sellTwo = 0 ; int holdTwo = Integer . MIN_VALUE ; int sellOne = 0 ; int holdOne = Integer . MIN_VALUE ; for ( int price : prices ) { sellTwo = Math . max ( sellTwo , holdTwo + price ); holdTwo = Math . max ( holdTwo , sellOne - price ); sellOne = Math . max ( sellOne , holdOne + price ); holdOne = Math . max ( holdOne , - price ); } return sellTwo ; } } 124. Binary Tree Maximum Path Sum $\\star\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public int maxPathSum ( TreeNode root ) { maxPathSumDownFrom ( root ); return ans ; } private int ans = Integer . MIN_VALUE ; private int maxPathSumDownFrom ( TreeNode root ) { if ( root == null ) return 0 ; int left = Math . max ( maxPathSumDownFrom ( root . left ), 0 ); int right = Math . max ( maxPathSumDownFrom ( root . right ), 0 ); ans = Math . max ( ans , root . val + left + right ); return root . val + Math . max ( left , right ); } } 125. Valid Palindrome $\\star$ 126. Word Ladder II $\\star\\star\\star$ Time: $O(n26^l)$, where n = len(wordList) and l = len(word) Space: $O(n + kl)$, where k = #paths class Solution { public List < List < String >> findLadders ( String beginWord , String endWord , List < String > wordList ) { List < List < String >> ans = new ArrayList <> (); Set < String > set = new HashSet <> ( wordList ); if ( ! set . contains ( endWord )) return ans ; Set < String > set1 = new HashSet <> ( Arrays . asList ( beginWord )); Map < String , List < String >> map = new HashMap <> (); boolean isFound = false ; while ( ! set1 . isEmpty () && ! isFound ) { for ( String word : set1 ) set . remove ( word ); Set < String > tempSet = new HashSet <> (); for ( String parent : set1 ) { char [] word = parent . toCharArray (); for ( int i = 0 ; i < word . length ; ++ i ) { char c = word [ i ] ; for ( char j = 'a' ; j <= 'z' ; ++ j ) { word [ i ] = j ; String newWord = String . valueOf ( word ); if ( newWord . equals ( endWord )) { if ( ! map . containsKey ( parent )) map . put ( parent , new ArrayList <> ()); map . get ( parent ). add ( newWord ); isFound = true ; } else if ( set . contains ( newWord ) && ! isFound ) { tempSet . add ( newWord ); if ( ! map . containsKey ( parent )) map . put ( parent , new ArrayList <> ()); map . get ( parent ). add ( newWord ); } } word [ i ] = c ; } } set1 = tempSet ; } if ( isFound ) { List < String > path = new ArrayList <> ( Arrays . asList ( beginWord )); dfs ( map , beginWord , endWord , path , ans ); } return ans ; } private void dfs ( Map < String , List < String >> map , String word , String endWord , List < String > path , List < List < String >> ans ) { if ( word . equals ( endWord )) { ans . add ( new ArrayList <> ( path )); return ; } if ( ! map . containsKey ( word )) return ; for ( String child : map . get ( word )) { path . add ( child ); dfs ( map , child , endWord , path , ans ); path . remove ( path . size () - 1 ); } } } 127. Word Ladder $\\star\\star$ Time: $O(n26^l)$, where n = len(wordList) and l = len(word) Space: $O(n)$ class Solution { public int ladderLength ( String beginWord , String endWord , List < String > wordList ) { Set < String > set = new HashSet <> ( wordList ); if ( ! set . contains ( endWord )) return 0 ; int ans = 0 ; Set < String > set1 = new HashSet <> ( Arrays . asList ( beginWord )); Set < String > set2 = new HashSet <> ( Arrays . asList ( endWord )); while ( ! set1 . isEmpty () && ! set2 . isEmpty ()) { ++ ans ; if ( set1 . size () > set2 . size ()) swap ( set1 , set2 ); Set < String > tempSet = new HashSet <> (); for ( String word : set1 ) { char [] charArray = word . toCharArray (); for ( int i = 0 ; i < word . length (); ++ i ) { char c = charArray [ i ] ; for ( char j = 'a' ; j <= 'z' ; ++ j ) { charArray [ i ] = j ; String newWord = String . valueOf ( charArray ); if ( set2 . contains ( newWord )) return ans + 1 ; if ( ! set . contains ( newWord )) continue ; set . remove ( newWord ); tempSet . add ( newWord ); } charArray [ i ] = c ; } } set1 = tempSet ; } return 0 ; } private void swap ( Set s1 , Set s2 ) { Set temp = s1 ; s1 = s2 ; s2 = temp ; } } 128. Longest Consecutive Sequence $\\star\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public int longestConsecutive ( int [] nums ) { int ans = 0 ; Set < Integer > set = new HashSet <> (); for ( int num : nums ) set . add ( num ); for ( int num : nums ) if ( ! set . contains ( num - 1 )) { int length = 0 ; while ( set . contains ( num ++ )) ++ length ; ans = Math . max ( ans , length ); } return ans ; } } 129. Sum Root to Leaf Numbers $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public int sumNumbers ( TreeNode root ) { dfs ( root , 0 ); return ans ; } private int ans = 0 ; private void dfs ( TreeNode root , int path ) { if ( root == null ) return ; if ( root . left == null && root . right == null ) { ans += path * 10 + root . val ; return ; } dfs ( root . left , path * 10 + root . val ); dfs ( root . right , path * 10 + root . val ); } } 130. Surrounded Regions $\\star\\star$ Time: $O(mn)$ Space: $O(1)$ class Solution { public void solve ( char [][] board ) { if ( board . length == 0 ) return ; final int m = board . length ; final int n = board [ 0 ] . length ; for ( int i = 0 ; i < m ; ++ i ) { dfs ( board , i , 0 ); dfs ( board , i , n - 1 ); } for ( int j = 1 ; j < n - 1 ; ++ j ) { dfs ( board , 0 , j ); dfs ( board , m - 1 , j ); } for ( char [] row : board ) for ( int i = 0 ; i < row . length ; ++ i ) row [ i ] = row [ i ] == '.' ? 'O' : 'X' ; } private void dfs ( char [][] board , int i , int j ) { if ( i < 0 || i >= board . length || j < 0 || j >= board [ 0 ] . length || board [ i ][ j ] != 'O' ) return ; board [ i ][ j ] = '.' ; dfs ( board , i + 1 , j ); dfs ( board , i - 1 , j ); dfs ( board , i , j + 1 ); dfs ( board , i , j - 1 ); } }","title":"0121-0130"},{"location":"java/0101-0200/0121-0130/#121-best-time-to-buy-and-sell-stock-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public int maxProfit ( int [] prices ) { int sellOne = 0 ; int holdOne = Integer . MIN_VALUE ; for ( int price : prices ) { sellOne = Math . max ( sellOne , holdOne + price ); holdOne = Math . max ( holdOne , - price ); } return sellOne ; } }","title":"121. Best Time to Buy and Sell Stock $\\star$"},{"location":"java/0101-0200/0121-0130/#122-best-time-to-buy-and-sell-stock-ii-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public int maxProfit ( int [] prices ) { int sell = 0 ; int hold = Integer . MIN_VALUE ; for ( int price : prices ) { sell = Math . max ( sell , hold + price ); hold = Math . max ( hold , sell - price ); } return sell ; } }","title":"122. Best Time to Buy and Sell Stock II $\\star$"},{"location":"java/0101-0200/0121-0130/#123-best-time-to-buy-and-sell-stock-iii-starstarstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public int maxProfit ( int [] prices ) { int sellTwo = 0 ; int holdTwo = Integer . MIN_VALUE ; int sellOne = 0 ; int holdOne = Integer . MIN_VALUE ; for ( int price : prices ) { sellTwo = Math . max ( sellTwo , holdTwo + price ); holdTwo = Math . max ( holdTwo , sellOne - price ); sellOne = Math . max ( sellOne , holdOne + price ); holdOne = Math . max ( holdOne , - price ); } return sellTwo ; } }","title":"123. Best Time to Buy and Sell Stock III $\\star\\star\\star$"},{"location":"java/0101-0200/0121-0130/#124-binary-tree-maximum-path-sum-starstarstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public int maxPathSum ( TreeNode root ) { maxPathSumDownFrom ( root ); return ans ; } private int ans = Integer . MIN_VALUE ; private int maxPathSumDownFrom ( TreeNode root ) { if ( root == null ) return 0 ; int left = Math . max ( maxPathSumDownFrom ( root . left ), 0 ); int right = Math . max ( maxPathSumDownFrom ( root . right ), 0 ); ans = Math . max ( ans , root . val + left + right ); return root . val + Math . max ( left , right ); } }","title":"124. Binary Tree Maximum Path Sum $\\star\\star\\star$"},{"location":"java/0101-0200/0121-0130/#125-valid-palindrome-star","text":"","title":"125. Valid Palindrome $\\star$"},{"location":"java/0101-0200/0121-0130/#126-word-ladder-ii-starstarstar","text":"Time: $O(n26^l)$, where n = len(wordList) and l = len(word) Space: $O(n + kl)$, where k = #paths class Solution { public List < List < String >> findLadders ( String beginWord , String endWord , List < String > wordList ) { List < List < String >> ans = new ArrayList <> (); Set < String > set = new HashSet <> ( wordList ); if ( ! set . contains ( endWord )) return ans ; Set < String > set1 = new HashSet <> ( Arrays . asList ( beginWord )); Map < String , List < String >> map = new HashMap <> (); boolean isFound = false ; while ( ! set1 . isEmpty () && ! isFound ) { for ( String word : set1 ) set . remove ( word ); Set < String > tempSet = new HashSet <> (); for ( String parent : set1 ) { char [] word = parent . toCharArray (); for ( int i = 0 ; i < word . length ; ++ i ) { char c = word [ i ] ; for ( char j = 'a' ; j <= 'z' ; ++ j ) { word [ i ] = j ; String newWord = String . valueOf ( word ); if ( newWord . equals ( endWord )) { if ( ! map . containsKey ( parent )) map . put ( parent , new ArrayList <> ()); map . get ( parent ). add ( newWord ); isFound = true ; } else if ( set . contains ( newWord ) && ! isFound ) { tempSet . add ( newWord ); if ( ! map . containsKey ( parent )) map . put ( parent , new ArrayList <> ()); map . get ( parent ). add ( newWord ); } } word [ i ] = c ; } } set1 = tempSet ; } if ( isFound ) { List < String > path = new ArrayList <> ( Arrays . asList ( beginWord )); dfs ( map , beginWord , endWord , path , ans ); } return ans ; } private void dfs ( Map < String , List < String >> map , String word , String endWord , List < String > path , List < List < String >> ans ) { if ( word . equals ( endWord )) { ans . add ( new ArrayList <> ( path )); return ; } if ( ! map . containsKey ( word )) return ; for ( String child : map . get ( word )) { path . add ( child ); dfs ( map , child , endWord , path , ans ); path . remove ( path . size () - 1 ); } } }","title":"126. Word Ladder II $\\star\\star\\star$"},{"location":"java/0101-0200/0121-0130/#127-word-ladder-starstar","text":"Time: $O(n26^l)$, where n = len(wordList) and l = len(word) Space: $O(n)$ class Solution { public int ladderLength ( String beginWord , String endWord , List < String > wordList ) { Set < String > set = new HashSet <> ( wordList ); if ( ! set . contains ( endWord )) return 0 ; int ans = 0 ; Set < String > set1 = new HashSet <> ( Arrays . asList ( beginWord )); Set < String > set2 = new HashSet <> ( Arrays . asList ( endWord )); while ( ! set1 . isEmpty () && ! set2 . isEmpty ()) { ++ ans ; if ( set1 . size () > set2 . size ()) swap ( set1 , set2 ); Set < String > tempSet = new HashSet <> (); for ( String word : set1 ) { char [] charArray = word . toCharArray (); for ( int i = 0 ; i < word . length (); ++ i ) { char c = charArray [ i ] ; for ( char j = 'a' ; j <= 'z' ; ++ j ) { charArray [ i ] = j ; String newWord = String . valueOf ( charArray ); if ( set2 . contains ( newWord )) return ans + 1 ; if ( ! set . contains ( newWord )) continue ; set . remove ( newWord ); tempSet . add ( newWord ); } charArray [ i ] = c ; } } set1 = tempSet ; } return 0 ; } private void swap ( Set s1 , Set s2 ) { Set temp = s1 ; s1 = s2 ; s2 = temp ; } }","title":"127. Word Ladder $\\star\\star$"},{"location":"java/0101-0200/0121-0130/#128-longest-consecutive-sequence-starstarstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public int longestConsecutive ( int [] nums ) { int ans = 0 ; Set < Integer > set = new HashSet <> (); for ( int num : nums ) set . add ( num ); for ( int num : nums ) if ( ! set . contains ( num - 1 )) { int length = 0 ; while ( set . contains ( num ++ )) ++ length ; ans = Math . max ( ans , length ); } return ans ; } }","title":"128. Longest Consecutive Sequence $\\star\\star\\star$"},{"location":"java/0101-0200/0121-0130/#129-sum-root-to-leaf-numbers-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public int sumNumbers ( TreeNode root ) { dfs ( root , 0 ); return ans ; } private int ans = 0 ; private void dfs ( TreeNode root , int path ) { if ( root == null ) return ; if ( root . left == null && root . right == null ) { ans += path * 10 + root . val ; return ; } dfs ( root . left , path * 10 + root . val ); dfs ( root . right , path * 10 + root . val ); } }","title":"129. Sum Root to Leaf Numbers $\\star\\star$"},{"location":"java/0101-0200/0121-0130/#130-surrounded-regions-starstar","text":"Time: $O(mn)$ Space: $O(1)$ class Solution { public void solve ( char [][] board ) { if ( board . length == 0 ) return ; final int m = board . length ; final int n = board [ 0 ] . length ; for ( int i = 0 ; i < m ; ++ i ) { dfs ( board , i , 0 ); dfs ( board , i , n - 1 ); } for ( int j = 1 ; j < n - 1 ; ++ j ) { dfs ( board , 0 , j ); dfs ( board , m - 1 , j ); } for ( char [] row : board ) for ( int i = 0 ; i < row . length ; ++ i ) row [ i ] = row [ i ] == '.' ? 'O' : 'X' ; } private void dfs ( char [][] board , int i , int j ) { if ( i < 0 || i >= board . length || j < 0 || j >= board [ 0 ] . length || board [ i ][ j ] != 'O' ) return ; board [ i ][ j ] = '.' ; dfs ( board , i + 1 , j ); dfs ( board , i - 1 , j ); dfs ( board , i , j + 1 ); dfs ( board , i , j - 1 ); } }","title":"130. Surrounded Regions $\\star\\star$"},{"location":"java/0101-0200/0131-0140/","text":"131. Palindrome Partitioning $\\star\\star$ 132. Palindrome Partitioning II $\\star\\star\\star$ 133. Clone Graph $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public Node cloneGraph ( Node node ) { if ( node == null ) return null ; if ( map . containsKey ( node )) return map . get ( node ); map . put ( node , new Node ( node . val )); for ( Node neighbor : node . neighbors ) map . get ( node ). neighbors . add ( cloneGraph ( neighbor )); return map . get ( node ); } private Map < Node , Node > map = new HashMap <> (); } 134. Gas Station $\\star\\star$ 135. Candy $\\star\\star\\star$ 136. Single Number $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public int singleNumber ( int [] nums ) { int ans = 0 ; for ( int num : nums ) ans ^= num ; return ans ; } } 137. Single Number II $\\star\\star$ 138. Copy List with Random Pointer $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public Node copyRandomList ( Node head ) { if ( head == null ) return null ; if ( map . containsKey ( head )) return map . get ( head ); map . put ( head , new Node ( head . val )); map . get ( head ). next = copyRandomList ( head . next ); map . get ( head ). random = copyRandomList ( head . random ); return map . get ( head ); } private Map < Node , Node > map = new HashMap <> (); } 139. Word Break $\\star\\star$ Time: $O(n^2)$ Space: $O(n)$ class Solution { public boolean wordBreak ( String s , List < String > wordDict ) { Set < String > wordSet = new HashSet <> ( wordDict ); return wordBreak ( s , wordSet ); } private Map < String , Boolean > memo = new HashMap <> (); private boolean wordBreak ( final String s , Set < String > wordSet ) { if ( memo . containsKey ( s )) return memo . get ( s ); if ( wordSet . contains ( s )) { memo . put ( s , true ); return true ; } for ( int i = 1 ; i < s . length (); ++ i ) { String prefix = s . substring ( 0 , i ); String suffix = s . substring ( i ); if ( wordSet . contains ( prefix ) && wordBreak ( suffix , wordSet )) { memo . put ( s , true ); return true ; } } memo . put ( s , false ); return false ; } } 140. Word Break II $\\star\\star\\star$","title":"0131-0140"},{"location":"java/0101-0200/0131-0140/#131-palindrome-partitioning-starstar","text":"","title":"131. Palindrome Partitioning $\\star\\star$"},{"location":"java/0101-0200/0131-0140/#132-palindrome-partitioning-ii-starstarstar","text":"","title":"132. Palindrome Partitioning II $\\star\\star\\star$"},{"location":"java/0101-0200/0131-0140/#133-clone-graph-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public Node cloneGraph ( Node node ) { if ( node == null ) return null ; if ( map . containsKey ( node )) return map . get ( node ); map . put ( node , new Node ( node . val )); for ( Node neighbor : node . neighbors ) map . get ( node ). neighbors . add ( cloneGraph ( neighbor )); return map . get ( node ); } private Map < Node , Node > map = new HashMap <> (); }","title":"133. Clone Graph $\\star\\star$"},{"location":"java/0101-0200/0131-0140/#134-gas-station-starstar","text":"","title":"134. Gas Station $\\star\\star$"},{"location":"java/0101-0200/0131-0140/#135-candy-starstarstar","text":"","title":"135. Candy $\\star\\star\\star$"},{"location":"java/0101-0200/0131-0140/#136-single-number-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public int singleNumber ( int [] nums ) { int ans = 0 ; for ( int num : nums ) ans ^= num ; return ans ; } }","title":"136. Single Number $\\star$"},{"location":"java/0101-0200/0131-0140/#137-single-number-ii-starstar","text":"","title":"137. Single Number II $\\star\\star$"},{"location":"java/0101-0200/0131-0140/#138-copy-list-with-random-pointer-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public Node copyRandomList ( Node head ) { if ( head == null ) return null ; if ( map . containsKey ( head )) return map . get ( head ); map . put ( head , new Node ( head . val )); map . get ( head ). next = copyRandomList ( head . next ); map . get ( head ). random = copyRandomList ( head . random ); return map . get ( head ); } private Map < Node , Node > map = new HashMap <> (); }","title":"138. Copy List with Random Pointer $\\star\\star$"},{"location":"java/0101-0200/0131-0140/#139-word-break-starstar","text":"Time: $O(n^2)$ Space: $O(n)$ class Solution { public boolean wordBreak ( String s , List < String > wordDict ) { Set < String > wordSet = new HashSet <> ( wordDict ); return wordBreak ( s , wordSet ); } private Map < String , Boolean > memo = new HashMap <> (); private boolean wordBreak ( final String s , Set < String > wordSet ) { if ( memo . containsKey ( s )) return memo . get ( s ); if ( wordSet . contains ( s )) { memo . put ( s , true ); return true ; } for ( int i = 1 ; i < s . length (); ++ i ) { String prefix = s . substring ( 0 , i ); String suffix = s . substring ( i ); if ( wordSet . contains ( prefix ) && wordBreak ( suffix , wordSet )) { memo . put ( s , true ); return true ; } } memo . put ( s , false ); return false ; } }","title":"139. Word Break $\\star\\star$"},{"location":"java/0101-0200/0131-0140/#140-word-break-ii-starstarstar","text":"","title":"140. Word Break II $\\star\\star\\star$"},{"location":"java/0101-0200/0141-0150/","text":"141. Linked List Cycle $\\star$ Time: $O(n)$ Space: $O(1)$ public class Solution { public boolean hasCycle ( ListNode head ) { ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; if ( slow == fast ) return true ; } return false ; } } 142. Linked List Cycle II $\\star\\star$ Time: $O(n)$ Space: $O(1)$ public class Solution { public ListNode detectCycle ( ListNode head ) { ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; if ( slow == fast ) { slow = head ; while ( slow != fast ) { slow = slow . next ; fast = fast . next ; } return slow ; } } return null ; } } 143. Reorder List $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public void reorderList ( ListNode head ) { if ( head == null || head . next == null ) return ; ListNode mid = findMid ( head ); ListNode reversed = reverse ( mid ); merge ( head , reversed ); } private ListNode findMid ( ListNode head ) { ListNode prev = null ; ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { prev = slow ; slow = slow . next ; fast = fast . next . next ; } prev . next = null ; return slow ; } private ListNode reverse ( ListNode head ) { ListNode prev = null ; ListNode curr = head ; while ( curr != null ) { ListNode next = curr . next ; curr . next = prev ; prev = curr ; curr = next ; } return prev ; } private void merge ( ListNode l1 , ListNode l2 ) { while ( l2 != null ) { ListNode next = l1 . next ; l1 . next = l2 ; l1 = l2 ; l2 = next ; } } } 144. Binary Tree Preorder Traversal $\\star\\star$ 145. Binary Tree Postorder Traversal $\\star\\star\\star$ 146. LRU Cache $\\star\\star$ Time: $O(1)$ Space: $O(capacity)$ class LRUCache { public LRUCache ( int capacity ) { this . capacity = capacity ; join ( head , tail ); } public int get ( int key ) { if ( ! map . containsKey ( key )) return - 1 ; Node node = map . get ( key ); remove ( node ); moveToHead ( node ); return node . value ; } public void put ( int key , int value ) { if ( map . containsKey ( key )) { Node node = map . get ( key ); node . value = value ; remove ( node ); moveToHead ( node ); return ; } if ( map . size () == capacity ) { Node lastNode = tail . prev ; map . remove ( lastNode . key ); remove ( lastNode ); } moveToHead ( new Node ( key , value )); map . put ( key , head . next ); } private void join ( Node node1 , Node node2 ) { node1 . next = node2 ; node2 . prev = node1 ; } private void remove ( Node node ) { join ( node . prev , node . next ); } private void moveToHead ( Node node ) { join ( node , head . next ); join ( head , node ); } private int capacity ; private Map < Integer , Node > map = new HashMap <> (); private Node head = new Node ( - 1 , - 1 ); private Node tail = new Node ( - 1 , - 1 ); private class Node { Node prev ; Node next ; int key ; int value ; public Node ( int key , int value ) { this . key = key ; this . value = value ; } } } 147. Insertion Sort List $\\star\\star$ Time: $O(n^2)$ Space: $O(1)$ class Solution { public ListNode insertionSortList ( ListNode head ) { ListNode dummy = new ListNode ( 0 ); ListNode curr = head ; while ( curr != null ) { ListNode prev = dummy ; while ( prev . next != null && prev . next . val < curr . val ) prev = prev . next ; ListNode next = curr . next ; curr . next = prev . next ; prev . next = curr ; curr = next ; } return dummy . next ; } } 148. Sort List $\\star\\star$ Time: $O(n\\log n)$ Space: $O(1)$ class Solution { public ListNode sortList ( ListNode head ) { int length = 0 ; for ( ListNode curr = head ; curr != null ; curr = curr . next ) ++ length ; ListNode dummy = new ListNode ( 0 ); dummy . next = head ; for ( int k = 1 ; k < length ; k *= 2 ) { ListNode curr = dummy . next ; ListNode tail = dummy ; while ( curr != null ) { ListNode l = curr ; ListNode r = split ( l , k ); curr = split ( r , k ); ListNode [] merged = merge ( l , r ); tail . next = merged [ 0 ] ; tail = merged [ 1 ] ; } } return dummy . next ; } private ListNode split ( ListNode head , int k ) { while ( -- k > 0 && head != null ) head = head . next ; ListNode rest = head == null ? null : head . next ; if ( head != null ) head . next = null ; return rest ; } private ListNode [] merge ( ListNode l1 , ListNode l2 ) { ListNode dummy = new ListNode ( 0 ); ListNode tail = dummy ; while ( l1 != null && l2 != null ) { if ( l1 . val > l2 . val ) { ListNode temp = l1 ; l1 = l2 ; l2 = temp ; } tail . next = l1 ; l1 = l1 . next ; tail = tail . next ; } tail . next = l1 == null ? l2 : l1 ; while ( tail . next != null ) tail = tail . next ; return new ListNode [] { dummy . next , tail }; } } 149. Max Points on a Line $\\star\\star\\star$ Time: $O(n^2)$ Space: $O(n)$ class Solution { public int maxPoints ( int [][] points ) { int ans = 0 ; for ( int i = 0 ; i < points . length ; ++ i ) { Map < Pair < Integer , Integer > , Integer > count = new HashMap <> (); int [] p1 = points [ i ] ; int samePoints = 1 ; int maxPoints = 0 ; for ( int j = i + 1 ; j < points . length ; ++ j ) { int [] p2 = points [ j ] ; if ( p1 [ 0 ] == p2 [ 0 ] && p1 [ 1 ] == p2 [ 1 ] ) ++ samePoints ; else { Pair < Integer , Integer > slope = getSlope ( p1 , p2 ); count . put ( slope , count . getOrDefault ( slope , 0 ) + 1 ); maxPoints = Math . max ( maxPoints , count . get ( slope )); } } ans = Math . max ( ans , samePoints + maxPoints ); } return ans ; } private Pair < Integer , Integer > getSlope ( int [] p1 , int [] p2 ) { int dx = p2 [ 0 ] - p1 [ 0 ] ; int dy = p2 [ 1 ] - p1 [ 1 ] ; if ( dx == 0 ) return new Pair <> ( 0 , p1 [ 0 ] ); if ( dy == 0 ) return new Pair <> ( p1 [ 1 ] , 0 ); int d = gcd ( dx , dy ); return new Pair <> ( dx / d , dy / d ); } private int gcd ( int a , int b ) { return b == 0 ? a : gcd ( b , a % b ); } } 150. Evaluate Reverse Polish Notation $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public int evalRPN ( String [] tokens ) { Stack < Integer > stack = new Stack < Integer > (); for ( final String token : tokens ) switch ( token ) { case \"+\" : stack . push ( stack . pop () + stack . pop ()); break ; case \"-\" : stack . push ( - stack . pop () + stack . pop ()); break ; case \"*\" : stack . push ( stack . pop () * stack . pop ()); break ; case \"/\" : int b = stack . pop (); int a = stack . pop (); stack . push ( a / b ); break ; default : stack . push ( Integer . valueOf ( token )); } return stack . peek (); } }","title":"0141-0150"},{"location":"java/0101-0200/0141-0150/#141-linked-list-cycle-star","text":"Time: $O(n)$ Space: $O(1)$ public class Solution { public boolean hasCycle ( ListNode head ) { ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; if ( slow == fast ) return true ; } return false ; } }","title":"141. Linked List Cycle $\\star$"},{"location":"java/0101-0200/0141-0150/#142-linked-list-cycle-ii-starstar","text":"Time: $O(n)$ Space: $O(1)$ public class Solution { public ListNode detectCycle ( ListNode head ) { ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; if ( slow == fast ) { slow = head ; while ( slow != fast ) { slow = slow . next ; fast = fast . next ; } return slow ; } } return null ; } }","title":"142. Linked List Cycle II $\\star\\star$"},{"location":"java/0101-0200/0141-0150/#143-reorder-list-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public void reorderList ( ListNode head ) { if ( head == null || head . next == null ) return ; ListNode mid = findMid ( head ); ListNode reversed = reverse ( mid ); merge ( head , reversed ); } private ListNode findMid ( ListNode head ) { ListNode prev = null ; ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { prev = slow ; slow = slow . next ; fast = fast . next . next ; } prev . next = null ; return slow ; } private ListNode reverse ( ListNode head ) { ListNode prev = null ; ListNode curr = head ; while ( curr != null ) { ListNode next = curr . next ; curr . next = prev ; prev = curr ; curr = next ; } return prev ; } private void merge ( ListNode l1 , ListNode l2 ) { while ( l2 != null ) { ListNode next = l1 . next ; l1 . next = l2 ; l1 = l2 ; l2 = next ; } } }","title":"143. Reorder List $\\star\\star$"},{"location":"java/0101-0200/0141-0150/#144-binary-tree-preorder-traversal-starstar","text":"","title":"144. Binary Tree Preorder Traversal $\\star\\star$"},{"location":"java/0101-0200/0141-0150/#145-binary-tree-postorder-traversal-starstarstar","text":"","title":"145. Binary Tree Postorder Traversal $\\star\\star\\star$"},{"location":"java/0101-0200/0141-0150/#146-lru-cache-starstar","text":"Time: $O(1)$ Space: $O(capacity)$ class LRUCache { public LRUCache ( int capacity ) { this . capacity = capacity ; join ( head , tail ); } public int get ( int key ) { if ( ! map . containsKey ( key )) return - 1 ; Node node = map . get ( key ); remove ( node ); moveToHead ( node ); return node . value ; } public void put ( int key , int value ) { if ( map . containsKey ( key )) { Node node = map . get ( key ); node . value = value ; remove ( node ); moveToHead ( node ); return ; } if ( map . size () == capacity ) { Node lastNode = tail . prev ; map . remove ( lastNode . key ); remove ( lastNode ); } moveToHead ( new Node ( key , value )); map . put ( key , head . next ); } private void join ( Node node1 , Node node2 ) { node1 . next = node2 ; node2 . prev = node1 ; } private void remove ( Node node ) { join ( node . prev , node . next ); } private void moveToHead ( Node node ) { join ( node , head . next ); join ( head , node ); } private int capacity ; private Map < Integer , Node > map = new HashMap <> (); private Node head = new Node ( - 1 , - 1 ); private Node tail = new Node ( - 1 , - 1 ); private class Node { Node prev ; Node next ; int key ; int value ; public Node ( int key , int value ) { this . key = key ; this . value = value ; } } }","title":"146. LRU Cache $\\star\\star$"},{"location":"java/0101-0200/0141-0150/#147-insertion-sort-list-starstar","text":"Time: $O(n^2)$ Space: $O(1)$ class Solution { public ListNode insertionSortList ( ListNode head ) { ListNode dummy = new ListNode ( 0 ); ListNode curr = head ; while ( curr != null ) { ListNode prev = dummy ; while ( prev . next != null && prev . next . val < curr . val ) prev = prev . next ; ListNode next = curr . next ; curr . next = prev . next ; prev . next = curr ; curr = next ; } return dummy . next ; } }","title":"147. Insertion Sort List $\\star\\star$"},{"location":"java/0101-0200/0141-0150/#148-sort-list-starstar","text":"Time: $O(n\\log n)$ Space: $O(1)$ class Solution { public ListNode sortList ( ListNode head ) { int length = 0 ; for ( ListNode curr = head ; curr != null ; curr = curr . next ) ++ length ; ListNode dummy = new ListNode ( 0 ); dummy . next = head ; for ( int k = 1 ; k < length ; k *= 2 ) { ListNode curr = dummy . next ; ListNode tail = dummy ; while ( curr != null ) { ListNode l = curr ; ListNode r = split ( l , k ); curr = split ( r , k ); ListNode [] merged = merge ( l , r ); tail . next = merged [ 0 ] ; tail = merged [ 1 ] ; } } return dummy . next ; } private ListNode split ( ListNode head , int k ) { while ( -- k > 0 && head != null ) head = head . next ; ListNode rest = head == null ? null : head . next ; if ( head != null ) head . next = null ; return rest ; } private ListNode [] merge ( ListNode l1 , ListNode l2 ) { ListNode dummy = new ListNode ( 0 ); ListNode tail = dummy ; while ( l1 != null && l2 != null ) { if ( l1 . val > l2 . val ) { ListNode temp = l1 ; l1 = l2 ; l2 = temp ; } tail . next = l1 ; l1 = l1 . next ; tail = tail . next ; } tail . next = l1 == null ? l2 : l1 ; while ( tail . next != null ) tail = tail . next ; return new ListNode [] { dummy . next , tail }; } }","title":"148. Sort List $\\star\\star$"},{"location":"java/0101-0200/0141-0150/#149-max-points-on-a-line-starstarstar","text":"Time: $O(n^2)$ Space: $O(n)$ class Solution { public int maxPoints ( int [][] points ) { int ans = 0 ; for ( int i = 0 ; i < points . length ; ++ i ) { Map < Pair < Integer , Integer > , Integer > count = new HashMap <> (); int [] p1 = points [ i ] ; int samePoints = 1 ; int maxPoints = 0 ; for ( int j = i + 1 ; j < points . length ; ++ j ) { int [] p2 = points [ j ] ; if ( p1 [ 0 ] == p2 [ 0 ] && p1 [ 1 ] == p2 [ 1 ] ) ++ samePoints ; else { Pair < Integer , Integer > slope = getSlope ( p1 , p2 ); count . put ( slope , count . getOrDefault ( slope , 0 ) + 1 ); maxPoints = Math . max ( maxPoints , count . get ( slope )); } } ans = Math . max ( ans , samePoints + maxPoints ); } return ans ; } private Pair < Integer , Integer > getSlope ( int [] p1 , int [] p2 ) { int dx = p2 [ 0 ] - p1 [ 0 ] ; int dy = p2 [ 1 ] - p1 [ 1 ] ; if ( dx == 0 ) return new Pair <> ( 0 , p1 [ 0 ] ); if ( dy == 0 ) return new Pair <> ( p1 [ 1 ] , 0 ); int d = gcd ( dx , dy ); return new Pair <> ( dx / d , dy / d ); } private int gcd ( int a , int b ) { return b == 0 ? a : gcd ( b , a % b ); } }","title":"149. Max Points on a Line $\\star\\star\\star$"},{"location":"java/0101-0200/0141-0150/#150-evaluate-reverse-polish-notation-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public int evalRPN ( String [] tokens ) { Stack < Integer > stack = new Stack < Integer > (); for ( final String token : tokens ) switch ( token ) { case \"+\" : stack . push ( stack . pop () + stack . pop ()); break ; case \"-\" : stack . push ( - stack . pop () + stack . pop ()); break ; case \"*\" : stack . push ( stack . pop () * stack . pop ()); break ; case \"/\" : int b = stack . pop (); int a = stack . pop (); stack . push ( a / b ); break ; default : stack . push ( Integer . valueOf ( token )); } return stack . peek (); } }","title":"150. Evaluate Reverse Polish Notation $\\star\\star$"},{"location":"java/0101-0200/0151-0160/","text":"151. Reverse Words in a String $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public String reverseWords ( String s ) { char [] charArray = s . toCharArray (); reverse ( charArray , 0 , charArray . length - 1 ); reverseWords ( charArray , 0 , 0 ); return cleanSpaces ( charArray , 0 , 0 ); } private void reverseWords ( char [] charArray , int i , int j ) { while ( i < charArray . length ) { while ( i < j || i < charArray . length && charArray [ i ] == ' ' ) ++ i ; while ( j < i || j < charArray . length && charArray [ j ] != ' ' ) ++ j ; reverse ( charArray , i , j - 1 ); } } private String cleanSpaces ( char [] charArray , int i , int j ) { while ( j < charArray . length ) { while ( j < charArray . length && charArray [ j ] == ' ' ) ++ j ; while ( j < charArray . length && charArray [ j ] != ' ' ) charArray [ i ++] = charArray [ j ++] ; while ( j < charArray . length && charArray [ j ] == ' ' ) ++ j ; if ( j < charArray . length ) charArray [ i ++] = ' ' ; } return new String ( charArray ). substring ( 0 , i ); } private void reverse ( char [] charArray , int l , int r ) { while ( l < r ) { char temp = charArray [ l ] ; charArray [ l ++] = charArray [ r ] ; charArray [ r --] = temp ; } } } 152. Maximum Product Subarray $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public int maxProduct ( int [] nums ) { int ans = nums [ 0 ] ; int prevMin = nums [ 0 ] ; int prevMax = nums [ 0 ] ; for ( int i = 1 ; i < nums . length ; ++ i ) { int min = prevMin * nums [ i ] ; int max = prevMax * nums [ i ] ; prevMin = Math . min ( nums [ i ] , Math . min ( min , max )); prevMax = Math . max ( nums [ i ] , Math . max ( min , max )); ans = Math . max ( ans , prevMax ); } return ans ; } } 153. Find Minimum in Rotated Sorted Array $\\star\\star$ Time: $O(\\log n)$ Space: $O(1)$ class Solution { public int findMin ( int [] nums ) { int l = 0 ; int r = nums . length - 1 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] < nums [ r ] ) r = m ; else l = m + 1 ; } return nums [ l ] ; } } 154. Find Minimum in Rotated Sorted Array II $\\star\\star\\star$ Time: $O(\\log n) \\to O(n)$ Space: $O(1)$ class Solution { public int findMin ( int [] nums ) { int l = 0 ; int r = nums . length - 1 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] == nums [ r ] ) -- r ; else if ( nums [ m ] < nums [ r ] ) r = m ; else l = m + 1 ; } return nums [ l ] ; } } 155. Min Stack $\\star$ 156. Binary Tree Upside Down $\\star\\star$ \ud83d\udd12 157. Read N Characters Given Read4 $\\star$ \ud83d\udd12 158. Read N Characters Given Read4 II - Call multiple times $\\star\\star\\star$ \ud83d\udd12 159. Longest Substring with At Most Two Distinct Characters $\\star\\star$ \ud83d\udd12 160. Intersection of Two Linked Lists $\\star$ Time: $O(n)$ Space: $O(1)$ public class Solution { public ListNode getIntersectionNode ( ListNode headA , ListNode headB ) { ListNode a = headA ; ListNode b = headB ; while ( a != b ) { a = a == null ? headB : a . next ; b = b == null ? headA : b . next ; } return a ; } }","title":"0151-0160"},{"location":"java/0101-0200/0151-0160/#151-reverse-words-in-a-string-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public String reverseWords ( String s ) { char [] charArray = s . toCharArray (); reverse ( charArray , 0 , charArray . length - 1 ); reverseWords ( charArray , 0 , 0 ); return cleanSpaces ( charArray , 0 , 0 ); } private void reverseWords ( char [] charArray , int i , int j ) { while ( i < charArray . length ) { while ( i < j || i < charArray . length && charArray [ i ] == ' ' ) ++ i ; while ( j < i || j < charArray . length && charArray [ j ] != ' ' ) ++ j ; reverse ( charArray , i , j - 1 ); } } private String cleanSpaces ( char [] charArray , int i , int j ) { while ( j < charArray . length ) { while ( j < charArray . length && charArray [ j ] == ' ' ) ++ j ; while ( j < charArray . length && charArray [ j ] != ' ' ) charArray [ i ++] = charArray [ j ++] ; while ( j < charArray . length && charArray [ j ] == ' ' ) ++ j ; if ( j < charArray . length ) charArray [ i ++] = ' ' ; } return new String ( charArray ). substring ( 0 , i ); } private void reverse ( char [] charArray , int l , int r ) { while ( l < r ) { char temp = charArray [ l ] ; charArray [ l ++] = charArray [ r ] ; charArray [ r --] = temp ; } } }","title":"151. Reverse Words in a String $\\star\\star$"},{"location":"java/0101-0200/0151-0160/#152-maximum-product-subarray-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public int maxProduct ( int [] nums ) { int ans = nums [ 0 ] ; int prevMin = nums [ 0 ] ; int prevMax = nums [ 0 ] ; for ( int i = 1 ; i < nums . length ; ++ i ) { int min = prevMin * nums [ i ] ; int max = prevMax * nums [ i ] ; prevMin = Math . min ( nums [ i ] , Math . min ( min , max )); prevMax = Math . max ( nums [ i ] , Math . max ( min , max )); ans = Math . max ( ans , prevMax ); } return ans ; } }","title":"152. Maximum Product Subarray $\\star\\star$"},{"location":"java/0101-0200/0151-0160/#153-find-minimum-in-rotated-sorted-array-starstar","text":"Time: $O(\\log n)$ Space: $O(1)$ class Solution { public int findMin ( int [] nums ) { int l = 0 ; int r = nums . length - 1 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] < nums [ r ] ) r = m ; else l = m + 1 ; } return nums [ l ] ; } }","title":"153. Find Minimum in Rotated Sorted Array $\\star\\star$"},{"location":"java/0101-0200/0151-0160/#154-find-minimum-in-rotated-sorted-array-ii-starstarstar","text":"Time: $O(\\log n) \\to O(n)$ Space: $O(1)$ class Solution { public int findMin ( int [] nums ) { int l = 0 ; int r = nums . length - 1 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] == nums [ r ] ) -- r ; else if ( nums [ m ] < nums [ r ] ) r = m ; else l = m + 1 ; } return nums [ l ] ; } }","title":"154. Find Minimum in Rotated Sorted Array II $\\star\\star\\star$"},{"location":"java/0101-0200/0151-0160/#155-min-stack-star","text":"","title":"155. Min Stack $\\star$"},{"location":"java/0101-0200/0151-0160/#156-binary-tree-upside-down-starstar","text":"","title":"156. Binary Tree Upside Down $\\star\\star$ \ud83d\udd12"},{"location":"java/0101-0200/0151-0160/#157-read-n-characters-given-read4-star","text":"","title":"157. Read N Characters Given Read4 $\\star$ \ud83d\udd12"},{"location":"java/0101-0200/0151-0160/#158-read-n-characters-given-read4-ii-call-multiple-times-starstarstar","text":"","title":"158. Read N Characters Given Read4 II - Call multiple times $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/0101-0200/0151-0160/#159-longest-substring-with-at-most-two-distinct-characters-starstar","text":"","title":"159. Longest Substring with At Most Two Distinct Characters $\\star\\star$ \ud83d\udd12"},{"location":"java/0101-0200/0151-0160/#160-intersection-of-two-linked-lists-star","text":"Time: $O(n)$ Space: $O(1)$ public class Solution { public ListNode getIntersectionNode ( ListNode headA , ListNode headB ) { ListNode a = headA ; ListNode b = headB ; while ( a != b ) { a = a == null ? headB : a . next ; b = b == null ? headA : b . next ; } return a ; } }","title":"160. Intersection of Two Linked Lists $\\star$"},{"location":"java/0101-0200/0161-0170/","text":"161. One Edit Distance $\\star\\star$ \ud83d\udd12 162. Find Peak Element $\\star\\star$ Time: $O(n\\log n)$ Space: $O(1)$ class Solution { public int findPeakElement ( int [] nums ) { int l = 0 ; int r = nums . length - 1 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] > nums [ m + 1 ] ) r = m ; else l = m + 1 ; } return l ; } } 163. Missing Ranges $\\star\\star$ \ud83d\udd12 164. Maximum Gap $\\star\\star\\star$ 165. Compare Version Numbers $\\star\\star$ 166. Fraction to Recurring Decimal $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public String fractionToDecimal ( int numerator , int denominator ) { if ( numerator == 0 ) return \"0\" ; String ans = \"\" ; if ( numerator < 0 ^ denominator < 0 ) ans += \"-\" ; long n = Math . abs (( long ) numerator ); long d = Math . abs (( long ) denominator ); ans += String . valueOf ( n / d ); if ( n % d == 0 ) return ans ; ans += \".\" ; Map < Long , Integer > map = new HashMap <> (); for ( long r = n % d ; r > 0 ; r %= d ) { if ( map . containsKey ( r )) { ans = ans . substring ( 0 , map . get ( r )) + \"(\" + ans . substring ( map . get ( r ), ans . length ()) + \")\" ; break ; } map . put ( r , ans . length ()); r *= 10 ; ans += String . valueOf ( r / d ); } return ans ; } } 167. Two Sum II - Input array is sorted $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public int [] twoSum ( int [] numbers , int target ) { int l = 0 ; int r = numbers . length - 1 ; while ( l < r ) { int sum = numbers [ l ] + numbers [ r ] ; if ( sum == target ) return new int [] { l + 1 , r + 1 }; if ( sum < target ) ++ l ; else -- r ; } throw new IllegalArgumentException (); } } 168. Excel Sheet Column Title $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public String convertToTitle ( int n ) { return n == 0 ? \"\" : convertToTitle (( n - 1 ) / 26 ) + ( char ) ( 'A' + (( n - 1 ) % 26 )); } } 169. Majority Element $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public int majorityElement ( int [] nums ) { Integer ans = null ; int count = 0 ; for ( int num : nums ) { if ( count == 0 ) ans = num ; count += num == ans ? 1 : - 1 ; } return ans ; } } 170. Two Sum III - Data structure design $\\star$ \ud83d\udd12","title":"0161-0170"},{"location":"java/0101-0200/0161-0170/#161-one-edit-distance-starstar","text":"","title":"161. One Edit Distance $\\star\\star$ \ud83d\udd12"},{"location":"java/0101-0200/0161-0170/#162-find-peak-element-starstar","text":"Time: $O(n\\log n)$ Space: $O(1)$ class Solution { public int findPeakElement ( int [] nums ) { int l = 0 ; int r = nums . length - 1 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] > nums [ m + 1 ] ) r = m ; else l = m + 1 ; } return l ; } }","title":"162. Find Peak Element $\\star\\star$"},{"location":"java/0101-0200/0161-0170/#163-missing-ranges-starstar","text":"","title":"163. Missing Ranges $\\star\\star$ \ud83d\udd12"},{"location":"java/0101-0200/0161-0170/#164-maximum-gap-starstarstar","text":"","title":"164. Maximum Gap $\\star\\star\\star$"},{"location":"java/0101-0200/0161-0170/#165-compare-version-numbers-starstar","text":"","title":"165. Compare Version Numbers $\\star\\star$"},{"location":"java/0101-0200/0161-0170/#166-fraction-to-recurring-decimal-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public String fractionToDecimal ( int numerator , int denominator ) { if ( numerator == 0 ) return \"0\" ; String ans = \"\" ; if ( numerator < 0 ^ denominator < 0 ) ans += \"-\" ; long n = Math . abs (( long ) numerator ); long d = Math . abs (( long ) denominator ); ans += String . valueOf ( n / d ); if ( n % d == 0 ) return ans ; ans += \".\" ; Map < Long , Integer > map = new HashMap <> (); for ( long r = n % d ; r > 0 ; r %= d ) { if ( map . containsKey ( r )) { ans = ans . substring ( 0 , map . get ( r )) + \"(\" + ans . substring ( map . get ( r ), ans . length ()) + \")\" ; break ; } map . put ( r , ans . length ()); r *= 10 ; ans += String . valueOf ( r / d ); } return ans ; } }","title":"166. Fraction to Recurring Decimal $\\star\\star$"},{"location":"java/0101-0200/0161-0170/#167-two-sum-ii-input-array-is-sorted-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public int [] twoSum ( int [] numbers , int target ) { int l = 0 ; int r = numbers . length - 1 ; while ( l < r ) { int sum = numbers [ l ] + numbers [ r ] ; if ( sum == target ) return new int [] { l + 1 , r + 1 }; if ( sum < target ) ++ l ; else -- r ; } throw new IllegalArgumentException (); } }","title":"167. Two Sum II - Input array is sorted $\\star$"},{"location":"java/0101-0200/0161-0170/#168-excel-sheet-column-title-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public String convertToTitle ( int n ) { return n == 0 ? \"\" : convertToTitle (( n - 1 ) / 26 ) + ( char ) ( 'A' + (( n - 1 ) % 26 )); } }","title":"168. Excel Sheet Column Title $\\star$"},{"location":"java/0101-0200/0161-0170/#169-majority-element-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public int majorityElement ( int [] nums ) { Integer ans = null ; int count = 0 ; for ( int num : nums ) { if ( count == 0 ) ans = num ; count += num == ans ? 1 : - 1 ; } return ans ; } }","title":"169. Majority Element $\\star$"},{"location":"java/0101-0200/0161-0170/#170-two-sum-iii-data-structure-design-star","text":"","title":"170. Two Sum III - Data structure design $\\star$ \ud83d\udd12"},{"location":"java/0101-0200/0171-0180/","text":"171. Excel Sheet Column Number $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public int titleToNumber ( String s ) { int ans = 0 ; for ( char c : s . toCharArray ()) ans = ans * 26 + c - '@' ; return ans ; } } 172. Factorial Trailing Zeroes $\\star$ Time: $O(\\log_5 n)$ Space: $O(1)$ class Solution { public int trailingZeroes ( int n ) { return n == 0 ? 0 : n / 5 + trailingZeroes ( n / 5 ); } } 173. Binary Search Tree Iterator $\\star\\star$ 174. Dungeon Game $\\star\\star\\star$ Time: $O(mn)$ Space: $O(mn) \\to O(n)$ class Solution { public int calculateMinimumHP ( int [][] dungeon ) { final int m = dungeon . length ; final int n = dungeon [ 0 ] . length ; int [][] dp = new int [ m + 1 ][ n + 1 ] ; for ( int [] row : dp ) Arrays . fill ( row , Integer . MAX_VALUE ); dp [ m ][ n - 1 ] = 1 ; dp [ m - 1 ][ n ] = 1 ; for ( int i = m - 1 ; i >= 0 ; -- i ) for ( int j = n - 1 ; j >= 0 ; -- j ) { dp [ i ][ j ] = Math . min ( dp [ i + 1 ][ j ] , dp [ i ][ j + 1 ] ) - dungeon [ i ][ j ] ; dp [ i ][ j ] = Math . max ( dp [ i ][ j ] , 1 ); } return dp [ 0 ][ 0 ] ; } } 175. Combine Two Tables $\\star$ 176. Second Highest Salary $\\star$ 177. Nth Highest Salary $\\star\\star$ 178. Rank Scores $\\star\\star$ 179. Largest Number $\\star\\star$ 180. Consecutive Numbers $\\star\\star$","title":"0171-0180"},{"location":"java/0101-0200/0171-0180/#171-excel-sheet-column-number-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public int titleToNumber ( String s ) { int ans = 0 ; for ( char c : s . toCharArray ()) ans = ans * 26 + c - '@' ; return ans ; } }","title":"171. Excel Sheet Column Number $\\star$"},{"location":"java/0101-0200/0171-0180/#172-factorial-trailing-zeroes-star","text":"Time: $O(\\log_5 n)$ Space: $O(1)$ class Solution { public int trailingZeroes ( int n ) { return n == 0 ? 0 : n / 5 + trailingZeroes ( n / 5 ); } }","title":"172. Factorial Trailing Zeroes $\\star$"},{"location":"java/0101-0200/0171-0180/#173-binary-search-tree-iterator-starstar","text":"","title":"173. Binary Search Tree Iterator $\\star\\star$"},{"location":"java/0101-0200/0171-0180/#174-dungeon-game-starstarstar","text":"Time: $O(mn)$ Space: $O(mn) \\to O(n)$ class Solution { public int calculateMinimumHP ( int [][] dungeon ) { final int m = dungeon . length ; final int n = dungeon [ 0 ] . length ; int [][] dp = new int [ m + 1 ][ n + 1 ] ; for ( int [] row : dp ) Arrays . fill ( row , Integer . MAX_VALUE ); dp [ m ][ n - 1 ] = 1 ; dp [ m - 1 ][ n ] = 1 ; for ( int i = m - 1 ; i >= 0 ; -- i ) for ( int j = n - 1 ; j >= 0 ; -- j ) { dp [ i ][ j ] = Math . min ( dp [ i + 1 ][ j ] , dp [ i ][ j + 1 ] ) - dungeon [ i ][ j ] ; dp [ i ][ j ] = Math . max ( dp [ i ][ j ] , 1 ); } return dp [ 0 ][ 0 ] ; } }","title":"174. Dungeon Game $\\star\\star\\star$"},{"location":"java/0101-0200/0171-0180/#175-combine-two-tables-star","text":"","title":"175. Combine Two Tables $\\star$"},{"location":"java/0101-0200/0171-0180/#176-second-highest-salary-star","text":"","title":"176. Second Highest Salary $\\star$"},{"location":"java/0101-0200/0171-0180/#177-nth-highest-salary-starstar","text":"","title":"177. Nth Highest Salary $\\star\\star$"},{"location":"java/0101-0200/0171-0180/#178-rank-scores-starstar","text":"","title":"178. Rank Scores $\\star\\star$"},{"location":"java/0101-0200/0171-0180/#179-largest-number-starstar","text":"","title":"179. Largest Number $\\star\\star$"},{"location":"java/0101-0200/0171-0180/#180-consecutive-numbers-starstar","text":"","title":"180. Consecutive Numbers $\\star\\star$"},{"location":"java/0101-0200/0181-0190/","text":"181. Employees Earning More Than Their Managers $\\star$ 182. Duplicate Emails $\\star$ 183. Customers Who Never Order $\\star$ 184. Department Highest Salary $\\star\\star$ 185. Department Top Three Salaries $\\star\\star\\star$ 186. Reverse Words in a String II $\\star\\star$ \ud83d\udd12 187. Repeated DNA Sequences $\\star\\star$ Time: $O(10n)$ Space: $O(10n)$ class Solution { public List < String > findRepeatedDnaSequences ( String s ) { Set < String > ans = new HashSet <> (); Set < String > seen = new HashSet <> (); for ( int i = 0 ; i + 10 <= s . length (); ++ i ) { String seq = s . substring ( i , i + 10 ); if ( seen . contains ( seq )) ans . add ( seq ); seen . add ( seq ); } return new ArrayList <> ( ans ); } } 188. Best Time to Buy and Sell Stock IV $\\star\\star\\star$ Time: $O(nk)$ Space: $O(k)$ class Solution { public int maxProfit ( int k , int [] prices ) { if ( k >= prices . length / 2 ) { int sell = 0 ; int hold = Integer . MIN_VALUE ; for ( int price : prices ) { sell = Math . max ( sell , hold + price ); hold = Math . max ( hold , sell - price ); } return sell ; } int [] sell = new int [ k + 1 ] ; int [] hold = new int [ k + 1 ] ; Arrays . fill ( hold , Integer . MIN_VALUE ); for ( int price : prices ) for ( int i = k ; i > 0 ; -- i ) { sell [ i ] = Math . max ( sell [ i ] , hold [ i ] + price ); hold [ i ] = Math . max ( hold [ i ] , sell [ i - 1 ] - price ); } return sell [ k ] ; } } 189. Rotate Array $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public void rotate ( int [] nums , int k ) { k %= nums . length ; reverse ( nums , 0 , nums . length - 1 ); reverse ( nums , 0 , k - 1 ); reverse ( nums , k , nums . length - 1 ); } private void reverse ( int [] nums , int l , int r ) { while ( l < r ) swap ( nums , l ++ , r -- ); } private void swap ( int [] nums , int l , int r ) { int temp = nums [ l ] ; nums [ l ] = nums [ r ] ; nums [ r ] = temp ; } } 190. Reverse Bits $\\star$","title":"0181-0190"},{"location":"java/0101-0200/0181-0190/#181-employees-earning-more-than-their-managers-star","text":"","title":"181. Employees Earning More Than Their Managers $\\star$"},{"location":"java/0101-0200/0181-0190/#182-duplicate-emails-star","text":"","title":"182. Duplicate Emails $\\star$"},{"location":"java/0101-0200/0181-0190/#183-customers-who-never-order-star","text":"","title":"183. Customers Who Never Order $\\star$"},{"location":"java/0101-0200/0181-0190/#184-department-highest-salary-starstar","text":"","title":"184. Department Highest Salary $\\star\\star$"},{"location":"java/0101-0200/0181-0190/#185-department-top-three-salaries-starstarstar","text":"","title":"185. Department Top Three Salaries $\\star\\star\\star$"},{"location":"java/0101-0200/0181-0190/#186-reverse-words-in-a-string-ii-starstar","text":"","title":"186. Reverse Words in a String II $\\star\\star$ \ud83d\udd12"},{"location":"java/0101-0200/0181-0190/#187-repeated-dna-sequences-starstar","text":"Time: $O(10n)$ Space: $O(10n)$ class Solution { public List < String > findRepeatedDnaSequences ( String s ) { Set < String > ans = new HashSet <> (); Set < String > seen = new HashSet <> (); for ( int i = 0 ; i + 10 <= s . length (); ++ i ) { String seq = s . substring ( i , i + 10 ); if ( seen . contains ( seq )) ans . add ( seq ); seen . add ( seq ); } return new ArrayList <> ( ans ); } }","title":"187. Repeated DNA Sequences $\\star\\star$"},{"location":"java/0101-0200/0181-0190/#188-best-time-to-buy-and-sell-stock-iv-starstarstar","text":"Time: $O(nk)$ Space: $O(k)$ class Solution { public int maxProfit ( int k , int [] prices ) { if ( k >= prices . length / 2 ) { int sell = 0 ; int hold = Integer . MIN_VALUE ; for ( int price : prices ) { sell = Math . max ( sell , hold + price ); hold = Math . max ( hold , sell - price ); } return sell ; } int [] sell = new int [ k + 1 ] ; int [] hold = new int [ k + 1 ] ; Arrays . fill ( hold , Integer . MIN_VALUE ); for ( int price : prices ) for ( int i = k ; i > 0 ; -- i ) { sell [ i ] = Math . max ( sell [ i ] , hold [ i ] + price ); hold [ i ] = Math . max ( hold [ i ] , sell [ i - 1 ] - price ); } return sell [ k ] ; } }","title":"188. Best Time to Buy and Sell Stock IV $\\star\\star\\star$"},{"location":"java/0101-0200/0181-0190/#189-rotate-array-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public void rotate ( int [] nums , int k ) { k %= nums . length ; reverse ( nums , 0 , nums . length - 1 ); reverse ( nums , 0 , k - 1 ); reverse ( nums , k , nums . length - 1 ); } private void reverse ( int [] nums , int l , int r ) { while ( l < r ) swap ( nums , l ++ , r -- ); } private void swap ( int [] nums , int l , int r ) { int temp = nums [ l ] ; nums [ l ] = nums [ r ] ; nums [ r ] = temp ; } }","title":"189. Rotate Array $\\star$"},{"location":"java/0101-0200/0181-0190/#190-reverse-bits-star","text":"","title":"190. Reverse Bits $\\star$"},{"location":"java/0101-0200/0191-0200/","text":"191. Number of 1 Bits $\\star$ 192. Word Frequency $\\star\\star$ 193. Valid Phone Numbers $\\star$ 194. Transpose File $\\star\\star$ 195. Tenth Line $\\star$ 196. Delete Duplicate Emails $\\star$ 197. Rising Temperature $\\star$ 198. House Robber $\\star$ 199. Binary Tree Right Side View $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public List < Integer > rightSideView ( TreeNode root ) { List < Integer > ans = new ArrayList <> (); dfs ( root , 0 , ans ); return ans ; } private void dfs ( TreeNode root , int depth , List < Integer > ans ) { if ( root == null ) return ; if ( depth == ans . size ()) ans . add ( root . val ); dfs ( root . right , depth + 1 , ans ); dfs ( root . left , depth + 1 , ans ); } } 200. Number of Islands $\\star\\star$ Time: $O(mn)$ Space: $O(mn)$ class Solution { public int numIslands ( char [][] grid ) { if ( grid . length == 0 ) return 0 ; final int m = grid . length ; final int n = grid [ 0 ] . length ; int ans = 0 ; boolean [][] seen = new boolean [ m ][ n ] ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( ! seen [ i ][ j ] && grid [ i ][ j ] == '1' ) { ++ ans ; dfs ( grid , i , j , seen ); } return ans ; } private void dfs ( char [][] grid , int i , int j , boolean [][] seen ) { if ( i < 0 || i >= grid . length || j < 0 || j >= grid [ 0 ] . length || seen [ i ][ j ] || grid [ i ][ j ] == '0' ) return ; seen [ i ][ j ] = true ; dfs ( grid , i + 1 , j , seen ); dfs ( grid , i - 1 , j , seen ); dfs ( grid , i , j + 1 , seen ); dfs ( grid , i , j - 1 , seen ); } }","title":"0191-0200"},{"location":"java/0101-0200/0191-0200/#191-number-of-1-bits-star","text":"","title":"191. Number of 1 Bits $\\star$"},{"location":"java/0101-0200/0191-0200/#192-word-frequency-starstar","text":"","title":"192. Word Frequency $\\star\\star$"},{"location":"java/0101-0200/0191-0200/#193-valid-phone-numbers-star","text":"","title":"193. Valid Phone Numbers $\\star$"},{"location":"java/0101-0200/0191-0200/#194-transpose-file-starstar","text":"","title":"194. Transpose File $\\star\\star$"},{"location":"java/0101-0200/0191-0200/#195-tenth-line-star","text":"","title":"195. Tenth Line $\\star$"},{"location":"java/0101-0200/0191-0200/#196-delete-duplicate-emails-star","text":"","title":"196. Delete Duplicate Emails $\\star$"},{"location":"java/0101-0200/0191-0200/#197-rising-temperature-star","text":"","title":"197. Rising Temperature $\\star$"},{"location":"java/0101-0200/0191-0200/#198-house-robber-star","text":"","title":"198. House Robber $\\star$"},{"location":"java/0101-0200/0191-0200/#199-binary-tree-right-side-view-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public List < Integer > rightSideView ( TreeNode root ) { List < Integer > ans = new ArrayList <> (); dfs ( root , 0 , ans ); return ans ; } private void dfs ( TreeNode root , int depth , List < Integer > ans ) { if ( root == null ) return ; if ( depth == ans . size ()) ans . add ( root . val ); dfs ( root . right , depth + 1 , ans ); dfs ( root . left , depth + 1 , ans ); } }","title":"199. Binary Tree Right Side View $\\star\\star$"},{"location":"java/0101-0200/0191-0200/#200-number-of-islands-starstar","text":"Time: $O(mn)$ Space: $O(mn)$ class Solution { public int numIslands ( char [][] grid ) { if ( grid . length == 0 ) return 0 ; final int m = grid . length ; final int n = grid [ 0 ] . length ; int ans = 0 ; boolean [][] seen = new boolean [ m ][ n ] ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( ! seen [ i ][ j ] && grid [ i ][ j ] == '1' ) { ++ ans ; dfs ( grid , i , j , seen ); } return ans ; } private void dfs ( char [][] grid , int i , int j , boolean [][] seen ) { if ( i < 0 || i >= grid . length || j < 0 || j >= grid [ 0 ] . length || seen [ i ][ j ] || grid [ i ][ j ] == '0' ) return ; seen [ i ][ j ] = true ; dfs ( grid , i + 1 , j , seen ); dfs ( grid , i - 1 , j , seen ); dfs ( grid , i , j + 1 , seen ); dfs ( grid , i , j - 1 , seen ); } }","title":"200. Number of Islands $\\star\\star$"},{"location":"java/0201-0300/0201-0210/","text":"201. Bitwise AND of Numbers Range $\\star\\star$ 202. Happy Number $\\star$ Time: $O(\\log n)$ Space: $O(1)$ class Solution { public boolean isHappy ( int n ) { int slow = helper ( n ); int fast = helper ( helper ( n )); while ( slow != fast ) { slow = helper ( slow ); fast = helper ( helper ( fast )); } return slow == 1 ; } private int helper ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += Math . pow ( n % 10 , 2 ); n /= 10 ; } return sum ; } } 203. Remove Linked List Elements $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public ListNode removeElements ( ListNode head , int val ) { ListNode dummy = new ListNode ( 0 ); dummy . next = head ; ListNode prev = dummy ; for (; head != null ; head = head . next ) if ( head . val != val ) { prev . next = head ; prev = prev . next ; } prev . next = null ; return dummy . next ; } } 204. Count Primes $\\star$ Time: $O(n\\log\\log n)$ Space: $O(n)$ class Solution { public int countPrimes ( int n ) { if ( n <= 2 ) return 0 ; int ans = 0 ; boolean [] prime = new boolean [ n ] ; Arrays . fill ( prime , 2 , n , true ); for ( int i = 0 ; i < Math . sqrt ( n ); ++ i ) if ( prime [ i ] ) for ( int j = i * i ; j < n ; j += i ) prime [ j ] = false ; for ( boolean p : prime ) if ( p ) ++ ans ; return ans ; } } 205. Isomorphic Strings $\\star$ Time: $O(n)$ Space: $O(128)$ class Solution { public boolean isIsomorphic ( String s , String t ) { Map < Character , Integer > map_s = new HashMap <> (); Map < Character , Integer > map_t = new HashMap <> (); for ( Integer i = 0 ; i < s . length (); ++ i ) if ( map_s . put ( s . charAt ( i ), i ) != map_t . put ( t . charAt ( i ), i )) return false ; return true ; } } 206. Reverse Linked List $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public ListNode reverseList ( ListNode head ) { ListNode prev = null ; ListNode curr = head ; while ( curr != null ) { ListNode next = curr . next ; curr . next = prev ; prev = curr ; curr = next ; } return prev ; } } 207. Course Schedule $\\star\\star$ Time: $O(n^2) \\to O(n)$ Space: $O(n)$ class Solution { public boolean canFinish ( int numCourses , int [][] prerequisites ) { List < Integer >[] graph = new List [ numCourses ] ; for ( int course = 0 ; course < numCourses ; ++ course ) graph [ course ] = new ArrayList <> (); int [] state = new int [ numCourses ] ; for ( final int [] p : prerequisites ) graph [ p [ 1 ]] . add ( p [ 0 ] ); for ( int course = 0 ; course < numCourses ; ++ course ) if ( hasCycle ( course , graph , state )) return false ; return true ; } boolean hasCycle ( int course , List < Integer >[] graph , int [] state ) { if ( state [ course ] == 1 ) return true ; if ( state [ course ] == 2 ) return false ; state [ course ] = 1 ; for ( int neighbor : graph [ course ] ) if ( hasCycle ( neighbor , graph , state )) return true ; state [ course ] = 2 ; return false ; } } 208. Implement Trie (Prefix Tree) $\\star\\star$ class Trie { public void insert ( String word ) { TrieNode node = root ; for ( char c : word . toCharArray ()) { int index = c - 'a' ; if ( node . children [ index ] == null ) node . children [ index ] = new TrieNode (); node = node . children [ index ] ; } node . isWord = true ; } public boolean search ( String word ) { TrieNode node = find ( word ); return node != null && node . isWord ; } public boolean startsWith ( String prefix ) { return find ( prefix ) != null ; } private class TrieNode { private TrieNode [] children = new TrieNode [ 26 ] ; private boolean isWord = false ; } private TrieNode root = new TrieNode (); private TrieNode find ( String prefix ) { TrieNode node = root ; for ( int i = 0 ; i < prefix . length (); ++ i ) { int index = ( int ) ( prefix . charAt ( i ) - 'a' ); if ( node . children [ index ] == null ) return null ; node = node . children [ index ] ; } return node ; } } 209. Minimum Size Subarray Sum $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public int minSubArrayLen ( int s , int [] nums ) { int ans = Integer . MAX_VALUE ; int sum = 0 ; for ( int i = 0 , j = 0 ; i < nums . length ; ++ i ) { sum += nums [ i ] ; while ( sum >= s ) { ans = Math . min ( ans , i - j + 1 ); sum -= nums [ j ++] ; } } return ans != Integer . MAX_VALUE ? ans : 0 ; } } 210. Course Schedule II $\\star\\star$ Time: $O(n^2) \\to O(n)$ Space: $O(n)$ class Solution { public int [] findOrder ( int numCourses , int [][] prerequisites ) { Deque < Integer > ans = new ArrayDeque <> (); List < Integer >[] graph = new List [ numCourses ] ; for ( int course = 0 ; course < numCourses ; ++ course ) graph [ course ] = new ArrayList <> (); int [] state = new int [ numCourses ] ; for ( final int [] p : prerequisites ) graph [ p [ 1 ]] . add ( p [ 0 ] ); for ( int course = 0 ; course < numCourses ; ++ course ) if ( hasCycle ( course , graph , state , ans )) return new int [] {}; return ans . stream (). mapToInt ( i -> i ). toArray (); } boolean hasCycle ( int course , List < Integer >[] graph , int [] state , Deque < Integer > ans ) { if ( state [ course ] == 1 ) return true ; if ( state [ course ] == 2 ) return false ; state [ course ] = 1 ; for ( int neighbor : graph [ course ] ) if ( hasCycle ( neighbor , graph , state , ans )) return true ; state [ course ] = 2 ; ans . addFirst ( course ); return false ; } }","title":"0201-0210"},{"location":"java/0201-0300/0201-0210/#201-bitwise-and-of-numbers-range-starstar","text":"","title":"201. Bitwise AND of Numbers Range $\\star\\star$"},{"location":"java/0201-0300/0201-0210/#202-happy-number-star","text":"Time: $O(\\log n)$ Space: $O(1)$ class Solution { public boolean isHappy ( int n ) { int slow = helper ( n ); int fast = helper ( helper ( n )); while ( slow != fast ) { slow = helper ( slow ); fast = helper ( helper ( fast )); } return slow == 1 ; } private int helper ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += Math . pow ( n % 10 , 2 ); n /= 10 ; } return sum ; } }","title":"202. Happy Number $\\star$"},{"location":"java/0201-0300/0201-0210/#203-remove-linked-list-elements-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public ListNode removeElements ( ListNode head , int val ) { ListNode dummy = new ListNode ( 0 ); dummy . next = head ; ListNode prev = dummy ; for (; head != null ; head = head . next ) if ( head . val != val ) { prev . next = head ; prev = prev . next ; } prev . next = null ; return dummy . next ; } }","title":"203. Remove Linked List Elements $\\star$"},{"location":"java/0201-0300/0201-0210/#204-count-primes-star","text":"Time: $O(n\\log\\log n)$ Space: $O(n)$ class Solution { public int countPrimes ( int n ) { if ( n <= 2 ) return 0 ; int ans = 0 ; boolean [] prime = new boolean [ n ] ; Arrays . fill ( prime , 2 , n , true ); for ( int i = 0 ; i < Math . sqrt ( n ); ++ i ) if ( prime [ i ] ) for ( int j = i * i ; j < n ; j += i ) prime [ j ] = false ; for ( boolean p : prime ) if ( p ) ++ ans ; return ans ; } }","title":"204. Count Primes $\\star$"},{"location":"java/0201-0300/0201-0210/#205-isomorphic-strings-star","text":"Time: $O(n)$ Space: $O(128)$ class Solution { public boolean isIsomorphic ( String s , String t ) { Map < Character , Integer > map_s = new HashMap <> (); Map < Character , Integer > map_t = new HashMap <> (); for ( Integer i = 0 ; i < s . length (); ++ i ) if ( map_s . put ( s . charAt ( i ), i ) != map_t . put ( t . charAt ( i ), i )) return false ; return true ; } }","title":"205. Isomorphic Strings $\\star$"},{"location":"java/0201-0300/0201-0210/#206-reverse-linked-list-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public ListNode reverseList ( ListNode head ) { ListNode prev = null ; ListNode curr = head ; while ( curr != null ) { ListNode next = curr . next ; curr . next = prev ; prev = curr ; curr = next ; } return prev ; } }","title":"206. Reverse Linked List $\\star$"},{"location":"java/0201-0300/0201-0210/#207-course-schedule-starstar","text":"Time: $O(n^2) \\to O(n)$ Space: $O(n)$ class Solution { public boolean canFinish ( int numCourses , int [][] prerequisites ) { List < Integer >[] graph = new List [ numCourses ] ; for ( int course = 0 ; course < numCourses ; ++ course ) graph [ course ] = new ArrayList <> (); int [] state = new int [ numCourses ] ; for ( final int [] p : prerequisites ) graph [ p [ 1 ]] . add ( p [ 0 ] ); for ( int course = 0 ; course < numCourses ; ++ course ) if ( hasCycle ( course , graph , state )) return false ; return true ; } boolean hasCycle ( int course , List < Integer >[] graph , int [] state ) { if ( state [ course ] == 1 ) return true ; if ( state [ course ] == 2 ) return false ; state [ course ] = 1 ; for ( int neighbor : graph [ course ] ) if ( hasCycle ( neighbor , graph , state )) return true ; state [ course ] = 2 ; return false ; } }","title":"207. Course Schedule $\\star\\star$"},{"location":"java/0201-0300/0201-0210/#208-implement-trie-prefix-tree-starstar","text":"class Trie { public void insert ( String word ) { TrieNode node = root ; for ( char c : word . toCharArray ()) { int index = c - 'a' ; if ( node . children [ index ] == null ) node . children [ index ] = new TrieNode (); node = node . children [ index ] ; } node . isWord = true ; } public boolean search ( String word ) { TrieNode node = find ( word ); return node != null && node . isWord ; } public boolean startsWith ( String prefix ) { return find ( prefix ) != null ; } private class TrieNode { private TrieNode [] children = new TrieNode [ 26 ] ; private boolean isWord = false ; } private TrieNode root = new TrieNode (); private TrieNode find ( String prefix ) { TrieNode node = root ; for ( int i = 0 ; i < prefix . length (); ++ i ) { int index = ( int ) ( prefix . charAt ( i ) - 'a' ); if ( node . children [ index ] == null ) return null ; node = node . children [ index ] ; } return node ; } }","title":"208. Implement Trie (Prefix Tree) $\\star\\star$"},{"location":"java/0201-0300/0201-0210/#209-minimum-size-subarray-sum-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public int minSubArrayLen ( int s , int [] nums ) { int ans = Integer . MAX_VALUE ; int sum = 0 ; for ( int i = 0 , j = 0 ; i < nums . length ; ++ i ) { sum += nums [ i ] ; while ( sum >= s ) { ans = Math . min ( ans , i - j + 1 ); sum -= nums [ j ++] ; } } return ans != Integer . MAX_VALUE ? ans : 0 ; } }","title":"209. Minimum Size Subarray Sum $\\star\\star$"},{"location":"java/0201-0300/0201-0210/#210-course-schedule-ii-starstar","text":"Time: $O(n^2) \\to O(n)$ Space: $O(n)$ class Solution { public int [] findOrder ( int numCourses , int [][] prerequisites ) { Deque < Integer > ans = new ArrayDeque <> (); List < Integer >[] graph = new List [ numCourses ] ; for ( int course = 0 ; course < numCourses ; ++ course ) graph [ course ] = new ArrayList <> (); int [] state = new int [ numCourses ] ; for ( final int [] p : prerequisites ) graph [ p [ 1 ]] . add ( p [ 0 ] ); for ( int course = 0 ; course < numCourses ; ++ course ) if ( hasCycle ( course , graph , state , ans )) return new int [] {}; return ans . stream (). mapToInt ( i -> i ). toArray (); } boolean hasCycle ( int course , List < Integer >[] graph , int [] state , Deque < Integer > ans ) { if ( state [ course ] == 1 ) return true ; if ( state [ course ] == 2 ) return false ; state [ course ] = 1 ; for ( int neighbor : graph [ course ] ) if ( hasCycle ( neighbor , graph , state , ans )) return true ; state [ course ] = 2 ; ans . addFirst ( course ); return false ; } }","title":"210. Course Schedule II $\\star\\star$"},{"location":"java/0201-0300/0211-0220/","text":"211. Add and Search Word - Data structure design $\\star\\star$ class WordDictionary { public void addWord ( String word ) { TrieNode node = root ; for ( char c : word . toCharArray ()) { int index = c - 'a' ; if ( node . children [ index ] == null ) node . children [ index ] = new TrieNode (); node = node . children [ index ] ; } node . isWord = true ; } public boolean search ( String word ) { return dfs ( word , 0 , root ); } private class TrieNode { private TrieNode [] children = new TrieNode [ 26 ] ; private boolean isWord = false ; } private TrieNode root = new TrieNode (); private boolean dfs ( String word , int depth , TrieNode node ) { if ( depth == word . length ()) return node . isWord ; if ( word . charAt ( depth ) != '.' ) { TrieNode next = node . children [ word . charAt ( depth ) - 'a' ] ; return next != null ? dfs ( word , depth + 1 , next ) : false ; } for ( int i = 0 ; i < 26 ; ++ i ) if ( node . children [ i ] != null && dfs ( word , depth + 1 , node . children [ i ] )) return true ; return false ; } } 212. Word Search II $\\star\\star\\star$ class Solution { public List < String > findWords ( char [][] board , String [] words ) { for ( String word : words ) insert ( word ); List < String > ans = new ArrayList <> (); for ( int i = 0 ; i < board . length ; ++ i ) for ( int j = 0 ; j < board [ 0 ] . length ; ++ j ) dfs ( board , i , j , root , ans ); return ans ; } private class TrieNode { private TrieNode [] children = new TrieNode [ 26 ] ; private String word ; } private TrieNode root = new TrieNode (); private void insert ( final String word ) { TrieNode node = root ; for ( char c : word . toCharArray ()) { int index = c - 'a' ; if ( node . children [ index ] == null ) node . children [ index ] = new TrieNode (); node = node . children [ index ] ; } node . word = word ; } private void dfs ( char [][] board , int i , int j , TrieNode node , List < String > ans ) { if ( i < 0 || i >= board . length || j < 0 || j >= board [ 0 ] . length || board [ i ][ j ] == '*' ) return ; char c = board [ i ][ j ] ; int index = ( int ) ( c - 'a' ); TrieNode next = node . children [ index ] ; if ( next == null ) return ; if ( next . word != null ) { ans . add ( next . word ); next . word = null ; } board [ i ][ j ] = '*' ; dfs ( board , i + 1 , j , next , ans ); dfs ( board , i - 1 , j , next , ans ); dfs ( board , i , j + 1 , next , ans ); dfs ( board , i , j - 1 , next , ans ); board [ i ][ j ] = c ; } } 213. House Robber II $\\star\\star$ 214. Shortest Palindrome $\\star\\star\\star$ 215. Kth Largest Element in an Array $\\star\\star$ 216. Combination Sum III $\\star\\star$ Time: $O(C(9, k)) = O(9^k)$ Space: $O(n)$ class Solution { public List < List < Integer >> combinationSum3 ( int k , int n ) { List < List < Integer >> ans = new ArrayList <> (); dfs ( k , n , 1 , new ArrayList <> (), ans ); return ans ; } private void dfs ( int k , int n , int s , List < Integer > path , List < List < Integer >> ans ) { if ( k == 0 && n == 0 ) { ans . add ( new ArrayList <> ( path )); return ; } if ( k == 0 || n < 0 ) return ; for ( int i = s ; i <= 9 ; ++ i ) { path . add ( i ); dfs ( k - 1 , n - i , i + 1 , path , ans ); path . remove ( path . size () - 1 ); } } } 217. Contains Duplicate $\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public boolean containsDuplicate ( int [] nums ) { Set < Integer > seen = new HashSet <> (); for ( int num : nums ) { if ( seen . contains ( num )) return true ; seen . add ( num ); } return false ; } } 218. The Skyline Problem $\\star\\star\\star$ 219. Contains Duplicate II $\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public boolean containsNearbyDuplicate ( int [] nums , int k ) { Set < Integer > seen = new HashSet <> (); for ( int i = 0 ; i < nums . length ; ++ i ) { if ( i > k ) seen . remove ( nums [ i - k - 1 ] ); if ( seen . contains ( nums [ i ] )) return true ; seen . add ( nums [ i ] ); } return false ; } } 220. Contains Duplicate III $\\star\\star$","title":"0211-0220"},{"location":"java/0201-0300/0211-0220/#211-add-and-search-word-data-structure-design-starstar","text":"class WordDictionary { public void addWord ( String word ) { TrieNode node = root ; for ( char c : word . toCharArray ()) { int index = c - 'a' ; if ( node . children [ index ] == null ) node . children [ index ] = new TrieNode (); node = node . children [ index ] ; } node . isWord = true ; } public boolean search ( String word ) { return dfs ( word , 0 , root ); } private class TrieNode { private TrieNode [] children = new TrieNode [ 26 ] ; private boolean isWord = false ; } private TrieNode root = new TrieNode (); private boolean dfs ( String word , int depth , TrieNode node ) { if ( depth == word . length ()) return node . isWord ; if ( word . charAt ( depth ) != '.' ) { TrieNode next = node . children [ word . charAt ( depth ) - 'a' ] ; return next != null ? dfs ( word , depth + 1 , next ) : false ; } for ( int i = 0 ; i < 26 ; ++ i ) if ( node . children [ i ] != null && dfs ( word , depth + 1 , node . children [ i ] )) return true ; return false ; } }","title":"211. Add and Search Word - Data structure design $\\star\\star$"},{"location":"java/0201-0300/0211-0220/#212-word-search-ii-starstarstar","text":"class Solution { public List < String > findWords ( char [][] board , String [] words ) { for ( String word : words ) insert ( word ); List < String > ans = new ArrayList <> (); for ( int i = 0 ; i < board . length ; ++ i ) for ( int j = 0 ; j < board [ 0 ] . length ; ++ j ) dfs ( board , i , j , root , ans ); return ans ; } private class TrieNode { private TrieNode [] children = new TrieNode [ 26 ] ; private String word ; } private TrieNode root = new TrieNode (); private void insert ( final String word ) { TrieNode node = root ; for ( char c : word . toCharArray ()) { int index = c - 'a' ; if ( node . children [ index ] == null ) node . children [ index ] = new TrieNode (); node = node . children [ index ] ; } node . word = word ; } private void dfs ( char [][] board , int i , int j , TrieNode node , List < String > ans ) { if ( i < 0 || i >= board . length || j < 0 || j >= board [ 0 ] . length || board [ i ][ j ] == '*' ) return ; char c = board [ i ][ j ] ; int index = ( int ) ( c - 'a' ); TrieNode next = node . children [ index ] ; if ( next == null ) return ; if ( next . word != null ) { ans . add ( next . word ); next . word = null ; } board [ i ][ j ] = '*' ; dfs ( board , i + 1 , j , next , ans ); dfs ( board , i - 1 , j , next , ans ); dfs ( board , i , j + 1 , next , ans ); dfs ( board , i , j - 1 , next , ans ); board [ i ][ j ] = c ; } }","title":"212. Word Search II $\\star\\star\\star$"},{"location":"java/0201-0300/0211-0220/#213-house-robber-ii-starstar","text":"","title":"213. House Robber II $\\star\\star$"},{"location":"java/0201-0300/0211-0220/#214-shortest-palindrome-starstarstar","text":"","title":"214. Shortest Palindrome $\\star\\star\\star$"},{"location":"java/0201-0300/0211-0220/#215-kth-largest-element-in-an-array-starstar","text":"","title":"215. Kth Largest Element in an Array $\\star\\star$"},{"location":"java/0201-0300/0211-0220/#216-combination-sum-iii-starstar","text":"Time: $O(C(9, k)) = O(9^k)$ Space: $O(n)$ class Solution { public List < List < Integer >> combinationSum3 ( int k , int n ) { List < List < Integer >> ans = new ArrayList <> (); dfs ( k , n , 1 , new ArrayList <> (), ans ); return ans ; } private void dfs ( int k , int n , int s , List < Integer > path , List < List < Integer >> ans ) { if ( k == 0 && n == 0 ) { ans . add ( new ArrayList <> ( path )); return ; } if ( k == 0 || n < 0 ) return ; for ( int i = s ; i <= 9 ; ++ i ) { path . add ( i ); dfs ( k - 1 , n - i , i + 1 , path , ans ); path . remove ( path . size () - 1 ); } } }","title":"216. Combination Sum III $\\star\\star$"},{"location":"java/0201-0300/0211-0220/#217-contains-duplicate-star","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public boolean containsDuplicate ( int [] nums ) { Set < Integer > seen = new HashSet <> (); for ( int num : nums ) { if ( seen . contains ( num )) return true ; seen . add ( num ); } return false ; } }","title":"217. Contains Duplicate $\\star$"},{"location":"java/0201-0300/0211-0220/#218-the-skyline-problem-starstarstar","text":"","title":"218. The Skyline Problem $\\star\\star\\star$"},{"location":"java/0201-0300/0211-0220/#219-contains-duplicate-ii-star","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public boolean containsNearbyDuplicate ( int [] nums , int k ) { Set < Integer > seen = new HashSet <> (); for ( int i = 0 ; i < nums . length ; ++ i ) { if ( i > k ) seen . remove ( nums [ i - k - 1 ] ); if ( seen . contains ( nums [ i ] )) return true ; seen . add ( nums [ i ] ); } return false ; } }","title":"219. Contains Duplicate II $\\star$"},{"location":"java/0201-0300/0211-0220/#220-contains-duplicate-iii-starstar","text":"","title":"220. Contains Duplicate III $\\star\\star$"},{"location":"java/0201-0300/0221-0230/","text":"221. Maximal Square $\\star\\star$ Time: $O(mn)$ Space: $O(mn) \\to O(n)$ class Solution { public int maximalSquare ( char [][] matrix ) { if ( matrix . length == 0 ) return 0 ; int [] dp = new int [ matrix [ 0 ] . length ] ; int maxLength = 0 ; int prev = 0 ; for ( int i = 0 ; i < matrix . length ; ++ i ) for ( int j = 0 ; j < matrix [ 0 ] . length ; ++ j ) { int cache = dp [ j ] ; if ( i == 0 || j == 0 || matrix [ i ][ j ] == '0' ) dp [ j ] = matrix [ i ][ j ] == '1' ? 1 : 0 ; else dp [ j ] = Math . min ( dp [ j ] , Math . min ( dp [ j - 1 ] , prev )) + 1 ; maxLength = Math . max ( maxLength , dp [ j ] ); prev = cache ; } return maxLength * maxLength ; } } 222. Count Complete Tree Nodes $\\star\\star$ 223. Rectangle Area $\\star\\star$ Time: $O(1)$ Space: $O(1)$ class Solution { public int computeArea ( long A , long B , long C , long D , long E , long F , long G , long H ) { long x = Math . max ( A , E ) < Math . min ( C , G ) ? ( Math . min ( C , G ) - Math . max ( A , E )) : 0 ; long y = Math . max ( B , F ) < Math . min ( D , H ) ? ( Math . min ( D , H ) - Math . max ( B , F )) : 0 ; return ( int ) (( C - A ) * ( D - B ) + ( G - E ) * ( H - F ) - x * y ); } } 224. Basic Calculator $\\star\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public int calculate ( String s ) { int ans = 0 ; int num = 0 ; int sign = 1 ; Stack < Integer > stack = new Stack <> (); stack . push ( sign ); for ( int i = 0 ; i < s . length (); ++ i ) { char c = s . charAt ( i ); if ( Character . isDigit ( c )) num = num * 10 + ( c - '0' ); else if ( c == '+' || c == '-' ) { ans += sign * num ; sign = stack . peek () * ( c == '+' ? 1 : - 1 ); num = 0 ; } else if ( c == '(' ) stack . push ( sign ); else if ( c == ')' ) stack . pop (); } return ans + sign * num ; } } 225. Implement Stack using Queues $\\star$ 226. Invert Binary Tree $\\star$ 227. Basic Calculator II $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public int calculate ( String s ) { int ans = 0 ; int num = 0 ; char sign = '+' ; Stack < Integer > stack = new Stack <> (); for ( int i = 0 ; i < s . length (); ++ i ) { char c = s . charAt ( i ); if ( Character . isDigit ( c )) num = num * 10 + ( c - '0' ); if ( ! Character . isDigit ( c ) && c != ' ' || i == s . length () - 1 ) { if ( sign == '+' ) stack . push ( num ); else if ( sign == '-' ) stack . push ( - num ); else if ( sign == '*' ) stack . push ( stack . pop () * num ); else stack . push ( stack . pop () / num ); num = 0 ; sign = c ; } } while ( ! stack . isEmpty ()) ans += stack . pop (); return ans ; } } 228. Summary Ranges $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public List < String > summaryRanges ( int [] nums ) { List < String > ans = new ArrayList <> (); for ( int i = 0 ; i < nums . length ; ++ i ) { int begin = nums [ i ] ; while ( i < nums . length - 1 && nums [ i ] == nums [ i + 1 ] - 1 ) ++ i ; int end = nums [ i ] ; if ( begin == end ) ans . add ( \"\" + begin ); else ans . add ( \"\" + begin + \"->\" + end ); } return ans ; } } 229. Majority Element II $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public List < Integer > majorityElement ( int [] nums ) { List < Integer > ans = new ArrayList <> (); int ans1 = 0 ; int ans2 = 1 ; int count1 = 0 ; int count2 = 0 ; for ( int num : nums ) { if ( num == ans1 ) ++ count1 ; else if ( num == ans2 ) ++ count2 ; else if ( count1 == 0 ) { ans1 = num ; ++ count1 ; } else if ( count2 == 0 ) { ans2 = num ; ++ count2 ; } else { -- count1 ; -- count2 ; } } count1 = 0 ; count2 = 0 ; for ( int num : nums ) { if ( num == ans1 ) ++ count1 ; else if ( num == ans2 ) ++ count2 ; } if ( count1 > nums . length / 3 ) ans . add ( ans1 ); if ( count2 > nums . length / 3 ) ans . add ( ans2 ); return ans ; } } 230. Kth Smallest Element in a BST $\\star\\star$","title":"0221-0230"},{"location":"java/0201-0300/0221-0230/#221-maximal-square-starstar","text":"Time: $O(mn)$ Space: $O(mn) \\to O(n)$ class Solution { public int maximalSquare ( char [][] matrix ) { if ( matrix . length == 0 ) return 0 ; int [] dp = new int [ matrix [ 0 ] . length ] ; int maxLength = 0 ; int prev = 0 ; for ( int i = 0 ; i < matrix . length ; ++ i ) for ( int j = 0 ; j < matrix [ 0 ] . length ; ++ j ) { int cache = dp [ j ] ; if ( i == 0 || j == 0 || matrix [ i ][ j ] == '0' ) dp [ j ] = matrix [ i ][ j ] == '1' ? 1 : 0 ; else dp [ j ] = Math . min ( dp [ j ] , Math . min ( dp [ j - 1 ] , prev )) + 1 ; maxLength = Math . max ( maxLength , dp [ j ] ); prev = cache ; } return maxLength * maxLength ; } }","title":"221. Maximal Square $\\star\\star$"},{"location":"java/0201-0300/0221-0230/#222-count-complete-tree-nodes-starstar","text":"","title":"222. Count Complete Tree Nodes $\\star\\star$"},{"location":"java/0201-0300/0221-0230/#223-rectangle-area-starstar","text":"Time: $O(1)$ Space: $O(1)$ class Solution { public int computeArea ( long A , long B , long C , long D , long E , long F , long G , long H ) { long x = Math . max ( A , E ) < Math . min ( C , G ) ? ( Math . min ( C , G ) - Math . max ( A , E )) : 0 ; long y = Math . max ( B , F ) < Math . min ( D , H ) ? ( Math . min ( D , H ) - Math . max ( B , F )) : 0 ; return ( int ) (( C - A ) * ( D - B ) + ( G - E ) * ( H - F ) - x * y ); } }","title":"223. Rectangle Area $\\star\\star$"},{"location":"java/0201-0300/0221-0230/#224-basic-calculator-starstarstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public int calculate ( String s ) { int ans = 0 ; int num = 0 ; int sign = 1 ; Stack < Integer > stack = new Stack <> (); stack . push ( sign ); for ( int i = 0 ; i < s . length (); ++ i ) { char c = s . charAt ( i ); if ( Character . isDigit ( c )) num = num * 10 + ( c - '0' ); else if ( c == '+' || c == '-' ) { ans += sign * num ; sign = stack . peek () * ( c == '+' ? 1 : - 1 ); num = 0 ; } else if ( c == '(' ) stack . push ( sign ); else if ( c == ')' ) stack . pop (); } return ans + sign * num ; } }","title":"224. Basic Calculator $\\star\\star\\star$"},{"location":"java/0201-0300/0221-0230/#225-implement-stack-using-queues-star","text":"","title":"225. Implement Stack using Queues $\\star$"},{"location":"java/0201-0300/0221-0230/#226-invert-binary-tree-star","text":"","title":"226. Invert Binary Tree $\\star$"},{"location":"java/0201-0300/0221-0230/#227-basic-calculator-ii-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public int calculate ( String s ) { int ans = 0 ; int num = 0 ; char sign = '+' ; Stack < Integer > stack = new Stack <> (); for ( int i = 0 ; i < s . length (); ++ i ) { char c = s . charAt ( i ); if ( Character . isDigit ( c )) num = num * 10 + ( c - '0' ); if ( ! Character . isDigit ( c ) && c != ' ' || i == s . length () - 1 ) { if ( sign == '+' ) stack . push ( num ); else if ( sign == '-' ) stack . push ( - num ); else if ( sign == '*' ) stack . push ( stack . pop () * num ); else stack . push ( stack . pop () / num ); num = 0 ; sign = c ; } } while ( ! stack . isEmpty ()) ans += stack . pop (); return ans ; } }","title":"227. Basic Calculator II $\\star\\star$"},{"location":"java/0201-0300/0221-0230/#228-summary-ranges-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public List < String > summaryRanges ( int [] nums ) { List < String > ans = new ArrayList <> (); for ( int i = 0 ; i < nums . length ; ++ i ) { int begin = nums [ i ] ; while ( i < nums . length - 1 && nums [ i ] == nums [ i + 1 ] - 1 ) ++ i ; int end = nums [ i ] ; if ( begin == end ) ans . add ( \"\" + begin ); else ans . add ( \"\" + begin + \"->\" + end ); } return ans ; } }","title":"228. Summary Ranges $\\star\\star$"},{"location":"java/0201-0300/0221-0230/#229-majority-element-ii-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public List < Integer > majorityElement ( int [] nums ) { List < Integer > ans = new ArrayList <> (); int ans1 = 0 ; int ans2 = 1 ; int count1 = 0 ; int count2 = 0 ; for ( int num : nums ) { if ( num == ans1 ) ++ count1 ; else if ( num == ans2 ) ++ count2 ; else if ( count1 == 0 ) { ans1 = num ; ++ count1 ; } else if ( count2 == 0 ) { ans2 = num ; ++ count2 ; } else { -- count1 ; -- count2 ; } } count1 = 0 ; count2 = 0 ; for ( int num : nums ) { if ( num == ans1 ) ++ count1 ; else if ( num == ans2 ) ++ count2 ; } if ( count1 > nums . length / 3 ) ans . add ( ans1 ); if ( count2 > nums . length / 3 ) ans . add ( ans2 ); return ans ; } }","title":"229. Majority Element II $\\star\\star$"},{"location":"java/0201-0300/0221-0230/#230-kth-smallest-element-in-a-bst-starstar","text":"","title":"230. Kth Smallest Element in a BST $\\star\\star$"},{"location":"java/0201-0300/0231-0240/","text":"231. Power of Two $\\star$ Time: $O(1)$ Space: $O(1)$ class Solution { public boolean isPowerOfTwo ( int n ) { return n < 0 ? false : Integer . bitCount ( n ) == 1 ; } } 232. Implement Queue using Stacks $\\star$ 233. Number of Digit One $\\star\\star\\star$ Time: $O(\\log n)$ Space: $O(1)$ class Solution { public int countDigitOne ( int n ) { if ( n < 0 ) return 0 ; int ans = 0 ; int num = n ; for ( long i = 1 ; i <= n ; i *= 10 , num /= 10 ) { int prefix = ( int ) ( n / ( i * 10 )); int suffix = ( int ) ( n % i ); int currentDigit = num % 10 ; ans += prefix * i ; if ( currentDigit > 1 ) ans += i ; else if ( currentDigit == 1 ) ans += suffix + 1 ; } return ans ; } } 234. Palindrome Linked List $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public boolean isPalindrome ( ListNode head ) { ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; } if ( fast != null ) slow = slow . next ; slow = reverseList ( slow ); while ( slow != null ) { if ( slow . val != head . val ) return false ; slow = slow . next ; head = head . next ; } return true ; } private ListNode reverseList ( ListNode head ) { ListNode prev = null ; ListNode curr = head ; while ( curr != null ) { ListNode next = curr . next ; curr . next = prev ; prev = curr ; curr = next ; } return prev ; } } 235. Lowest Common Ancestor of a Binary Search Tree $\\star$ 236. Lowest Common Ancestor of a Binary Tree $\\star\\star$ 237. Delete Node in a Linked List $\\star$ Time: $O(1)$ Space: $O(1)$ class Solution { public void deleteNode ( ListNode node ) { node . val = node . next . val ; node . next = node . next . next ; } } 238. Product of Array Except Self $\\star\\star$ Time: $O(n)$ Space: $O(n) \\to O(1)$ class Solution { public int [] productExceptSelf ( int [] nums ) { int [] ans = new int [ nums . length ] ; ans [ 0 ] = 1 ; int r = 1 ; for ( int i = 1 ; i < nums . length ; ++ i ) ans [ i ] = ans [ i - 1 ] * nums [ i - 1 ] ; for ( int i = nums . length - 1 ; i >= 0 ; -- i ) { ans [ i ] *= r ; r *= nums [ i ] ; } return ans ; } } 239. Sliding Window Maximum $\\star\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public int [] maxSlidingWindow ( int [] nums , int k ) { List < Integer > ans = new ArrayList <> (); Deque < Integer > decreasingDeque = new ArrayDeque <> (); for ( int i = 0 ; i < nums . length ; ++ i ) { while ( ! decreasingDeque . isEmpty () && nums [ i ] > decreasingDeque . getLast ()) decreasingDeque . removeLast (); decreasingDeque . addLast ( nums [ i ] ); if ( i >= k - 1 ) { ans . add ( decreasingDeque . getFirst ()); if ( nums [ i - k + 1 ] == decreasingDeque . getFirst ()) decreasingDeque . removeFirst (); } } return ans . stream (). mapToInt ( i -> i ). toArray (); } } 240. Search a 2D Matrix II $\\star\\star$","title":"0231-0240"},{"location":"java/0201-0300/0231-0240/#231-power-of-two-star","text":"Time: $O(1)$ Space: $O(1)$ class Solution { public boolean isPowerOfTwo ( int n ) { return n < 0 ? false : Integer . bitCount ( n ) == 1 ; } }","title":"231. Power of Two $\\star$"},{"location":"java/0201-0300/0231-0240/#232-implement-queue-using-stacks-star","text":"","title":"232. Implement Queue using Stacks $\\star$"},{"location":"java/0201-0300/0231-0240/#233-number-of-digit-one-starstarstar","text":"Time: $O(\\log n)$ Space: $O(1)$ class Solution { public int countDigitOne ( int n ) { if ( n < 0 ) return 0 ; int ans = 0 ; int num = n ; for ( long i = 1 ; i <= n ; i *= 10 , num /= 10 ) { int prefix = ( int ) ( n / ( i * 10 )); int suffix = ( int ) ( n % i ); int currentDigit = num % 10 ; ans += prefix * i ; if ( currentDigit > 1 ) ans += i ; else if ( currentDigit == 1 ) ans += suffix + 1 ; } return ans ; } }","title":"233. Number of Digit One $\\star\\star\\star$"},{"location":"java/0201-0300/0231-0240/#234-palindrome-linked-list-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public boolean isPalindrome ( ListNode head ) { ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; } if ( fast != null ) slow = slow . next ; slow = reverseList ( slow ); while ( slow != null ) { if ( slow . val != head . val ) return false ; slow = slow . next ; head = head . next ; } return true ; } private ListNode reverseList ( ListNode head ) { ListNode prev = null ; ListNode curr = head ; while ( curr != null ) { ListNode next = curr . next ; curr . next = prev ; prev = curr ; curr = next ; } return prev ; } }","title":"234. Palindrome Linked List $\\star$"},{"location":"java/0201-0300/0231-0240/#235-lowest-common-ancestor-of-a-binary-search-tree-star","text":"","title":"235. Lowest Common Ancestor of a Binary Search Tree $\\star$"},{"location":"java/0201-0300/0231-0240/#236-lowest-common-ancestor-of-a-binary-tree-starstar","text":"","title":"236. Lowest Common Ancestor of a Binary Tree $\\star\\star$"},{"location":"java/0201-0300/0231-0240/#237-delete-node-in-a-linked-list-star","text":"Time: $O(1)$ Space: $O(1)$ class Solution { public void deleteNode ( ListNode node ) { node . val = node . next . val ; node . next = node . next . next ; } }","title":"237. Delete Node in a Linked List $\\star$"},{"location":"java/0201-0300/0231-0240/#238-product-of-array-except-self-starstar","text":"Time: $O(n)$ Space: $O(n) \\to O(1)$ class Solution { public int [] productExceptSelf ( int [] nums ) { int [] ans = new int [ nums . length ] ; ans [ 0 ] = 1 ; int r = 1 ; for ( int i = 1 ; i < nums . length ; ++ i ) ans [ i ] = ans [ i - 1 ] * nums [ i - 1 ] ; for ( int i = nums . length - 1 ; i >= 0 ; -- i ) { ans [ i ] *= r ; r *= nums [ i ] ; } return ans ; } }","title":"238. Product of Array Except Self $\\star\\star$"},{"location":"java/0201-0300/0231-0240/#239-sliding-window-maximum-starstarstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public int [] maxSlidingWindow ( int [] nums , int k ) { List < Integer > ans = new ArrayList <> (); Deque < Integer > decreasingDeque = new ArrayDeque <> (); for ( int i = 0 ; i < nums . length ; ++ i ) { while ( ! decreasingDeque . isEmpty () && nums [ i ] > decreasingDeque . getLast ()) decreasingDeque . removeLast (); decreasingDeque . addLast ( nums [ i ] ); if ( i >= k - 1 ) { ans . add ( decreasingDeque . getFirst ()); if ( nums [ i - k + 1 ] == decreasingDeque . getFirst ()) decreasingDeque . removeFirst (); } } return ans . stream (). mapToInt ( i -> i ). toArray (); } }","title":"239. Sliding Window Maximum $\\star\\star\\star$"},{"location":"java/0201-0300/0231-0240/#240-search-a-2d-matrix-ii-starstar","text":"","title":"240. Search a 2D Matrix II $\\star\\star$"},{"location":"java/0201-0300/0241-0250/","text":"241. Different Ways to Add Parentheses $\\star\\star$ 242. Valid Anagram $\\star$ Time: $O(26)$ Space: $O(n)$ class Solution { public boolean isAnagram ( String s , String t ) { if ( s . length () != t . length ()) return false ; int [] count = new int [ 26 ] ; for ( char c : s . toCharArray ()) ++ count [ c - 'a' ] ; for ( char c : t . toCharArray ()) if ( -- count [ c - 'a' ] < 0 ) return false ; return true ; } } 243. Shortest Word Distance $\\star$ \ud83d\udd12 244. Shortest Word Distance II $\\star\\star$ \ud83d\udd12 245. Shortest Word Distance III $\\star\\star$ \ud83d\udd12 246. Strobogrammatic Number $\\star$ \ud83d\udd12 247. Strobogrammatic Number II $\\star\\star$ \ud83d\udd12 248. Strobogrammatic Number III $\\star\\star\\star$ \ud83d\udd12 249. Group Shifted Strings $\\star\\star$ \ud83d\udd12 250. Count Univalue Subtrees $\\star\\star$ \ud83d\udd12","title":"0241-0250"},{"location":"java/0201-0300/0241-0250/#241-different-ways-to-add-parentheses-starstar","text":"","title":"241. Different Ways to Add Parentheses $\\star\\star$"},{"location":"java/0201-0300/0241-0250/#242-valid-anagram-star","text":"Time: $O(26)$ Space: $O(n)$ class Solution { public boolean isAnagram ( String s , String t ) { if ( s . length () != t . length ()) return false ; int [] count = new int [ 26 ] ; for ( char c : s . toCharArray ()) ++ count [ c - 'a' ] ; for ( char c : t . toCharArray ()) if ( -- count [ c - 'a' ] < 0 ) return false ; return true ; } }","title":"242. Valid Anagram $\\star$"},{"location":"java/0201-0300/0241-0250/#243-shortest-word-distance-star","text":"","title":"243. Shortest Word Distance $\\star$ \ud83d\udd12"},{"location":"java/0201-0300/0241-0250/#244-shortest-word-distance-ii-starstar","text":"","title":"244. Shortest Word Distance II $\\star\\star$ \ud83d\udd12"},{"location":"java/0201-0300/0241-0250/#245-shortest-word-distance-iii-starstar","text":"","title":"245. Shortest Word Distance III $\\star\\star$ \ud83d\udd12"},{"location":"java/0201-0300/0241-0250/#246-strobogrammatic-number-star","text":"","title":"246. Strobogrammatic Number $\\star$ \ud83d\udd12"},{"location":"java/0201-0300/0241-0250/#247-strobogrammatic-number-ii-starstar","text":"","title":"247. Strobogrammatic Number II $\\star\\star$ \ud83d\udd12"},{"location":"java/0201-0300/0241-0250/#248-strobogrammatic-number-iii-starstarstar","text":"","title":"248. Strobogrammatic Number III $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/0201-0300/0241-0250/#249-group-shifted-strings-starstar","text":"","title":"249. Group Shifted Strings $\\star\\star$ \ud83d\udd12"},{"location":"java/0201-0300/0241-0250/#250-count-univalue-subtrees-starstar","text":"","title":"250. Count Univalue Subtrees $\\star\\star$ \ud83d\udd12"},{"location":"java/0201-0300/0251-0260/","text":"251. Flatten 2D Vector $\\star\\star$ \ud83d\udd12 252. Meeting Rooms $\\star$ \ud83d\udd12 253. Meeting Rooms II $\\star\\star$ \ud83d\udd12 254. Factor Combinations $\\star\\star$ \ud83d\udd12 255. Verify Preorder Sequence in Binary Search Tree $\\star\\star$ \ud83d\udd12 256. Paint House $\\star$ \ud83d\udd12 257. Binary Tree Paths $\\star$ Time: $O(n)$ Space: $O(\\log n)$ class Solution { public List < String > binaryTreePaths ( TreeNode root ) { List < String > ans = new ArrayList <> (); dfs ( root , \"\" , ans ); return ans ; } private void dfs ( TreeNode root , String path , List < String > ans ) { if ( root == null ) return ; if ( root . left == null && root . right == null ) { ans . add ( path + String . valueOf ( root . val )); return ; } dfs ( root . left , path + String . valueOf ( root . val ) + \"->\" , ans ); dfs ( root . right , path + String . valueOf ( root . val ) + \"->\" , ans ); } } 258. Add Digits $\\star$ Time: $O(1)$ Space: $O(1)$ class Solution { public int addDigits ( int num ) { return 1 + ( num - 1 ) % 9 ; } } 259. 3Sum Smaller $\\star\\star$ \ud83d\udd12 260. Single Number III $\\star\\star$","title":"0251-0260"},{"location":"java/0201-0300/0251-0260/#251-flatten-2d-vector-starstar","text":"","title":"251. Flatten 2D Vector $\\star\\star$ \ud83d\udd12"},{"location":"java/0201-0300/0251-0260/#252-meeting-rooms-star","text":"","title":"252. Meeting Rooms $\\star$ \ud83d\udd12"},{"location":"java/0201-0300/0251-0260/#253-meeting-rooms-ii-starstar","text":"","title":"253. Meeting Rooms II $\\star\\star$ \ud83d\udd12"},{"location":"java/0201-0300/0251-0260/#254-factor-combinations-starstar","text":"","title":"254. Factor Combinations $\\star\\star$ \ud83d\udd12"},{"location":"java/0201-0300/0251-0260/#255-verify-preorder-sequence-in-binary-search-tree-starstar","text":"","title":"255. Verify Preorder Sequence in Binary Search Tree $\\star\\star$ \ud83d\udd12"},{"location":"java/0201-0300/0251-0260/#256-paint-house-star","text":"","title":"256. Paint House $\\star$ \ud83d\udd12"},{"location":"java/0201-0300/0251-0260/#257-binary-tree-paths-star","text":"Time: $O(n)$ Space: $O(\\log n)$ class Solution { public List < String > binaryTreePaths ( TreeNode root ) { List < String > ans = new ArrayList <> (); dfs ( root , \"\" , ans ); return ans ; } private void dfs ( TreeNode root , String path , List < String > ans ) { if ( root == null ) return ; if ( root . left == null && root . right == null ) { ans . add ( path + String . valueOf ( root . val )); return ; } dfs ( root . left , path + String . valueOf ( root . val ) + \"->\" , ans ); dfs ( root . right , path + String . valueOf ( root . val ) + \"->\" , ans ); } }","title":"257. Binary Tree Paths $\\star$"},{"location":"java/0201-0300/0251-0260/#258-add-digits-star","text":"Time: $O(1)$ Space: $O(1)$ class Solution { public int addDigits ( int num ) { return 1 + ( num - 1 ) % 9 ; } }","title":"258. Add Digits $\\star$"},{"location":"java/0201-0300/0251-0260/#259-3sum-smaller-starstar","text":"","title":"259. 3Sum Smaller $\\star\\star$ \ud83d\udd12"},{"location":"java/0201-0300/0251-0260/#260-single-number-iii-starstar","text":"","title":"260. Single Number III $\\star\\star$"},{"location":"java/0201-0300/0261-0270/","text":"261. Graph Valid Tree $\\star\\star$ \ud83d\udd12 262. Trips and Users $\\star\\star\\star$ 263. Ugly Number $\\star$ Time: $O(\\log n)$ Space: $O(1)$ class Solution { public boolean isUgly ( int num ) { if ( num == 0 ) return false ; for ( int prime : new int [] { 2 , 3 , 5 }) while ( num % prime == 0 ) num /= prime ; return num == 1 ; } } 264. Ugly Number II $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public int nthUglyNumber ( int n ) { List < Integer > nums = new ArrayList <> (); nums . add ( 1 ); int i2 = 0 ; int i3 = 0 ; int i5 = 0 ; while ( nums . size () < n ) { int next2 = nums . get ( i2 ) * 2 ; int next3 = nums . get ( i3 ) * 3 ; int next5 = nums . get ( i5 ) * 5 ; int next = Math . min ( next2 , Math . min ( next3 , next5 )); if ( next == next2 ) ++ i2 ; if ( next == next3 ) ++ i3 ; if ( next == next5 ) ++ i5 ; nums . add ( next ); } return nums . get ( nums . size () - 1 ); } } 265. Paint House II $\\star\\star\\star$ \ud83d\udd12 266. Palindrome Permutation $\\star$ \ud83d\udd12 267. Palindrome Permutation II $\\star\\star$ \ud83d\udd12 268. Missing Number $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public int missingNumber ( int [] nums ) { int ans = nums . length ; for ( int i = 0 ; i < nums . length ; ++ i ) ans ^= i ^ nums [ i ] ; return ans ; } } 269. Alien Dictionary $\\star\\star\\star$ \ud83d\udd12 270. Closest Binary Search Tree Value $\\star$ \ud83d\udd12","title":"0261-0270"},{"location":"java/0201-0300/0261-0270/#261-graph-valid-tree-starstar","text":"","title":"261. Graph Valid Tree $\\star\\star$ \ud83d\udd12"},{"location":"java/0201-0300/0261-0270/#262-trips-and-users-starstarstar","text":"","title":"262. Trips and Users $\\star\\star\\star$"},{"location":"java/0201-0300/0261-0270/#263-ugly-number-star","text":"Time: $O(\\log n)$ Space: $O(1)$ class Solution { public boolean isUgly ( int num ) { if ( num == 0 ) return false ; for ( int prime : new int [] { 2 , 3 , 5 }) while ( num % prime == 0 ) num /= prime ; return num == 1 ; } }","title":"263. Ugly Number $\\star$"},{"location":"java/0201-0300/0261-0270/#264-ugly-number-ii-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public int nthUglyNumber ( int n ) { List < Integer > nums = new ArrayList <> (); nums . add ( 1 ); int i2 = 0 ; int i3 = 0 ; int i5 = 0 ; while ( nums . size () < n ) { int next2 = nums . get ( i2 ) * 2 ; int next3 = nums . get ( i3 ) * 3 ; int next5 = nums . get ( i5 ) * 5 ; int next = Math . min ( next2 , Math . min ( next3 , next5 )); if ( next == next2 ) ++ i2 ; if ( next == next3 ) ++ i3 ; if ( next == next5 ) ++ i5 ; nums . add ( next ); } return nums . get ( nums . size () - 1 ); } }","title":"264. Ugly Number II $\\star\\star$"},{"location":"java/0201-0300/0261-0270/#265-paint-house-ii-starstarstar","text":"","title":"265. Paint House II $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/0201-0300/0261-0270/#266-palindrome-permutation-star","text":"","title":"266. Palindrome Permutation $\\star$ \ud83d\udd12"},{"location":"java/0201-0300/0261-0270/#267-palindrome-permutation-ii-starstar","text":"","title":"267. Palindrome Permutation II $\\star\\star$ \ud83d\udd12"},{"location":"java/0201-0300/0261-0270/#268-missing-number-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public int missingNumber ( int [] nums ) { int ans = nums . length ; for ( int i = 0 ; i < nums . length ; ++ i ) ans ^= i ^ nums [ i ] ; return ans ; } }","title":"268. Missing Number $\\star$"},{"location":"java/0201-0300/0261-0270/#269-alien-dictionary-starstarstar","text":"","title":"269. Alien Dictionary $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/0201-0300/0261-0270/#270-closest-binary-search-tree-value-star","text":"","title":"270. Closest Binary Search Tree Value $\\star$ \ud83d\udd12"},{"location":"java/0201-0300/0271-0280/","text":"271. Encode and Decode Strings $\\star\\star$ \ud83d\udd12 272. Closest Binary Search Tree Value II $\\star\\star\\star$ \ud83d\udd12 273. Integer to English Words $\\star\\star\\star$ class Solution { public String numberToWords ( int num ) { return num == 0 ? \"Zero\" : helper ( num ); } private String [] belowTwenty = { \"\" , \"One\" , \"Two\" , \"Three\" , \"Four\" , \"Five\" , \"Six\" , \"Seven\" , \"Eight\" , \"Nine\" , \"Ten\" , \"Eleven\" , \"Twelve\" , \"Thirteen\" , \"Fourteen\" , \"Fifteen\" , \"Sixteen\" , \"Seventeen\" , \"Eighteen\" , \"Nineteen\" }; private String [] tens = { \"\" , \"Ten\" , \"Twenty\" , \"Thirty\" , \"Forty\" , \"Fifty\" , \"Sixty\" , \"Seventy\" , \"Eighty\" , \"Ninety\" }; private String helper ( int num ) { String s = \"\" ; if ( num < 20 ) s = belowTwenty [ num ] ; else if ( num < 100 ) s = tens [ num / 10 ] + \" \" + helper ( num % 10 ); else if ( num < 1000 ) s = helper ( num / 100 ) + \" Hundred \" + helper ( num % 100 ); else if ( num < 1000000 ) s = helper ( num / 1000 ) + \" Thousand \" + helper ( num % 1000 ); else if ( num < 1000000000 ) s = helper ( num / 1000000 ) + \" Million \" + helper ( num % 1000000 ); else s = helper ( num / 1000000000 ) + \" Billion \" + helper ( num % 1000000000 ); return s . trim (); } } 274. H-Index $\\star\\star$ Time: $O(n\\log n)$ Space: $O(n)$ class Solution { public int hIndex ( int [] citations ) { final int n = citations . length ; Arrays . sort ( citations ); for ( int i = 0 ; i < n ; ++ i ) if ( citations [ i ] >= n - i ) return n - i ; return 0 ; } } 275. H-Index II $\\star\\star$ 276. Paint Fence $\\star$ \ud83d\udd12 277. Find the Celebrity $\\star\\star$ \ud83d\udd12 278. First Bad Version $\\star$ Time: $O(\\log n)$ Space: $O(1)$ public class Solution extends VersionControl { public int firstBadVersion ( int n ) { int l = 1 ; int r = n ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( isBadVersion ( m )) r = m ; else l = m + 1 ; } return l ; } } 279. Perfect Squares $\\star\\star$ Time: $O(\\log n)$ Space: $O(n\\log n)$ class Solution { public int numSquares ( int n ) { int [] dp = new int [ n + 1 ] ; Arrays . fill ( dp , n ); dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; ++ i ) for ( int j = 1 ; j * j <= i ; ++ j ) dp [ i ] = Math . min ( dp [ i ] , dp [ i - j * j ] + 1 ); return dp [ n ] ; } } 280. Wiggle Sort $\\star\\star$ \ud83d\udd12","title":"0271-0280"},{"location":"java/0201-0300/0271-0280/#271-encode-and-decode-strings-starstar","text":"","title":"271. Encode and Decode Strings $\\star\\star$ \ud83d\udd12"},{"location":"java/0201-0300/0271-0280/#272-closest-binary-search-tree-value-ii-starstarstar","text":"","title":"272. Closest Binary Search Tree Value II $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/0201-0300/0271-0280/#273-integer-to-english-words-starstarstar","text":"class Solution { public String numberToWords ( int num ) { return num == 0 ? \"Zero\" : helper ( num ); } private String [] belowTwenty = { \"\" , \"One\" , \"Two\" , \"Three\" , \"Four\" , \"Five\" , \"Six\" , \"Seven\" , \"Eight\" , \"Nine\" , \"Ten\" , \"Eleven\" , \"Twelve\" , \"Thirteen\" , \"Fourteen\" , \"Fifteen\" , \"Sixteen\" , \"Seventeen\" , \"Eighteen\" , \"Nineteen\" }; private String [] tens = { \"\" , \"Ten\" , \"Twenty\" , \"Thirty\" , \"Forty\" , \"Fifty\" , \"Sixty\" , \"Seventy\" , \"Eighty\" , \"Ninety\" }; private String helper ( int num ) { String s = \"\" ; if ( num < 20 ) s = belowTwenty [ num ] ; else if ( num < 100 ) s = tens [ num / 10 ] + \" \" + helper ( num % 10 ); else if ( num < 1000 ) s = helper ( num / 100 ) + \" Hundred \" + helper ( num % 100 ); else if ( num < 1000000 ) s = helper ( num / 1000 ) + \" Thousand \" + helper ( num % 1000 ); else if ( num < 1000000000 ) s = helper ( num / 1000000 ) + \" Million \" + helper ( num % 1000000 ); else s = helper ( num / 1000000000 ) + \" Billion \" + helper ( num % 1000000000 ); return s . trim (); } }","title":"273. Integer to English Words $\\star\\star\\star$"},{"location":"java/0201-0300/0271-0280/#274-h-index-starstar","text":"Time: $O(n\\log n)$ Space: $O(n)$ class Solution { public int hIndex ( int [] citations ) { final int n = citations . length ; Arrays . sort ( citations ); for ( int i = 0 ; i < n ; ++ i ) if ( citations [ i ] >= n - i ) return n - i ; return 0 ; } }","title":"274. H-Index $\\star\\star$"},{"location":"java/0201-0300/0271-0280/#275-h-index-ii-starstar","text":"","title":"275. H-Index II $\\star\\star$"},{"location":"java/0201-0300/0271-0280/#276-paint-fence-star","text":"","title":"276. Paint Fence $\\star$ \ud83d\udd12"},{"location":"java/0201-0300/0271-0280/#277-find-the-celebrity-starstar","text":"","title":"277. Find the Celebrity $\\star\\star$ \ud83d\udd12"},{"location":"java/0201-0300/0271-0280/#278-first-bad-version-star","text":"Time: $O(\\log n)$ Space: $O(1)$ public class Solution extends VersionControl { public int firstBadVersion ( int n ) { int l = 1 ; int r = n ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( isBadVersion ( m )) r = m ; else l = m + 1 ; } return l ; } }","title":"278. First Bad Version $\\star$"},{"location":"java/0201-0300/0271-0280/#279-perfect-squares-starstar","text":"Time: $O(\\log n)$ Space: $O(n\\log n)$ class Solution { public int numSquares ( int n ) { int [] dp = new int [ n + 1 ] ; Arrays . fill ( dp , n ); dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; ++ i ) for ( int j = 1 ; j * j <= i ; ++ j ) dp [ i ] = Math . min ( dp [ i ] , dp [ i - j * j ] + 1 ); return dp [ n ] ; } }","title":"279. Perfect Squares $\\star\\star$"},{"location":"java/0201-0300/0271-0280/#280-wiggle-sort-starstar","text":"","title":"280. Wiggle Sort $\\star\\star$ \ud83d\udd12"},{"location":"java/0201-0300/0281-0290/","text":"281. Zigzag Iterator $\\star\\star$ \ud83d\udd12 282. Expression Add Operators $\\star\\star\\star$ 283. Move Zeroes $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public void moveZeroes ( int [] nums ) { int j = 0 ; for ( int num : nums ) if ( num != 0 ) nums [ j ++] = num ; for ( int i = j ; i < nums . length ; ++ i ) nums [ i ] = 0 ; } } 284. Peeking Iterator $\\star\\star$ 285. Inorder Successor in BST $\\star\\star$ \ud83d\udd12 286. Walls and Gates $\\star\\star$ \ud83d\udd12 287. Find the Duplicate Number $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public int findDuplicate ( int [] nums ) { int slow = nums [ nums [ 0 ]] ; int fast = nums [ nums [ nums [ 0 ]]] ; while ( slow != fast ) { slow = nums [ slow ] ; fast = nums [ nums [ fast ]] ; } slow = nums [ 0 ] ; while ( slow != fast ) { slow = nums [ slow ] ; fast = nums [ fast ] ; } return slow ; } } 288. Unique Word Abbreviation $\\star\\star$ \ud83d\udd12 289. Game of Life $\\star\\star$ Time: $O(mn)$ Space: $O(1)$ class Solution { public void gameOfLife ( int [][] board ) { final int m = board . length ; final int n = board [ 0 ] . length ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int ones = 0 ; for ( int y = Math . max ( 0 , i - 1 ); y < Math . min ( m , i + 2 ); ++ y ) for ( int x = Math . max ( 0 , j - 1 ); x < Math . min ( n , j + 2 ); ++ x ) ones += board [ y ][ x ] & 1 ; if (( board [ i ][ j ] == 1 && ( ones == 3 || ones == 4 )) || ( board [ i ][ j ] == 0 && ones == 3 )) board [ i ][ j ] |= 0b10 ; } for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) board [ i ][ j ] >>= 1 ; } } 290. Word Pattern $\\star$ class Solution { public boolean wordPattern ( String pattern , String str ) { String [] words = str . split ( \" \" ); if ( words . length != pattern . length ()) return false ; Map < Character , Integer > charMap = new HashMap <> (); Map < String , Integer > strMap = new HashMap <> (); for ( Integer i = 0 ; i < pattern . length (); ++ i ) if ( charMap . put ( pattern . charAt ( i ), i ) != strMap . put ( words [ i ] , i )) return false ; return true ; } }","title":"0281-0290"},{"location":"java/0201-0300/0281-0290/#281-zigzag-iterator-starstar","text":"","title":"281. Zigzag Iterator $\\star\\star$ \ud83d\udd12"},{"location":"java/0201-0300/0281-0290/#282-expression-add-operators-starstarstar","text":"","title":"282. Expression Add Operators $\\star\\star\\star$"},{"location":"java/0201-0300/0281-0290/#283-move-zeroes-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public void moveZeroes ( int [] nums ) { int j = 0 ; for ( int num : nums ) if ( num != 0 ) nums [ j ++] = num ; for ( int i = j ; i < nums . length ; ++ i ) nums [ i ] = 0 ; } }","title":"283. Move Zeroes $\\star$"},{"location":"java/0201-0300/0281-0290/#284-peeking-iterator-starstar","text":"","title":"284. Peeking Iterator $\\star\\star$"},{"location":"java/0201-0300/0281-0290/#285-inorder-successor-in-bst-starstar","text":"","title":"285. Inorder Successor in BST $\\star\\star$ \ud83d\udd12"},{"location":"java/0201-0300/0281-0290/#286-walls-and-gates-starstar","text":"","title":"286. Walls and Gates $\\star\\star$ \ud83d\udd12"},{"location":"java/0201-0300/0281-0290/#287-find-the-duplicate-number-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public int findDuplicate ( int [] nums ) { int slow = nums [ nums [ 0 ]] ; int fast = nums [ nums [ nums [ 0 ]]] ; while ( slow != fast ) { slow = nums [ slow ] ; fast = nums [ nums [ fast ]] ; } slow = nums [ 0 ] ; while ( slow != fast ) { slow = nums [ slow ] ; fast = nums [ fast ] ; } return slow ; } }","title":"287. Find the Duplicate Number $\\star\\star$"},{"location":"java/0201-0300/0281-0290/#288-unique-word-abbreviation-starstar","text":"","title":"288. Unique Word Abbreviation $\\star\\star$ \ud83d\udd12"},{"location":"java/0201-0300/0281-0290/#289-game-of-life-starstar","text":"Time: $O(mn)$ Space: $O(1)$ class Solution { public void gameOfLife ( int [][] board ) { final int m = board . length ; final int n = board [ 0 ] . length ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int ones = 0 ; for ( int y = Math . max ( 0 , i - 1 ); y < Math . min ( m , i + 2 ); ++ y ) for ( int x = Math . max ( 0 , j - 1 ); x < Math . min ( n , j + 2 ); ++ x ) ones += board [ y ][ x ] & 1 ; if (( board [ i ][ j ] == 1 && ( ones == 3 || ones == 4 )) || ( board [ i ][ j ] == 0 && ones == 3 )) board [ i ][ j ] |= 0b10 ; } for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) board [ i ][ j ] >>= 1 ; } }","title":"289. Game of Life $\\star\\star$"},{"location":"java/0201-0300/0281-0290/#290-word-pattern-star","text":"class Solution { public boolean wordPattern ( String pattern , String str ) { String [] words = str . split ( \" \" ); if ( words . length != pattern . length ()) return false ; Map < Character , Integer > charMap = new HashMap <> (); Map < String , Integer > strMap = new HashMap <> (); for ( Integer i = 0 ; i < pattern . length (); ++ i ) if ( charMap . put ( pattern . charAt ( i ), i ) != strMap . put ( words [ i ] , i )) return false ; return true ; } }","title":"290. Word Pattern $\\star$"},{"location":"java/0201-0300/0291-0300/","text":"291. Word Pattern II $\\star\\star\\star$ \ud83d\udd12 292. Nim Game $\\star$ 293. Flip Game $\\star$ \ud83d\udd12 294. Flip Game II $\\star\\star$ \ud83d\udd12 295. Find Median from Data Stream $\\star\\star\\star$ 296. Best Meeting Point $\\star\\star\\star$ \ud83d\udd12 297. Serialize and Deserialize Binary Tree $\\star\\star\\star$ Time: $O(n)$ Space: $O(n)$ public class Codec { public String serialize ( TreeNode root ) { if ( root == null ) return \"\" ; StringBuilder ans = new StringBuilder (); Queue < TreeNode > queue = new LinkedList <> (); queue . add ( root ); while ( ! queue . isEmpty ()) { TreeNode node = queue . poll (); if ( node == null ) { ans . append ( \"n \" ); continue ; } ans . append ( node . val + \" \" ); queue . add ( node . left ); queue . add ( node . right ); } return ans . toString (); } public TreeNode deserialize ( String data ) { if ( data . equals ( \"\" )) return null ; String [] vals = data . split ( \" \" ); TreeNode root = new TreeNode ( Integer . parseInt ( vals [ 0 ] )); Queue < TreeNode > queue = new LinkedList <> (); queue . add ( root ); for ( int i = 1 ; i < vals . length ; ++ i ) { TreeNode parent = queue . poll (); if ( ! vals [ i ] . equals ( \"n\" )) { TreeNode left = new TreeNode ( Integer . parseInt ( vals [ i ] )); parent . left = left ; queue . add ( left ); } if ( ! vals [++ i ] . equals ( \"n\" )) { TreeNode right = new TreeNode ( Integer . parseInt ( vals [ i ] )); parent . right = right ; queue . add ( right ); } } return root ; } } 298. Binary Tree Longest Consecutive Sequence $\\star\\star$ \ud83d\udd12 299. Bulls and Cows $\\star$ Time: $O(n)$ Space: $O(10)$ class Solution { public String getHint ( String secret , String guess ) { int A = 0 ; int B = 0 ; int [] count1 = new int [ 10 ] ; int [] count2 = new int [ 10 ] ; for ( int i = 0 ; i < secret . length (); ++ i ) { if ( secret . charAt ( i ) == guess . charAt ( i )) ++ A ; else { ++ count1 [ secret . charAt ( i ) - '0' ] ; ++ count2 [ guess . charAt ( i ) - '0' ] ; } } for ( int i = 0 ; i <= 9 ; ++ i ) B += Math . min ( count1 [ i ] , count2 [ i ] ); return String . valueOf ( A ) + \"A\" + String . valueOf ( B ) + \"B\" ; } } 300. Longest Increasing Subsequence $\\star\\star$","title":"0291-0300"},{"location":"java/0201-0300/0291-0300/#291-word-pattern-ii-starstarstar","text":"","title":"291. Word Pattern II $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/0201-0300/0291-0300/#292-nim-game-star","text":"","title":"292. Nim Game $\\star$"},{"location":"java/0201-0300/0291-0300/#293-flip-game-star","text":"","title":"293. Flip Game $\\star$ \ud83d\udd12"},{"location":"java/0201-0300/0291-0300/#294-flip-game-ii-starstar","text":"","title":"294. Flip Game II $\\star\\star$ \ud83d\udd12"},{"location":"java/0201-0300/0291-0300/#295-find-median-from-data-stream-starstarstar","text":"","title":"295. Find Median from Data Stream $\\star\\star\\star$"},{"location":"java/0201-0300/0291-0300/#296-best-meeting-point-starstarstar","text":"","title":"296. Best Meeting Point $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/0201-0300/0291-0300/#297-serialize-and-deserialize-binary-tree-starstarstar","text":"Time: $O(n)$ Space: $O(n)$ public class Codec { public String serialize ( TreeNode root ) { if ( root == null ) return \"\" ; StringBuilder ans = new StringBuilder (); Queue < TreeNode > queue = new LinkedList <> (); queue . add ( root ); while ( ! queue . isEmpty ()) { TreeNode node = queue . poll (); if ( node == null ) { ans . append ( \"n \" ); continue ; } ans . append ( node . val + \" \" ); queue . add ( node . left ); queue . add ( node . right ); } return ans . toString (); } public TreeNode deserialize ( String data ) { if ( data . equals ( \"\" )) return null ; String [] vals = data . split ( \" \" ); TreeNode root = new TreeNode ( Integer . parseInt ( vals [ 0 ] )); Queue < TreeNode > queue = new LinkedList <> (); queue . add ( root ); for ( int i = 1 ; i < vals . length ; ++ i ) { TreeNode parent = queue . poll (); if ( ! vals [ i ] . equals ( \"n\" )) { TreeNode left = new TreeNode ( Integer . parseInt ( vals [ i ] )); parent . left = left ; queue . add ( left ); } if ( ! vals [++ i ] . equals ( \"n\" )) { TreeNode right = new TreeNode ( Integer . parseInt ( vals [ i ] )); parent . right = right ; queue . add ( right ); } } return root ; } }","title":"297. Serialize and Deserialize Binary Tree $\\star\\star\\star$"},{"location":"java/0201-0300/0291-0300/#298-binary-tree-longest-consecutive-sequence-starstar","text":"","title":"298. Binary Tree Longest Consecutive Sequence $\\star\\star$ \ud83d\udd12"},{"location":"java/0201-0300/0291-0300/#299-bulls-and-cows-star","text":"Time: $O(n)$ Space: $O(10)$ class Solution { public String getHint ( String secret , String guess ) { int A = 0 ; int B = 0 ; int [] count1 = new int [ 10 ] ; int [] count2 = new int [ 10 ] ; for ( int i = 0 ; i < secret . length (); ++ i ) { if ( secret . charAt ( i ) == guess . charAt ( i )) ++ A ; else { ++ count1 [ secret . charAt ( i ) - '0' ] ; ++ count2 [ guess . charAt ( i ) - '0' ] ; } } for ( int i = 0 ; i <= 9 ; ++ i ) B += Math . min ( count1 [ i ] , count2 [ i ] ); return String . valueOf ( A ) + \"A\" + String . valueOf ( B ) + \"B\" ; } }","title":"299. Bulls and Cows $\\star$"},{"location":"java/0201-0300/0291-0300/#300-longest-increasing-subsequence-starstar","text":"","title":"300. Longest Increasing Subsequence $\\star\\star$"},{"location":"java/0301-0400/0301-0310/","text":"301. Remove Invalid Parentheses $\\star\\star\\star$ Time: $O(2^n)$ class Solution { public List < String > removeInvalidParentheses ( String s ) { List < String > ans = new ArrayList <> (); int l = 0 ; int r = 0 ; for ( final char c : s . toCharArray ()) if ( c == '(' ) ++ l ; else if ( c == ')' ) { if ( l == 0 ) ++ r ; else -- l ; } dfs ( s , 0 , l , r , ans ); return ans ; } private boolean isValid ( final String s ) { int count = 0 ; for ( final char c : s . toCharArray ()) { if ( c == '(' ) ++ count ; else if ( c == ')' ) -- count ; if ( count < 0 ) return false ; } return true ; } private void dfs ( final String s , int start , int l , int r , List < String > ans ) { if ( l == 0 && r == 0 && isValid ( s )) { ans . add ( s ); return ; } for ( int i = start ; i < s . length (); ++ i ) { if ( i > start && s . charAt ( i ) == s . charAt ( i - 1 )) continue ; if ( r > 0 && s . charAt ( i ) == ')' ) dfs ( s . substring ( 0 , i ) + s . substring ( i + 1 ), i , l , r - 1 , ans ); else if ( l > 0 && s . charAt ( i ) == '(' ) dfs ( s . substring ( 0 , i ) + s . substring ( i + 1 ), i , l - 1 , r , ans ); } } } 302. Smallest Rectangle Enclosing Black Pixels $\\star\\star\\star$ \ud83d\udd12 303. Range Sum Query - Immutable $\\star$ 304. Range Sum Query 2D - Immutable $\\star\\star$ 305. Number of Islands II $\\star\\star\\star$ \ud83d\udd12 306. Additive Number $\\star\\star$ 307. Range Sum Query - Mutable $\\star\\star$ 308. Range Sum Query 2D - Mutable $\\star\\star\\star$ \ud83d\udd12 309. Best Time to Buy and Sell Stock with Cooldown $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public int maxProfit ( int [] prices ) { int sell = 0 ; int hold = Integer . MIN_VALUE ; int prev = 0 ; for ( int price : prices ) { int cache = sell ; sell = Math . max ( sell , hold + price ); hold = Math . max ( hold , prev - price ); prev = cache ; } return sell ; } } 310. Minimum Height Trees $\\star\\star$","title":"0301-0310"},{"location":"java/0301-0400/0301-0310/#301-remove-invalid-parentheses-starstarstar","text":"Time: $O(2^n)$ class Solution { public List < String > removeInvalidParentheses ( String s ) { List < String > ans = new ArrayList <> (); int l = 0 ; int r = 0 ; for ( final char c : s . toCharArray ()) if ( c == '(' ) ++ l ; else if ( c == ')' ) { if ( l == 0 ) ++ r ; else -- l ; } dfs ( s , 0 , l , r , ans ); return ans ; } private boolean isValid ( final String s ) { int count = 0 ; for ( final char c : s . toCharArray ()) { if ( c == '(' ) ++ count ; else if ( c == ')' ) -- count ; if ( count < 0 ) return false ; } return true ; } private void dfs ( final String s , int start , int l , int r , List < String > ans ) { if ( l == 0 && r == 0 && isValid ( s )) { ans . add ( s ); return ; } for ( int i = start ; i < s . length (); ++ i ) { if ( i > start && s . charAt ( i ) == s . charAt ( i - 1 )) continue ; if ( r > 0 && s . charAt ( i ) == ')' ) dfs ( s . substring ( 0 , i ) + s . substring ( i + 1 ), i , l , r - 1 , ans ); else if ( l > 0 && s . charAt ( i ) == '(' ) dfs ( s . substring ( 0 , i ) + s . substring ( i + 1 ), i , l - 1 , r , ans ); } } }","title":"301. Remove Invalid Parentheses $\\star\\star\\star$"},{"location":"java/0301-0400/0301-0310/#302-smallest-rectangle-enclosing-black-pixels-starstarstar","text":"","title":"302. Smallest Rectangle Enclosing Black Pixels $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/0301-0400/0301-0310/#303-range-sum-query-immutable-star","text":"","title":"303. Range Sum Query - Immutable $\\star$"},{"location":"java/0301-0400/0301-0310/#304-range-sum-query-2d-immutable-starstar","text":"","title":"304. Range Sum Query 2D - Immutable $\\star\\star$"},{"location":"java/0301-0400/0301-0310/#305-number-of-islands-ii-starstarstar","text":"","title":"305. Number of Islands II $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/0301-0400/0301-0310/#306-additive-number-starstar","text":"","title":"306. Additive Number $\\star\\star$"},{"location":"java/0301-0400/0301-0310/#307-range-sum-query-mutable-starstar","text":"","title":"307. Range Sum Query - Mutable $\\star\\star$"},{"location":"java/0301-0400/0301-0310/#308-range-sum-query-2d-mutable-starstarstar","text":"","title":"308. Range Sum Query 2D - Mutable $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/0301-0400/0301-0310/#309-best-time-to-buy-and-sell-stock-with-cooldown-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public int maxProfit ( int [] prices ) { int sell = 0 ; int hold = Integer . MIN_VALUE ; int prev = 0 ; for ( int price : prices ) { int cache = sell ; sell = Math . max ( sell , hold + price ); hold = Math . max ( hold , prev - price ); prev = cache ; } return sell ; } }","title":"309. Best Time to Buy and Sell Stock with Cooldown $\\star\\star$"},{"location":"java/0301-0400/0301-0310/#310-minimum-height-trees-starstar","text":"","title":"310. Minimum Height Trees $\\star\\star$"},{"location":"java/0301-0400/0311-0320/","text":"311. Sparse Matrix Multiplication $\\star\\star$ \ud83d\udd12 312. Burst Balloons $\\star\\star\\star$ 313. Super Ugly Number $\\star\\star$ Time: $O(n\\log k)$ Space: $O(k)$ class Solution { public int nthSuperUglyNumber ( int n , int [] primes ) { final int k = primes . length ; List < Integer > nums = new ArrayList <> (); nums . add ( 1 ); int [] indices = new int [ k ] ; while ( nums . size () < n ) { int [] nexts = new int [ k ] ; for ( int i = 0 ; i < k ; ++ i ) nexts [ i ] = nums . get ( indices [ i ] ) * primes [ i ] ; int next = Arrays . stream ( nexts ). min (). getAsInt (); for ( int i = 0 ; i < k ; ++ i ) if ( next == nexts [ i ] ) ++ indices [ i ] ; nums . add ( next ); } return nums . get ( nums . size () - 1 ); } } 314. Binary Tree Vertical Order Traversal $\\star\\star$ \ud83d\udd12 315. Count of Smaller Numbers After Self $\\star\\star\\star$ 316. Remove Duplicate Letters $\\star\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public String removeDuplicateLetters ( String s ) { StringBuilder ans = new StringBuilder (); int [] count = new int [ 26 ] ; boolean [] used = new boolean [ 26 ] ; for ( char c : s . toCharArray ()) ++ count [ c - 'a' ] ; for ( char c : s . toCharArray ()) { -- count [ c - 'a' ] ; if ( used [ c - 'a' ] ) continue ; while ( ans . length () > 0 && ans . charAt ( ans . length () - 1 ) > c && count [ ans . charAt ( ans . length () - 1 ) - 'a' ] > 0 ) { used [ ans . charAt ( ans . length () - 1 ) - 'a' ] = false ; ans . setLength ( ans . length () - 1 ); } ans . append ( c ); used [ c - 'a' ] = true ; } return ans . toString (); } } 317. Shortest Distance from All Buildings $\\star\\star\\star$ \ud83d\udd12 318. Maximum Product of Word Lengths $\\star\\star$ 319. Bulb Switcher $\\star\\star$ Time: $O(1)$ Space: $O(1)$ class Solution { public int bulbSwitch ( int n ) { return ( int ) Math . sqrt ( n ); } } 320. Generalized Abbreviation $\\star\\star$ \ud83d\udd12","title":"0311-0320"},{"location":"java/0301-0400/0311-0320/#311-sparse-matrix-multiplication-starstar","text":"","title":"311. Sparse Matrix Multiplication $\\star\\star$ \ud83d\udd12"},{"location":"java/0301-0400/0311-0320/#312-burst-balloons-starstarstar","text":"","title":"312. Burst Balloons $\\star\\star\\star$"},{"location":"java/0301-0400/0311-0320/#313-super-ugly-number-starstar","text":"Time: $O(n\\log k)$ Space: $O(k)$ class Solution { public int nthSuperUglyNumber ( int n , int [] primes ) { final int k = primes . length ; List < Integer > nums = new ArrayList <> (); nums . add ( 1 ); int [] indices = new int [ k ] ; while ( nums . size () < n ) { int [] nexts = new int [ k ] ; for ( int i = 0 ; i < k ; ++ i ) nexts [ i ] = nums . get ( indices [ i ] ) * primes [ i ] ; int next = Arrays . stream ( nexts ). min (). getAsInt (); for ( int i = 0 ; i < k ; ++ i ) if ( next == nexts [ i ] ) ++ indices [ i ] ; nums . add ( next ); } return nums . get ( nums . size () - 1 ); } }","title":"313. Super Ugly Number $\\star\\star$"},{"location":"java/0301-0400/0311-0320/#314-binary-tree-vertical-order-traversal-starstar","text":"","title":"314. Binary Tree Vertical Order Traversal $\\star\\star$ \ud83d\udd12"},{"location":"java/0301-0400/0311-0320/#315-count-of-smaller-numbers-after-self-starstarstar","text":"","title":"315. Count of Smaller Numbers After Self $\\star\\star\\star$"},{"location":"java/0301-0400/0311-0320/#316-remove-duplicate-letters-starstarstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public String removeDuplicateLetters ( String s ) { StringBuilder ans = new StringBuilder (); int [] count = new int [ 26 ] ; boolean [] used = new boolean [ 26 ] ; for ( char c : s . toCharArray ()) ++ count [ c - 'a' ] ; for ( char c : s . toCharArray ()) { -- count [ c - 'a' ] ; if ( used [ c - 'a' ] ) continue ; while ( ans . length () > 0 && ans . charAt ( ans . length () - 1 ) > c && count [ ans . charAt ( ans . length () - 1 ) - 'a' ] > 0 ) { used [ ans . charAt ( ans . length () - 1 ) - 'a' ] = false ; ans . setLength ( ans . length () - 1 ); } ans . append ( c ); used [ c - 'a' ] = true ; } return ans . toString (); } }","title":"316. Remove Duplicate Letters $\\star\\star\\star$"},{"location":"java/0301-0400/0311-0320/#317-shortest-distance-from-all-buildings-starstarstar","text":"","title":"317. Shortest Distance from All Buildings $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/0301-0400/0311-0320/#318-maximum-product-of-word-lengths-starstar","text":"","title":"318. Maximum Product of Word Lengths $\\star\\star$"},{"location":"java/0301-0400/0311-0320/#319-bulb-switcher-starstar","text":"Time: $O(1)$ Space: $O(1)$ class Solution { public int bulbSwitch ( int n ) { return ( int ) Math . sqrt ( n ); } }","title":"319. Bulb Switcher $\\star\\star$"},{"location":"java/0301-0400/0311-0320/#320-generalized-abbreviation-starstar","text":"","title":"320. Generalized Abbreviation $\\star\\star$ \ud83d\udd12"},{"location":"java/0301-0400/0321-0330/","text":"321. Create Maximum Number $\\star\\star\\star$ 322. Coin Change $\\star\\star$ Time: $O(nk)$, where n = len(coins) and k = amount Space: $O(k)$ class Solution { public int coinChange ( int [] coins , int amount ) { int [] dp = new int [ amount + 1 ] ; Arrays . fill ( dp , 1 , dp . length , amount + 1 ); for ( int i = 1 ; i < amount + 1 ; ++ i ) for ( int coin : coins ) if ( coin <= i ) dp [ i ] = Math . min ( dp [ i ] , dp [ i - coin ] + 1 ); return dp [ amount ] < amount + 1 ? dp [ amount ] : - 1 ; } } 323. Number of Connected Components in an Undirected Graph $\\star\\star$ \ud83d\udd12 324. Wiggle Sort II $\\star\\star$ 325. Maximum Size Subarray Sum Equals k $\\star\\star$ \ud83d\udd12 326. Power of Three $\\star$ class Solution { public boolean isPowerOfThree ( int n ) { return n > 0 && Math . pow ( 3 , 19 ) % n == 0 ; } } 327. Count of Range Sum $\\star\\star\\star$ 328. Odd Even Linked List $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public ListNode oddEvenList ( ListNode head ) { ListNode oddHead = new ListNode ( 0 ); ListNode evenHead = new ListNode ( 0 ); ListNode odd = oddHead ; ListNode even = evenHead ; for ( boolean isOdd = true ; head != null ; head = head . next , isOdd = ! isOdd ) { if ( isOdd ) { odd . next = head ; odd = head ; } else { even . next = head ; even = head ; } } even . next = null ; odd . next = evenHead . next ; return oddHead . next ; } } 329. Longest Increasing Path in a Matrix $\\star\\star\\star$ Time: $O(mn)$ Space: $O(mn)$ class Solution { public int longestIncreasingPath ( int [][] matrix ) { if ( matrix . length == 0 ) return 0 ; int ans = 0 ; int [][] cached = new int [ matrix . length ][ matrix [ 0 ] . length ] ; for ( int i = 0 ; i < matrix . length ; ++ i ) for ( int j = 0 ; j < matrix [ 0 ] . length ; ++ j ) ans = Math . max ( ans , dfs ( matrix , i , j , Integer . MIN_VALUE , cached )); return ans ; } private int dfs ( int [][] matrix , int i , int j , int max , int [][] cached ) { if ( i < 0 || i >= matrix . length || j < 0 || j >= matrix [ 0 ] . length || matrix [ i ][ j ] <= max ) return 0 ; if ( cached [ i ][ j ] != 0 ) return cached [ i ][ j ] ; int a = dfs ( matrix , i + 1 , j , matrix [ i ][ j ] , cached ); int b = dfs ( matrix , i - 1 , j , matrix [ i ][ j ] , cached ); int c = dfs ( matrix , i , j + 1 , matrix [ i ][ j ] , cached ); int d = dfs ( matrix , i , j - 1 , matrix [ i ][ j ] , cached ); cached [ i ][ j ] = 1 + Math . max ( Math . max ( a , b ), Math . max ( c , d )); return cached [ i ][ j ] ; } } 330. Patching Array $\\star\\star\\star$","title":"0321-0330"},{"location":"java/0301-0400/0321-0330/#321-create-maximum-number-starstarstar","text":"","title":"321. Create Maximum Number $\\star\\star\\star$"},{"location":"java/0301-0400/0321-0330/#322-coin-change-starstar","text":"Time: $O(nk)$, where n = len(coins) and k = amount Space: $O(k)$ class Solution { public int coinChange ( int [] coins , int amount ) { int [] dp = new int [ amount + 1 ] ; Arrays . fill ( dp , 1 , dp . length , amount + 1 ); for ( int i = 1 ; i < amount + 1 ; ++ i ) for ( int coin : coins ) if ( coin <= i ) dp [ i ] = Math . min ( dp [ i ] , dp [ i - coin ] + 1 ); return dp [ amount ] < amount + 1 ? dp [ amount ] : - 1 ; } }","title":"322. Coin Change $\\star\\star$"},{"location":"java/0301-0400/0321-0330/#323-number-of-connected-components-in-an-undirected-graph-starstar","text":"","title":"323. Number of Connected Components in an Undirected Graph $\\star\\star$ \ud83d\udd12"},{"location":"java/0301-0400/0321-0330/#324-wiggle-sort-ii-starstar","text":"","title":"324. Wiggle Sort II $\\star\\star$"},{"location":"java/0301-0400/0321-0330/#325-maximum-size-subarray-sum-equals-k-starstar","text":"","title":"325. Maximum Size Subarray Sum Equals k $\\star\\star$ \ud83d\udd12"},{"location":"java/0301-0400/0321-0330/#326-power-of-three-star","text":"class Solution { public boolean isPowerOfThree ( int n ) { return n > 0 && Math . pow ( 3 , 19 ) % n == 0 ; } }","title":"326. Power of Three $\\star$"},{"location":"java/0301-0400/0321-0330/#327-count-of-range-sum-starstarstar","text":"","title":"327. Count of Range Sum $\\star\\star\\star$"},{"location":"java/0301-0400/0321-0330/#328-odd-even-linked-list-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public ListNode oddEvenList ( ListNode head ) { ListNode oddHead = new ListNode ( 0 ); ListNode evenHead = new ListNode ( 0 ); ListNode odd = oddHead ; ListNode even = evenHead ; for ( boolean isOdd = true ; head != null ; head = head . next , isOdd = ! isOdd ) { if ( isOdd ) { odd . next = head ; odd = head ; } else { even . next = head ; even = head ; } } even . next = null ; odd . next = evenHead . next ; return oddHead . next ; } }","title":"328. Odd Even Linked List $\\star\\star$"},{"location":"java/0301-0400/0321-0330/#329-longest-increasing-path-in-a-matrix-starstarstar","text":"Time: $O(mn)$ Space: $O(mn)$ class Solution { public int longestIncreasingPath ( int [][] matrix ) { if ( matrix . length == 0 ) return 0 ; int ans = 0 ; int [][] cached = new int [ matrix . length ][ matrix [ 0 ] . length ] ; for ( int i = 0 ; i < matrix . length ; ++ i ) for ( int j = 0 ; j < matrix [ 0 ] . length ; ++ j ) ans = Math . max ( ans , dfs ( matrix , i , j , Integer . MIN_VALUE , cached )); return ans ; } private int dfs ( int [][] matrix , int i , int j , int max , int [][] cached ) { if ( i < 0 || i >= matrix . length || j < 0 || j >= matrix [ 0 ] . length || matrix [ i ][ j ] <= max ) return 0 ; if ( cached [ i ][ j ] != 0 ) return cached [ i ][ j ] ; int a = dfs ( matrix , i + 1 , j , matrix [ i ][ j ] , cached ); int b = dfs ( matrix , i - 1 , j , matrix [ i ][ j ] , cached ); int c = dfs ( matrix , i , j + 1 , matrix [ i ][ j ] , cached ); int d = dfs ( matrix , i , j - 1 , matrix [ i ][ j ] , cached ); cached [ i ][ j ] = 1 + Math . max ( Math . max ( a , b ), Math . max ( c , d )); return cached [ i ][ j ] ; } }","title":"329. Longest Increasing Path in a Matrix $\\star\\star\\star$"},{"location":"java/0301-0400/0321-0330/#330-patching-array-starstarstar","text":"","title":"330. Patching Array $\\star\\star\\star$"},{"location":"java/0301-0400/0331-0340/","text":"331. Verify Preorder Serialization of a Binary Tree $\\star\\star$ 332. Reconstruct Itinerary $\\star\\star$ Time: $O(|E|\\log |E|)$ Space: $O(|E|)$ class Solution { public List < String > findItinerary ( List < List < String >> tickets ) { List < String > ans = new LinkedList <> (); Map < String , PriorityQueue < String >> graph = new HashMap <> (); for ( final List < String > ticket : tickets ) graph . computeIfAbsent ( ticket . get ( 0 ), k -> new PriorityQueue <> ()). add ( ticket . get ( 1 )); dfs ( \"JFK\" , graph , ans ); return ans ; } private void dfs ( final String airport , Map < String , PriorityQueue < String >> graph , List < String > ans ) { while ( graph . containsKey ( airport ) && ! graph . get ( airport ). isEmpty ()) { String nextAirport = graph . get ( airport ). poll (); dfs ( nextAirport , graph , ans ); } ans . add ( 0 , airport ); } } 333. Largest BST Subtree $\\star\\star$ \ud83d\udd12 334. Increasing Triplet Subsequence $\\star\\star$ 335. Self Crossing $\\star\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public boolean isSelfCrossing ( int [] x ) { if ( x . length <= 3 ) return false ; for ( int i = 3 ; i < x . length ; ++ i ) { if ( x [ i - 2 ] <= x [ i ] && x [ i - 1 ] <= x [ i - 3 ] ) return true ; if ( i >= 4 && x [ i - 1 ] == x [ i - 3 ] && x [ i - 2 ] <= x [ i ] + x [ i - 4 ] ) return true ; if ( i >= 5 && x [ i - 4 ] <= x [ i - 2 ] && x [ i - 2 ] <= x [ i ] + x [ i - 4 ] && x [ i - 1 ] <= x [ i - 3 ] && x [ i - 3 ] <= x [ i - 1 ] + x [ i - 5 ] ) return true ; } return false ; } } 336. Palindrome Pairs $\\star\\star\\star$ Time: $O(nk^2)$, where n = len(words) and k = len(words[i]) Space: $O(nk)$ class Solution { public List < List < Integer >> palindromePairs ( String [] words ) { List < List < Integer >> ans = new ArrayList <> (); Map < String , Integer > map = new HashMap <> (); for ( int i = 0 ; i < words . length ; ++ i ) { StringBuilder sb = new StringBuilder ( words [ i ] ); map . put ( sb . reverse (). toString (), i ); } for ( int i = 0 ; i < words . length ; ++ i ) { if ( map . containsKey ( \"\" ) && map . get ( \"\" ) != i && isPalindrome ( words [ i ] )) ans . add ( Arrays . asList ( i , map . get ( \"\" ))); for ( int j = 1 ; j <= words [ i ] . length (); ++ j ) { String l = words [ i ] . substring ( 0 , j ); String r = words [ i ] . substring ( j , words [ i ] . length ()); if ( map . containsKey ( l ) && map . get ( l ) != i && isPalindrome ( r )) ans . add ( Arrays . asList ( i , map . get ( l ))); if ( map . containsKey ( r ) && map . get ( r ) != i && isPalindrome ( l )) ans . add ( Arrays . asList ( map . get ( r ), i )); } } return ans ; } private boolean isPalindrome ( String s ) { int l = 0 ; int r = s . length () - 1 ; while ( l < r ) if ( s . charAt ( l ++ ) != s . charAt ( r -- )) return false ; return true ; } } 337. House Robber III $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public int rob ( TreeNode root ) { int [] ans = helper ( root ); return Math . max ( ans [ 0 ] , ans [ 1 ] ); } private int [] helper ( TreeNode root ) { if ( root == null ) return new int [ 2 ] ; int [] robLeft = helper ( root . left ); int [] robRight = helper ( root . right ); return new int [] { root . val + robLeft [ 1 ] + robRight [ 1 ] , Math . max ( robLeft [ 0 ] , robLeft [ 1 ] ) + Math . max ( robRight [ 0 ] , robRight [ 1 ] ) }; } } 338. Counting Bits $\\star\\star$ 339. Nested List Weight Sum $\\star$ \ud83d\udd12 340. Longest Substring with At Most K Distinct Characters $\\star\\star\\star$ \ud83d\udd12","title":"0331-0340"},{"location":"java/0301-0400/0331-0340/#331-verify-preorder-serialization-of-a-binary-tree-starstar","text":"","title":"331. Verify Preorder Serialization of a Binary Tree $\\star\\star$"},{"location":"java/0301-0400/0331-0340/#332-reconstruct-itinerary-starstar","text":"Time: $O(|E|\\log |E|)$ Space: $O(|E|)$ class Solution { public List < String > findItinerary ( List < List < String >> tickets ) { List < String > ans = new LinkedList <> (); Map < String , PriorityQueue < String >> graph = new HashMap <> (); for ( final List < String > ticket : tickets ) graph . computeIfAbsent ( ticket . get ( 0 ), k -> new PriorityQueue <> ()). add ( ticket . get ( 1 )); dfs ( \"JFK\" , graph , ans ); return ans ; } private void dfs ( final String airport , Map < String , PriorityQueue < String >> graph , List < String > ans ) { while ( graph . containsKey ( airport ) && ! graph . get ( airport ). isEmpty ()) { String nextAirport = graph . get ( airport ). poll (); dfs ( nextAirport , graph , ans ); } ans . add ( 0 , airport ); } }","title":"332. Reconstruct Itinerary $\\star\\star$"},{"location":"java/0301-0400/0331-0340/#333-largest-bst-subtree-starstar","text":"","title":"333. Largest BST Subtree $\\star\\star$ \ud83d\udd12"},{"location":"java/0301-0400/0331-0340/#334-increasing-triplet-subsequence-starstar","text":"","title":"334. Increasing Triplet Subsequence $\\star\\star$"},{"location":"java/0301-0400/0331-0340/#335-self-crossing-starstarstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public boolean isSelfCrossing ( int [] x ) { if ( x . length <= 3 ) return false ; for ( int i = 3 ; i < x . length ; ++ i ) { if ( x [ i - 2 ] <= x [ i ] && x [ i - 1 ] <= x [ i - 3 ] ) return true ; if ( i >= 4 && x [ i - 1 ] == x [ i - 3 ] && x [ i - 2 ] <= x [ i ] + x [ i - 4 ] ) return true ; if ( i >= 5 && x [ i - 4 ] <= x [ i - 2 ] && x [ i - 2 ] <= x [ i ] + x [ i - 4 ] && x [ i - 1 ] <= x [ i - 3 ] && x [ i - 3 ] <= x [ i - 1 ] + x [ i - 5 ] ) return true ; } return false ; } }","title":"335. Self Crossing $\\star\\star\\star$"},{"location":"java/0301-0400/0331-0340/#336-palindrome-pairs-starstarstar","text":"Time: $O(nk^2)$, where n = len(words) and k = len(words[i]) Space: $O(nk)$ class Solution { public List < List < Integer >> palindromePairs ( String [] words ) { List < List < Integer >> ans = new ArrayList <> (); Map < String , Integer > map = new HashMap <> (); for ( int i = 0 ; i < words . length ; ++ i ) { StringBuilder sb = new StringBuilder ( words [ i ] ); map . put ( sb . reverse (). toString (), i ); } for ( int i = 0 ; i < words . length ; ++ i ) { if ( map . containsKey ( \"\" ) && map . get ( \"\" ) != i && isPalindrome ( words [ i ] )) ans . add ( Arrays . asList ( i , map . get ( \"\" ))); for ( int j = 1 ; j <= words [ i ] . length (); ++ j ) { String l = words [ i ] . substring ( 0 , j ); String r = words [ i ] . substring ( j , words [ i ] . length ()); if ( map . containsKey ( l ) && map . get ( l ) != i && isPalindrome ( r )) ans . add ( Arrays . asList ( i , map . get ( l ))); if ( map . containsKey ( r ) && map . get ( r ) != i && isPalindrome ( l )) ans . add ( Arrays . asList ( map . get ( r ), i )); } } return ans ; } private boolean isPalindrome ( String s ) { int l = 0 ; int r = s . length () - 1 ; while ( l < r ) if ( s . charAt ( l ++ ) != s . charAt ( r -- )) return false ; return true ; } }","title":"336. Palindrome Pairs $\\star\\star\\star$"},{"location":"java/0301-0400/0331-0340/#337-house-robber-iii-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public int rob ( TreeNode root ) { int [] ans = helper ( root ); return Math . max ( ans [ 0 ] , ans [ 1 ] ); } private int [] helper ( TreeNode root ) { if ( root == null ) return new int [ 2 ] ; int [] robLeft = helper ( root . left ); int [] robRight = helper ( root . right ); return new int [] { root . val + robLeft [ 1 ] + robRight [ 1 ] , Math . max ( robLeft [ 0 ] , robLeft [ 1 ] ) + Math . max ( robRight [ 0 ] , robRight [ 1 ] ) }; } }","title":"337. House Robber III $\\star\\star$"},{"location":"java/0301-0400/0331-0340/#338-counting-bits-starstar","text":"","title":"338. Counting Bits $\\star\\star$"},{"location":"java/0301-0400/0331-0340/#339-nested-list-weight-sum-star","text":"","title":"339. Nested List Weight Sum $\\star$ \ud83d\udd12"},{"location":"java/0301-0400/0331-0340/#340-longest-substring-with-at-most-k-distinct-characters-starstarstar","text":"","title":"340. Longest Substring with At Most K Distinct Characters $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/0301-0400/0341-0350/","text":"341. Flatten Nested List Iterator $\\star\\star$ 342. Power of Four $\\star$ 343. Integer Break $\\star\\star$ Time: $O(n / 3)$ Space: $O(1)$ class Solution { public int integerBreak ( int n ) { if ( n == 2 ) return 1 ; if ( n == 3 ) return 2 ; int ans = 1 ; while ( n > 4 ) { n -= 3 ; ans *= 3 ; } ans *= n ; return ans ; } } 344. Reverse String $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public void reverseString ( char [] s ) { int l = 0 ; int r = s . length - 1 ; while ( l < r ) { char temp = s [ l ] ; s [ l ++] = s [ r ] ; s [ r --] = temp ; } } } 345. Reverse Vowels of a String $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public String reverseVowels ( String s ) { String vowels = \"aeiouAEIOU\" ; char [] charArray = s . toCharArray (); int l = 0 ; int r = s . length () - 1 ; while ( l < r ) { while ( l < r && ! vowels . contains ( \"\" + charArray [ l ] )) ++ l ; while ( l < r && ! vowels . contains ( \"\" + charArray [ r ] )) -- r ; char temp = charArray [ l ] ; charArray [ l ++] = charArray [ r ] ; charArray [ r --] = temp ; } return String . valueOf ( charArray ); } } 346. Moving Average from Data Stream $\\star$ \ud83d\udd12 347. Top K Frequent Elements $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public List < Integer > topKFrequent ( int [] nums , int k ) { List < Integer > ans = new ArrayList <> (); List < Integer >[] bucket = new List [ nums . length + 1 ] ; Map < Integer , Integer > count = new HashMap <> (); for ( int num : nums ) count . put ( num , count . getOrDefault ( num , 0 ) + 1 ); for ( int num : count . keySet ()) { int freq = count . get ( num ); if ( bucket [ freq ] == null ) bucket [ freq ] = new ArrayList <> (); bucket [ freq ] . add ( num ); } for ( int freq = bucket . length - 1 ; freq >= 0 ; -- freq ) { if ( bucket [ freq ] != null ) ans . addAll ( bucket [ freq ] ); if ( ans . size () == k ) return ans ; } throw new IllegalArgumentException (); } } 348. Design Tic-Tac-Toe $\\star\\star$ \ud83d\udd12 349. Intersection of Two Arrays $\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public int [] intersection ( int [] nums1 , int [] nums2 ) { List < Integer > ans = new ArrayList <> (); Set < Integer > set = new HashSet <> (); for ( int num : nums1 ) set . add ( num ); for ( int num : nums2 ) if ( set . remove ( num )) ans . add ( num ); return ans . stream (). mapToInt ( i -> i ). toArray (); } } 350. Intersection of Two Arrays II $\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public int [] intersect ( int [] nums1 , int [] nums2 ) { List < Integer > ans = new ArrayList <> (); Map < Integer , Integer > count = new HashMap <> (); for ( int num : nums1 ) count . put ( num , count . getOrDefault ( num , 0 ) + 1 ); for ( int num : nums2 ) if ( count . getOrDefault ( num , 0 ) > 0 ) { ans . add ( num ); count . put ( num , count . get ( num ) - 1 ); } return ans . stream (). mapToInt ( i -> i ). toArray (); } }","title":"0341-0350"},{"location":"java/0301-0400/0341-0350/#341-flatten-nested-list-iterator-starstar","text":"","title":"341. Flatten Nested List Iterator $\\star\\star$"},{"location":"java/0301-0400/0341-0350/#342-power-of-four-star","text":"","title":"342. Power of Four $\\star$"},{"location":"java/0301-0400/0341-0350/#343-integer-break-starstar","text":"Time: $O(n / 3)$ Space: $O(1)$ class Solution { public int integerBreak ( int n ) { if ( n == 2 ) return 1 ; if ( n == 3 ) return 2 ; int ans = 1 ; while ( n > 4 ) { n -= 3 ; ans *= 3 ; } ans *= n ; return ans ; } }","title":"343. Integer Break $\\star\\star$"},{"location":"java/0301-0400/0341-0350/#344-reverse-string-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public void reverseString ( char [] s ) { int l = 0 ; int r = s . length - 1 ; while ( l < r ) { char temp = s [ l ] ; s [ l ++] = s [ r ] ; s [ r --] = temp ; } } }","title":"344. Reverse String $\\star$"},{"location":"java/0301-0400/0341-0350/#345-reverse-vowels-of-a-string-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public String reverseVowels ( String s ) { String vowels = \"aeiouAEIOU\" ; char [] charArray = s . toCharArray (); int l = 0 ; int r = s . length () - 1 ; while ( l < r ) { while ( l < r && ! vowels . contains ( \"\" + charArray [ l ] )) ++ l ; while ( l < r && ! vowels . contains ( \"\" + charArray [ r ] )) -- r ; char temp = charArray [ l ] ; charArray [ l ++] = charArray [ r ] ; charArray [ r --] = temp ; } return String . valueOf ( charArray ); } }","title":"345. Reverse Vowels of a String $\\star$"},{"location":"java/0301-0400/0341-0350/#346-moving-average-from-data-stream-star","text":"","title":"346. Moving Average from Data Stream $\\star$ \ud83d\udd12"},{"location":"java/0301-0400/0341-0350/#347-top-k-frequent-elements-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public List < Integer > topKFrequent ( int [] nums , int k ) { List < Integer > ans = new ArrayList <> (); List < Integer >[] bucket = new List [ nums . length + 1 ] ; Map < Integer , Integer > count = new HashMap <> (); for ( int num : nums ) count . put ( num , count . getOrDefault ( num , 0 ) + 1 ); for ( int num : count . keySet ()) { int freq = count . get ( num ); if ( bucket [ freq ] == null ) bucket [ freq ] = new ArrayList <> (); bucket [ freq ] . add ( num ); } for ( int freq = bucket . length - 1 ; freq >= 0 ; -- freq ) { if ( bucket [ freq ] != null ) ans . addAll ( bucket [ freq ] ); if ( ans . size () == k ) return ans ; } throw new IllegalArgumentException (); } }","title":"347. Top K Frequent Elements $\\star\\star$"},{"location":"java/0301-0400/0341-0350/#348-design-tic-tac-toe-starstar","text":"","title":"348. Design Tic-Tac-Toe $\\star\\star$ \ud83d\udd12"},{"location":"java/0301-0400/0341-0350/#349-intersection-of-two-arrays-star","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public int [] intersection ( int [] nums1 , int [] nums2 ) { List < Integer > ans = new ArrayList <> (); Set < Integer > set = new HashSet <> (); for ( int num : nums1 ) set . add ( num ); for ( int num : nums2 ) if ( set . remove ( num )) ans . add ( num ); return ans . stream (). mapToInt ( i -> i ). toArray (); } }","title":"349. Intersection of Two Arrays $\\star$"},{"location":"java/0301-0400/0341-0350/#350-intersection-of-two-arrays-ii-star","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public int [] intersect ( int [] nums1 , int [] nums2 ) { List < Integer > ans = new ArrayList <> (); Map < Integer , Integer > count = new HashMap <> (); for ( int num : nums1 ) count . put ( num , count . getOrDefault ( num , 0 ) + 1 ); for ( int num : nums2 ) if ( count . getOrDefault ( num , 0 ) > 0 ) { ans . add ( num ); count . put ( num , count . get ( num ) - 1 ); } return ans . stream (). mapToInt ( i -> i ). toArray (); } }","title":"350. Intersection of Two Arrays II $\\star$"},{"location":"java/0301-0400/0351-0360/","text":"351. Android Unlock Patterns $\\star\\star$ \ud83d\udd12 352. Data Stream as Disjoint Intervals $\\star\\star\\star$ 353. Design Snake Game $\\star\\star$ \ud83d\udd12 354. Russian Doll Envelopes $\\star\\star\\star$ 355. Design Twitter $\\star\\star$ Time: $O(n + k\\log n)$, where n = len(tweets) and k = min(10, len(tweets)) Space: $O(n)$ class Twitter { public void postTweet ( int userId , int tweetId ) { if ( ! tweets . containsKey ( userId )) tweets . put ( userId , new LinkedList <> ()); tweets . get ( userId ). addFirst ( new Pair <> ( timer ++ , tweetId )); if ( tweets . get ( userId ). size () > 10 ) tweets . get ( userId ). removeLast (); } public List < Integer > getNewsFeed ( int userId ) { List < Integer > ans = new ArrayList <> (); Queue < Pair < Integer , Integer >> pq = new PriorityQueue <> (( t1 , t2 ) -> t2 . getKey () - t1 . getKey ()); for ( Pair < Integer , Integer > tweet : tweets . getOrDefault ( userId , new LinkedList <> ())) pq . add ( tweet ); for ( Integer followee : followees . getOrDefault ( userId , new HashSet <> ())) for ( Pair < Integer , Integer > tweet : tweets . getOrDefault ( followee , new LinkedList <> ())) pq . add ( tweet ); for ( int i = Math . min ( 10 , pq . size ()); i > 0 ; -- i ) ans . add ( pq . poll (). getValue ()); return ans ; } public void follow ( int followerId , int followeeId ) { if ( followerId == followeeId ) return ; if ( ! followees . containsKey ( followerId )) followees . put ( followerId , new HashSet <> ()); followees . get ( followerId ). add ( followeeId ); } public void unfollow ( int followerId , int followeeId ) { if ( followerId == followeeId ) return ; if ( followees . containsKey ( followerId )) if ( followees . get ( followerId ). contains ( followeeId )) followees . get ( followerId ). remove ( followeeId ); } private int timer = 0 ; private Map < Integer , Deque < Pair < Integer , Integer >>> tweets = new HashMap <> (); private Map < Integer , Set < Integer >> followees = new HashMap <> (); } 356. Line Reflection $\\star\\star$ \ud83d\udd12 357. Count Numbers with Unique Digits $\\star\\star$ Time: $O(9)$ Space: $O(1)$ class Solution { public int countNumbersWithUniqueDigits ( int n ) { if ( n == 0 ) return 1 ; int ans = 10 ; int uniqueDigits = 9 ; for ( int availableNum = 9 ; n > 1 && availableNum > 0 ; -- n , -- availableNum ) { uniqueDigits *= availableNum ; ans += uniqueDigits ; } return ans ; } } 358. Rearrange String k Distance Apart $\\star\\star\\star$ \ud83d\udd12 359. Logger Rate Limiter $\\star$ \ud83d\udd12 360. Sort Transformed Array $\\star\\star$ \ud83d\udd12","title":"0351-0360"},{"location":"java/0301-0400/0351-0360/#351-android-unlock-patterns-starstar","text":"","title":"351. Android Unlock Patterns $\\star\\star$ \ud83d\udd12"},{"location":"java/0301-0400/0351-0360/#352-data-stream-as-disjoint-intervals-starstarstar","text":"","title":"352. Data Stream as Disjoint Intervals $\\star\\star\\star$"},{"location":"java/0301-0400/0351-0360/#353-design-snake-game-starstar","text":"","title":"353. Design Snake Game $\\star\\star$ \ud83d\udd12"},{"location":"java/0301-0400/0351-0360/#354-russian-doll-envelopes-starstarstar","text":"","title":"354. Russian Doll Envelopes $\\star\\star\\star$"},{"location":"java/0301-0400/0351-0360/#355-design-twitter-starstar","text":"Time: $O(n + k\\log n)$, where n = len(tweets) and k = min(10, len(tweets)) Space: $O(n)$ class Twitter { public void postTweet ( int userId , int tweetId ) { if ( ! tweets . containsKey ( userId )) tweets . put ( userId , new LinkedList <> ()); tweets . get ( userId ). addFirst ( new Pair <> ( timer ++ , tweetId )); if ( tweets . get ( userId ). size () > 10 ) tweets . get ( userId ). removeLast (); } public List < Integer > getNewsFeed ( int userId ) { List < Integer > ans = new ArrayList <> (); Queue < Pair < Integer , Integer >> pq = new PriorityQueue <> (( t1 , t2 ) -> t2 . getKey () - t1 . getKey ()); for ( Pair < Integer , Integer > tweet : tweets . getOrDefault ( userId , new LinkedList <> ())) pq . add ( tweet ); for ( Integer followee : followees . getOrDefault ( userId , new HashSet <> ())) for ( Pair < Integer , Integer > tweet : tweets . getOrDefault ( followee , new LinkedList <> ())) pq . add ( tweet ); for ( int i = Math . min ( 10 , pq . size ()); i > 0 ; -- i ) ans . add ( pq . poll (). getValue ()); return ans ; } public void follow ( int followerId , int followeeId ) { if ( followerId == followeeId ) return ; if ( ! followees . containsKey ( followerId )) followees . put ( followerId , new HashSet <> ()); followees . get ( followerId ). add ( followeeId ); } public void unfollow ( int followerId , int followeeId ) { if ( followerId == followeeId ) return ; if ( followees . containsKey ( followerId )) if ( followees . get ( followerId ). contains ( followeeId )) followees . get ( followerId ). remove ( followeeId ); } private int timer = 0 ; private Map < Integer , Deque < Pair < Integer , Integer >>> tweets = new HashMap <> (); private Map < Integer , Set < Integer >> followees = new HashMap <> (); }","title":"355. Design Twitter $\\star\\star$"},{"location":"java/0301-0400/0351-0360/#356-line-reflection-starstar","text":"","title":"356. Line Reflection $\\star\\star$ \ud83d\udd12"},{"location":"java/0301-0400/0351-0360/#357-count-numbers-with-unique-digits-starstar","text":"Time: $O(9)$ Space: $O(1)$ class Solution { public int countNumbersWithUniqueDigits ( int n ) { if ( n == 0 ) return 1 ; int ans = 10 ; int uniqueDigits = 9 ; for ( int availableNum = 9 ; n > 1 && availableNum > 0 ; -- n , -- availableNum ) { uniqueDigits *= availableNum ; ans += uniqueDigits ; } return ans ; } }","title":"357. Count Numbers with Unique Digits $\\star\\star$"},{"location":"java/0301-0400/0351-0360/#358-rearrange-string-k-distance-apart-starstarstar","text":"","title":"358. Rearrange String k Distance Apart $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/0301-0400/0351-0360/#359-logger-rate-limiter-star","text":"","title":"359. Logger Rate Limiter $\\star$ \ud83d\udd12"},{"location":"java/0301-0400/0351-0360/#360-sort-transformed-array-starstar","text":"","title":"360. Sort Transformed Array $\\star\\star$ \ud83d\udd12"},{"location":"java/0301-0400/0361-0370/","text":"361. Bomb Enemy $\\star\\star$ \ud83d\udd12 362. Design Hit Counter $\\star\\star$ \ud83d\udd12 363. Max Sum of Rectangle No Larger Than K $\\star\\star\\star$ 364. Nested List Weight Sum II $\\star\\star$ \ud83d\udd12 365. Water and Jug Problem $\\star\\star$ Time: $O(1)$ Space: $O(1)$ class Solution { public boolean canMeasureWater ( int x , int y , int z ) { return z == 0 || ( long ) x + y >= z && z % gcd ( x , y ) == 0 ; } private int gcd ( int x , int y ) { return y == 0 ? x : gcd ( y , x % y ); } } 366. Find Leaves of Binary Tree $\\star\\star$ \ud83d\udd12 367. Valid Perfect Square $\\star$ Time: $O(\\log num)$ Space: $O(1)$ class Solution { public boolean isPerfectSquare ( long num ) { long l = 1 ; long r = num + 1 ; while ( l < r ) { long m = l + ( r - l ) / 2 ; if ( m > num / m ) r = m ; else l = m + 1 ; } return ( l - 1 ) * ( l - 1 ) == num ; } } 368. Largest Divisible Subset $\\star\\star$ Time: $O(n^2)$ Space: $O(n)$ class Solution { public List < Integer > largestDivisibleSubset ( int [] nums ) { final int n = nums . length ; List < Integer > ans = new ArrayList <> (); int [] count = new int [ n ] ; int [] prevIndex = new int [ n ] ; int maxCount = 0 ; int index = - 1 ; Arrays . fill ( count , 1 ); Arrays . fill ( prevIndex , - 1 ); Arrays . sort ( nums ); for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i - 1 ; j >= 0 ; -- j ) if ( nums [ i ] % nums [ j ] == 0 && count [ i ] < count [ j ] + 1 ) { count [ i ] = count [ j ] + 1 ; prevIndex [ i ] = j ; } if ( count [ i ] > maxCount ) { maxCount = count [ i ] ; index = i ; } } while ( index != - 1 ) { ans . add ( nums [ index ] ); index = prevIndex [ index ] ; } return ans ; } } 369. Plus One Linked List $\\star\\star$ \ud83d\udd12 370. Range Addition $\\star\\star$ \ud83d\udd12","title":"0361-0370"},{"location":"java/0301-0400/0361-0370/#361-bomb-enemy-starstar","text":"","title":"361. Bomb Enemy $\\star\\star$ \ud83d\udd12"},{"location":"java/0301-0400/0361-0370/#362-design-hit-counter-starstar","text":"","title":"362. Design Hit Counter $\\star\\star$ \ud83d\udd12"},{"location":"java/0301-0400/0361-0370/#363-max-sum-of-rectangle-no-larger-than-k-starstarstar","text":"","title":"363. Max Sum of Rectangle No Larger Than K $\\star\\star\\star$"},{"location":"java/0301-0400/0361-0370/#364-nested-list-weight-sum-ii-starstar","text":"","title":"364. Nested List Weight Sum II $\\star\\star$ \ud83d\udd12"},{"location":"java/0301-0400/0361-0370/#365-water-and-jug-problem-starstar","text":"Time: $O(1)$ Space: $O(1)$ class Solution { public boolean canMeasureWater ( int x , int y , int z ) { return z == 0 || ( long ) x + y >= z && z % gcd ( x , y ) == 0 ; } private int gcd ( int x , int y ) { return y == 0 ? x : gcd ( y , x % y ); } }","title":"365. Water and Jug Problem $\\star\\star$"},{"location":"java/0301-0400/0361-0370/#366-find-leaves-of-binary-tree-starstar","text":"","title":"366. Find Leaves of Binary Tree $\\star\\star$ \ud83d\udd12"},{"location":"java/0301-0400/0361-0370/#367-valid-perfect-square-star","text":"Time: $O(\\log num)$ Space: $O(1)$ class Solution { public boolean isPerfectSquare ( long num ) { long l = 1 ; long r = num + 1 ; while ( l < r ) { long m = l + ( r - l ) / 2 ; if ( m > num / m ) r = m ; else l = m + 1 ; } return ( l - 1 ) * ( l - 1 ) == num ; } }","title":"367. Valid Perfect Square $\\star$"},{"location":"java/0301-0400/0361-0370/#368-largest-divisible-subset-starstar","text":"Time: $O(n^2)$ Space: $O(n)$ class Solution { public List < Integer > largestDivisibleSubset ( int [] nums ) { final int n = nums . length ; List < Integer > ans = new ArrayList <> (); int [] count = new int [ n ] ; int [] prevIndex = new int [ n ] ; int maxCount = 0 ; int index = - 1 ; Arrays . fill ( count , 1 ); Arrays . fill ( prevIndex , - 1 ); Arrays . sort ( nums ); for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i - 1 ; j >= 0 ; -- j ) if ( nums [ i ] % nums [ j ] == 0 && count [ i ] < count [ j ] + 1 ) { count [ i ] = count [ j ] + 1 ; prevIndex [ i ] = j ; } if ( count [ i ] > maxCount ) { maxCount = count [ i ] ; index = i ; } } while ( index != - 1 ) { ans . add ( nums [ index ] ); index = prevIndex [ index ] ; } return ans ; } }","title":"368. Largest Divisible Subset $\\star\\star$"},{"location":"java/0301-0400/0361-0370/#369-plus-one-linked-list-starstar","text":"","title":"369. Plus One Linked List $\\star\\star$ \ud83d\udd12"},{"location":"java/0301-0400/0361-0370/#370-range-addition-starstar","text":"","title":"370. Range Addition $\\star\\star$ \ud83d\udd12"},{"location":"java/0301-0400/0371-0380/","text":"371. Sum of Two Integers $\\star$ 372. Super Pow $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public int superPow ( int a , int [] b ) { int ans = 1 ; a %= k ; for ( int i : b ) ans = powMod ( ans , 10 ) * powMod ( a , i ) % k ; return ans ; } private final int k = 1337 ; private int powMod ( int x , int y ) { int pow = 1 ; for ( int i = 0 ; i < y ; ++ i ) pow = ( pow * x ) % k ; return pow ; } } 373. Find K Pairs with Smallest Sums $\\star\\star$ Time: $O(k\\log k)$ Space: $O(k)$ class Solution { public List < List < Integer >> kSmallestPairs ( int [] nums1 , int [] nums2 , int k ) { if ( nums1 . length == 0 || nums2 . length == 0 || k == 0 ) return new ArrayList <> (); List < List < Integer >> ans = new ArrayList <> (); PriorityQueue < int []> pq = new PriorityQueue <> (( a , b ) -> ( nums1 [ a [ 0 ]] + nums2 [ a [ 1 ]] ) - ( nums1 [ b [ 0 ]] + nums2 [ b [ 1 ]] )); for ( int i = 0 ; i < nums1 . length && i < k ; ++ i ) pq . offer ( new int [] { i , 0 }); while ( k -- > 0 && ! pq . isEmpty ()) { int [] index = pq . poll (); ans . add ( Arrays . asList ( nums1 [ index [ 0 ]] , nums2 [ index [ 1 ]] )); if ( index [ 1 ] < nums2 . length - 1 ) pq . offer ( new int [] { index [ 0 ] , index [ 1 ] + 1 }); } return ans ; } } 374. Guess Number Higher or Lower $\\star$ 375. Guess Number Higher or Lower II $\\star\\star$ 376. Wiggle Subsequence $\\star\\star$ 377. Combination Sum IV $\\star\\star$ 378. Kth Smallest Element in a Sorted Matrix $\\star\\star$ 379. Design Phone Directory $\\star\\star$ \ud83d\udd12 380. Insert Delete GetRandom O(1) $\\star\\star$ class RandomizedSet { public boolean insert ( int val ) { if ( map . containsKey ( val )) return false ; map . put ( val , vals . size ()); vals . add ( val ); return true ; } public boolean remove ( int val ) { if ( ! map . containsKey ( val )) return false ; int index = map . get ( val ); map . put ( vals . get ( vals . size () - 1 ), index ); map . remove ( val ); vals . set ( index , vals . get ( vals . size () - 1 )); vals . remove ( vals . size () - 1 ); return true ; } public int getRandom () { int index = rand . nextInt ( vals . size ()); return vals . get ( index ); } private List < Integer > vals = new ArrayList <> (); private Map < Integer , Integer > map = new HashMap <> (); private Random rand = new Random (); }","title":"0371-0380"},{"location":"java/0301-0400/0371-0380/#371-sum-of-two-integers-star","text":"","title":"371. Sum of Two Integers $\\star$"},{"location":"java/0301-0400/0371-0380/#372-super-pow-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public int superPow ( int a , int [] b ) { int ans = 1 ; a %= k ; for ( int i : b ) ans = powMod ( ans , 10 ) * powMod ( a , i ) % k ; return ans ; } private final int k = 1337 ; private int powMod ( int x , int y ) { int pow = 1 ; for ( int i = 0 ; i < y ; ++ i ) pow = ( pow * x ) % k ; return pow ; } }","title":"372. Super Pow $\\star\\star$"},{"location":"java/0301-0400/0371-0380/#373-find-k-pairs-with-smallest-sums-starstar","text":"Time: $O(k\\log k)$ Space: $O(k)$ class Solution { public List < List < Integer >> kSmallestPairs ( int [] nums1 , int [] nums2 , int k ) { if ( nums1 . length == 0 || nums2 . length == 0 || k == 0 ) return new ArrayList <> (); List < List < Integer >> ans = new ArrayList <> (); PriorityQueue < int []> pq = new PriorityQueue <> (( a , b ) -> ( nums1 [ a [ 0 ]] + nums2 [ a [ 1 ]] ) - ( nums1 [ b [ 0 ]] + nums2 [ b [ 1 ]] )); for ( int i = 0 ; i < nums1 . length && i < k ; ++ i ) pq . offer ( new int [] { i , 0 }); while ( k -- > 0 && ! pq . isEmpty ()) { int [] index = pq . poll (); ans . add ( Arrays . asList ( nums1 [ index [ 0 ]] , nums2 [ index [ 1 ]] )); if ( index [ 1 ] < nums2 . length - 1 ) pq . offer ( new int [] { index [ 0 ] , index [ 1 ] + 1 }); } return ans ; } }","title":"373. Find K Pairs with Smallest Sums $\\star\\star$"},{"location":"java/0301-0400/0371-0380/#374-guess-number-higher-or-lower-star","text":"","title":"374. Guess Number Higher or Lower $\\star$"},{"location":"java/0301-0400/0371-0380/#375-guess-number-higher-or-lower-ii-starstar","text":"","title":"375. Guess Number Higher or Lower II $\\star\\star$"},{"location":"java/0301-0400/0371-0380/#376-wiggle-subsequence-starstar","text":"","title":"376. Wiggle Subsequence $\\star\\star$"},{"location":"java/0301-0400/0371-0380/#377-combination-sum-iv-starstar","text":"","title":"377. Combination Sum IV $\\star\\star$"},{"location":"java/0301-0400/0371-0380/#378-kth-smallest-element-in-a-sorted-matrix-starstar","text":"","title":"378. Kth Smallest Element in a Sorted Matrix $\\star\\star$"},{"location":"java/0301-0400/0371-0380/#379-design-phone-directory-starstar","text":"","title":"379. Design Phone Directory $\\star\\star$ \ud83d\udd12"},{"location":"java/0301-0400/0371-0380/#380-insert-delete-getrandom-o1-starstar","text":"class RandomizedSet { public boolean insert ( int val ) { if ( map . containsKey ( val )) return false ; map . put ( val , vals . size ()); vals . add ( val ); return true ; } public boolean remove ( int val ) { if ( ! map . containsKey ( val )) return false ; int index = map . get ( val ); map . put ( vals . get ( vals . size () - 1 ), index ); map . remove ( val ); vals . set ( index , vals . get ( vals . size () - 1 )); vals . remove ( vals . size () - 1 ); return true ; } public int getRandom () { int index = rand . nextInt ( vals . size ()); return vals . get ( index ); } private List < Integer > vals = new ArrayList <> (); private Map < Integer , Integer > map = new HashMap <> (); private Random rand = new Random (); }","title":"380. Insert Delete GetRandom O(1) $\\star\\star$"},{"location":"java/0301-0400/0381-0390/","text":"381. Insert Delete GetRandom O(1) - Duplicates allowed $\\star\\star\\star$ class RandomizedCollection { public boolean insert ( int val ) { if ( ! map . containsKey ( val )) map . put ( val , new LinkedHashSet <> ()); map . get ( val ). add ( vals . size ()); vals . add ( val ); return map . get ( val ). size () == 1 ; } public boolean remove ( int val ) { if ( ! map . containsKey ( val ) || map . get ( val ). isEmpty ()) return false ; int index = map . get ( val ). iterator (). next (); int lastVal = vals . get ( vals . size () - 1 ); vals . set ( index , lastVal ); vals . remove ( vals . size () - 1 ); map . get ( val ). remove ( index ); map . get ( lastVal ). add ( index ); map . get ( lastVal ). remove ( vals . size ()); return true ; } public int getRandom () { int index = rand . nextInt ( vals . size ()); return vals . get ( index ); } private List < Integer > vals = new ArrayList <> (); private Map < Integer , LinkedHashSet < Integer >> map = new HashMap <> (); private Random rand = new Random (); } 382. Linked List Random Node $\\star\\star$ 383. Ransom Note $\\star$ Time: $O(n + m)$, where n = ransomNote and m = magazine Space: $O(26)$ class Solution { public boolean canConstruct ( String ransomNote , String magazine ) { int [] count = new int [ 26 ] ; for ( char c : magazine . toCharArray ()) ++ count [ c - 'a' ] ; for ( char c : ransomNote . toCharArray ()) if ( -- count [ c - 'a' ] < 0 ) return false ; return true ; } } 384. Shuffle an Array $\\star\\star$ 385. Mini Parser $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public NestedInteger deserialize ( String s ) { if ( s . charAt ( 0 ) != '[' ) return new NestedInteger ( Integer . valueOf ( s )); Stack < NestedInteger > stack = new Stack <> (); int start = 1 ; for ( int i = 0 ; i < s . length (); ++ i ) switch ( s . charAt ( i )) { case '[' : stack . push ( new NestedInteger ()); start = i + 1 ; break ; case ',' : if ( i > start ) { int num = Integer . valueOf ( s . substring ( start , i )); stack . peek (). add ( new NestedInteger ( num )); } start = i + 1 ; break ; case ']' : NestedInteger popped = stack . pop (); if ( i > start ) { int num = Integer . valueOf ( s . substring ( start , i )); popped . add ( new NestedInteger ( num )); } if ( ! stack . isEmpty ()) stack . peek (). add ( popped ); else return popped ; start = i + 1 ; break ; } throw new IllegalArgumentException (); } } 386. Lexicographical Numbers $\\star\\star$ 387. First Unique Character in a String $\\star$ Time: $O(n)$ Space: $O(26)$ class Solution { public int firstUniqChar ( String s ) { int [] count = new int [ 26 ] ; for ( char c : s . toCharArray ()) ++ count [ c - 'a' ] ; for ( int i = 0 ; i < s . length (); ++ i ) if ( count [ s . charAt ( i ) - 'a' ] == 1 ) return i ; return - 1 ; } } 388. Longest Absolute File Path $\\star\\star$ 389. Find the Difference $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public char findTheDifference ( String s , String t ) { int [] count = new int [ 26 ] ; for ( char c : s . toCharArray ()) ++ count [ c - 'a' ] ; for ( int i = 0 ; i < t . length (); ++ i ) if ( -- count [ t . charAt ( i ) - 'a' ] < 0 ) return t . charAt ( i ); throw new IllegalArgumentException (); } } 390. Elimination Game $\\star\\star$","title":"0381-0390"},{"location":"java/0301-0400/0381-0390/#381-insert-delete-getrandom-o1-duplicates-allowed-starstarstar","text":"class RandomizedCollection { public boolean insert ( int val ) { if ( ! map . containsKey ( val )) map . put ( val , new LinkedHashSet <> ()); map . get ( val ). add ( vals . size ()); vals . add ( val ); return map . get ( val ). size () == 1 ; } public boolean remove ( int val ) { if ( ! map . containsKey ( val ) || map . get ( val ). isEmpty ()) return false ; int index = map . get ( val ). iterator (). next (); int lastVal = vals . get ( vals . size () - 1 ); vals . set ( index , lastVal ); vals . remove ( vals . size () - 1 ); map . get ( val ). remove ( index ); map . get ( lastVal ). add ( index ); map . get ( lastVal ). remove ( vals . size ()); return true ; } public int getRandom () { int index = rand . nextInt ( vals . size ()); return vals . get ( index ); } private List < Integer > vals = new ArrayList <> (); private Map < Integer , LinkedHashSet < Integer >> map = new HashMap <> (); private Random rand = new Random (); }","title":"381. Insert Delete GetRandom O(1) - Duplicates allowed $\\star\\star\\star$"},{"location":"java/0301-0400/0381-0390/#382-linked-list-random-node-starstar","text":"","title":"382. Linked List Random Node $\\star\\star$"},{"location":"java/0301-0400/0381-0390/#383-ransom-note-star","text":"Time: $O(n + m)$, where n = ransomNote and m = magazine Space: $O(26)$ class Solution { public boolean canConstruct ( String ransomNote , String magazine ) { int [] count = new int [ 26 ] ; for ( char c : magazine . toCharArray ()) ++ count [ c - 'a' ] ; for ( char c : ransomNote . toCharArray ()) if ( -- count [ c - 'a' ] < 0 ) return false ; return true ; } }","title":"383. Ransom Note $\\star$"},{"location":"java/0301-0400/0381-0390/#384-shuffle-an-array-starstar","text":"","title":"384. Shuffle an Array $\\star\\star$"},{"location":"java/0301-0400/0381-0390/#385-mini-parser-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public NestedInteger deserialize ( String s ) { if ( s . charAt ( 0 ) != '[' ) return new NestedInteger ( Integer . valueOf ( s )); Stack < NestedInteger > stack = new Stack <> (); int start = 1 ; for ( int i = 0 ; i < s . length (); ++ i ) switch ( s . charAt ( i )) { case '[' : stack . push ( new NestedInteger ()); start = i + 1 ; break ; case ',' : if ( i > start ) { int num = Integer . valueOf ( s . substring ( start , i )); stack . peek (). add ( new NestedInteger ( num )); } start = i + 1 ; break ; case ']' : NestedInteger popped = stack . pop (); if ( i > start ) { int num = Integer . valueOf ( s . substring ( start , i )); popped . add ( new NestedInteger ( num )); } if ( ! stack . isEmpty ()) stack . peek (). add ( popped ); else return popped ; start = i + 1 ; break ; } throw new IllegalArgumentException (); } }","title":"385. Mini Parser $\\star\\star$"},{"location":"java/0301-0400/0381-0390/#386-lexicographical-numbers-starstar","text":"","title":"386. Lexicographical Numbers $\\star\\star$"},{"location":"java/0301-0400/0381-0390/#387-first-unique-character-in-a-string-star","text":"Time: $O(n)$ Space: $O(26)$ class Solution { public int firstUniqChar ( String s ) { int [] count = new int [ 26 ] ; for ( char c : s . toCharArray ()) ++ count [ c - 'a' ] ; for ( int i = 0 ; i < s . length (); ++ i ) if ( count [ s . charAt ( i ) - 'a' ] == 1 ) return i ; return - 1 ; } }","title":"387. First Unique Character in a String $\\star$"},{"location":"java/0301-0400/0381-0390/#388-longest-absolute-file-path-starstar","text":"","title":"388. Longest Absolute File Path $\\star\\star$"},{"location":"java/0301-0400/0381-0390/#389-find-the-difference-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public char findTheDifference ( String s , String t ) { int [] count = new int [ 26 ] ; for ( char c : s . toCharArray ()) ++ count [ c - 'a' ] ; for ( int i = 0 ; i < t . length (); ++ i ) if ( -- count [ t . charAt ( i ) - 'a' ] < 0 ) return t . charAt ( i ); throw new IllegalArgumentException (); } }","title":"389. Find the Difference $\\star$"},{"location":"java/0301-0400/0381-0390/#390-elimination-game-starstar","text":"","title":"390. Elimination Game $\\star\\star$"},{"location":"java/0301-0400/0391-0400/","text":"391. Perfect Rectangle $\\star\\star\\star$ 392. Is Subsequence $\\star$ 393. UTF-8 Validation $\\star\\star$ 394. Decode String $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public String decodeString ( String s ) { String currStr = \"\" ; int currNum = 0 ; Stack < String > stack = new Stack <> (); for ( char c : s . toCharArray ()) { if ( Character . isDigit ( c )) currNum = currNum * 10 + c - '0' ; else if ( c == '[' ) { stack . push ( currStr ); stack . push ( String . valueOf ( currNum )); currStr = \"\" ; currNum = 0 ; } else if ( c == ']' ) { int num = Integer . valueOf ( stack . pop ()); String prevStr = stack . pop (); String repeated = \"\" ; for ( int i = 0 ; i < num ; ++ i ) repeated += currStr ; currStr = prevStr + repeated ; } else currStr += c ; } return currStr ; } } 395. Longest Substring with At Least K Repeating Characters $\\star\\star$ 396. Rotate Function $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public int maxRotateFunction ( int [] A ) { int sum = Arrays . stream ( A ). sum (); int f = 0 ; for ( int i = 0 ; i < A . length ; ++ i ) f += i * A [ i ] ; int ans = f ; for ( int i = A . length - 1 ; i >= 0 ; -- i ) { f += sum - A . length * A [ i ] ; ans = Math . max ( ans , f ); } return ans ; } } 397. Integer Replacement $\\star\\star$ Time: $O(\\log n)$ Space: $O(1)$ class Solution { public int integerReplacement ( long n ) { int ans = 0 ; for (; n > 1 ; ++ ans ) { if (( n & 1 ) == 0 ) { n >>= 1 ; } else if ( n == 3 || (( n >> 1 ) & 1 ) == 0 ) { -- n ; } else { ++ n ; } } return ans ; } } 398. Random Pick Index $\\star\\star$ 399. Evaluate Division $\\star\\star$ 400. Nth Digit $\\star\\star$ class Solution { public int findNthDigit ( int n ) { int digitSize = 1 ; int startNum = 1 ; for ( long count = 9 ; digitSize * count < n ; count *= 10 ) { n -= digitSize * count ; ++ digitSize ; startNum *= 10 ; } int targetNum = startNum + ( n - 1 ) / digitSize ; int pos = n % digitSize ; return getDigit ( targetNum , pos , digitSize ); } private int getDigit ( int num , int pos , int digitSize ) { if ( pos == 0 ) return num % 10 ; for ( int i = 0 ; i < digitSize - pos ; ++ i ) num /= 10 ; return num % 10 ; } }","title":"0391-0300"},{"location":"java/0301-0400/0391-0400/#391-perfect-rectangle-starstarstar","text":"","title":"391. Perfect Rectangle $\\star\\star\\star$"},{"location":"java/0301-0400/0391-0400/#392-is-subsequence-star","text":"","title":"392. Is Subsequence $\\star$"},{"location":"java/0301-0400/0391-0400/#393-utf-8-validation-starstar","text":"","title":"393. UTF-8 Validation $\\star\\star$"},{"location":"java/0301-0400/0391-0400/#394-decode-string-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public String decodeString ( String s ) { String currStr = \"\" ; int currNum = 0 ; Stack < String > stack = new Stack <> (); for ( char c : s . toCharArray ()) { if ( Character . isDigit ( c )) currNum = currNum * 10 + c - '0' ; else if ( c == '[' ) { stack . push ( currStr ); stack . push ( String . valueOf ( currNum )); currStr = \"\" ; currNum = 0 ; } else if ( c == ']' ) { int num = Integer . valueOf ( stack . pop ()); String prevStr = stack . pop (); String repeated = \"\" ; for ( int i = 0 ; i < num ; ++ i ) repeated += currStr ; currStr = prevStr + repeated ; } else currStr += c ; } return currStr ; } }","title":"394. Decode String $\\star\\star$"},{"location":"java/0301-0400/0391-0400/#395-longest-substring-with-at-least-k-repeating-characters-starstar","text":"","title":"395. Longest Substring with At Least K Repeating Characters $\\star\\star$"},{"location":"java/0301-0400/0391-0400/#396-rotate-function-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public int maxRotateFunction ( int [] A ) { int sum = Arrays . stream ( A ). sum (); int f = 0 ; for ( int i = 0 ; i < A . length ; ++ i ) f += i * A [ i ] ; int ans = f ; for ( int i = A . length - 1 ; i >= 0 ; -- i ) { f += sum - A . length * A [ i ] ; ans = Math . max ( ans , f ); } return ans ; } }","title":"396. Rotate Function $\\star\\star$"},{"location":"java/0301-0400/0391-0400/#397-integer-replacement-starstar","text":"Time: $O(\\log n)$ Space: $O(1)$ class Solution { public int integerReplacement ( long n ) { int ans = 0 ; for (; n > 1 ; ++ ans ) { if (( n & 1 ) == 0 ) { n >>= 1 ; } else if ( n == 3 || (( n >> 1 ) & 1 ) == 0 ) { -- n ; } else { ++ n ; } } return ans ; } }","title":"397. Integer Replacement $\\star\\star$"},{"location":"java/0301-0400/0391-0400/#398-random-pick-index-starstar","text":"","title":"398. Random Pick Index $\\star\\star$"},{"location":"java/0301-0400/0391-0400/#399-evaluate-division-starstar","text":"","title":"399. Evaluate Division $\\star\\star$"},{"location":"java/0301-0400/0391-0400/#400-nth-digit-starstar","text":"class Solution { public int findNthDigit ( int n ) { int digitSize = 1 ; int startNum = 1 ; for ( long count = 9 ; digitSize * count < n ; count *= 10 ) { n -= digitSize * count ; ++ digitSize ; startNum *= 10 ; } int targetNum = startNum + ( n - 1 ) / digitSize ; int pos = n % digitSize ; return getDigit ( targetNum , pos , digitSize ); } private int getDigit ( int num , int pos , int digitSize ) { if ( pos == 0 ) return num % 10 ; for ( int i = 0 ; i < digitSize - pos ; ++ i ) num /= 10 ; return num % 10 ; } }","title":"400. Nth Digit $\\star\\star$"},{"location":"java/0401-0500/0401-0410/","text":"401. Binary Watch $\\star$ 402. Remove K Digits $\\star\\star$ 403. Frog Jump $\\star\\star\\star$ 404. Sum of Left Leaves $\\star$ 405. Convert a Number to Hexadecimal $\\star$ 406. Queue Reconstruction by Height $\\star\\star$ 407. Trapping Rain Water II $\\star\\star\\star$ 408. Valid Word Abbreviation $\\star$ \ud83d\udd12 409. Longest Palindrome $\\star$ class Solution { public int longestPalindrome ( String s ) { int ans = 0 ; int [] count = new int [ 128 ] ; for ( char c : s . toCharArray ()) ++ count [ c ] ; for ( int c : count ) ans += c % 2 == 0 ? c : c - 1 ; boolean hasOddCount = Arrays . stream ( count ). anyMatch ( c -> c % 2 == 1 ); return ans + ( hasOddCount ? 1 : 0 ); } } 410. Split Array Largest Sum $\\star\\star\\star$","title":"0401-0410"},{"location":"java/0401-0500/0401-0410/#401-binary-watch-star","text":"","title":"401. Binary Watch $\\star$"},{"location":"java/0401-0500/0401-0410/#402-remove-k-digits-starstar","text":"","title":"402. Remove K Digits $\\star\\star$"},{"location":"java/0401-0500/0401-0410/#403-frog-jump-starstarstar","text":"","title":"403. Frog Jump $\\star\\star\\star$"},{"location":"java/0401-0500/0401-0410/#404-sum-of-left-leaves-star","text":"","title":"404. Sum of Left Leaves $\\star$"},{"location":"java/0401-0500/0401-0410/#405-convert-a-number-to-hexadecimal-star","text":"","title":"405. Convert a Number to Hexadecimal $\\star$"},{"location":"java/0401-0500/0401-0410/#406-queue-reconstruction-by-height-starstar","text":"","title":"406. Queue Reconstruction by Height $\\star\\star$"},{"location":"java/0401-0500/0401-0410/#407-trapping-rain-water-ii-starstarstar","text":"","title":"407. Trapping Rain Water II $\\star\\star\\star$"},{"location":"java/0401-0500/0401-0410/#408-valid-word-abbreviation-star","text":"","title":"408. Valid Word Abbreviation $\\star$ \ud83d\udd12"},{"location":"java/0401-0500/0401-0410/#409-longest-palindrome-star","text":"class Solution { public int longestPalindrome ( String s ) { int ans = 0 ; int [] count = new int [ 128 ] ; for ( char c : s . toCharArray ()) ++ count [ c ] ; for ( int c : count ) ans += c % 2 == 0 ? c : c - 1 ; boolean hasOddCount = Arrays . stream ( count ). anyMatch ( c -> c % 2 == 1 ); return ans + ( hasOddCount ? 1 : 0 ); } }","title":"409. Longest Palindrome $\\star$"},{"location":"java/0401-0500/0401-0410/#410-split-array-largest-sum-starstarstar","text":"","title":"410. Split Array Largest Sum $\\star\\star\\star$"},{"location":"java/0401-0500/0411-0420/","text":"411. Minimum Unique Word Abbreviation $\\star\\star\\star$ \ud83d\udd12 412. Fizz Buzz $\\star$ 413. Arithmetic Slices $\\star\\star$ class Solution { public int numberOfArithmeticSlices ( int [] A ) { int ans = 0 ; int dp = 0 ; for ( int i = 2 ; i < A . length ; ++ i ) { if ( A [ i ] - A [ i - 1 ] == A [ i - 1 ] - A [ i - 2 ] ) ans += ++ dp ; else dp = 0 ; } return ans ; } } 414. Third Maximum Number $\\star$ public class Solution { public int thirdMax ( int [] nums ) { Queue < Integer > pq = new PriorityQueue <> (); Set < Integer > seen = new HashSet <> (); for ( int num : nums ) if ( seen . add ( num )) { pq . add ( num ); if ( pq . size () > 3 ) pq . poll (); } if ( pq . size () == 2 ) pq . poll (); return pq . peek (); } } 415. Add Strings $\\star$ class Solution { public String addStrings ( String num1 , String num2 ) { StringBuilder ans = new StringBuilder (); int carry = 0 ; int i = num1 . length () - 1 ; int j = num2 . length () - 1 ; while ( i >= 0 || j >= 0 || carry > 0 ) { if ( i >= 0 ) carry += num1 . charAt ( i ) - '0' ; if ( j >= 0 ) carry += num2 . charAt ( j ) - '0' ; ans . append ( carry % 10 ); carry /= 10 ; -- i ; -- j ; } return ans . reverse (). toString (); } } 416. Partition Equal Subset Sum $\\star\\star$ class Solution { public boolean canPartition ( int [] nums ) { final int sum = Arrays . stream ( nums ). sum (); if ( sum % 2 == 1 ) return false ; boolean [] dp = new boolean [ sum / 2 + 1 ] ; dp [ 0 ] = true ; for ( int num : nums ) for ( int w = sum / 2 ; w >= num ; -- w ) dp [ w ] = dp [ w ] || dp [ w - num ] ; return dp [ sum / 2 ] ; } } 417. Pacific Atlantic Water Flow $\\star\\star$ class Solution { public List < List < Integer >> pacificAtlantic ( int [][] matrix ) { if ( matrix . length == 0 ) return new ArrayList <> (); final int m = matrix . length ; final int n = matrix [ 0 ] . length ; List < List < Integer >> ans = new ArrayList <> (); boolean [][] seenP = new boolean [ m ][ n ] ; boolean [][] seenA = new boolean [ m ][ n ] ; for ( int i = 0 ; i < m ; ++ i ) { dfs ( matrix , i , 0 , 0 , seenP ); dfs ( matrix , i , n - 1 , 0 , seenA ); } for ( int j = 0 ; j < n ; ++ j ) { dfs ( matrix , 0 , j , 0 , seenP ); dfs ( matrix , m - 1 , j , 0 , seenA ); } for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( seenP [ i ][ j ] && seenA [ i ][ j ] ) ans . add ( new ArrayList <> ( Arrays . asList ( i , j ))); return ans ; } private void dfs ( int [][] matrix , int i , int j , int h , boolean [][] seen ) { if ( i < 0 || i >= matrix . length || j < 0 || j >= matrix [ 0 ] . length || seen [ i ][ j ] || matrix [ i ][ j ] < h ) return ; seen [ i ][ j ] = true ; dfs ( matrix , i + 1 , j , matrix [ i ][ j ] , seen ); dfs ( matrix , i - 1 , j , matrix [ i ][ j ] , seen ); dfs ( matrix , i , j + 1 , matrix [ i ][ j ] , seen ); dfs ( matrix , i , j - 1 , matrix [ i ][ j ] , seen ); } } 418. Sentence Screen Fitting $\\star\\star$ \ud83d\udd12 419. Battleships in a Board $\\star\\star$ 420. Strong Password Checker $\\star\\star\\star$","title":"0411-0420"},{"location":"java/0401-0500/0411-0420/#411-minimum-unique-word-abbreviation-starstarstar","text":"","title":"411. Minimum Unique Word Abbreviation $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/0401-0500/0411-0420/#412-fizz-buzz-star","text":"","title":"412. Fizz Buzz $\\star$"},{"location":"java/0401-0500/0411-0420/#413-arithmetic-slices-starstar","text":"class Solution { public int numberOfArithmeticSlices ( int [] A ) { int ans = 0 ; int dp = 0 ; for ( int i = 2 ; i < A . length ; ++ i ) { if ( A [ i ] - A [ i - 1 ] == A [ i - 1 ] - A [ i - 2 ] ) ans += ++ dp ; else dp = 0 ; } return ans ; } }","title":"413. Arithmetic Slices $\\star\\star$"},{"location":"java/0401-0500/0411-0420/#414-third-maximum-number-star","text":"public class Solution { public int thirdMax ( int [] nums ) { Queue < Integer > pq = new PriorityQueue <> (); Set < Integer > seen = new HashSet <> (); for ( int num : nums ) if ( seen . add ( num )) { pq . add ( num ); if ( pq . size () > 3 ) pq . poll (); } if ( pq . size () == 2 ) pq . poll (); return pq . peek (); } }","title":"414. Third Maximum Number $\\star$"},{"location":"java/0401-0500/0411-0420/#415-add-strings-star","text":"class Solution { public String addStrings ( String num1 , String num2 ) { StringBuilder ans = new StringBuilder (); int carry = 0 ; int i = num1 . length () - 1 ; int j = num2 . length () - 1 ; while ( i >= 0 || j >= 0 || carry > 0 ) { if ( i >= 0 ) carry += num1 . charAt ( i ) - '0' ; if ( j >= 0 ) carry += num2 . charAt ( j ) - '0' ; ans . append ( carry % 10 ); carry /= 10 ; -- i ; -- j ; } return ans . reverse (). toString (); } }","title":"415. Add Strings $\\star$"},{"location":"java/0401-0500/0411-0420/#416-partition-equal-subset-sum-starstar","text":"class Solution { public boolean canPartition ( int [] nums ) { final int sum = Arrays . stream ( nums ). sum (); if ( sum % 2 == 1 ) return false ; boolean [] dp = new boolean [ sum / 2 + 1 ] ; dp [ 0 ] = true ; for ( int num : nums ) for ( int w = sum / 2 ; w >= num ; -- w ) dp [ w ] = dp [ w ] || dp [ w - num ] ; return dp [ sum / 2 ] ; } }","title":"416. Partition Equal Subset Sum $\\star\\star$"},{"location":"java/0401-0500/0411-0420/#417-pacific-atlantic-water-flow-starstar","text":"class Solution { public List < List < Integer >> pacificAtlantic ( int [][] matrix ) { if ( matrix . length == 0 ) return new ArrayList <> (); final int m = matrix . length ; final int n = matrix [ 0 ] . length ; List < List < Integer >> ans = new ArrayList <> (); boolean [][] seenP = new boolean [ m ][ n ] ; boolean [][] seenA = new boolean [ m ][ n ] ; for ( int i = 0 ; i < m ; ++ i ) { dfs ( matrix , i , 0 , 0 , seenP ); dfs ( matrix , i , n - 1 , 0 , seenA ); } for ( int j = 0 ; j < n ; ++ j ) { dfs ( matrix , 0 , j , 0 , seenP ); dfs ( matrix , m - 1 , j , 0 , seenA ); } for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( seenP [ i ][ j ] && seenA [ i ][ j ] ) ans . add ( new ArrayList <> ( Arrays . asList ( i , j ))); return ans ; } private void dfs ( int [][] matrix , int i , int j , int h , boolean [][] seen ) { if ( i < 0 || i >= matrix . length || j < 0 || j >= matrix [ 0 ] . length || seen [ i ][ j ] || matrix [ i ][ j ] < h ) return ; seen [ i ][ j ] = true ; dfs ( matrix , i + 1 , j , matrix [ i ][ j ] , seen ); dfs ( matrix , i - 1 , j , matrix [ i ][ j ] , seen ); dfs ( matrix , i , j + 1 , matrix [ i ][ j ] , seen ); dfs ( matrix , i , j - 1 , matrix [ i ][ j ] , seen ); } }","title":"417. Pacific Atlantic Water Flow $\\star\\star$"},{"location":"java/0401-0500/0411-0420/#418-sentence-screen-fitting-starstar","text":"","title":"418. Sentence Screen Fitting $\\star\\star$ \ud83d\udd12"},{"location":"java/0401-0500/0411-0420/#419-battleships-in-a-board-starstar","text":"","title":"419. Battleships in a Board $\\star\\star$"},{"location":"java/0401-0500/0411-0420/#420-strong-password-checker-starstarstar","text":"","title":"420. Strong Password Checker $\\star\\star\\star$"},{"location":"java/0401-0500/0421-0430/","text":"421. Maximum XOR of Two Numbers in an Array $\\star\\star$ 422. Valid Word Square $\\star$ \ud83d\udd12 423. Reconstruct Original Digits from English $\\star\\star$ class Solution { public String originalDigits ( String s ) { StringBuilder ans = new StringBuilder (); int [] count = new int [ 10 ] ; for ( char c : s . toCharArray ()) { if ( c == 'z' ) ++ count [ 0 ] ; if ( c == 'o' ) ++ count [ 1 ] ; if ( c == 'w' ) ++ count [ 2 ] ; if ( c == 'h' ) ++ count [ 3 ] ; if ( c == 'u' ) ++ count [ 4 ] ; if ( c == 'f' ) ++ count [ 5 ] ; if ( c == 'x' ) ++ count [ 6 ] ; if ( c == 's' ) ++ count [ 7 ] ; if ( c == 'g' ) ++ count [ 8 ] ; if ( c == 'i' ) ++ count [ 9 ] ; } count [ 1 ] -= count [ 0 ] + count [ 2 ] + count [ 4 ] ; count [ 3 ] -= count [ 8 ] ; count [ 5 ] -= count [ 4 ] ; count [ 7 ] -= count [ 6 ] ; count [ 9 ] -= count [ 5 ] + count [ 6 ] + count [ 8 ] ; for ( int i = 0 ; i < 10 ; ++ i ) for ( int j = 0 ; j < count [ i ] ; ++ j ) ans . append ( i ); return ans . toString (); } } 424. Longest Repeating Character Replacement $\\star\\star$ class Solution { public int characterReplacement ( String s , int k ) { int ans = 0 ; int maxFreq = 0 ; int [] count = new int [ 26 ] ; for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { ++ count [ s . charAt ( r ) - 'A' ] ; maxFreq = Math . max ( maxFreq , count [ s . charAt ( r ) - 'A' ] ); while ( maxFreq + k < r - l + 1 ) -- count [ s . charAt ( l ++ ) - 'A' ] ; ans = Math . max ( ans , r - l + 1 ); } return ans ; } } 425. Word Squares $\\star\\star\\star$ \ud83d\udd12 426. Convert Binary Search Tree to Sorted Doubly Linked List $\\star\\star$ \ud83d\udd12 427. Construct Quad Tree $\\star\\star$ 428. Serialize and Deserialize N-ary Tree $\\star\\star\\star$ \ud83d\udd12 429. N-ary Tree Level Order Traversal $\\star\\star$ 430. Flatten a Multilevel Doubly Linked List $\\star\\star$ class Solution { public Node flatten ( Node head ) { for ( Node curr = head ; curr != null ; curr = curr . next ) if ( curr . child != null ) { Node cachedNext = curr . next ; curr . next = curr . child ; curr . child . prev = curr ; curr . child = null ; Node tail = curr . next ; while ( tail . next != null ) tail = tail . next ; tail . next = cachedNext ; if ( cachedNext != null ) cachedNext . prev = tail ; } return head ; } }","title":"0421-0430"},{"location":"java/0401-0500/0421-0430/#421-maximum-xor-of-two-numbers-in-an-array-starstar","text":"","title":"421. Maximum XOR of Two Numbers in an Array $\\star\\star$"},{"location":"java/0401-0500/0421-0430/#422-valid-word-square-star","text":"","title":"422. Valid Word Square $\\star$ \ud83d\udd12"},{"location":"java/0401-0500/0421-0430/#423-reconstruct-original-digits-from-english-starstar","text":"class Solution { public String originalDigits ( String s ) { StringBuilder ans = new StringBuilder (); int [] count = new int [ 10 ] ; for ( char c : s . toCharArray ()) { if ( c == 'z' ) ++ count [ 0 ] ; if ( c == 'o' ) ++ count [ 1 ] ; if ( c == 'w' ) ++ count [ 2 ] ; if ( c == 'h' ) ++ count [ 3 ] ; if ( c == 'u' ) ++ count [ 4 ] ; if ( c == 'f' ) ++ count [ 5 ] ; if ( c == 'x' ) ++ count [ 6 ] ; if ( c == 's' ) ++ count [ 7 ] ; if ( c == 'g' ) ++ count [ 8 ] ; if ( c == 'i' ) ++ count [ 9 ] ; } count [ 1 ] -= count [ 0 ] + count [ 2 ] + count [ 4 ] ; count [ 3 ] -= count [ 8 ] ; count [ 5 ] -= count [ 4 ] ; count [ 7 ] -= count [ 6 ] ; count [ 9 ] -= count [ 5 ] + count [ 6 ] + count [ 8 ] ; for ( int i = 0 ; i < 10 ; ++ i ) for ( int j = 0 ; j < count [ i ] ; ++ j ) ans . append ( i ); return ans . toString (); } }","title":"423. Reconstruct Original Digits from English $\\star\\star$"},{"location":"java/0401-0500/0421-0430/#424-longest-repeating-character-replacement-starstar","text":"class Solution { public int characterReplacement ( String s , int k ) { int ans = 0 ; int maxFreq = 0 ; int [] count = new int [ 26 ] ; for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { ++ count [ s . charAt ( r ) - 'A' ] ; maxFreq = Math . max ( maxFreq , count [ s . charAt ( r ) - 'A' ] ); while ( maxFreq + k < r - l + 1 ) -- count [ s . charAt ( l ++ ) - 'A' ] ; ans = Math . max ( ans , r - l + 1 ); } return ans ; } }","title":"424. Longest Repeating Character Replacement $\\star\\star$"},{"location":"java/0401-0500/0421-0430/#425-word-squares-starstarstar","text":"","title":"425. Word Squares $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/0401-0500/0421-0430/#426-convert-binary-search-tree-to-sorted-doubly-linked-list-starstar","text":"","title":"426. Convert Binary Search Tree to Sorted Doubly Linked List $\\star\\star$ \ud83d\udd12"},{"location":"java/0401-0500/0421-0430/#427-construct-quad-tree-starstar","text":"","title":"427. Construct Quad Tree $\\star\\star$"},{"location":"java/0401-0500/0421-0430/#428-serialize-and-deserialize-n-ary-tree-starstarstar","text":"","title":"428. Serialize and Deserialize N-ary Tree $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/0401-0500/0421-0430/#429-n-ary-tree-level-order-traversal-starstar","text":"","title":"429. N-ary Tree Level Order Traversal $\\star\\star$"},{"location":"java/0401-0500/0421-0430/#430-flatten-a-multilevel-doubly-linked-list-starstar","text":"class Solution { public Node flatten ( Node head ) { for ( Node curr = head ; curr != null ; curr = curr . next ) if ( curr . child != null ) { Node cachedNext = curr . next ; curr . next = curr . child ; curr . child . prev = curr ; curr . child = null ; Node tail = curr . next ; while ( tail . next != null ) tail = tail . next ; tail . next = cachedNext ; if ( cachedNext != null ) cachedNext . prev = tail ; } return head ; } }","title":"430. Flatten a Multilevel Doubly Linked List $\\star\\star$"},{"location":"java/0401-0500/0431-0440/","text":"431. Encode N-ary Tree to Binary Tree $\\star\\star\\star$ \ud83d\udd12 432. All O`one Data Structure $\\star\\star\\star$ 433. Minimum Genetic Mutation $\\star\\star$ 434. Number of Segments in a String $\\star$ class Solution { public int countSegments ( String s ) { int ans = 0 ; for ( int i = 0 ; i < s . length (); ++ i ) if ( s . charAt ( i ) != ' ' && ( i == 0 || s . charAt ( i - 1 ) == ' ' )) ++ ans ; return ans ; } } 435. Non-overlapping Intervals $\\star\\star$ class Solution { public int eraseOverlapIntervals ( int [][] intervals ) { int ans = 0 ; int currentEnd = Integer . MIN_VALUE ; Arrays . sort ( intervals , ( a , b ) -> a [ 1 ] - b [ 1 ] ); for ( int [] interval : intervals ) { if ( interval [ 0 ] >= currentEnd ) currentEnd = interval [ 1 ] ; else ++ ans ; } return ans ; } } 436. Find Right Interval $\\star\\star$ 437. Path Sum III $\\star$ 438. Find All Anagrams in a String $\\star\\star$ class Solution { public List < Integer > findAnagrams ( String s , String p ) { List < Integer > ans = new ArrayList <> (); int [] count = new int [ 26 ] ; int required = p . length (); for ( char c : p . toCharArray ()) ++ count [ c - 'a' ] ; for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { if ( -- count [ s . charAt ( r ) - 'a' ] >= 0 ) -- required ; while ( required == 0 ) { if ( r - l + 1 == p . length ()) ans . add ( l ); if ( ++ count [ s . charAt ( l ++ ) - 'a' ] > 0 ) ++ required ; } } return ans ; } } 439. Ternary Expression Parser $\\star\\star$ \ud83d\udd12 440. K-th Smallest in Lexicographical Order $\\star\\star\\star$","title":"0431-0440"},{"location":"java/0401-0500/0431-0440/#431-encode-n-ary-tree-to-binary-tree-starstarstar","text":"","title":"431. Encode N-ary Tree to Binary Tree $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/0401-0500/0431-0440/#432-all-oone-data-structure-starstarstar","text":"","title":"432. All O`one Data Structure $\\star\\star\\star$"},{"location":"java/0401-0500/0431-0440/#433-minimum-genetic-mutation-starstar","text":"","title":"433. Minimum Genetic Mutation $\\star\\star$"},{"location":"java/0401-0500/0431-0440/#434-number-of-segments-in-a-string-star","text":"class Solution { public int countSegments ( String s ) { int ans = 0 ; for ( int i = 0 ; i < s . length (); ++ i ) if ( s . charAt ( i ) != ' ' && ( i == 0 || s . charAt ( i - 1 ) == ' ' )) ++ ans ; return ans ; } }","title":"434. Number of Segments in a String $\\star$"},{"location":"java/0401-0500/0431-0440/#435-non-overlapping-intervals-starstar","text":"class Solution { public int eraseOverlapIntervals ( int [][] intervals ) { int ans = 0 ; int currentEnd = Integer . MIN_VALUE ; Arrays . sort ( intervals , ( a , b ) -> a [ 1 ] - b [ 1 ] ); for ( int [] interval : intervals ) { if ( interval [ 0 ] >= currentEnd ) currentEnd = interval [ 1 ] ; else ++ ans ; } return ans ; } }","title":"435. Non-overlapping Intervals $\\star\\star$"},{"location":"java/0401-0500/0431-0440/#436-find-right-interval-starstar","text":"","title":"436. Find Right Interval $\\star\\star$"},{"location":"java/0401-0500/0431-0440/#437-path-sum-iii-star","text":"","title":"437. Path Sum III $\\star$"},{"location":"java/0401-0500/0431-0440/#438-find-all-anagrams-in-a-string-starstar","text":"class Solution { public List < Integer > findAnagrams ( String s , String p ) { List < Integer > ans = new ArrayList <> (); int [] count = new int [ 26 ] ; int required = p . length (); for ( char c : p . toCharArray ()) ++ count [ c - 'a' ] ; for ( int l = 0 , r = 0 ; r < s . length (); ++ r ) { if ( -- count [ s . charAt ( r ) - 'a' ] >= 0 ) -- required ; while ( required == 0 ) { if ( r - l + 1 == p . length ()) ans . add ( l ); if ( ++ count [ s . charAt ( l ++ ) - 'a' ] > 0 ) ++ required ; } } return ans ; } }","title":"438. Find All Anagrams in a String $\\star\\star$"},{"location":"java/0401-0500/0431-0440/#439-ternary-expression-parser-starstar","text":"","title":"439. Ternary Expression Parser $\\star\\star$ \ud83d\udd12"},{"location":"java/0401-0500/0431-0440/#440-k-th-smallest-in-lexicographical-order-starstarstar","text":"","title":"440. K-th Smallest in Lexicographical Order $\\star\\star\\star$"},{"location":"java/0401-0500/0441-0450/","text":"441. Arranging Coins $\\star$ class Solution { public int arrangeCoins ( long n ) { return ( int ) ( - 1 + Math . sqrt ( 8 * n + 1 )) / 2 ; } } 442. Find All Duplicates in an Array $\\star\\star$ class Solution { public List < Integer > findDuplicates ( int [] nums ) { List < Integer > ans = new ArrayList <> (); for ( int num : nums ) { nums [ Math . abs ( num ) - 1 ] *= - 1 ; if ( nums [ Math . abs ( num ) - 1 ] > 0 ) ans . add ( Math . abs ( num )); } return ans ; } } 443. String Compression $\\star$ class Solution { public int compress ( char [] chars ) { int ans = 0 ; for ( int i = 0 ; i < chars . length ;) { char letter = chars [ i ] ; int count = 0 ; while ( i < chars . length && chars [ i ] == letter ) { ++ count ; ++ i ; } chars [ ans ++] = letter ; if ( count > 1 ) for ( char c : String . valueOf ( count ). toCharArray ()) chars [ ans ++] = c ; } return ans ; } } 444. Sequence Reconstruction $\\star\\star$ \ud83d\udd12 445. Add Two Numbers II $\\star\\star$ class Solution { public ListNode addTwoNumbers ( ListNode l1 , ListNode l2 ) { Stack < ListNode > stack1 = new Stack <> (); Stack < ListNode > stack2 = new Stack <> (); while ( l1 != null ) { stack1 . push ( l1 ); l1 = l1 . next ; } while ( l2 != null ) { stack2 . push ( l2 ); l2 = l2 . next ; } ListNode head = null ; int carry = 0 ; while ( carry > 0 || ! stack1 . isEmpty () || ! stack2 . isEmpty ()) { if ( ! stack1 . isEmpty ()) carry += stack1 . pop (). val ; if ( ! stack2 . isEmpty ()) carry += stack2 . pop (). val ; ListNode node = new ListNode ( carry % 10 ); node . next = head ; head = node ; carry /= 10 ; } return head ; } } 446. Arithmetic Slices II - Subsequence $\\star\\star\\star$ 447. Number of Boomerangs $\\star$ class Solution { public int numberOfBoomerangs ( int [][] points ) { int ans = 0 ; for ( int [] p1 : points ) { Map < Integer , Integer > count = new HashMap <> (); for ( int [] p2 : points ) { int distance = ( int ) Math . pow ( p1 [ 0 ] - p2 [ 0 ] , 2 ) + ( int ) Math . pow ( p1 [ 1 ] - p2 [ 1 ] , 2 ); ans += 2 * count . getOrDefault ( distance , 0 ); count . put ( distance , count . getOrDefault ( distance , 0 ) + 1 ); } } return ans ; } } 448. Find All Numbers Disappeared in an Array $\\star$ class Solution { public List < Integer > findDisappearedNumbers ( int [] nums ) { List < Integer > ans = new ArrayList <> (); for ( int num : nums ) { int index = Math . abs ( num ) - 1 ; nums [ index ] = - Math . abs ( nums [ index ] ); } for ( int i = 0 ; i < nums . length ; ++ i ) if ( nums [ i ] > 0 ) ans . add ( i + 1 ); return ans ; } } 449. Serialize and Deserialize BST $\\star\\star$ 450. Delete Node in a BST $\\star\\star$","title":"0441-0450"},{"location":"java/0401-0500/0441-0450/#441-arranging-coins-star","text":"class Solution { public int arrangeCoins ( long n ) { return ( int ) ( - 1 + Math . sqrt ( 8 * n + 1 )) / 2 ; } }","title":"441. Arranging Coins $\\star$"},{"location":"java/0401-0500/0441-0450/#442-find-all-duplicates-in-an-array-starstar","text":"class Solution { public List < Integer > findDuplicates ( int [] nums ) { List < Integer > ans = new ArrayList <> (); for ( int num : nums ) { nums [ Math . abs ( num ) - 1 ] *= - 1 ; if ( nums [ Math . abs ( num ) - 1 ] > 0 ) ans . add ( Math . abs ( num )); } return ans ; } }","title":"442. Find All Duplicates in an Array $\\star\\star$"},{"location":"java/0401-0500/0441-0450/#443-string-compression-star","text":"class Solution { public int compress ( char [] chars ) { int ans = 0 ; for ( int i = 0 ; i < chars . length ;) { char letter = chars [ i ] ; int count = 0 ; while ( i < chars . length && chars [ i ] == letter ) { ++ count ; ++ i ; } chars [ ans ++] = letter ; if ( count > 1 ) for ( char c : String . valueOf ( count ). toCharArray ()) chars [ ans ++] = c ; } return ans ; } }","title":"443. String Compression $\\star$"},{"location":"java/0401-0500/0441-0450/#444-sequence-reconstruction-starstar","text":"","title":"444. Sequence Reconstruction $\\star\\star$ \ud83d\udd12"},{"location":"java/0401-0500/0441-0450/#445-add-two-numbers-ii-starstar","text":"class Solution { public ListNode addTwoNumbers ( ListNode l1 , ListNode l2 ) { Stack < ListNode > stack1 = new Stack <> (); Stack < ListNode > stack2 = new Stack <> (); while ( l1 != null ) { stack1 . push ( l1 ); l1 = l1 . next ; } while ( l2 != null ) { stack2 . push ( l2 ); l2 = l2 . next ; } ListNode head = null ; int carry = 0 ; while ( carry > 0 || ! stack1 . isEmpty () || ! stack2 . isEmpty ()) { if ( ! stack1 . isEmpty ()) carry += stack1 . pop (). val ; if ( ! stack2 . isEmpty ()) carry += stack2 . pop (). val ; ListNode node = new ListNode ( carry % 10 ); node . next = head ; head = node ; carry /= 10 ; } return head ; } }","title":"445. Add Two Numbers II $\\star\\star$"},{"location":"java/0401-0500/0441-0450/#446-arithmetic-slices-ii-subsequence-starstarstar","text":"","title":"446. Arithmetic Slices II - Subsequence $\\star\\star\\star$"},{"location":"java/0401-0500/0441-0450/#447-number-of-boomerangs-star","text":"class Solution { public int numberOfBoomerangs ( int [][] points ) { int ans = 0 ; for ( int [] p1 : points ) { Map < Integer , Integer > count = new HashMap <> (); for ( int [] p2 : points ) { int distance = ( int ) Math . pow ( p1 [ 0 ] - p2 [ 0 ] , 2 ) + ( int ) Math . pow ( p1 [ 1 ] - p2 [ 1 ] , 2 ); ans += 2 * count . getOrDefault ( distance , 0 ); count . put ( distance , count . getOrDefault ( distance , 0 ) + 1 ); } } return ans ; } }","title":"447. Number of Boomerangs $\\star$"},{"location":"java/0401-0500/0441-0450/#448-find-all-numbers-disappeared-in-an-array-star","text":"class Solution { public List < Integer > findDisappearedNumbers ( int [] nums ) { List < Integer > ans = new ArrayList <> (); for ( int num : nums ) { int index = Math . abs ( num ) - 1 ; nums [ index ] = - Math . abs ( nums [ index ] ); } for ( int i = 0 ; i < nums . length ; ++ i ) if ( nums [ i ] > 0 ) ans . add ( i + 1 ); return ans ; } }","title":"448. Find All Numbers Disappeared in an Array $\\star$"},{"location":"java/0401-0500/0441-0450/#449-serialize-and-deserialize-bst-starstar","text":"","title":"449. Serialize and Deserialize BST $\\star\\star$"},{"location":"java/0401-0500/0441-0450/#450-delete-node-in-a-bst-starstar","text":"","title":"450. Delete Node in a BST $\\star\\star$"},{"location":"java/0401-0500/0451-0460/","text":"451. Sort Characters By Frequency $\\star\\star$ class Solution { public String frequencySort ( String s ) { String ans = \"\" ; List < Character >[] bucket = new List [ s . length () + 1 ] ; int [] count = new int [ 128 ] ; for ( char c : s . toCharArray ()) ++ count [ c ] ; for ( int i = 0 ; i < count . length ; ++ i ) { int freq = count [ i ] ; if ( freq > 0 ) { if ( bucket [ freq ] == null ) bucket [ freq ] = new ArrayList <> (); bucket [ freq ] . add (( char ) i ); } } for ( int freq = bucket . length - 1 ; freq >= 0 ; -- freq ) if ( bucket [ freq ] != null ) for ( Character c : bucket [ freq ] ) for ( int i = 0 ; i < freq ; ++ i ) ans += c ; return ans ; } } 452. Minimum Number of Arrows to Burst Balloons $\\star\\star$ class Solution { public int findMinArrowShots ( int [][] points ) { int ans = 0 ; long arrowX = ( long ) Integer . MIN_VALUE - 1 ; Arrays . sort ( points , ( a , b ) -> a [ 1 ] - b [ 1 ] ); for ( int [] point : points ) if ( point [ 0 ] > arrowX ) { ++ ans ; arrowX = point [ 1 ] ; } return ans ; } } 453. Minimum Moves to Equal Array Elements $\\star$ class Solution { public int minMoves ( int [] nums ) { int ans = 0 ; int min = Arrays . stream ( nums ). min (). getAsInt (); for ( int num : nums ) ans += num - min ; return ans ; } } 454. 4Sum II $\\star\\star$ class Solution { public int fourSumCount ( int [] A , int [] B , int [] C , int [] D ) { int ans = 0 ; Map < Integer , Integer > count = new HashMap <> (); for ( int a : A ) for ( int b : B ) count . put ( a + b , count . getOrDefault ( a + b , 0 ) + 1 ); for ( int c : C ) for ( int d : D ) if ( count . containsKey ( - c - d )) ans += count . get ( - c - d ); return ans ; } } 455. Assign Cookies $\\star$ 456. 132 Pattern $\\star\\star$ 457. Circular Array Loop $\\star\\star$ class Solution { public boolean circularArrayLoop ( int [] nums ) { if ( nums . length < 2 ) return false ; for ( int i = 0 ; i < nums . length ; ++ i ) { if ( nums [ i ] == 0 ) continue ; int slow = i ; int fast = advance ( nums , slow ); while ( nums [ i ] * nums [ fast ] > 0 && nums [ i ] * nums [ advance ( nums , fast ) ] > 0 ) { if ( slow == fast ) { if ( slow == advance ( nums , slow )) break ; return true ; } slow = advance ( nums , slow ); fast = advance ( nums , advance ( nums , fast )); } slow = i ; int sign = nums [ i ] ; while ( sign * nums [ slow ] > 0 ) { int next = advance ( nums , slow ); nums [ slow ] = 0 ; slow = next ; } } return false ; } private int advance ( int [] nums , int i ) { final int n = nums . length ; int val = ( i + nums [ i ] ) % n ; return i + nums [ i ] >= 0 ? val : n + val ; } } 458. Poor Pigs $\\star\\star\\star$ class Solution { public int poorPigs ( int buckets , int minutesToDie , int minutesToTest ) { return ( int ) Math . ceil ( Math . log ( buckets ) / Math . log ( minutesToTest / minutesToDie + 1 )); } } 459. Repeated Substring Pattern $\\star$ class Solution { public boolean repeatedSubstringPattern ( String s ) { String ss = s + s ; return ss . substring ( 1 , ss . length () - 1 ). contains ( s ); } } 460. LFU Cache $\\star\\star\\star$","title":"0451-0460"},{"location":"java/0401-0500/0451-0460/#451-sort-characters-by-frequency-starstar","text":"class Solution { public String frequencySort ( String s ) { String ans = \"\" ; List < Character >[] bucket = new List [ s . length () + 1 ] ; int [] count = new int [ 128 ] ; for ( char c : s . toCharArray ()) ++ count [ c ] ; for ( int i = 0 ; i < count . length ; ++ i ) { int freq = count [ i ] ; if ( freq > 0 ) { if ( bucket [ freq ] == null ) bucket [ freq ] = new ArrayList <> (); bucket [ freq ] . add (( char ) i ); } } for ( int freq = bucket . length - 1 ; freq >= 0 ; -- freq ) if ( bucket [ freq ] != null ) for ( Character c : bucket [ freq ] ) for ( int i = 0 ; i < freq ; ++ i ) ans += c ; return ans ; } }","title":"451. Sort Characters By Frequency $\\star\\star$"},{"location":"java/0401-0500/0451-0460/#452-minimum-number-of-arrows-to-burst-balloons-starstar","text":"class Solution { public int findMinArrowShots ( int [][] points ) { int ans = 0 ; long arrowX = ( long ) Integer . MIN_VALUE - 1 ; Arrays . sort ( points , ( a , b ) -> a [ 1 ] - b [ 1 ] ); for ( int [] point : points ) if ( point [ 0 ] > arrowX ) { ++ ans ; arrowX = point [ 1 ] ; } return ans ; } }","title":"452. Minimum Number of Arrows to Burst Balloons $\\star\\star$"},{"location":"java/0401-0500/0451-0460/#453-minimum-moves-to-equal-array-elements-star","text":"class Solution { public int minMoves ( int [] nums ) { int ans = 0 ; int min = Arrays . stream ( nums ). min (). getAsInt (); for ( int num : nums ) ans += num - min ; return ans ; } }","title":"453. Minimum Moves to Equal Array Elements $\\star$"},{"location":"java/0401-0500/0451-0460/#454-4sum-ii-starstar","text":"class Solution { public int fourSumCount ( int [] A , int [] B , int [] C , int [] D ) { int ans = 0 ; Map < Integer , Integer > count = new HashMap <> (); for ( int a : A ) for ( int b : B ) count . put ( a + b , count . getOrDefault ( a + b , 0 ) + 1 ); for ( int c : C ) for ( int d : D ) if ( count . containsKey ( - c - d )) ans += count . get ( - c - d ); return ans ; } }","title":"454. 4Sum II $\\star\\star$"},{"location":"java/0401-0500/0451-0460/#455-assign-cookies-star","text":"","title":"455. Assign Cookies $\\star$"},{"location":"java/0401-0500/0451-0460/#456-132-pattern-starstar","text":"","title":"456. 132 Pattern $\\star\\star$"},{"location":"java/0401-0500/0451-0460/#457-circular-array-loop-starstar","text":"class Solution { public boolean circularArrayLoop ( int [] nums ) { if ( nums . length < 2 ) return false ; for ( int i = 0 ; i < nums . length ; ++ i ) { if ( nums [ i ] == 0 ) continue ; int slow = i ; int fast = advance ( nums , slow ); while ( nums [ i ] * nums [ fast ] > 0 && nums [ i ] * nums [ advance ( nums , fast ) ] > 0 ) { if ( slow == fast ) { if ( slow == advance ( nums , slow )) break ; return true ; } slow = advance ( nums , slow ); fast = advance ( nums , advance ( nums , fast )); } slow = i ; int sign = nums [ i ] ; while ( sign * nums [ slow ] > 0 ) { int next = advance ( nums , slow ); nums [ slow ] = 0 ; slow = next ; } } return false ; } private int advance ( int [] nums , int i ) { final int n = nums . length ; int val = ( i + nums [ i ] ) % n ; return i + nums [ i ] >= 0 ? val : n + val ; } }","title":"457. Circular Array Loop $\\star\\star$"},{"location":"java/0401-0500/0451-0460/#458-poor-pigs-starstarstar","text":"class Solution { public int poorPigs ( int buckets , int minutesToDie , int minutesToTest ) { return ( int ) Math . ceil ( Math . log ( buckets ) / Math . log ( minutesToTest / minutesToDie + 1 )); } }","title":"458. Poor Pigs $\\star\\star\\star$"},{"location":"java/0401-0500/0451-0460/#459-repeated-substring-pattern-star","text":"class Solution { public boolean repeatedSubstringPattern ( String s ) { String ss = s + s ; return ss . substring ( 1 , ss . length () - 1 ). contains ( s ); } }","title":"459. Repeated Substring Pattern $\\star$"},{"location":"java/0401-0500/0451-0460/#460-lfu-cache-starstarstar","text":"","title":"460. LFU Cache $\\star\\star\\star$"},{"location":"java/0401-0500/0461-0470/","text":"461. Hamming Distance $\\star$ 462. Minimum Moves to Equal Array Elements II $\\star\\star$ class Solution { public int minMoves2 ( int [] nums ) { Arrays . sort ( nums ); int median = nums [ nums . length / 2 ] ; int ans = 0 ; for ( int num : nums ) ans += Math . abs ( num - median ); return ans ; } } 463. Island Perimeter $\\star$ class Solution { public int islandPerimeter ( int [][] grid ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; int islands = 0 ; int neighbors = 0 ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ][ j ] == 1 ) { ++ islands ; if ( i + 1 < m && grid [ i + 1 ][ j ] == 1 ) ++ neighbors ; if ( j + 1 < n && grid [ i ][ j + 1 ] == 1 ) ++ neighbors ; } return islands * 4 - neighbors * 2 ; } } 464. Can I Win $\\star\\star$ 465. Optimal Account Balancing $\\star\\star\\star$ \ud83d\udd12 466. Count The Repetitions $\\star\\star\\star$ 467. Unique Substrings in Wraparound String $\\star\\star$ 468. Validate IP Address $\\star\\star$ 469. Convex Polygon $\\star\\star$ \ud83d\udd12 470. Implement Rand10() Using Rand7() $\\star\\star$","title":"0461-0470"},{"location":"java/0401-0500/0461-0470/#461-hamming-distance-star","text":"","title":"461. Hamming Distance $\\star$"},{"location":"java/0401-0500/0461-0470/#462-minimum-moves-to-equal-array-elements-ii-starstar","text":"class Solution { public int minMoves2 ( int [] nums ) { Arrays . sort ( nums ); int median = nums [ nums . length / 2 ] ; int ans = 0 ; for ( int num : nums ) ans += Math . abs ( num - median ); return ans ; } }","title":"462. Minimum Moves to Equal Array Elements II $\\star\\star$"},{"location":"java/0401-0500/0461-0470/#463-island-perimeter-star","text":"class Solution { public int islandPerimeter ( int [][] grid ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; int islands = 0 ; int neighbors = 0 ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ][ j ] == 1 ) { ++ islands ; if ( i + 1 < m && grid [ i + 1 ][ j ] == 1 ) ++ neighbors ; if ( j + 1 < n && grid [ i ][ j + 1 ] == 1 ) ++ neighbors ; } return islands * 4 - neighbors * 2 ; } }","title":"463. Island Perimeter $\\star$"},{"location":"java/0401-0500/0461-0470/#464-can-i-win-starstar","text":"","title":"464. Can I Win $\\star\\star$"},{"location":"java/0401-0500/0461-0470/#465-optimal-account-balancing-starstarstar","text":"","title":"465. Optimal Account Balancing $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/0401-0500/0461-0470/#466-count-the-repetitions-starstarstar","text":"","title":"466. Count The Repetitions $\\star\\star\\star$"},{"location":"java/0401-0500/0461-0470/#467-unique-substrings-in-wraparound-string-starstar","text":"","title":"467. Unique Substrings in Wraparound String $\\star\\star$"},{"location":"java/0401-0500/0461-0470/#468-validate-ip-address-starstar","text":"","title":"468. Validate IP Address $\\star\\star$"},{"location":"java/0401-0500/0461-0470/#469-convex-polygon-starstar","text":"","title":"469. Convex Polygon $\\star\\star$ \ud83d\udd12"},{"location":"java/0401-0500/0461-0470/#470-implement-rand10-using-rand7-starstar","text":"","title":"470. Implement Rand10() Using Rand7() $\\star\\star$"},{"location":"java/0401-0500/0471-0480/","text":"471. Encode String with Shortest Length $\\star\\star\\star$ \ud83d\udd12 472. Concatenated Words $\\star\\star\\star$ class Solution { public List < String > findAllConcatenatedWordsInADict ( String [] words ) { List < String > ans = new ArrayList <> (); Set < String > wordSet = new HashSet <> (); for ( final String word : words ) wordSet . add ( word ); for ( final String word : words ) if ( wordBreak ( word , wordSet )) ans . add ( word ); return ans ; } private Map < String , Boolean > memo = new HashMap <> (); private boolean wordBreak ( final String word , Set < String > wordSet ) { if ( memo . containsKey ( word )) return memo . get ( word ); for ( int i = 1 ; i < word . length (); ++ i ) { String prefix = word . substring ( 0 , i ); String suffix = word . substring ( i ); if ( wordSet . contains ( prefix ) && ( wordSet . contains ( suffix ) || wordBreak ( suffix , wordSet ))) { memo . put ( word , true ); return true ; } } memo . put ( word , false ); return false ; } } 473. Matchsticks to Square $\\star\\star$ class Solution { public boolean makesquare ( int [] nums ) { if ( nums . length < 4 ) return false ; int perimeter = Arrays . stream ( nums ). sum (); if ( perimeter % 4 != 0 ) return false ; int [] edges = new int [ 4 ] ; Arrays . fill ( edges , perimeter / 4 ); Arrays . sort ( edges ); return dfs ( nums , nums . length - 1 , edges ); } private boolean dfs ( int [] nums , int selected , int [] edges ) { if ( selected == - 1 ) return edges [ 0 ] == edges [ 1 ] && edges [ 1 ] == edges [ 2 ] && edges [ 2 ] == edges [ 3 ] ; for ( int i = 0 ; i < edges . length ; ++ i ) { if ( nums [ selected ] > edges [ i ] ) continue ; edges [ i ] -= nums [ selected ] ; if ( dfs ( nums , selected - 1 , edges )) return true ; edges [ i ] += nums [ selected ] ; } return false ; } } 474. Ones and Zeroes $\\star\\star$ class Solution { public int findMaxForm ( String [] strs , int m , int n ) { int [][] dp = new int [ m + 1 ][ n + 1 ] ; for ( final String s : strs ) { int count0 = 0 ; int count1 = 0 ; for ( char c : s . toCharArray ()) if ( c == '0' ) ++ count0 ; else ++ count1 ; for ( int i = m ; i >= count0 ; -- i ) for ( int j = n ; j >= count1 ; -- j ) dp [ i ][ j ] = Math . max ( dp [ i ][ j ] , dp [ i - count0 ][ j - count1 ] + 1 ); } return dp [ m ][ n ] ; } } 475. Heaters $\\star$ 476. Number Complement $\\star$ 477. Total Hamming Distance $\\star\\star$ 478. Generate Random Point in a Circle $\\star\\star$ class Solution { public Solution ( double radius , double x_center , double y_center ) { this . radius = radius ; this . x_center = x_center ; this . y_center = y_center ; } public double [] randPoint () { double length = Math . sqrt ( Math . random ()) * radius ; double degree = Math . random () * 2 * Math . PI ; double x = x_center + length * Math . cos ( degree ); double y = y_center + length * Math . sin ( degree ); return new double [] { x , y }; } private double radius ; private double x_center ; private double y_center ; } 479. Largest Palindrome Product $\\star\\star\\star$ 480. Sliding Window Median $\\star\\star\\star$","title":"0471-0480"},{"location":"java/0401-0500/0471-0480/#471-encode-string-with-shortest-length-starstarstar","text":"","title":"471. Encode String with Shortest Length $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/0401-0500/0471-0480/#472-concatenated-words-starstarstar","text":"class Solution { public List < String > findAllConcatenatedWordsInADict ( String [] words ) { List < String > ans = new ArrayList <> (); Set < String > wordSet = new HashSet <> (); for ( final String word : words ) wordSet . add ( word ); for ( final String word : words ) if ( wordBreak ( word , wordSet )) ans . add ( word ); return ans ; } private Map < String , Boolean > memo = new HashMap <> (); private boolean wordBreak ( final String word , Set < String > wordSet ) { if ( memo . containsKey ( word )) return memo . get ( word ); for ( int i = 1 ; i < word . length (); ++ i ) { String prefix = word . substring ( 0 , i ); String suffix = word . substring ( i ); if ( wordSet . contains ( prefix ) && ( wordSet . contains ( suffix ) || wordBreak ( suffix , wordSet ))) { memo . put ( word , true ); return true ; } } memo . put ( word , false ); return false ; } }","title":"472. Concatenated Words $\\star\\star\\star$"},{"location":"java/0401-0500/0471-0480/#473-matchsticks-to-square-starstar","text":"class Solution { public boolean makesquare ( int [] nums ) { if ( nums . length < 4 ) return false ; int perimeter = Arrays . stream ( nums ). sum (); if ( perimeter % 4 != 0 ) return false ; int [] edges = new int [ 4 ] ; Arrays . fill ( edges , perimeter / 4 ); Arrays . sort ( edges ); return dfs ( nums , nums . length - 1 , edges ); } private boolean dfs ( int [] nums , int selected , int [] edges ) { if ( selected == - 1 ) return edges [ 0 ] == edges [ 1 ] && edges [ 1 ] == edges [ 2 ] && edges [ 2 ] == edges [ 3 ] ; for ( int i = 0 ; i < edges . length ; ++ i ) { if ( nums [ selected ] > edges [ i ] ) continue ; edges [ i ] -= nums [ selected ] ; if ( dfs ( nums , selected - 1 , edges )) return true ; edges [ i ] += nums [ selected ] ; } return false ; } }","title":"473. Matchsticks to Square $\\star\\star$"},{"location":"java/0401-0500/0471-0480/#474-ones-and-zeroes-starstar","text":"class Solution { public int findMaxForm ( String [] strs , int m , int n ) { int [][] dp = new int [ m + 1 ][ n + 1 ] ; for ( final String s : strs ) { int count0 = 0 ; int count1 = 0 ; for ( char c : s . toCharArray ()) if ( c == '0' ) ++ count0 ; else ++ count1 ; for ( int i = m ; i >= count0 ; -- i ) for ( int j = n ; j >= count1 ; -- j ) dp [ i ][ j ] = Math . max ( dp [ i ][ j ] , dp [ i - count0 ][ j - count1 ] + 1 ); } return dp [ m ][ n ] ; } }","title":"474. Ones and Zeroes $\\star\\star$"},{"location":"java/0401-0500/0471-0480/#475-heaters-star","text":"","title":"475. Heaters $\\star$"},{"location":"java/0401-0500/0471-0480/#476-number-complement-star","text":"","title":"476. Number Complement $\\star$"},{"location":"java/0401-0500/0471-0480/#477-total-hamming-distance-starstar","text":"","title":"477. Total Hamming Distance $\\star\\star$"},{"location":"java/0401-0500/0471-0480/#478-generate-random-point-in-a-circle-starstar","text":"class Solution { public Solution ( double radius , double x_center , double y_center ) { this . radius = radius ; this . x_center = x_center ; this . y_center = y_center ; } public double [] randPoint () { double length = Math . sqrt ( Math . random ()) * radius ; double degree = Math . random () * 2 * Math . PI ; double x = x_center + length * Math . cos ( degree ); double y = y_center + length * Math . sin ( degree ); return new double [] { x , y }; } private double radius ; private double x_center ; private double y_center ; }","title":"478. Generate Random Point in a Circle $\\star\\star$"},{"location":"java/0401-0500/0471-0480/#479-largest-palindrome-product-starstarstar","text":"","title":"479. Largest Palindrome Product $\\star\\star\\star$"},{"location":"java/0401-0500/0471-0480/#480-sliding-window-median-starstarstar","text":"","title":"480. Sliding Window Median $\\star\\star\\star$"},{"location":"java/0401-0500/0481-0490/","text":"481. Magical String $\\star\\star$ 482. License Key Formatting $\\star$ 483. Smallest Good Base $\\star\\star\\star$ class Solution { public String smallestGoodBase ( String n ) { long num = Long . valueOf ( n ); for ( int m = ( int ) ( Math . log ( num ) / Math . log ( 2 )); m >= 2 ; -- m ) { int k = ( int ) Math . floor ( Math . pow ( num , 1.0 / m )); long sum = 1 ; long prod = 1 ; for ( int i = 0 ; i < m ; ++ i ) { prod *= k ; sum += prod ; } if ( sum == num ) return String . valueOf ( k ); } return String . valueOf ( num - 1 ); } } 484. Find Permutation $\\star\\star$ \ud83d\udd12 485. Max Consecutive Ones $\\star$ class Solution { public int findMaxConsecutiveOnes ( int [] nums ) { int ans = 0 ; int sum = 0 ; for ( int num : nums ) { if ( num == 0 ) sum = 0 ; else { sum += num ; ans = Math . max ( ans , sum ); } } return ans ; } } 486. Predict the Winner $\\star\\star$ 487. Max Consecutive Ones II $\\star\\star$ \ud83d\udd12 488. Zuma Game $\\star\\star\\star$ 489. Robot Room Cleaner $\\star\\star\\star$ \ud83d\udd12 490. The Maze $\\star\\star$ \ud83d\udd12","title":"0481-0490"},{"location":"java/0401-0500/0481-0490/#481-magical-string-starstar","text":"","title":"481. Magical String $\\star\\star$"},{"location":"java/0401-0500/0481-0490/#482-license-key-formatting-star","text":"","title":"482. License Key Formatting $\\star$"},{"location":"java/0401-0500/0481-0490/#483-smallest-good-base-starstarstar","text":"class Solution { public String smallestGoodBase ( String n ) { long num = Long . valueOf ( n ); for ( int m = ( int ) ( Math . log ( num ) / Math . log ( 2 )); m >= 2 ; -- m ) { int k = ( int ) Math . floor ( Math . pow ( num , 1.0 / m )); long sum = 1 ; long prod = 1 ; for ( int i = 0 ; i < m ; ++ i ) { prod *= k ; sum += prod ; } if ( sum == num ) return String . valueOf ( k ); } return String . valueOf ( num - 1 ); } }","title":"483. Smallest Good Base $\\star\\star\\star$"},{"location":"java/0401-0500/0481-0490/#484-find-permutation-starstar","text":"","title":"484. Find Permutation $\\star\\star$ \ud83d\udd12"},{"location":"java/0401-0500/0481-0490/#485-max-consecutive-ones-star","text":"class Solution { public int findMaxConsecutiveOnes ( int [] nums ) { int ans = 0 ; int sum = 0 ; for ( int num : nums ) { if ( num == 0 ) sum = 0 ; else { sum += num ; ans = Math . max ( ans , sum ); } } return ans ; } }","title":"485. Max Consecutive Ones $\\star$"},{"location":"java/0401-0500/0481-0490/#486-predict-the-winner-starstar","text":"","title":"486. Predict the Winner $\\star\\star$"},{"location":"java/0401-0500/0481-0490/#487-max-consecutive-ones-ii-starstar","text":"","title":"487. Max Consecutive Ones II $\\star\\star$ \ud83d\udd12"},{"location":"java/0401-0500/0481-0490/#488-zuma-game-starstarstar","text":"","title":"488. Zuma Game $\\star\\star\\star$"},{"location":"java/0401-0500/0481-0490/#489-robot-room-cleaner-starstarstar","text":"","title":"489. Robot Room Cleaner $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/0401-0500/0481-0490/#490-the-maze-starstar","text":"","title":"490. The Maze $\\star\\star$ \ud83d\udd12"},{"location":"java/0401-0500/0491-0500/","text":"491. Increasing Subsequences $\\star\\star$ class Solution { public List < List < Integer >> findSubsequences ( int [] nums ) { List < List < Integer >> ans = new LinkedList <> (); dfs ( nums , 0 , new LinkedList <> (), ans ); return ans ; } private void dfs ( int [] nums , int s , LinkedList < Integer > path , List < List < Integer >> ans ) { if ( path . size () > 1 ) ans . add ( new LinkedList <> ( path )); Set < Integer > used = new HashSet <> (); for ( int i = s ; i < nums . length ; ++ i ) { if ( used . contains ( nums [ i ] )) continue ; if ( path . isEmpty () || nums [ i ] >= path . getLast ()) { used . add ( nums [ i ] ); path . addLast ( nums [ i ] ); dfs ( nums , i + 1 , path , ans ); path . removeLast (); } } } } 492. Construct the Rectangle $\\star$ 493. Reverse Pairs $\\star\\star\\star$ 494. Target Sum $\\star\\star$ class Solution { public int findTargetSumWays ( int [] nums , int S ) { final int sum = Arrays . stream ( nums ). sum (); if ( sum < S || ( sum + S ) % 2 == 1 ) return 0 ; return subsetSum ( nums , ( sum + S ) / 2 ); } private int subsetSum ( int [] nums , int s ) { int [] dp = new int [ s + 1 ] ; dp [ 0 ] = 1 ; for ( int num : nums ) for ( int w = s ; w >= num ; -- w ) dp [ w ] += dp [ w - num ] ; return dp [ s ] ; } } 495. Teemo Attacking $\\star\\star$ class Solution { public int findPoisonedDuration ( int [] timeSeries , int duration ) { if ( timeSeries . length == 0 || duration == 0 ) return 0 ; int ans = 0 ; for ( int i = 0 ; i + 1 < timeSeries . length ; ++ i ) ans += Math . min ( timeSeries [ i + 1 ] - timeSeries [ i ] , duration ); return ans + duration ; } } 496. Next Greater Element I $\\star$ 497. Random Point in Non-overlapping Rectangles $\\star\\star$ 498. Diagonal Traverse $\\star\\star$ 499. The Maze III $\\star\\star\\star$ \ud83d\udd12 500. Keyboard Row $\\star$ class Solution { public String [] findWords ( String [] words ) { List < String > ans = new ArrayList <> (); int [] rows = { 2 , 3 , 3 , 2 , 1 , 2 , 2 , 2 , 1 , 2 , 2 , 2 , 3 , 3 , 1 , 1 , 1 , 1 , 2 , 1 , 1 , 3 , 1 , 3 , 1 , 3 }; for ( final String word : words ) { String lowerWord = word . toLowerCase (); int row = rows [ lowerWord . charAt ( 0 ) - 'a' ] ; boolean isValid = true ; for ( int i = 1 ; i < lowerWord . length (); ++ i ) if ( rows [ lowerWord . charAt ( i ) - 'a' ] != row ) { isValid = false ; break ; } if ( isValid ) ans . add ( word ); } return ans . toArray ( new String [ 0 ] ); } }","title":"0491-0500"},{"location":"java/0401-0500/0491-0500/#491-increasing-subsequences-starstar","text":"class Solution { public List < List < Integer >> findSubsequences ( int [] nums ) { List < List < Integer >> ans = new LinkedList <> (); dfs ( nums , 0 , new LinkedList <> (), ans ); return ans ; } private void dfs ( int [] nums , int s , LinkedList < Integer > path , List < List < Integer >> ans ) { if ( path . size () > 1 ) ans . add ( new LinkedList <> ( path )); Set < Integer > used = new HashSet <> (); for ( int i = s ; i < nums . length ; ++ i ) { if ( used . contains ( nums [ i ] )) continue ; if ( path . isEmpty () || nums [ i ] >= path . getLast ()) { used . add ( nums [ i ] ); path . addLast ( nums [ i ] ); dfs ( nums , i + 1 , path , ans ); path . removeLast (); } } } }","title":"491. Increasing Subsequences $\\star\\star$"},{"location":"java/0401-0500/0491-0500/#492-construct-the-rectangle-star","text":"","title":"492. Construct the Rectangle $\\star$"},{"location":"java/0401-0500/0491-0500/#493-reverse-pairs-starstarstar","text":"","title":"493. Reverse Pairs $\\star\\star\\star$"},{"location":"java/0401-0500/0491-0500/#494-target-sum-starstar","text":"class Solution { public int findTargetSumWays ( int [] nums , int S ) { final int sum = Arrays . stream ( nums ). sum (); if ( sum < S || ( sum + S ) % 2 == 1 ) return 0 ; return subsetSum ( nums , ( sum + S ) / 2 ); } private int subsetSum ( int [] nums , int s ) { int [] dp = new int [ s + 1 ] ; dp [ 0 ] = 1 ; for ( int num : nums ) for ( int w = s ; w >= num ; -- w ) dp [ w ] += dp [ w - num ] ; return dp [ s ] ; } }","title":"494. Target Sum $\\star\\star$"},{"location":"java/0401-0500/0491-0500/#495-teemo-attacking-starstar","text":"class Solution { public int findPoisonedDuration ( int [] timeSeries , int duration ) { if ( timeSeries . length == 0 || duration == 0 ) return 0 ; int ans = 0 ; for ( int i = 0 ; i + 1 < timeSeries . length ; ++ i ) ans += Math . min ( timeSeries [ i + 1 ] - timeSeries [ i ] , duration ); return ans + duration ; } }","title":"495. Teemo Attacking $\\star\\star$"},{"location":"java/0401-0500/0491-0500/#496-next-greater-element-i-star","text":"","title":"496. Next Greater Element I $\\star$"},{"location":"java/0401-0500/0491-0500/#497-random-point-in-non-overlapping-rectangles-starstar","text":"","title":"497. Random Point in Non-overlapping Rectangles $\\star\\star$"},{"location":"java/0401-0500/0491-0500/#498-diagonal-traverse-starstar","text":"","title":"498. Diagonal Traverse $\\star\\star$"},{"location":"java/0401-0500/0491-0500/#499-the-maze-iii-starstarstar","text":"","title":"499. The Maze III $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/0401-0500/0491-0500/#500-keyboard-row-star","text":"class Solution { public String [] findWords ( String [] words ) { List < String > ans = new ArrayList <> (); int [] rows = { 2 , 3 , 3 , 2 , 1 , 2 , 2 , 2 , 1 , 2 , 2 , 2 , 3 , 3 , 1 , 1 , 1 , 1 , 2 , 1 , 1 , 3 , 1 , 3 , 1 , 3 }; for ( final String word : words ) { String lowerWord = word . toLowerCase (); int row = rows [ lowerWord . charAt ( 0 ) - 'a' ] ; boolean isValid = true ; for ( int i = 1 ; i < lowerWord . length (); ++ i ) if ( rows [ lowerWord . charAt ( i ) - 'a' ] != row ) { isValid = false ; break ; } if ( isValid ) ans . add ( word ); } return ans . toArray ( new String [ 0 ] ); } }","title":"500. Keyboard Row $\\star$"},{"location":"java/0501-0600/0501-0510/","text":"501. Find Mode in Binary Search Tree $\\star$ 502. IPO $\\star\\star\\star$ 503. Next Greater Element II $\\star\\star$ class Solution { public int [] nextGreaterElements ( int [] nums ) { int [] ans = new int [ nums . length ] ; Arrays . fill ( ans , - 1 ); Stack < Integer > stack = new Stack <> (); for ( int i = 0 ; i < nums . length * 2 ; ++ i ) { int num = nums [ i % nums . length ] ; while ( ! stack . isEmpty () && nums [ stack . peek () ] < num ) ans [ stack . pop () ] = num ; if ( i < nums . length ) stack . push ( i ); } return ans ; } } 504. Base 7 $\\star$ 505. The Maze II $\\star\\star$ \ud83d\udd12 506. Relative Ranks $\\star$ 507. Perfect Number $\\star$ class Solution { public boolean checkPerfectNumber ( int num ) { if ( num == 1 ) return false ; int sum = 1 ; for ( int i = 2 ; i <= Math . sqrt ( num ); ++ i ) if ( num % i == 0 ) sum += i + num / i ; return sum == num ; } } 508. Most Frequent Subtree Sum $\\star\\star$ class Solution { public int [] findFrequentTreeSum ( TreeNode root ) { List < Integer > ans = new ArrayList <> (); Map < Integer , Integer > count = new HashMap <> (); int maxFreq = 0 ; dfs ( root , count ); for ( int freq : count . values ()) maxFreq = Math . max ( maxFreq , freq ); for ( int sum : count . keySet ()) if ( count . get ( sum ) == maxFreq ) ans . add ( sum ); return ans . stream (). mapToInt ( i -> i ). toArray (); } private int dfs ( TreeNode root , Map < Integer , Integer > count ) { if ( root == null ) return 0 ; int sum = root . val + dfs ( root . left , count ) + dfs ( root . right , count ); count . put ( sum , count . getOrDefault ( sum , 0 ) + 1 ); return sum ; } } 509. Fibonacci Number $\\star$ class Solution { public int fib ( int N ) { if ( N < 2 ) return N ; int [] dp = { 0 , 0 , 1 }; for ( int i = 2 ; i <= N ; ++ i ) { dp [ 0 ] = dp [ 1 ] ; dp [ 1 ] = dp [ 2 ] ; dp [ 2 ] = dp [ 0 ] + dp [ 1 ] ; } return dp [ 2 ] ; } } 510. Inorder Successor in BST II $\\star\\star$ \ud83d\udd12","title":"0501-0510"},{"location":"java/0501-0600/0501-0510/#501-find-mode-in-binary-search-tree-star","text":"","title":"501. Find Mode in Binary Search Tree $\\star$"},{"location":"java/0501-0600/0501-0510/#502-ipo-starstarstar","text":"","title":"502. IPO $\\star\\star\\star$"},{"location":"java/0501-0600/0501-0510/#503-next-greater-element-ii-starstar","text":"class Solution { public int [] nextGreaterElements ( int [] nums ) { int [] ans = new int [ nums . length ] ; Arrays . fill ( ans , - 1 ); Stack < Integer > stack = new Stack <> (); for ( int i = 0 ; i < nums . length * 2 ; ++ i ) { int num = nums [ i % nums . length ] ; while ( ! stack . isEmpty () && nums [ stack . peek () ] < num ) ans [ stack . pop () ] = num ; if ( i < nums . length ) stack . push ( i ); } return ans ; } }","title":"503. Next Greater Element II $\\star\\star$"},{"location":"java/0501-0600/0501-0510/#504-base-7-star","text":"","title":"504. Base 7 $\\star$"},{"location":"java/0501-0600/0501-0510/#505-the-maze-ii-starstar","text":"","title":"505. The Maze II $\\star\\star$ \ud83d\udd12"},{"location":"java/0501-0600/0501-0510/#506-relative-ranks-star","text":"","title":"506. Relative Ranks $\\star$"},{"location":"java/0501-0600/0501-0510/#507-perfect-number-star","text":"class Solution { public boolean checkPerfectNumber ( int num ) { if ( num == 1 ) return false ; int sum = 1 ; for ( int i = 2 ; i <= Math . sqrt ( num ); ++ i ) if ( num % i == 0 ) sum += i + num / i ; return sum == num ; } }","title":"507. Perfect Number $\\star$"},{"location":"java/0501-0600/0501-0510/#508-most-frequent-subtree-sum-starstar","text":"class Solution { public int [] findFrequentTreeSum ( TreeNode root ) { List < Integer > ans = new ArrayList <> (); Map < Integer , Integer > count = new HashMap <> (); int maxFreq = 0 ; dfs ( root , count ); for ( int freq : count . values ()) maxFreq = Math . max ( maxFreq , freq ); for ( int sum : count . keySet ()) if ( count . get ( sum ) == maxFreq ) ans . add ( sum ); return ans . stream (). mapToInt ( i -> i ). toArray (); } private int dfs ( TreeNode root , Map < Integer , Integer > count ) { if ( root == null ) return 0 ; int sum = root . val + dfs ( root . left , count ) + dfs ( root . right , count ); count . put ( sum , count . getOrDefault ( sum , 0 ) + 1 ); return sum ; } }","title":"508. Most Frequent Subtree Sum $\\star\\star$"},{"location":"java/0501-0600/0501-0510/#509-fibonacci-number-star","text":"class Solution { public int fib ( int N ) { if ( N < 2 ) return N ; int [] dp = { 0 , 0 , 1 }; for ( int i = 2 ; i <= N ; ++ i ) { dp [ 0 ] = dp [ 1 ] ; dp [ 1 ] = dp [ 2 ] ; dp [ 2 ] = dp [ 0 ] + dp [ 1 ] ; } return dp [ 2 ] ; } }","title":"509. Fibonacci Number $\\star$"},{"location":"java/0501-0600/0501-0510/#510-inorder-successor-in-bst-ii-starstar","text":"","title":"510. Inorder Successor in BST II $\\star\\star$ \ud83d\udd12"},{"location":"java/0501-0600/0511-0520/","text":"511. Game Play Analysis I $\\star$ \ud83d\udd12 512. Game Play Analysis II $\\star$ \ud83d\udd12 513. Find Bottom Left Tree Value $\\star\\star$ class Solution { public int findBottomLeftValue ( TreeNode root ) { Queue < TreeNode > queue = new LinkedList <> (); queue . add ( root ); while ( ! queue . isEmpty ()) { root = queue . poll (); if ( root . right != null ) queue . add ( root . right ); if ( root . left != null ) queue . add ( root . left ); } return root . val ; } } 514. Freedom Trail $\\star\\star\\star$ class Solution { public int findRotateSteps ( String ring , String key ) { Map < String , Integer > memo = new HashMap <> (); return dfs ( ring , key , 0 , memo ) + key . length (); } private int dfs ( final String ring , final String key , int index , Map < String , Integer > memo ) { if ( index == key . length ()) return 0 ; final String hashKey = ring + index ; if ( memo . containsKey ( hashKey )) return memo . get ( hashKey ); int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < ring . length (); ++ i ) if ( ring . charAt ( i ) == key . charAt ( index )) { int diff = Math . min ( i , ring . length () - i ); int step = dfs ( ring . substring ( i ) + ring . substring ( 0 , i ), key , index + 1 , memo ); ans = Math . min ( ans , diff + step ); } memo . put ( hashKey , ans ); return ans ; } } 515. Find Largest Value in Each Tree Row $\\star\\star$ class Solution { public List < Integer > largestValues ( TreeNode root ) { if ( root == null ) return new ArrayList <> (); List < Integer > ans = new ArrayList <> (); Queue < TreeNode > queue = new LinkedList <> (); queue . add ( root ); while ( ! queue . isEmpty ()) { int max = Integer . MIN_VALUE ; for ( int i = queue . size (); i > 0 ; -- i ) { root = queue . poll (); max = Math . max ( max , root . val ); if ( root . left != null ) queue . add ( root . left ); if ( root . right != null ) queue . add ( root . right ); } ans . add ( max ); } return ans ; } } 516. Longest Palindromic Subsequence $\\star\\star$ 517. Super Washing Machines $\\star\\star\\star$ class Solution { public int findMinMoves ( int [] machines ) { int dresses = Arrays . stream ( machines ). sum (); if ( dresses % machines . length != 0 ) return - 1 ; int ans = 0 ; int average = dresses / machines . length ; int inout = 0 ; for ( int dress : machines ) { inout += dress - average ; ans = Math . max ( ans , Math . max ( Math . abs ( inout ), dress - average )); } return ans ; } } 518. Coin Change 2 $\\star\\star$ Time: $O(nk)$, where n = len(coins) and k = target Space: $O(k)$ class Solution { public int change ( int amount , int [] coins ) { int [] dp = new int [ amount + 1 ] ; dp [ 0 ] = 1 ; for ( int coin : coins ) for ( int i = coin ; i <= amount ; ++ i ) dp [ i ] += dp [ i - coin ] ; return dp [ amount ] ; } } 519. Random Flip Matrix $\\star\\star$ 520. Detect Capital $\\star$ class Solution { public boolean detectCapitalUse ( String word ) { return word . equals ( word . toUpperCase ()) || word . substring ( 1 ). equals ( word . substring ( 1 ). toLowerCase ()); } }","title":"0511-0520"},{"location":"java/0501-0600/0511-0520/#511-game-play-analysis-i-star","text":"","title":"511. Game Play Analysis I $\\star$ \ud83d\udd12"},{"location":"java/0501-0600/0511-0520/#512-game-play-analysis-ii-star","text":"","title":"512. Game Play Analysis II $\\star$ \ud83d\udd12"},{"location":"java/0501-0600/0511-0520/#513-find-bottom-left-tree-value-starstar","text":"class Solution { public int findBottomLeftValue ( TreeNode root ) { Queue < TreeNode > queue = new LinkedList <> (); queue . add ( root ); while ( ! queue . isEmpty ()) { root = queue . poll (); if ( root . right != null ) queue . add ( root . right ); if ( root . left != null ) queue . add ( root . left ); } return root . val ; } }","title":"513. Find Bottom Left Tree Value $\\star\\star$"},{"location":"java/0501-0600/0511-0520/#514-freedom-trail-starstarstar","text":"class Solution { public int findRotateSteps ( String ring , String key ) { Map < String , Integer > memo = new HashMap <> (); return dfs ( ring , key , 0 , memo ) + key . length (); } private int dfs ( final String ring , final String key , int index , Map < String , Integer > memo ) { if ( index == key . length ()) return 0 ; final String hashKey = ring + index ; if ( memo . containsKey ( hashKey )) return memo . get ( hashKey ); int ans = Integer . MAX_VALUE ; for ( int i = 0 ; i < ring . length (); ++ i ) if ( ring . charAt ( i ) == key . charAt ( index )) { int diff = Math . min ( i , ring . length () - i ); int step = dfs ( ring . substring ( i ) + ring . substring ( 0 , i ), key , index + 1 , memo ); ans = Math . min ( ans , diff + step ); } memo . put ( hashKey , ans ); return ans ; } }","title":"514. Freedom Trail $\\star\\star\\star$"},{"location":"java/0501-0600/0511-0520/#515-find-largest-value-in-each-tree-row-starstar","text":"class Solution { public List < Integer > largestValues ( TreeNode root ) { if ( root == null ) return new ArrayList <> (); List < Integer > ans = new ArrayList <> (); Queue < TreeNode > queue = new LinkedList <> (); queue . add ( root ); while ( ! queue . isEmpty ()) { int max = Integer . MIN_VALUE ; for ( int i = queue . size (); i > 0 ; -- i ) { root = queue . poll (); max = Math . max ( max , root . val ); if ( root . left != null ) queue . add ( root . left ); if ( root . right != null ) queue . add ( root . right ); } ans . add ( max ); } return ans ; } }","title":"515. Find Largest Value in Each Tree Row $\\star\\star$"},{"location":"java/0501-0600/0511-0520/#516-longest-palindromic-subsequence-starstar","text":"","title":"516. Longest Palindromic Subsequence $\\star\\star$"},{"location":"java/0501-0600/0511-0520/#517-super-washing-machines-starstarstar","text":"class Solution { public int findMinMoves ( int [] machines ) { int dresses = Arrays . stream ( machines ). sum (); if ( dresses % machines . length != 0 ) return - 1 ; int ans = 0 ; int average = dresses / machines . length ; int inout = 0 ; for ( int dress : machines ) { inout += dress - average ; ans = Math . max ( ans , Math . max ( Math . abs ( inout ), dress - average )); } return ans ; } }","title":"517. Super Washing Machines $\\star\\star\\star$"},{"location":"java/0501-0600/0511-0520/#518-coin-change-2-starstar","text":"Time: $O(nk)$, where n = len(coins) and k = target Space: $O(k)$ class Solution { public int change ( int amount , int [] coins ) { int [] dp = new int [ amount + 1 ] ; dp [ 0 ] = 1 ; for ( int coin : coins ) for ( int i = coin ; i <= amount ; ++ i ) dp [ i ] += dp [ i - coin ] ; return dp [ amount ] ; } }","title":"518. Coin Change 2 $\\star\\star$"},{"location":"java/0501-0600/0511-0520/#519-random-flip-matrix-starstar","text":"","title":"519. Random Flip Matrix $\\star\\star$"},{"location":"java/0501-0600/0511-0520/#520-detect-capital-star","text":"class Solution { public boolean detectCapitalUse ( String word ) { return word . equals ( word . toUpperCase ()) || word . substring ( 1 ). equals ( word . substring ( 1 ). toLowerCase ()); } }","title":"520. Detect Capital $\\star$"},{"location":"java/0501-0600/0521-0530/","text":"521. Longest Uncommon Subsequence I $\\star$ class Solution { public int findLUSlength ( String a , String b ) { return a . equals ( b ) ? - 1 : Math . max ( a . length (), b . length ()); } } 522. Longest Uncommon Subsequence II $\\star\\star$ class Solution { public int findLUSlength ( String [] strs ) { Set < String > seen = new HashSet <> (); Set < String > duplicates = new HashSet <> (); for ( final String str : strs ) { if ( seen . contains ( str )) duplicates . add ( str ); seen . add ( str ); } Arrays . sort ( strs , ( a , b ) -> b . length () - a . length ()); for ( int i = 0 ; i < strs . length ; ++ i ) { if ( duplicates . contains ( strs [ i ] )) continue ; boolean isASubsequence = false ; for ( int j = 0 ; j < i ; ++ j ) isASubsequence |= isSubsequence ( strs [ i ] , strs [ j ] ); if ( ! isASubsequence ) return strs [ i ] . length (); } return - 1 ; } private boolean isSubsequence ( final String a , final String b ) { int i = 0 ; for ( int j = 0 ; i < a . length () && j < b . length (); ++ j ) if ( a . charAt ( i ) == b . charAt ( j )) ++ i ; return i == a . length (); } } 523. Continuous Subarray Sum $\\star\\star$ class Solution { public boolean checkSubarraySum ( int [] nums , int k ) { int prefixSum = 0 ; Map < Integer , Integer > prefixSumToIndex = new HashMap <> (); prefixSumToIndex . put ( 0 , - 1 ); for ( int i = 0 ; i < nums . length ; ++ i ) { prefixSum += nums [ i ] ; if ( k != 0 ) prefixSum %= k ; if ( prefixSumToIndex . containsKey ( prefixSum )) { if ( i - prefixSumToIndex . get ( prefixSum ) > 1 ) return true ; } else prefixSumToIndex . put ( prefixSum , i ); } return false ; } } 524. Longest Word in Dictionary through Deleting $\\star\\star$ class Solution { public String findLongestWord ( String s , List < String > d ) { String ans = \"\" ; for ( final String word : d ) { int i = 0 ; for ( char c : s . toCharArray ()) if ( i < word . length () && c == word . charAt ( i )) ++ i ; if ( i == word . length ()) if ( word . length () > ans . length () || word . length () == ans . length () && word . compareTo ( ans ) < 0 ) ans = word ; } return ans ; } } 525. Contiguous Array $\\star\\star$ class Solution { public int findMaxLength ( int [] nums ) { int ans = 0 ; int prefixSum = 0 ; Map < Integer , Integer > prefixSumToIndex = new HashMap <> (); prefixSumToIndex . put ( 0 , - 1 ); for ( int i = 0 ; i < nums . length ; ++ i ) { prefixSum += nums [ i ] == 1 ? 1 : - 1 ; if ( prefixSumToIndex . containsKey ( prefixSum )) ans = Math . max ( ans , i - prefixSumToIndex . get ( prefixSum )); else prefixSumToIndex . put ( prefixSum , i ); } return ans ; } } 526. Beautiful Arrangement $\\star\\star$ 527. Word Abbreviation $\\star\\star\\star$ \ud83d\udd12 528. Random Pick with Weight $\\star\\star$ 529. Minesweeper $\\star\\star$ class Solution { public char [][] updateBoard ( char [][] board , int [] click ) { if ( board [ click [ 0 ]][ click [ 1 ]] == 'M' ) { board [ click [ 0 ]][ click [ 1 ]] = 'X' ; return board ; } dfs ( board , click [ 0 ] , click [ 1 ] ); return board ; } private int [][] dirs = new int [][] { { - 1 , - 1 }, { - 1 , 0 }, { - 1 , 1 }, { 0 , - 1 }, { 0 , 1 }, { 1 , - 1 }, { 1 , 0 }, { 1 , 1 } }; private void dfs ( char [][] board , int i , int j ) { if ( i < 0 || i >= board . length || j < 0 || j >= board [ 0 ] . length || board [ i ][ j ] != 'E' ) return ; int minesCount = 0 ; for ( final int [] dir : dirs ) { int x = i + dir [ 0 ] ; int y = j + dir [ 1 ] ; if ( 0 <= x && x < board . length && 0 <= y && y < board [ 0 ] . length && board [ x ][ y ] == 'M' ) ++ minesCount ; } board [ i ][ j ] = minesCount > 0 ? ( char ) ( '0' + minesCount ) : 'B' ; if ( minesCount == 0 ) for ( final int [] dir : dirs ) dfs ( board , i + dir [ 0 ] , j + dir [ 1 ] ); } } 530. Minimum Absolute Difference in BST $\\star$","title":"0521-0530"},{"location":"java/0501-0600/0521-0530/#521-longest-uncommon-subsequence-i-star","text":"class Solution { public int findLUSlength ( String a , String b ) { return a . equals ( b ) ? - 1 : Math . max ( a . length (), b . length ()); } }","title":"521. Longest Uncommon Subsequence I  $\\star$"},{"location":"java/0501-0600/0521-0530/#522-longest-uncommon-subsequence-ii-starstar","text":"class Solution { public int findLUSlength ( String [] strs ) { Set < String > seen = new HashSet <> (); Set < String > duplicates = new HashSet <> (); for ( final String str : strs ) { if ( seen . contains ( str )) duplicates . add ( str ); seen . add ( str ); } Arrays . sort ( strs , ( a , b ) -> b . length () - a . length ()); for ( int i = 0 ; i < strs . length ; ++ i ) { if ( duplicates . contains ( strs [ i ] )) continue ; boolean isASubsequence = false ; for ( int j = 0 ; j < i ; ++ j ) isASubsequence |= isSubsequence ( strs [ i ] , strs [ j ] ); if ( ! isASubsequence ) return strs [ i ] . length (); } return - 1 ; } private boolean isSubsequence ( final String a , final String b ) { int i = 0 ; for ( int j = 0 ; i < a . length () && j < b . length (); ++ j ) if ( a . charAt ( i ) == b . charAt ( j )) ++ i ; return i == a . length (); } }","title":"522. Longest Uncommon Subsequence II $\\star\\star$"},{"location":"java/0501-0600/0521-0530/#523-continuous-subarray-sum-starstar","text":"class Solution { public boolean checkSubarraySum ( int [] nums , int k ) { int prefixSum = 0 ; Map < Integer , Integer > prefixSumToIndex = new HashMap <> (); prefixSumToIndex . put ( 0 , - 1 ); for ( int i = 0 ; i < nums . length ; ++ i ) { prefixSum += nums [ i ] ; if ( k != 0 ) prefixSum %= k ; if ( prefixSumToIndex . containsKey ( prefixSum )) { if ( i - prefixSumToIndex . get ( prefixSum ) > 1 ) return true ; } else prefixSumToIndex . put ( prefixSum , i ); } return false ; } }","title":"523. Continuous Subarray Sum $\\star\\star$"},{"location":"java/0501-0600/0521-0530/#524-longest-word-in-dictionary-through-deleting-starstar","text":"class Solution { public String findLongestWord ( String s , List < String > d ) { String ans = \"\" ; for ( final String word : d ) { int i = 0 ; for ( char c : s . toCharArray ()) if ( i < word . length () && c == word . charAt ( i )) ++ i ; if ( i == word . length ()) if ( word . length () > ans . length () || word . length () == ans . length () && word . compareTo ( ans ) < 0 ) ans = word ; } return ans ; } }","title":"524. Longest Word in Dictionary through Deleting $\\star\\star$"},{"location":"java/0501-0600/0521-0530/#525-contiguous-array-starstar","text":"class Solution { public int findMaxLength ( int [] nums ) { int ans = 0 ; int prefixSum = 0 ; Map < Integer , Integer > prefixSumToIndex = new HashMap <> (); prefixSumToIndex . put ( 0 , - 1 ); for ( int i = 0 ; i < nums . length ; ++ i ) { prefixSum += nums [ i ] == 1 ? 1 : - 1 ; if ( prefixSumToIndex . containsKey ( prefixSum )) ans = Math . max ( ans , i - prefixSumToIndex . get ( prefixSum )); else prefixSumToIndex . put ( prefixSum , i ); } return ans ; } }","title":"525. Contiguous Array $\\star\\star$"},{"location":"java/0501-0600/0521-0530/#526-beautiful-arrangement-starstar","text":"","title":"526. Beautiful Arrangement $\\star\\star$"},{"location":"java/0501-0600/0521-0530/#527-word-abbreviation-starstarstar","text":"","title":"527. Word Abbreviation $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/0501-0600/0521-0530/#528-random-pick-with-weight-starstar","text":"","title":"528. Random Pick with Weight $\\star\\star$"},{"location":"java/0501-0600/0521-0530/#529-minesweeper-starstar","text":"class Solution { public char [][] updateBoard ( char [][] board , int [] click ) { if ( board [ click [ 0 ]][ click [ 1 ]] == 'M' ) { board [ click [ 0 ]][ click [ 1 ]] = 'X' ; return board ; } dfs ( board , click [ 0 ] , click [ 1 ] ); return board ; } private int [][] dirs = new int [][] { { - 1 , - 1 }, { - 1 , 0 }, { - 1 , 1 }, { 0 , - 1 }, { 0 , 1 }, { 1 , - 1 }, { 1 , 0 }, { 1 , 1 } }; private void dfs ( char [][] board , int i , int j ) { if ( i < 0 || i >= board . length || j < 0 || j >= board [ 0 ] . length || board [ i ][ j ] != 'E' ) return ; int minesCount = 0 ; for ( final int [] dir : dirs ) { int x = i + dir [ 0 ] ; int y = j + dir [ 1 ] ; if ( 0 <= x && x < board . length && 0 <= y && y < board [ 0 ] . length && board [ x ][ y ] == 'M' ) ++ minesCount ; } board [ i ][ j ] = minesCount > 0 ? ( char ) ( '0' + minesCount ) : 'B' ; if ( minesCount == 0 ) for ( final int [] dir : dirs ) dfs ( board , i + dir [ 0 ] , j + dir [ 1 ] ); } }","title":"529. Minesweeper $\\star\\star$"},{"location":"java/0501-0600/0521-0530/#530-minimum-absolute-difference-in-bst-star","text":"","title":"530. Minimum Absolute Difference in BST $\\star$"},{"location":"java/0501-0600/0531-0540/","text":"531. Lonely Pixel I $\\star\\star$ \ud83d\udd12 532. K-diff Pairs in an Array $\\star$ class Solution { public int findPairs ( int [] nums , int k ) { if ( k < 0 ) return 0 ; int ans = 0 ; Map < Integer , Integer > map = new HashMap <> (); for ( int i = 0 ; i < nums . length ; ++ i ) map . put ( nums [ i ] , i ); for ( int i = 0 ; i < nums . length ; ++ i ) { int target = nums [ i ] + k ; if ( map . containsKey ( target ) && map . get ( target ) != i ) { ++ ans ; map . remove ( target ); } } return ans ; } } 533. Lonely Pixel II $\\star\\star$ \ud83d\udd12 534. Game Play Analysis III $\\star\\star$ \ud83d\udd12 535. Encode and Decode TinyURL $\\star\\star$ public class Codec { public String encode ( String longUrl ) { while ( ! urlToCode . containsKey ( longUrl )) { String code = \"\" ; for ( int i = 0 ; i < 6 ; ++ i ) code += alphabets . charAt ( rand . nextInt ( alphabets . length ())); if ( ! codeToUrl . containsKey ( code )) { codeToUrl . put ( code , longUrl ); urlToCode . put ( longUrl , code ); return \"http://tinyurl.com/\" + code ; } } throw new IllegalArgumentException (); } public String decode ( String shortUrl ) { return codeToUrl . get ( shortUrl . substring ( 19 )); } private final String alphabets = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\" ; private Map < String , String > urlToCode = new HashMap <> (); private Map < String , String > codeToUrl = new HashMap <> (); private Random rand = new Random (); } 536. Construct Binary Tree from String $\\star\\star$ \ud83d\udd12 537. Complex Number Multiplication $\\star\\star$ class Solution { public String complexNumberMultiply ( String a , String b ) { int [] A = getRealAndImag ( a ); int [] B = getRealAndImag ( b ); return String . valueOf ( A [ 0 ] * B [ 0 ] - A [ 1 ] * B [ 1 ] ) + \"+\" + String . valueOf ( A [ 0 ] * B [ 1 ] + A [ 1 ] * B [ 0 ] ) + \"i\" ; } private int [] getRealAndImag ( final String s ) { String real = s . substring ( 0 , s . indexOf ( '+' )); String imag = s . substring ( s . indexOf ( '+' ) + 1 , s . length () - 1 ); return new int [] { Integer . valueOf ( real ), Integer . valueOf ( imag ) }; } } 538. Convert BST to Greater Tree $\\star$ 539. Minimum Time Difference $\\star\\star$ class Solution { public int findMinDifference ( List < String > timePoints ) { int ans = 24 * 60 ; int first = 24 * 60 ; boolean [] bucket = new boolean [ 24 * 60 ] ; for ( final String timePoint : timePoints ) { int num = Integer . valueOf ( timePoint . substring ( 0 , 2 )) * 60 + Integer . valueOf ( timePoint . substring ( 3 )); first = Math . min ( first , num ); if ( bucket [ num ] ) return 0 ; bucket [ num ] = true ; } int prev = first ; for ( int i = first + 1 ; i < bucket . length ; ++ i ) if ( bucket [ i ] ) { ans = Math . min ( ans , i - prev ); prev = i ; } return Math . min ( ans , 24 * 60 - prev + first ); } } 540. Single Element in a Sorted Array $\\star\\star$ class Solution { public int singleNonDuplicate ( int [] nums ) { int l = 0 ; int r = nums . length - 1 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( m % 2 == 1 ) -- m ; if ( nums [ m ] == nums [ m + 1 ] ) l = m + 2 ; else r = m ; } return nums [ l ] ; } }","title":"0531-0540"},{"location":"java/0501-0600/0531-0540/#531-lonely-pixel-i-starstar","text":"","title":"531. Lonely Pixel I $\\star\\star$ \ud83d\udd12"},{"location":"java/0501-0600/0531-0540/#532-k-diff-pairs-in-an-array-star","text":"class Solution { public int findPairs ( int [] nums , int k ) { if ( k < 0 ) return 0 ; int ans = 0 ; Map < Integer , Integer > map = new HashMap <> (); for ( int i = 0 ; i < nums . length ; ++ i ) map . put ( nums [ i ] , i ); for ( int i = 0 ; i < nums . length ; ++ i ) { int target = nums [ i ] + k ; if ( map . containsKey ( target ) && map . get ( target ) != i ) { ++ ans ; map . remove ( target ); } } return ans ; } }","title":"532. K-diff Pairs in an Array $\\star$"},{"location":"java/0501-0600/0531-0540/#533-lonely-pixel-ii-starstar","text":"","title":"533. Lonely Pixel II $\\star\\star$ \ud83d\udd12"},{"location":"java/0501-0600/0531-0540/#534-game-play-analysis-iii-starstar","text":"","title":"534. Game Play Analysis III $\\star\\star$ \ud83d\udd12"},{"location":"java/0501-0600/0531-0540/#535-encode-and-decode-tinyurl-starstar","text":"public class Codec { public String encode ( String longUrl ) { while ( ! urlToCode . containsKey ( longUrl )) { String code = \"\" ; for ( int i = 0 ; i < 6 ; ++ i ) code += alphabets . charAt ( rand . nextInt ( alphabets . length ())); if ( ! codeToUrl . containsKey ( code )) { codeToUrl . put ( code , longUrl ); urlToCode . put ( longUrl , code ); return \"http://tinyurl.com/\" + code ; } } throw new IllegalArgumentException (); } public String decode ( String shortUrl ) { return codeToUrl . get ( shortUrl . substring ( 19 )); } private final String alphabets = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\" ; private Map < String , String > urlToCode = new HashMap <> (); private Map < String , String > codeToUrl = new HashMap <> (); private Random rand = new Random (); }","title":"535. Encode and Decode TinyURL $\\star\\star$"},{"location":"java/0501-0600/0531-0540/#536-construct-binary-tree-from-string-starstar","text":"","title":"536. Construct Binary Tree from String $\\star\\star$ \ud83d\udd12"},{"location":"java/0501-0600/0531-0540/#537-complex-number-multiplication-starstar","text":"class Solution { public String complexNumberMultiply ( String a , String b ) { int [] A = getRealAndImag ( a ); int [] B = getRealAndImag ( b ); return String . valueOf ( A [ 0 ] * B [ 0 ] - A [ 1 ] * B [ 1 ] ) + \"+\" + String . valueOf ( A [ 0 ] * B [ 1 ] + A [ 1 ] * B [ 0 ] ) + \"i\" ; } private int [] getRealAndImag ( final String s ) { String real = s . substring ( 0 , s . indexOf ( '+' )); String imag = s . substring ( s . indexOf ( '+' ) + 1 , s . length () - 1 ); return new int [] { Integer . valueOf ( real ), Integer . valueOf ( imag ) }; } }","title":"537. Complex Number Multiplication $\\star\\star$"},{"location":"java/0501-0600/0531-0540/#538-convert-bst-to-greater-tree-star","text":"","title":"538. Convert BST to Greater Tree $\\star$"},{"location":"java/0501-0600/0531-0540/#539-minimum-time-difference-starstar","text":"class Solution { public int findMinDifference ( List < String > timePoints ) { int ans = 24 * 60 ; int first = 24 * 60 ; boolean [] bucket = new boolean [ 24 * 60 ] ; for ( final String timePoint : timePoints ) { int num = Integer . valueOf ( timePoint . substring ( 0 , 2 )) * 60 + Integer . valueOf ( timePoint . substring ( 3 )); first = Math . min ( first , num ); if ( bucket [ num ] ) return 0 ; bucket [ num ] = true ; } int prev = first ; for ( int i = first + 1 ; i < bucket . length ; ++ i ) if ( bucket [ i ] ) { ans = Math . min ( ans , i - prev ); prev = i ; } return Math . min ( ans , 24 * 60 - prev + first ); } }","title":"539. Minimum Time Difference $\\star\\star$"},{"location":"java/0501-0600/0531-0540/#540-single-element-in-a-sorted-array-starstar","text":"class Solution { public int singleNonDuplicate ( int [] nums ) { int l = 0 ; int r = nums . length - 1 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( m % 2 == 1 ) -- m ; if ( nums [ m ] == nums [ m + 1 ] ) l = m + 2 ; else r = m ; } return nums [ l ] ; } }","title":"540. Single Element in a Sorted Array $\\star\\star$"},{"location":"java/0501-0600/0541-0550/","text":"541. Reverse String II $\\star$ class Solution { public String reverseStr ( String s , int k ) { char [] charArray = s . toCharArray (); for ( int i = 0 ; i < charArray . length ; i += 2 * k ) { int l = i ; int r = Math . min ( i + k - 1 , charArray . length - 1 ); while ( l < r ) { char temp = charArray [ l ] ; charArray [ l ++] = charArray [ r ] ; charArray [ r --] = temp ; } } return new String ( charArray ); } } 542. 01 Matrix $\\star\\star$ class Solution { public int [][] updateMatrix ( int [][] matrix ) { final int [] dirs = new int [] { 0 , 1 , 0 , - 1 , 0 }; Queue < int []> queue = new LinkedList <> (); for ( int i = 0 ; i < matrix . length ; ++ i ) for ( int j = 0 ; j < matrix [ 0 ] . length ; ++ j ) if ( matrix [ i ][ j ] == 0 ) queue . add ( new int [] { i , j }); else matrix [ i ][ j ] = Integer . MAX_VALUE ; while ( ! queue . isEmpty ()) { int [] cell = queue . poll (); for ( int k = 0 ; k < 4 ; ++ k ) { int x = cell [ 0 ] + dirs [ k ] ; int y = cell [ 1 ] + dirs [ k + 1 ] ; if ( x < 0 || x >= matrix . length || y < 0 || y >= matrix [ 0 ] . length || matrix [ x ][ y ] <= matrix [ cell [ 0 ]][ cell [ 1 ]] + 1 ) continue ; queue . add ( new int [] { x , y }); matrix [ x ][ y ] = matrix [ cell [ 0 ]][ cell [ 1 ]] + 1 ; } } return matrix ; } } 543. Diameter of Binary Tree $\\star$ 544. Output Contest Matches $\\star\\star$ \ud83d\udd12 545. Boundary of Binary Tree $\\star\\star$ \ud83d\udd12 546. Remove Boxes $\\star\\star\\star$ 547. Friend Circles $\\star\\star$ class Solution { public int findCircleNum ( int [][] M ) { final int n = M . length ; UF uf = new UF ( n ); Set < Integer > friendCircle = new HashSet <> (); for ( int i = 0 ; i < n ; ++ i ) for ( int j = i ; j < n ; ++ j ) if ( M [ i ][ j ] == 1 ) uf . union ( i , j ); for ( int i = 0 ; i < n ; ++ i ) friendCircle . add ( uf . find ( i )); return friendCircle . size (); } } class UF { public UF ( int n ) { rank = new int [ n ] ; parent = new int [ n ] ; for ( int i = 0 ; i < parent . length ; ++ i ) parent [ i ] = i ; } public void union ( int u , int v ) { int pu = find ( u ); int pv = find ( v ); if ( pu == pv ) return ; if ( rank [ pu ] < rank [ pv ] ) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ] ) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ] ; } } public int find ( int u ) { while ( u != parent [ u ] ) { parent [ u ] = parent [ parent [ u ]] ; u = parent [ u ] ; } return u ; } private int [] rank ; private int [] parent ; } 548. Split Array with Equal Sum $\\star\\star$ \ud83d\udd12 549. Binary Tree Longest Consecutive Sequence II $\\star\\star$ \ud83d\udd12 550. Game Play Analysis IV $\\star\\star$ \ud83d\udd12","title":"0541-0550"},{"location":"java/0501-0600/0541-0550/#541-reverse-string-ii-star","text":"class Solution { public String reverseStr ( String s , int k ) { char [] charArray = s . toCharArray (); for ( int i = 0 ; i < charArray . length ; i += 2 * k ) { int l = i ; int r = Math . min ( i + k - 1 , charArray . length - 1 ); while ( l < r ) { char temp = charArray [ l ] ; charArray [ l ++] = charArray [ r ] ; charArray [ r --] = temp ; } } return new String ( charArray ); } }","title":"541. Reverse String II $\\star$"},{"location":"java/0501-0600/0541-0550/#542-01-matrix-starstar","text":"class Solution { public int [][] updateMatrix ( int [][] matrix ) { final int [] dirs = new int [] { 0 , 1 , 0 , - 1 , 0 }; Queue < int []> queue = new LinkedList <> (); for ( int i = 0 ; i < matrix . length ; ++ i ) for ( int j = 0 ; j < matrix [ 0 ] . length ; ++ j ) if ( matrix [ i ][ j ] == 0 ) queue . add ( new int [] { i , j }); else matrix [ i ][ j ] = Integer . MAX_VALUE ; while ( ! queue . isEmpty ()) { int [] cell = queue . poll (); for ( int k = 0 ; k < 4 ; ++ k ) { int x = cell [ 0 ] + dirs [ k ] ; int y = cell [ 1 ] + dirs [ k + 1 ] ; if ( x < 0 || x >= matrix . length || y < 0 || y >= matrix [ 0 ] . length || matrix [ x ][ y ] <= matrix [ cell [ 0 ]][ cell [ 1 ]] + 1 ) continue ; queue . add ( new int [] { x , y }); matrix [ x ][ y ] = matrix [ cell [ 0 ]][ cell [ 1 ]] + 1 ; } } return matrix ; } }","title":"542. 01 Matrix $\\star\\star$"},{"location":"java/0501-0600/0541-0550/#543-diameter-of-binary-tree-star","text":"","title":"543. Diameter of Binary Tree $\\star$"},{"location":"java/0501-0600/0541-0550/#544-output-contest-matches-starstar","text":"","title":"544. Output Contest Matches $\\star\\star$ \ud83d\udd12"},{"location":"java/0501-0600/0541-0550/#545-boundary-of-binary-tree-starstar","text":"","title":"545. Boundary of Binary Tree $\\star\\star$ \ud83d\udd12"},{"location":"java/0501-0600/0541-0550/#546-remove-boxes-starstarstar","text":"","title":"546. Remove Boxes $\\star\\star\\star$"},{"location":"java/0501-0600/0541-0550/#547-friend-circles-starstar","text":"class Solution { public int findCircleNum ( int [][] M ) { final int n = M . length ; UF uf = new UF ( n ); Set < Integer > friendCircle = new HashSet <> (); for ( int i = 0 ; i < n ; ++ i ) for ( int j = i ; j < n ; ++ j ) if ( M [ i ][ j ] == 1 ) uf . union ( i , j ); for ( int i = 0 ; i < n ; ++ i ) friendCircle . add ( uf . find ( i )); return friendCircle . size (); } } class UF { public UF ( int n ) { rank = new int [ n ] ; parent = new int [ n ] ; for ( int i = 0 ; i < parent . length ; ++ i ) parent [ i ] = i ; } public void union ( int u , int v ) { int pu = find ( u ); int pv = find ( v ); if ( pu == pv ) return ; if ( rank [ pu ] < rank [ pv ] ) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ] ) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ] ; } } public int find ( int u ) { while ( u != parent [ u ] ) { parent [ u ] = parent [ parent [ u ]] ; u = parent [ u ] ; } return u ; } private int [] rank ; private int [] parent ; }","title":"547. Friend Circles $\\star\\star$"},{"location":"java/0501-0600/0541-0550/#548-split-array-with-equal-sum-starstar","text":"","title":"548. Split Array with Equal Sum $\\star\\star$ \ud83d\udd12"},{"location":"java/0501-0600/0541-0550/#549-binary-tree-longest-consecutive-sequence-ii-starstar","text":"","title":"549. Binary Tree Longest Consecutive Sequence II $\\star\\star$ \ud83d\udd12"},{"location":"java/0501-0600/0541-0550/#550-game-play-analysis-iv-starstar","text":"","title":"550. Game Play Analysis IV $\\star\\star$ \ud83d\udd12"},{"location":"java/0501-0600/0551-0560/","text":"551. Student Attendance Record I $\\star$ class Solution { public boolean checkRecord ( String s ) { return s . indexOf ( \"A\" ) == s . lastIndexOf ( \"A\" ) && ! s . contains ( \"LLL\" ); } } 552. Student Attendance Record II $\\star\\star\\star$ 553. Optimal Division $\\star\\star$ class Solution { public String optimalDivision ( int [] nums ) { String ans = String . valueOf ( nums [ 0 ] ); if ( nums . length == 1 ) return ans ; if ( nums . length == 2 ) return ans + \"/\" + String . valueOf ( nums [ 1 ] ); ans += \"/(\" + String . valueOf ( nums [ 1 ] ); for ( int i = 2 ; i < nums . length ; ++ i ) ans += \"/\" + String . valueOf ( nums [ i ] ); ans += \")\" ; return ans ; } } 554. Brick Wall $\\star\\star$ class Solution { public int leastBricks ( List < List < Integer >> wall ) { int maxFreq = 0 ; Map < Integer , Integer > count = new HashMap <> (); for ( List < Integer > row : wall ) { int prefixSum = 0 ; for ( int i = 0 ; i < row . size () - 1 ; ++ i ) { prefixSum += row . get ( i ); count . put ( prefixSum , count . getOrDefault ( prefixSum , 0 ) + 1 ); maxFreq = Math . max ( maxFreq , count . get ( prefixSum )); } } return wall . size () - maxFreq ; } } 555. Split Concatenated Strings $\\star\\star$ \ud83d\udd12 556. Next Greater Element III $\\star\\star$ class Solution { public int nextGreaterElement ( int n ) { String s = nextPermutation ( String . valueOf ( n ). toCharArray ()); long ans = Long . valueOf ( s ); return ans > Integer . MAX_VALUE || ans <= ( long ) n ? - 1 : ( int ) ans ; } private String nextPermutation ( char [] charArray ) { int i ; for ( i = charArray . length - 2 ; i >= 0 ; -- i ) if ( charArray [ i ] < charArray [ i + 1 ] ) break ; if ( i >= 0 ) { int j ; for ( j = charArray . length - 1 ; j > i ; -- j ) if ( charArray [ j ] > charArray [ i ] ) break ; swap ( charArray , i , j ); } reverse ( charArray , i + 1 , charArray . length - 1 ); return new String ( charArray ); } private void reverse ( char [] charArray , int l , int r ) { while ( l < r ) swap ( charArray , l ++ , r -- ); } private void swap ( char [] charArray , int i , int j ) { char temp = charArray [ i ] ; charArray [ i ] = charArray [ j ] ; charArray [ j ] = temp ; } } 557. Reverse Words in a String III $\\star$ 558. Logical OR of Two Binary Grids Represented as Quad-Trees $\\star\\star$ 559. Maximum Depth of N-ary Tree $\\star$ class Solution { public int maxDepth ( Node root ) { if ( root == null ) return 0 ; int ans = 0 ; for ( Node child : root . children ) ans = Math . max ( ans , maxDepth ( child )); return 1 + ans ; } } 560. Subarray Sum Equals K $\\star\\star$ class Solution { public int subarraySum ( int [] nums , int k ) { int ans = 0 ; int sum = 0 ; Map < Integer , Integer > count = new HashMap <> (); count . put ( 0 , 1 ); for ( int num : nums ) { sum += num ; ans += count . getOrDefault ( sum - k , 0 ); count . put ( sum , count . getOrDefault ( sum , 0 ) + 1 ); } return ans ; } }","title":"0551-0560"},{"location":"java/0501-0600/0551-0560/#551-student-attendance-record-i-star","text":"class Solution { public boolean checkRecord ( String s ) { return s . indexOf ( \"A\" ) == s . lastIndexOf ( \"A\" ) && ! s . contains ( \"LLL\" ); } }","title":"551. Student Attendance Record I $\\star$"},{"location":"java/0501-0600/0551-0560/#552-student-attendance-record-ii-starstarstar","text":"","title":"552. Student Attendance Record II $\\star\\star\\star$"},{"location":"java/0501-0600/0551-0560/#553-optimal-division-starstar","text":"class Solution { public String optimalDivision ( int [] nums ) { String ans = String . valueOf ( nums [ 0 ] ); if ( nums . length == 1 ) return ans ; if ( nums . length == 2 ) return ans + \"/\" + String . valueOf ( nums [ 1 ] ); ans += \"/(\" + String . valueOf ( nums [ 1 ] ); for ( int i = 2 ; i < nums . length ; ++ i ) ans += \"/\" + String . valueOf ( nums [ i ] ); ans += \")\" ; return ans ; } }","title":"553. Optimal Division $\\star\\star$"},{"location":"java/0501-0600/0551-0560/#554-brick-wall-starstar","text":"class Solution { public int leastBricks ( List < List < Integer >> wall ) { int maxFreq = 0 ; Map < Integer , Integer > count = new HashMap <> (); for ( List < Integer > row : wall ) { int prefixSum = 0 ; for ( int i = 0 ; i < row . size () - 1 ; ++ i ) { prefixSum += row . get ( i ); count . put ( prefixSum , count . getOrDefault ( prefixSum , 0 ) + 1 ); maxFreq = Math . max ( maxFreq , count . get ( prefixSum )); } } return wall . size () - maxFreq ; } }","title":"554. Brick Wall $\\star\\star$"},{"location":"java/0501-0600/0551-0560/#555-split-concatenated-strings-starstar","text":"","title":"555. Split Concatenated Strings $\\star\\star$ \ud83d\udd12"},{"location":"java/0501-0600/0551-0560/#556-next-greater-element-iii-starstar","text":"class Solution { public int nextGreaterElement ( int n ) { String s = nextPermutation ( String . valueOf ( n ). toCharArray ()); long ans = Long . valueOf ( s ); return ans > Integer . MAX_VALUE || ans <= ( long ) n ? - 1 : ( int ) ans ; } private String nextPermutation ( char [] charArray ) { int i ; for ( i = charArray . length - 2 ; i >= 0 ; -- i ) if ( charArray [ i ] < charArray [ i + 1 ] ) break ; if ( i >= 0 ) { int j ; for ( j = charArray . length - 1 ; j > i ; -- j ) if ( charArray [ j ] > charArray [ i ] ) break ; swap ( charArray , i , j ); } reverse ( charArray , i + 1 , charArray . length - 1 ); return new String ( charArray ); } private void reverse ( char [] charArray , int l , int r ) { while ( l < r ) swap ( charArray , l ++ , r -- ); } private void swap ( char [] charArray , int i , int j ) { char temp = charArray [ i ] ; charArray [ i ] = charArray [ j ] ; charArray [ j ] = temp ; } }","title":"556. Next Greater Element III $\\star\\star$"},{"location":"java/0501-0600/0551-0560/#557-reverse-words-in-a-string-iii-star","text":"","title":"557. Reverse Words in a String III $\\star$"},{"location":"java/0501-0600/0551-0560/#558-logical-or-of-two-binary-grids-represented-as-quad-trees-starstar","text":"","title":"558. Logical OR of Two Binary Grids Represented as Quad-Trees $\\star\\star$"},{"location":"java/0501-0600/0551-0560/#559-maximum-depth-of-n-ary-tree-star","text":"class Solution { public int maxDepth ( Node root ) { if ( root == null ) return 0 ; int ans = 0 ; for ( Node child : root . children ) ans = Math . max ( ans , maxDepth ( child )); return 1 + ans ; } }","title":"559. Maximum Depth of N-ary Tree $\\star$"},{"location":"java/0501-0600/0551-0560/#560-subarray-sum-equals-k-starstar","text":"class Solution { public int subarraySum ( int [] nums , int k ) { int ans = 0 ; int sum = 0 ; Map < Integer , Integer > count = new HashMap <> (); count . put ( 0 , 1 ); for ( int num : nums ) { sum += num ; ans += count . getOrDefault ( sum - k , 0 ); count . put ( sum , count . getOrDefault ( sum , 0 ) + 1 ); } return ans ; } }","title":"560. Subarray Sum Equals K $\\star\\star$"},{"location":"java/0501-0600/0561-0570/","text":"561. Array Partition I $\\star$ class Solution { public int arrayPairSum ( int [] nums ) { int ans = 0 ; Arrays . sort ( nums ); for ( int i = 0 ; i < nums . length ; i += 2 ) ans += nums [ i ] ; return ans ; } } 562. Longest Line of Consecutive One in Matrix $\\star\\star$ \ud83d\udd12 563. Binary Tree Tilt $\\star$ 564. Find the Closest Palindrome $\\star\\star\\star$ class Solution { public String nearestPalindromic ( String n ) { final long [] palindromes = getPalindromes ( n ); return Math . abs ( palindromes [ 0 ] - Long . valueOf ( n )) <= Math . abs ( palindromes [ 1 ] - Long . valueOf ( n )) ? String . valueOf ( palindromes [ 0 ] ) : String . valueOf ( palindromes [ 1 ] ); } private long [] getPalindromes ( final String s ) { final long num = Long . valueOf ( s ); final int n = s . length (); long [] palindromes = new long [ 2 ] ; String half = s . substring ( 0 , ( n + 1 ) / 2 ); String reversedHalf = new StringBuilder ( half . substring ( 0 , n / 2 )). reverse (). toString (); long candidate = Long . valueOf ( half + reversedHalf ); if ( candidate < num ) palindromes [ 0 ] = candidate ; else { String prevHalf = String . valueOf ( Long . valueOf ( half ) - 1 ); String reversedPrevHalf = new StringBuilder ( prevHalf . substring ( 0 , Math . min ( prevHalf . length (), n / 2 ))). reverse () . toString (); if ( n % 2 == 0 && Long . valueOf ( prevHalf ) == 0 ) palindromes [ 0 ] = 9 ; else if ( n % 2 == 0 && ( Long . valueOf ( prevHalf ) + 1 ) % 10 == 0 ) palindromes [ 0 ] = Long . valueOf ( prevHalf + '9' + reversedPrevHalf ); else palindromes [ 0 ] = Long . valueOf ( prevHalf + reversedPrevHalf ); } if ( candidate > num ) palindromes [ 1 ] = candidate ; else { String nextHalf = String . valueOf ( Long . valueOf ( half ) + 1 ); String reversedNextHalf = new StringBuilder ( nextHalf . substring ( 0 , n / 2 )). reverse (). toString (); palindromes [ 1 ] = Long . valueOf ( nextHalf + reversedNextHalf ); } return palindromes ; } } 565. Array Nesting $\\star\\star$ class Solution { public int arrayNesting ( int [] nums ) { int ans = 0 ; for ( int num : nums ) { if ( num == - 1 ) continue ; int index = num ; int count = 0 ; while ( nums [ index ] != - 1 ) { int temp = index ; index = nums [ index ] ; nums [ temp ] = - 1 ; ++ count ; } ans = Math . max ( ans , count ); } return ans ; } } 566. Reshape the Matrix $\\star$ class Solution { public int [][] matrixReshape ( int [][] nums , int r , int c ) { if ( nums . length == 0 || r * c != nums . length * nums [ 0 ] . length ) return nums ; int [][] ans = new int [ r ][ c ] ; int k = 0 ; for ( int [] row : nums ) for ( int num : row ) { ans [ k / c ][ k % c ] = num ; ++ k ; } return ans ; } } 567. Permutation in String $\\star\\star$ class Solution { public boolean checkInclusion ( String s1 , String s2 ) { int [] count1 = new int [ 26 ] ; int required = s1 . length (); for ( char c : s1 . toCharArray ()) ++ count1 [ c - 'a' ] ; for ( int r = 0 ; r < s2 . length (); ++ r ) { if ( -- count1 [ s2 . charAt ( r ) - 'a' ] >= 0 ) -- required ; if ( r >= s1 . length ()) if ( ++ count1 [ s2 . charAt ( r - s1 . length ()) - 'a' ] > 0 ) ++ required ; if ( required == 0 ) return true ; } return false ; } } 568. Maximum Vacation Days $\\star\\star\\star$ \ud83d\udd12 569. Median Employee Salary $\\star\\star\\star$ \ud83d\udd12 570. Managers with at Least 5 Direct Reports $\\star\\star$ \ud83d\udd12","title":"0561-0570"},{"location":"java/0501-0600/0561-0570/#561-array-partition-i-star","text":"class Solution { public int arrayPairSum ( int [] nums ) { int ans = 0 ; Arrays . sort ( nums ); for ( int i = 0 ; i < nums . length ; i += 2 ) ans += nums [ i ] ; return ans ; } }","title":"561. Array Partition I $\\star$"},{"location":"java/0501-0600/0561-0570/#562-longest-line-of-consecutive-one-in-matrix-starstar","text":"","title":"562. Longest Line of Consecutive One in Matrix $\\star\\star$ \ud83d\udd12"},{"location":"java/0501-0600/0561-0570/#563-binary-tree-tilt-star","text":"","title":"563. Binary Tree Tilt $\\star$"},{"location":"java/0501-0600/0561-0570/#564-find-the-closest-palindrome-starstarstar","text":"class Solution { public String nearestPalindromic ( String n ) { final long [] palindromes = getPalindromes ( n ); return Math . abs ( palindromes [ 0 ] - Long . valueOf ( n )) <= Math . abs ( palindromes [ 1 ] - Long . valueOf ( n )) ? String . valueOf ( palindromes [ 0 ] ) : String . valueOf ( palindromes [ 1 ] ); } private long [] getPalindromes ( final String s ) { final long num = Long . valueOf ( s ); final int n = s . length (); long [] palindromes = new long [ 2 ] ; String half = s . substring ( 0 , ( n + 1 ) / 2 ); String reversedHalf = new StringBuilder ( half . substring ( 0 , n / 2 )). reverse (). toString (); long candidate = Long . valueOf ( half + reversedHalf ); if ( candidate < num ) palindromes [ 0 ] = candidate ; else { String prevHalf = String . valueOf ( Long . valueOf ( half ) - 1 ); String reversedPrevHalf = new StringBuilder ( prevHalf . substring ( 0 , Math . min ( prevHalf . length (), n / 2 ))). reverse () . toString (); if ( n % 2 == 0 && Long . valueOf ( prevHalf ) == 0 ) palindromes [ 0 ] = 9 ; else if ( n % 2 == 0 && ( Long . valueOf ( prevHalf ) + 1 ) % 10 == 0 ) palindromes [ 0 ] = Long . valueOf ( prevHalf + '9' + reversedPrevHalf ); else palindromes [ 0 ] = Long . valueOf ( prevHalf + reversedPrevHalf ); } if ( candidate > num ) palindromes [ 1 ] = candidate ; else { String nextHalf = String . valueOf ( Long . valueOf ( half ) + 1 ); String reversedNextHalf = new StringBuilder ( nextHalf . substring ( 0 , n / 2 )). reverse (). toString (); palindromes [ 1 ] = Long . valueOf ( nextHalf + reversedNextHalf ); } return palindromes ; } }","title":"564. Find the Closest Palindrome $\\star\\star\\star$"},{"location":"java/0501-0600/0561-0570/#565-array-nesting-starstar","text":"class Solution { public int arrayNesting ( int [] nums ) { int ans = 0 ; for ( int num : nums ) { if ( num == - 1 ) continue ; int index = num ; int count = 0 ; while ( nums [ index ] != - 1 ) { int temp = index ; index = nums [ index ] ; nums [ temp ] = - 1 ; ++ count ; } ans = Math . max ( ans , count ); } return ans ; } }","title":"565. Array Nesting $\\star\\star$"},{"location":"java/0501-0600/0561-0570/#566-reshape-the-matrix-star","text":"class Solution { public int [][] matrixReshape ( int [][] nums , int r , int c ) { if ( nums . length == 0 || r * c != nums . length * nums [ 0 ] . length ) return nums ; int [][] ans = new int [ r ][ c ] ; int k = 0 ; for ( int [] row : nums ) for ( int num : row ) { ans [ k / c ][ k % c ] = num ; ++ k ; } return ans ; } }","title":"566. Reshape the Matrix $\\star$"},{"location":"java/0501-0600/0561-0570/#567-permutation-in-string-starstar","text":"class Solution { public boolean checkInclusion ( String s1 , String s2 ) { int [] count1 = new int [ 26 ] ; int required = s1 . length (); for ( char c : s1 . toCharArray ()) ++ count1 [ c - 'a' ] ; for ( int r = 0 ; r < s2 . length (); ++ r ) { if ( -- count1 [ s2 . charAt ( r ) - 'a' ] >= 0 ) -- required ; if ( r >= s1 . length ()) if ( ++ count1 [ s2 . charAt ( r - s1 . length ()) - 'a' ] > 0 ) ++ required ; if ( required == 0 ) return true ; } return false ; } }","title":"567. Permutation in String $\\star\\star$"},{"location":"java/0501-0600/0561-0570/#568-maximum-vacation-days-starstarstar","text":"","title":"568. Maximum Vacation Days $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/0501-0600/0561-0570/#569-median-employee-salary-starstarstar","text":"","title":"569. Median Employee Salary $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/0501-0600/0561-0570/#570-managers-with-at-least-5-direct-reports-starstar","text":"","title":"570. Managers with at Least 5 Direct Reports $\\star\\star$ \ud83d\udd12"},{"location":"java/0501-0600/0571-0580/","text":"571. Find Median Given Frequency of Numbers $\\star\\star\\star$ \ud83d\udd12 572. Subtree of Another Tree $\\star$ 573. Squirrel Simulation $\\star\\star$ \ud83d\udd12 574. Winning Candidate $\\star\\star$ \ud83d\udd12 575. Distribute Candies $\\star$ class Solution { public int distributeCandies ( int [] candies ) { BitSet bitset = new BitSet ( 200001 ); for ( int candy : candies ) bitset . set ( candy + 100000 ); return Math . min ( candies . length / 2 , bitset . cardinality ()); } } 576. Out of Boundary Paths $\\star\\star$ 577. Employee Bonus $\\star$ \ud83d\udd12 578. Get Highest Answer Rate Question $\\star\\star$ \ud83d\udd12 579. Find Cumulative Salary of an Employee $\\star\\star\\star$ \ud83d\udd12 580. Count Student Number in Departments $\\star\\star$ \ud83d\udd12","title":"0571-0580"},{"location":"java/0501-0600/0571-0580/#571-find-median-given-frequency-of-numbers-starstarstar","text":"","title":"571. Find Median Given Frequency of Numbers $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/0501-0600/0571-0580/#572-subtree-of-another-tree-star","text":"","title":"572. Subtree of Another Tree $\\star$"},{"location":"java/0501-0600/0571-0580/#573-squirrel-simulation-starstar","text":"","title":"573. Squirrel Simulation $\\star\\star$ \ud83d\udd12"},{"location":"java/0501-0600/0571-0580/#574-winning-candidate-starstar","text":"","title":"574. Winning Candidate $\\star\\star$ \ud83d\udd12"},{"location":"java/0501-0600/0571-0580/#575-distribute-candies-star","text":"class Solution { public int distributeCandies ( int [] candies ) { BitSet bitset = new BitSet ( 200001 ); for ( int candy : candies ) bitset . set ( candy + 100000 ); return Math . min ( candies . length / 2 , bitset . cardinality ()); } }","title":"575. Distribute Candies $\\star$"},{"location":"java/0501-0600/0571-0580/#576-out-of-boundary-paths-starstar","text":"","title":"576. Out of Boundary Paths $\\star\\star$"},{"location":"java/0501-0600/0571-0580/#577-employee-bonus-star","text":"","title":"577. Employee Bonus $\\star$ \ud83d\udd12"},{"location":"java/0501-0600/0571-0580/#578-get-highest-answer-rate-question-starstar","text":"","title":"578. Get Highest Answer Rate Question $\\star\\star$ \ud83d\udd12"},{"location":"java/0501-0600/0571-0580/#579-find-cumulative-salary-of-an-employee-starstarstar","text":"","title":"579. Find Cumulative Salary of an Employee $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/0501-0600/0571-0580/#580-count-student-number-in-departments-starstar","text":"","title":"580. Count Student Number in Departments $\\star\\star$ \ud83d\udd12"},{"location":"java/0501-0600/0581-0590/","text":"581. Shortest Unsorted Continuous Subarray $\\star$ class Solution { public int findUnsortedSubarray ( int [] nums ) { int min = Integer . MAX_VALUE ; int max = Integer . MIN_VALUE ; boolean flag = false ; for ( int i = 1 ; i < nums . length ; ++ i ) { if ( nums [ i ] < nums [ i - 1 ] ) flag = true ; if ( flag ) min = Math . min ( min , nums [ i ] ); } flag = false ; for ( int i = nums . length - 2 ; i >= 0 ; -- i ) { if ( nums [ i ] > nums [ i + 1 ] ) flag = true ; if ( flag ) max = Math . max ( max , nums [ i ] ); } int l = 0 ; for ( l = 0 ; l < nums . length ; ++ l ) if ( nums [ l ] > min ) break ; int r = 0 ; for ( r = nums . length - 1 ; r >= 0 ; -- r ) if ( nums [ r ] < max ) break ; return l > r ? 0 : r - l + 1 ; } } 582. Kill Process $\\star\\star$ \ud83d\udd12 583. Delete Operation for Two Strings $\\star\\star$ 584. Find Customer Referee $\\star$ \ud83d\udd12 585. Investments in 2016 $\\star\\star$ \ud83d\udd12 586. Customer Placing the Largest Number of Orders $\\star$ \ud83d\udd12 587. Erect the Fence $\\star\\star\\star$ 588. Design In-Memory File System $\\star\\star\\star$ \ud83d\udd12 589. N-ary Tree Preorder Traversal $\\star$ 590. N-ary Tree Postorder Traversal $\\star$","title":"0581-0590"},{"location":"java/0501-0600/0581-0590/#581-shortest-unsorted-continuous-subarray-star","text":"class Solution { public int findUnsortedSubarray ( int [] nums ) { int min = Integer . MAX_VALUE ; int max = Integer . MIN_VALUE ; boolean flag = false ; for ( int i = 1 ; i < nums . length ; ++ i ) { if ( nums [ i ] < nums [ i - 1 ] ) flag = true ; if ( flag ) min = Math . min ( min , nums [ i ] ); } flag = false ; for ( int i = nums . length - 2 ; i >= 0 ; -- i ) { if ( nums [ i ] > nums [ i + 1 ] ) flag = true ; if ( flag ) max = Math . max ( max , nums [ i ] ); } int l = 0 ; for ( l = 0 ; l < nums . length ; ++ l ) if ( nums [ l ] > min ) break ; int r = 0 ; for ( r = nums . length - 1 ; r >= 0 ; -- r ) if ( nums [ r ] < max ) break ; return l > r ? 0 : r - l + 1 ; } }","title":"581. Shortest Unsorted Continuous Subarray $\\star$"},{"location":"java/0501-0600/0581-0590/#582-kill-process-starstar","text":"","title":"582. Kill Process $\\star\\star$ \ud83d\udd12"},{"location":"java/0501-0600/0581-0590/#583-delete-operation-for-two-strings-starstar","text":"","title":"583. Delete Operation for Two Strings $\\star\\star$"},{"location":"java/0501-0600/0581-0590/#584-find-customer-referee-star","text":"","title":"584. Find Customer Referee $\\star$ \ud83d\udd12"},{"location":"java/0501-0600/0581-0590/#585-investments-in-2016-starstar","text":"","title":"585. Investments in 2016 $\\star\\star$ \ud83d\udd12"},{"location":"java/0501-0600/0581-0590/#586-customer-placing-the-largest-number-of-orders-star","text":"","title":"586. Customer Placing the Largest Number of Orders $\\star$ \ud83d\udd12"},{"location":"java/0501-0600/0581-0590/#587-erect-the-fence-starstarstar","text":"","title":"587. Erect the Fence $\\star\\star\\star$"},{"location":"java/0501-0600/0581-0590/#588-design-in-memory-file-system-starstarstar","text":"","title":"588. Design In-Memory File System $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/0501-0600/0581-0590/#589-n-ary-tree-preorder-traversal-star","text":"","title":"589. N-ary Tree Preorder Traversal $\\star$"},{"location":"java/0501-0600/0581-0590/#590-n-ary-tree-postorder-traversal-star","text":"","title":"590. N-ary Tree Postorder Traversal $\\star$"},{"location":"java/0501-0600/0591-0600/","text":"591. Tag Validator $\\star\\star\\star$ 592. Fraction Addition and Subtraction $\\star\\star$ class Solution { public String fractionAddition ( String expression ) { Scanner sc = new Scanner ( expression ). useDelimiter ( \"/|(?=[+-])\" ); int A = 0 ; int B = 1 ; while ( sc . hasNext ()) { int a = sc . nextInt (); int b = sc . nextInt (); A = A * b + a * B ; B *= b ; int g = gcd ( A , B ); A /= g ; B /= g ; } return A + \"/\" + B ; } private int gcd ( int a , int b ) { return a == 0 ? Math . abs ( b ) : gcd ( b % a , a ); } } 593. Valid Square $\\star\\star$ class Solution { public boolean validSquare ( int [] p1 , int [] p2 , int [] p3 , int [] p4 ) { Set < Integer > distSet = new HashSet <> (); int [][] points = new int [][] { p1 , p2 , p3 , p4 }; for ( int i = 0 ; i < 4 ; ++ i ) for ( int j = i + 1 ; j < 4 ; ++ j ) distSet . add ( dist ( points [ i ] , points [ j ] )); return ! distSet . contains ( 0 ) && distSet . size () == 2 ; } private int dist ( int [] p1 , int [] p2 ) { return ( p1 [ 0 ] - p2 [ 0 ] ) * ( p1 [ 0 ] - p2 [ 0 ] ) + ( p1 [ 1 ] - p2 [ 1 ] ) * ( p1 [ 1 ] - p2 [ 1 ] ); } } 594. Longest Harmonious Subsequence $\\star$ class Solution { public int findLHS ( int [] nums ) { int ans = 0 ; Map < Integer , Integer > count = new HashMap <> (); for ( int num : nums ) count . put ( num , count . getOrDefault ( num , 0 ) + 1 ); for ( int num : count . keySet ()) if ( count . containsKey ( num + 1 )) ans = Math . max ( ans , count . get ( num ) + count . get ( num + 1 )); return ans ; } } 595. Big Countries $\\star$ 596. Classes More Than 5 Students $\\star$ 597. Friend Requests I: Overall Acceptance Rate $\\star$ \ud83d\udd12 598. Range Addition II $\\star$ class Solution { public int maxCount ( int m , int n , int [][] ops ) { int minY = m ; int minX = n ; for ( int [] op : ops ) { minY = Math . min ( minY , op [ 0 ] ); minX = Math . min ( minX , op [ 1 ] ); } return minX * minY ; } } 599. Minimum Index Sum of Two Lists $\\star$ class Solution { public String [] findRestaurant ( String [] list1 , String [] list2 ) { List < String > ans = new LinkedList <> (); Map < String , Integer > restaurantToIndex = new HashMap <> (); int minSum = Integer . MAX_VALUE ; for ( int i = 0 ; i < list1 . length ; ++ i ) restaurantToIndex . put ( list1 [ i ] , i ); for ( int i = 0 ; i < list2 . length ; ++ i ) { if ( restaurantToIndex . containsKey ( list2 [ i ] )) { int sum = restaurantToIndex . get ( list2 [ i ] ) + i ; if ( sum < minSum ) ans . clear (); if ( sum <= minSum ) { ans . add ( list2 [ i ] ); minSum = sum ; } } } return ans . toArray ( new String [ 0 ] ); } } 600. Non-negative Integers without Consecutive Ones $\\star\\star\\star$","title":"0591-0600"},{"location":"java/0501-0600/0591-0600/#591-tag-validator-starstarstar","text":"","title":"591. Tag Validator $\\star\\star\\star$"},{"location":"java/0501-0600/0591-0600/#592-fraction-addition-and-subtraction-starstar","text":"class Solution { public String fractionAddition ( String expression ) { Scanner sc = new Scanner ( expression ). useDelimiter ( \"/|(?=[+-])\" ); int A = 0 ; int B = 1 ; while ( sc . hasNext ()) { int a = sc . nextInt (); int b = sc . nextInt (); A = A * b + a * B ; B *= b ; int g = gcd ( A , B ); A /= g ; B /= g ; } return A + \"/\" + B ; } private int gcd ( int a , int b ) { return a == 0 ? Math . abs ( b ) : gcd ( b % a , a ); } }","title":"592. Fraction Addition and Subtraction $\\star\\star$"},{"location":"java/0501-0600/0591-0600/#593-valid-square-starstar","text":"class Solution { public boolean validSquare ( int [] p1 , int [] p2 , int [] p3 , int [] p4 ) { Set < Integer > distSet = new HashSet <> (); int [][] points = new int [][] { p1 , p2 , p3 , p4 }; for ( int i = 0 ; i < 4 ; ++ i ) for ( int j = i + 1 ; j < 4 ; ++ j ) distSet . add ( dist ( points [ i ] , points [ j ] )); return ! distSet . contains ( 0 ) && distSet . size () == 2 ; } private int dist ( int [] p1 , int [] p2 ) { return ( p1 [ 0 ] - p2 [ 0 ] ) * ( p1 [ 0 ] - p2 [ 0 ] ) + ( p1 [ 1 ] - p2 [ 1 ] ) * ( p1 [ 1 ] - p2 [ 1 ] ); } }","title":"593. Valid Square $\\star\\star$"},{"location":"java/0501-0600/0591-0600/#594-longest-harmonious-subsequence-star","text":"class Solution { public int findLHS ( int [] nums ) { int ans = 0 ; Map < Integer , Integer > count = new HashMap <> (); for ( int num : nums ) count . put ( num , count . getOrDefault ( num , 0 ) + 1 ); for ( int num : count . keySet ()) if ( count . containsKey ( num + 1 )) ans = Math . max ( ans , count . get ( num ) + count . get ( num + 1 )); return ans ; } }","title":"594. Longest Harmonious Subsequence $\\star$"},{"location":"java/0501-0600/0591-0600/#595-big-countries-star","text":"","title":"595. Big Countries $\\star$"},{"location":"java/0501-0600/0591-0600/#596-classes-more-than-5-students-star","text":"","title":"596. Classes More Than 5 Students $\\star$"},{"location":"java/0501-0600/0591-0600/#597-friend-requests-i-overall-acceptance-rate-star","text":"","title":"597. Friend Requests I: Overall Acceptance Rate $\\star$ \ud83d\udd12"},{"location":"java/0501-0600/0591-0600/#598-range-addition-ii-star","text":"class Solution { public int maxCount ( int m , int n , int [][] ops ) { int minY = m ; int minX = n ; for ( int [] op : ops ) { minY = Math . min ( minY , op [ 0 ] ); minX = Math . min ( minX , op [ 1 ] ); } return minX * minY ; } }","title":"598. Range Addition II $\\star$"},{"location":"java/0501-0600/0591-0600/#599-minimum-index-sum-of-two-lists-star","text":"class Solution { public String [] findRestaurant ( String [] list1 , String [] list2 ) { List < String > ans = new LinkedList <> (); Map < String , Integer > restaurantToIndex = new HashMap <> (); int minSum = Integer . MAX_VALUE ; for ( int i = 0 ; i < list1 . length ; ++ i ) restaurantToIndex . put ( list1 [ i ] , i ); for ( int i = 0 ; i < list2 . length ; ++ i ) { if ( restaurantToIndex . containsKey ( list2 [ i ] )) { int sum = restaurantToIndex . get ( list2 [ i ] ) + i ; if ( sum < minSum ) ans . clear (); if ( sum <= minSum ) { ans . add ( list2 [ i ] ); minSum = sum ; } } } return ans . toArray ( new String [ 0 ] ); } }","title":"599. Minimum Index Sum of Two Lists $\\star$"},{"location":"java/0501-0600/0591-0600/#600-non-negative-integers-without-consecutive-ones-starstarstar","text":"","title":"600. Non-negative Integers without Consecutive Ones $\\star\\star\\star$"},{"location":"java/0601-0700/0601-0610/","text":"601. Human Traffic of Stadium $\\star\\star\\star$ 602. Friend Requests II: Who Has the Most Friends $\\star\\star$ \ud83d\udd12 603. Consecutive Available Seats $\\star$ \ud83d\udd12 604. Design Compressed String Iterator $\\star$ \ud83d\udd12 605. Can Place Flowers $\\star$ class Solution { public boolean canPlaceFlowers ( int [] flowerbed , int n ) { for ( int i = 0 ; i < flowerbed . length ; ++ i ) { if ( flowerbed [ i ] == 0 && ( i == 0 || flowerbed [ i - 1 ] == 0 ) && ( i == flowerbed . length - 1 || flowerbed [ i + 1 ] == 0 )) { flowerbed [ i ] = 1 ; -- n ; } if ( n <= 0 ) return true ; } return false ; } } 606. Construct String from Binary Tree $\\star$ class Solution { public String tree2str ( TreeNode t ) { return dfs ( t ); } private String dfs ( TreeNode root ) { if ( root == null ) return \"\" ; if ( root . right != null ) return root . val + \"(\" + dfs ( root . left ) + \")(\" + dfs ( root . right ) + \")\" ; if ( root . left != null ) return root . val + \"(\" + dfs ( root . left ) + \")\" ; return root . val + \"\" ; } } 607. Sales Person $\\star$ \ud83d\udd12 608. Tree Node $\\star\\star$ \ud83d\udd12 609. Find Duplicate File in System $\\star\\star$ class Solution { public List < List < String >> findDuplicate ( String [] paths ) { List < List < String >> ans = new ArrayList <> (); Map < String , List < String >> files = new HashMap <> (); for ( final String path : paths ) { String [] words = path . split ( \" \" ); String root = words [ 0 ] ; for ( int i = 1 ; i < words . length ; ++ i ) { final String s = words [ i ] ; String filePath = root + '/' + s . substring ( 0 , s . indexOf ( '(' )); String fileContent = s . substring ( s . indexOf ( '(' ) + 1 , s . indexOf ( ')' )); if ( ! files . containsKey ( fileContent )) files . put ( fileContent , new ArrayList <> ()); files . get ( fileContent ). add ( filePath ); } } for ( List < String > filePath : files . values ()) if ( filePath . size () > 1 ) ans . add ( filePath ); return ans ; } } 610. Triangle Judgement $\\star$ \ud83d\udd12","title":"0601-0610"},{"location":"java/0601-0700/0601-0610/#601-human-traffic-of-stadium-starstarstar","text":"","title":"601. Human Traffic of Stadium $\\star\\star\\star$"},{"location":"java/0601-0700/0601-0610/#602-friend-requests-ii-who-has-the-most-friends-starstar","text":"","title":"602. Friend Requests II: Who Has the Most Friends $\\star\\star$ \ud83d\udd12"},{"location":"java/0601-0700/0601-0610/#603-consecutive-available-seats-star","text":"","title":"603. Consecutive Available Seats $\\star$ \ud83d\udd12"},{"location":"java/0601-0700/0601-0610/#604-design-compressed-string-iterator-star","text":"","title":"604. Design Compressed String Iterator $\\star$ \ud83d\udd12"},{"location":"java/0601-0700/0601-0610/#605-can-place-flowers-star","text":"class Solution { public boolean canPlaceFlowers ( int [] flowerbed , int n ) { for ( int i = 0 ; i < flowerbed . length ; ++ i ) { if ( flowerbed [ i ] == 0 && ( i == 0 || flowerbed [ i - 1 ] == 0 ) && ( i == flowerbed . length - 1 || flowerbed [ i + 1 ] == 0 )) { flowerbed [ i ] = 1 ; -- n ; } if ( n <= 0 ) return true ; } return false ; } }","title":"605. Can Place Flowers $\\star$"},{"location":"java/0601-0700/0601-0610/#606-construct-string-from-binary-tree-star","text":"class Solution { public String tree2str ( TreeNode t ) { return dfs ( t ); } private String dfs ( TreeNode root ) { if ( root == null ) return \"\" ; if ( root . right != null ) return root . val + \"(\" + dfs ( root . left ) + \")(\" + dfs ( root . right ) + \")\" ; if ( root . left != null ) return root . val + \"(\" + dfs ( root . left ) + \")\" ; return root . val + \"\" ; } }","title":"606. Construct String from Binary Tree $\\star$"},{"location":"java/0601-0700/0601-0610/#607-sales-person-star","text":"","title":"607. Sales Person $\\star$ \ud83d\udd12"},{"location":"java/0601-0700/0601-0610/#608-tree-node-starstar","text":"","title":"608. Tree Node $\\star\\star$ \ud83d\udd12"},{"location":"java/0601-0700/0601-0610/#609-find-duplicate-file-in-system-starstar","text":"class Solution { public List < List < String >> findDuplicate ( String [] paths ) { List < List < String >> ans = new ArrayList <> (); Map < String , List < String >> files = new HashMap <> (); for ( final String path : paths ) { String [] words = path . split ( \" \" ); String root = words [ 0 ] ; for ( int i = 1 ; i < words . length ; ++ i ) { final String s = words [ i ] ; String filePath = root + '/' + s . substring ( 0 , s . indexOf ( '(' )); String fileContent = s . substring ( s . indexOf ( '(' ) + 1 , s . indexOf ( ')' )); if ( ! files . containsKey ( fileContent )) files . put ( fileContent , new ArrayList <> ()); files . get ( fileContent ). add ( filePath ); } } for ( List < String > filePath : files . values ()) if ( filePath . size () > 1 ) ans . add ( filePath ); return ans ; } }","title":"609. Find Duplicate File in System $\\star\\star$"},{"location":"java/0601-0700/0601-0610/#610-triangle-judgement-star","text":"","title":"610. Triangle Judgement $\\star$ \ud83d\udd12"},{"location":"java/0601-0700/0611-0620/","text":"611. Valid Triangle Number $\\star\\star$ class Solution { public int triangleNumber ( int [] nums ) { int ans = 0 ; Arrays . sort ( nums ); for ( int k = nums . length - 1 ; k > 1 ; -- k ) for ( int i = 0 , j = k - 1 ; i < j ;) { if ( nums [ i ] + nums [ j ] > nums [ k ] ) { ans += j - i ; -- j ; } else ++ i ; } return ans ; } } 612. Shortest Distance in a Plane $\\star\\star$ \ud83d\udd12 613. Shortest Distance in a Line $\\star$ \ud83d\udd12 614. Second Degree Follower $\\star\\star$ \ud83d\udd12 615. Average Salary: Departments VS Company $\\star\\star\\star$ \ud83d\udd12 616. Add Bold Tag in String $\\star\\star$ \ud83d\udd12 617. Merge Two Binary Trees $\\star$ 618. Students Report By Geography $\\star\\star\\star$ \ud83d\udd12 619. Biggest Single Number $\\star$ \ud83d\udd12 620. Not Boring Movies $\\star$","title":"0611-0620"},{"location":"java/0601-0700/0611-0620/#611-valid-triangle-number-starstar","text":"class Solution { public int triangleNumber ( int [] nums ) { int ans = 0 ; Arrays . sort ( nums ); for ( int k = nums . length - 1 ; k > 1 ; -- k ) for ( int i = 0 , j = k - 1 ; i < j ;) { if ( nums [ i ] + nums [ j ] > nums [ k ] ) { ans += j - i ; -- j ; } else ++ i ; } return ans ; } }","title":"611. Valid Triangle Number $\\star\\star$"},{"location":"java/0601-0700/0611-0620/#612-shortest-distance-in-a-plane-starstar","text":"","title":"612. Shortest Distance in a Plane $\\star\\star$ \ud83d\udd12"},{"location":"java/0601-0700/0611-0620/#613-shortest-distance-in-a-line-star","text":"","title":"613. Shortest Distance in a Line $\\star$ \ud83d\udd12"},{"location":"java/0601-0700/0611-0620/#614-second-degree-follower-starstar","text":"","title":"614. Second Degree Follower $\\star\\star$ \ud83d\udd12"},{"location":"java/0601-0700/0611-0620/#615-average-salary-departments-vs-company-starstarstar","text":"","title":"615. Average Salary: Departments VS Company $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/0601-0700/0611-0620/#616-add-bold-tag-in-string-starstar","text":"","title":"616. Add Bold Tag in String $\\star\\star$ \ud83d\udd12"},{"location":"java/0601-0700/0611-0620/#617-merge-two-binary-trees-star","text":"","title":"617. Merge Two Binary Trees $\\star$"},{"location":"java/0601-0700/0611-0620/#618-students-report-by-geography-starstarstar","text":"","title":"618. Students Report By Geography $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/0601-0700/0611-0620/#619-biggest-single-number-star","text":"","title":"619. Biggest Single Number $\\star$ \ud83d\udd12"},{"location":"java/0601-0700/0611-0620/#620-not-boring-movies-star","text":"","title":"620. Not Boring Movies $\\star$"},{"location":"java/0601-0700/0621-0630/","text":"621. Task Scheduler $\\star\\star$ class Solution { public int leastInterval ( char [] tasks , int n ) { int [] count = new int [ 26 ] ; for ( char task : tasks ) ++ count [ task - 'A' ] ; int maxFreq = 0 ; for ( int c : count ) maxFreq = Math . max ( maxFreq , c ); int ans = ( maxFreq - 1 ) * ( n + 1 ); for ( int c : count ) if ( c == maxFreq ) ++ ans ; return Math . max ( ans , tasks . length ); } } 622. Design Circular Queue $\\star\\star$ 623. Add One Row to Tree $\\star\\star$ 624. Maximum Distance in Arrays $\\star$ \ud83d\udd12 625. Minimum Factorization $\\star\\star$ \ud83d\udd12 626. Exchange Seats $\\star\\star$ 627. Swap Salary $\\star$ 628. Maximum Product of Three Numbers $\\star$ class Solution { public int maximumProduct ( int [] nums ) { int min = Integer . MAX_VALUE ; int secondMin = Integer . MAX_VALUE ; int max = Integer . MIN_VALUE ; int secondMax = Integer . MIN_VALUE ; int thirdMax = Integer . MIN_VALUE ; for ( int num : nums ) { if ( num <= min ) { secondMin = min ; min = num ; } else if ( num <= secondMin ) secondMin = num ; if ( num >= max ) { thirdMax = secondMax ; secondMax = max ; max = num ; } else if ( num >= secondMax ) { thirdMax = secondMax ; secondMax = num ; } else if ( num >= thirdMax ) thirdMax = num ; } return Math . max ( min * secondMin * max , max * secondMax * thirdMax ); } } 629. K Inverse Pairs Array $\\star\\star\\star$ 630. Course Schedule III $\\star\\star\\star$","title":"0621-0630"},{"location":"java/0601-0700/0621-0630/#621-task-scheduler-starstar","text":"class Solution { public int leastInterval ( char [] tasks , int n ) { int [] count = new int [ 26 ] ; for ( char task : tasks ) ++ count [ task - 'A' ] ; int maxFreq = 0 ; for ( int c : count ) maxFreq = Math . max ( maxFreq , c ); int ans = ( maxFreq - 1 ) * ( n + 1 ); for ( int c : count ) if ( c == maxFreq ) ++ ans ; return Math . max ( ans , tasks . length ); } }","title":"621. Task Scheduler $\\star\\star$"},{"location":"java/0601-0700/0621-0630/#622-design-circular-queue-starstar","text":"","title":"622. Design Circular Queue $\\star\\star$"},{"location":"java/0601-0700/0621-0630/#623-add-one-row-to-tree-starstar","text":"","title":"623. Add One Row to Tree $\\star\\star$"},{"location":"java/0601-0700/0621-0630/#624-maximum-distance-in-arrays-star","text":"","title":"624. Maximum Distance in Arrays $\\star$ \ud83d\udd12"},{"location":"java/0601-0700/0621-0630/#625-minimum-factorization-starstar","text":"","title":"625. Minimum Factorization $\\star\\star$ \ud83d\udd12"},{"location":"java/0601-0700/0621-0630/#626-exchange-seats-starstar","text":"","title":"626. Exchange Seats $\\star\\star$"},{"location":"java/0601-0700/0621-0630/#627-swap-salary-star","text":"","title":"627. Swap Salary $\\star$"},{"location":"java/0601-0700/0621-0630/#628-maximum-product-of-three-numbers-star","text":"class Solution { public int maximumProduct ( int [] nums ) { int min = Integer . MAX_VALUE ; int secondMin = Integer . MAX_VALUE ; int max = Integer . MIN_VALUE ; int secondMax = Integer . MIN_VALUE ; int thirdMax = Integer . MIN_VALUE ; for ( int num : nums ) { if ( num <= min ) { secondMin = min ; min = num ; } else if ( num <= secondMin ) secondMin = num ; if ( num >= max ) { thirdMax = secondMax ; secondMax = max ; max = num ; } else if ( num >= secondMax ) { thirdMax = secondMax ; secondMax = num ; } else if ( num >= thirdMax ) thirdMax = num ; } return Math . max ( min * secondMin * max , max * secondMax * thirdMax ); } }","title":"628. Maximum Product of Three Numbers $\\star$"},{"location":"java/0601-0700/0621-0630/#629-k-inverse-pairs-array-starstarstar","text":"","title":"629. K Inverse Pairs Array $\\star\\star\\star$"},{"location":"java/0601-0700/0621-0630/#630-course-schedule-iii-starstarstar","text":"","title":"630. Course Schedule III $\\star\\star\\star$"},{"location":"java/0601-0700/0631-0640/","text":"631. Design Excel Sum Formula $\\star\\star\\star$ \ud83d\udd12 632. Smallest Range Covering Elements from K Lists $\\star\\star\\star$ class Solution { public int [] smallestRange ( List < List < Integer >> nums ) { Queue < Elem > pq = new PriorityQueue <> (( e1 , e2 ) -> e1 . value - e2 . value ); int maxRange = Integer . MIN_VALUE ; for ( int i = 0 ; i < nums . size (); ++ i ) { pq . add ( new Elem ( nums . get ( i ). get ( 0 ), i , 0 )); maxRange = Math . max ( maxRange , nums . get ( i ). get ( 0 )); } int minRange = pq . peek (). value ; int [] ans = new int [] { minRange , maxRange }; while ( pq . size () == nums . size ()) { Elem elem = pq . poll (); if ( elem . c + 1 < nums . get ( elem . r ). size ()) { pq . add ( new Elem ( nums . get ( elem . r ). get ( elem . c + 1 ), elem . r , elem . c + 1 )); maxRange = Math . max ( maxRange , nums . get ( elem . r ). get ( elem . c + 1 )); minRange = pq . peek (). value ; if ( maxRange - minRange < ans [ 1 ] - ans [ 0 ] ) { ans [ 0 ] = minRange ; ans [ 1 ] = maxRange ; } } } return ans ; } private class Elem { int value ; int r ; int c ; public Elem ( int value , int r , int c ) { this . value = value ; this . r = r ; this . c = c ; } } } 633. Sum of Square Numbers $\\star$ class Solution { public boolean judgeSquareSum ( int c ) { int l = 0 ; int r = ( int ) Math . sqrt ( c ); while ( l <= r ) { int sum = l * l + r * r ; if ( sum == c ) return true ; if ( sum < c ) ++ l ; else -- r ; } return false ; } } 634. Find the Derangement of An Array $\\star\\star$ \ud83d\udd12 635. Design Log Storage System $\\star\\star$ \ud83d\udd12 636. Exclusive Time of Functions $\\star\\star$ 637. Average of Levels in Binary Tree $\\star$ 638. Shopping Offers $\\star\\star$ class Solution { public int shoppingOffers ( List < Integer > price , List < List < Integer >> special , List < Integer > needs ) { return dfs ( price , special , needs , 0 ); } private int dfs ( List < Integer > price , List < List < Integer >> special , List < Integer > needs , int s ) { int ans = 0 ; for ( int i = 0 ; i < needs . size (); ++ i ) ans += needs . get ( i ) * price . get ( i ); for ( int i = s ; i < special . size (); ++ i ) { List < Integer > offer = special . get ( i ); if ( isValid ( offer , needs )) { for ( int j = 0 ; j < needs . size (); ++ j ) needs . set ( j , needs . get ( j ) - offer . get ( j )); ans = Math . min ( ans , offer . get ( offer . size () - 1 ) + dfs ( price , special , needs , i )); for ( int j = 0 ; j < needs . size (); ++ j ) needs . set ( j , needs . get ( j ) + offer . get ( j )); } } return ans ; } private boolean isValid ( List < Integer > offer , List < Integer > needs ) { for ( int i = 0 ; i < needs . size (); ++ i ) if ( offer . get ( i ) > needs . get ( i )) return false ; return true ; } } 639. Decode Ways II $\\star\\star\\star$ 640. Solve the Equation $\\star\\star$ class Solution { public String solveEquation ( String equation ) { String [] equations = equation . split ( \"=\" ); int [] lhs = calculate ( equations [ 0 ] ); int [] rhs = calculate ( equations [ 1 ] ); int coefficient = lhs [ 0 ] - rhs [ 0 ] ; int constant = rhs [ 1 ] - lhs [ 1 ] ; if ( coefficient == 0 && constant == 0 ) return \"Infinite solutions\" ; if ( coefficient == 0 && constant != 0 ) return \"No solution\" ; return \"x=\" + constant / coefficient ; } private int [] calculate ( final String s ) { int coefficient = 0 ; int constant = 0 ; int num = 0 ; int sign = 1 ; for ( int i = 0 ; i < s . length (); ++ i ) { char c = s . charAt ( i ); if ( Character . isDigit ( c )) num = num * 10 + ( c - '0' ); else if ( c == '+' || c == '-' ) { constant += sign * num ; sign = c == '+' ? 1 : - 1 ; num = 0 ; } else { if ( i > 0 && num == 0 && s . charAt ( i - 1 ) == '0' ) continue ; coefficient += num == 0 ? sign : sign * num ; num = 0 ; } } return new int [] { coefficient , constant + sign * num }; } }","title":"0631-0640"},{"location":"java/0601-0700/0631-0640/#631-design-excel-sum-formula-starstarstar","text":"","title":"631. Design Excel Sum Formula $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/0601-0700/0631-0640/#632-smallest-range-covering-elements-from-k-lists-starstarstar","text":"class Solution { public int [] smallestRange ( List < List < Integer >> nums ) { Queue < Elem > pq = new PriorityQueue <> (( e1 , e2 ) -> e1 . value - e2 . value ); int maxRange = Integer . MIN_VALUE ; for ( int i = 0 ; i < nums . size (); ++ i ) { pq . add ( new Elem ( nums . get ( i ). get ( 0 ), i , 0 )); maxRange = Math . max ( maxRange , nums . get ( i ). get ( 0 )); } int minRange = pq . peek (). value ; int [] ans = new int [] { minRange , maxRange }; while ( pq . size () == nums . size ()) { Elem elem = pq . poll (); if ( elem . c + 1 < nums . get ( elem . r ). size ()) { pq . add ( new Elem ( nums . get ( elem . r ). get ( elem . c + 1 ), elem . r , elem . c + 1 )); maxRange = Math . max ( maxRange , nums . get ( elem . r ). get ( elem . c + 1 )); minRange = pq . peek (). value ; if ( maxRange - minRange < ans [ 1 ] - ans [ 0 ] ) { ans [ 0 ] = minRange ; ans [ 1 ] = maxRange ; } } } return ans ; } private class Elem { int value ; int r ; int c ; public Elem ( int value , int r , int c ) { this . value = value ; this . r = r ; this . c = c ; } } }","title":"632. Smallest Range Covering Elements from K Lists $\\star\\star\\star$"},{"location":"java/0601-0700/0631-0640/#633-sum-of-square-numbers-star","text":"class Solution { public boolean judgeSquareSum ( int c ) { int l = 0 ; int r = ( int ) Math . sqrt ( c ); while ( l <= r ) { int sum = l * l + r * r ; if ( sum == c ) return true ; if ( sum < c ) ++ l ; else -- r ; } return false ; } }","title":"633. Sum of Square Numbers $\\star$"},{"location":"java/0601-0700/0631-0640/#634-find-the-derangement-of-an-array-starstar","text":"","title":"634. Find the Derangement of An Array $\\star\\star$ \ud83d\udd12"},{"location":"java/0601-0700/0631-0640/#635-design-log-storage-system-starstar","text":"","title":"635. Design Log Storage System $\\star\\star$ \ud83d\udd12"},{"location":"java/0601-0700/0631-0640/#636-exclusive-time-of-functions-starstar","text":"","title":"636. Exclusive Time of Functions $\\star\\star$"},{"location":"java/0601-0700/0631-0640/#637-average-of-levels-in-binary-tree-star","text":"","title":"637. Average of Levels in Binary Tree $\\star$"},{"location":"java/0601-0700/0631-0640/#638-shopping-offers-starstar","text":"class Solution { public int shoppingOffers ( List < Integer > price , List < List < Integer >> special , List < Integer > needs ) { return dfs ( price , special , needs , 0 ); } private int dfs ( List < Integer > price , List < List < Integer >> special , List < Integer > needs , int s ) { int ans = 0 ; for ( int i = 0 ; i < needs . size (); ++ i ) ans += needs . get ( i ) * price . get ( i ); for ( int i = s ; i < special . size (); ++ i ) { List < Integer > offer = special . get ( i ); if ( isValid ( offer , needs )) { for ( int j = 0 ; j < needs . size (); ++ j ) needs . set ( j , needs . get ( j ) - offer . get ( j )); ans = Math . min ( ans , offer . get ( offer . size () - 1 ) + dfs ( price , special , needs , i )); for ( int j = 0 ; j < needs . size (); ++ j ) needs . set ( j , needs . get ( j ) + offer . get ( j )); } } return ans ; } private boolean isValid ( List < Integer > offer , List < Integer > needs ) { for ( int i = 0 ; i < needs . size (); ++ i ) if ( offer . get ( i ) > needs . get ( i )) return false ; return true ; } }","title":"638. Shopping Offers $\\star\\star$"},{"location":"java/0601-0700/0631-0640/#639-decode-ways-ii-starstarstar","text":"","title":"639. Decode Ways II $\\star\\star\\star$"},{"location":"java/0601-0700/0631-0640/#640-solve-the-equation-starstar","text":"class Solution { public String solveEquation ( String equation ) { String [] equations = equation . split ( \"=\" ); int [] lhs = calculate ( equations [ 0 ] ); int [] rhs = calculate ( equations [ 1 ] ); int coefficient = lhs [ 0 ] - rhs [ 0 ] ; int constant = rhs [ 1 ] - lhs [ 1 ] ; if ( coefficient == 0 && constant == 0 ) return \"Infinite solutions\" ; if ( coefficient == 0 && constant != 0 ) return \"No solution\" ; return \"x=\" + constant / coefficient ; } private int [] calculate ( final String s ) { int coefficient = 0 ; int constant = 0 ; int num = 0 ; int sign = 1 ; for ( int i = 0 ; i < s . length (); ++ i ) { char c = s . charAt ( i ); if ( Character . isDigit ( c )) num = num * 10 + ( c - '0' ); else if ( c == '+' || c == '-' ) { constant += sign * num ; sign = c == '+' ? 1 : - 1 ; num = 0 ; } else { if ( i > 0 && num == 0 && s . charAt ( i - 1 ) == '0' ) continue ; coefficient += num == 0 ? sign : sign * num ; num = 0 ; } } return new int [] { coefficient , constant + sign * num }; } }","title":"640. Solve the Equation $\\star\\star$"},{"location":"java/0601-0700/0641-0650/","text":"641. Design Circular Deque $\\star\\star$ 642. Design Search Autocomplete System $\\star\\star\\star$ \ud83d\udd12 643. Maximum Average Subarray I $\\star$ class Solution { public double findMaxAverage ( int [] nums , int k ) { double sum = 0 ; for ( int i = 0 ; i < k ; ++ i ) sum += nums [ i ] ; double ans = sum ; for ( int i = k ; i < nums . length ; ++ i ) { sum += nums [ i ] - nums [ i - k ] ; ans = Math . max ( ans , sum ); } return ans / k ; } } 644. Maximum Average Subarray II $\\star\\star\\star$ \ud83d\udd12 645. Set Mismatch $\\star$ class Solution { public int [] findErrorNums ( int [] nums ) { int duplicate = 0 ; for ( int num : nums ) { if ( nums [ Math . abs ( num ) - 1 ] < 0 ) duplicate = Math . abs ( num ); else nums [ Math . abs ( num ) - 1 ] *= - 1 ; } for ( int i = 0 ; i < nums . length ; ++ i ) if ( nums [ i ] > 0 ) return new int [] { duplicate , i + 1 }; throw new IllegalArgumentException (); } } 646. Maximum Length of Pair Chain $\\star\\star$ 647. Palindromic Substrings $\\star\\star$ class Solution { public int countSubstrings ( String s ) { int ans = 0 ; for ( int i = 0 ; i < s . length (); ++ i ) { ans += extendPalindromes ( s , i , i ); ans += extendPalindromes ( s , i , i + 1 ); } return ans ; } private int extendPalindromes ( final String s , int l , int r ) { int count = 0 ; while ( l >= 0 && r < s . length () && s . charAt ( l ) == s . charAt ( r )) { ++ count ; -- l ; ++ r ; } return count ; } } 648. Replace Words $\\star\\star$ class Solution { public String replaceWords ( List < String > dict , String sentence ) { String ans = \"\" ; for ( final String word : dict ) insert ( word ); final String [] words = sentence . split ( \" \" ); for ( final String word : words ) ans += ' ' + search ( word ); return ans . substring ( 1 ); } private class TrieNode { private TrieNode [] children = new TrieNode [ 26 ] ; private String word ; } private TrieNode root = new TrieNode (); private void insert ( final String word ) { TrieNode node = root ; for ( char c : word . toCharArray ()) { int index = c - 'a' ; if ( node . children [ index ] == null ) node . children [ index ] = new TrieNode (); node = node . children [ index ] ; } node . word = word ; } private String search ( final String word ) { TrieNode node = root ; for ( char c : word . toCharArray ()) { if ( node . word != null ) return node . word ; int index = c - 'a' ; if ( node . children [ index ] == null ) return word ; node = node . children [ index ] ; } return word ; } } 649. Dota2 Senate $\\star\\star$ 650. 2 Keys Keyboard $\\star\\star$ class Solution { public int minSteps ( int n ) { int [] dp = new int [ n + 1 ] ; for ( int i = 2 ; i <= n ; ++ i ) { dp [ i ] = i ; for ( int j = i / 2 ; j > 2 ; -- j ) if ( i % j == 0 ) { dp [ i ] = dp [ j ] + i / j ; break ; } } return dp [ n ] ; } }","title":"0641-0650"},{"location":"java/0601-0700/0641-0650/#641-design-circular-deque-starstar","text":"","title":"641. Design Circular Deque $\\star\\star$"},{"location":"java/0601-0700/0641-0650/#642-design-search-autocomplete-system-starstarstar","text":"","title":"642. Design Search Autocomplete System $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/0601-0700/0641-0650/#643-maximum-average-subarray-i-star","text":"class Solution { public double findMaxAverage ( int [] nums , int k ) { double sum = 0 ; for ( int i = 0 ; i < k ; ++ i ) sum += nums [ i ] ; double ans = sum ; for ( int i = k ; i < nums . length ; ++ i ) { sum += nums [ i ] - nums [ i - k ] ; ans = Math . max ( ans , sum ); } return ans / k ; } }","title":"643. Maximum Average Subarray I $\\star$"},{"location":"java/0601-0700/0641-0650/#644-maximum-average-subarray-ii-starstarstar","text":"","title":"644. Maximum Average Subarray II $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/0601-0700/0641-0650/#645-set-mismatch-star","text":"class Solution { public int [] findErrorNums ( int [] nums ) { int duplicate = 0 ; for ( int num : nums ) { if ( nums [ Math . abs ( num ) - 1 ] < 0 ) duplicate = Math . abs ( num ); else nums [ Math . abs ( num ) - 1 ] *= - 1 ; } for ( int i = 0 ; i < nums . length ; ++ i ) if ( nums [ i ] > 0 ) return new int [] { duplicate , i + 1 }; throw new IllegalArgumentException (); } }","title":"645. Set Mismatch $\\star$"},{"location":"java/0601-0700/0641-0650/#646-maximum-length-of-pair-chain-starstar","text":"","title":"646. Maximum Length of Pair Chain $\\star\\star$"},{"location":"java/0601-0700/0641-0650/#647-palindromic-substrings-starstar","text":"class Solution { public int countSubstrings ( String s ) { int ans = 0 ; for ( int i = 0 ; i < s . length (); ++ i ) { ans += extendPalindromes ( s , i , i ); ans += extendPalindromes ( s , i , i + 1 ); } return ans ; } private int extendPalindromes ( final String s , int l , int r ) { int count = 0 ; while ( l >= 0 && r < s . length () && s . charAt ( l ) == s . charAt ( r )) { ++ count ; -- l ; ++ r ; } return count ; } }","title":"647. Palindromic Substrings $\\star\\star$"},{"location":"java/0601-0700/0641-0650/#648-replace-words-starstar","text":"class Solution { public String replaceWords ( List < String > dict , String sentence ) { String ans = \"\" ; for ( final String word : dict ) insert ( word ); final String [] words = sentence . split ( \" \" ); for ( final String word : words ) ans += ' ' + search ( word ); return ans . substring ( 1 ); } private class TrieNode { private TrieNode [] children = new TrieNode [ 26 ] ; private String word ; } private TrieNode root = new TrieNode (); private void insert ( final String word ) { TrieNode node = root ; for ( char c : word . toCharArray ()) { int index = c - 'a' ; if ( node . children [ index ] == null ) node . children [ index ] = new TrieNode (); node = node . children [ index ] ; } node . word = word ; } private String search ( final String word ) { TrieNode node = root ; for ( char c : word . toCharArray ()) { if ( node . word != null ) return node . word ; int index = c - 'a' ; if ( node . children [ index ] == null ) return word ; node = node . children [ index ] ; } return word ; } }","title":"648. Replace Words $\\star\\star$"},{"location":"java/0601-0700/0641-0650/#649-dota2-senate-starstar","text":"","title":"649. Dota2 Senate $\\star\\star$"},{"location":"java/0601-0700/0641-0650/#650-2-keys-keyboard-starstar","text":"class Solution { public int minSteps ( int n ) { int [] dp = new int [ n + 1 ] ; for ( int i = 2 ; i <= n ; ++ i ) { dp [ i ] = i ; for ( int j = i / 2 ; j > 2 ; -- j ) if ( i % j == 0 ) { dp [ i ] = dp [ j ] + i / j ; break ; } } return dp [ n ] ; } }","title":"650. 2 Keys Keyboard $\\star\\star$"},{"location":"java/0601-0700/0651-0660/","text":"651. 4 Keys Keyboard $\\star\\star$ \ud83d\udd12 652. Find Duplicate Subtrees $\\star\\star$ 653. Two Sum IV - Input is a BST $\\star$ 654. Maximum Binary Tree $\\star\\star$ 655. Print Binary Tree $\\star\\star$ 656. Coin Path $\\star\\star\\star$ \ud83d\udd12 657. Robot Return to Origin $\\star$ class Solution { public boolean judgeCircle ( String moves ) { int right = 0 ; int up = 0 ; for ( char move : moves . toCharArray ()) { switch ( move ) { case 'R' : ++ right ; break ; case 'L' : -- right ; break ; case 'U' : ++ up ; break ; case 'D' : -- up ; break ; } } return right == 0 && up == 0 ; } } 658. Find K Closest Elements $\\star\\star$ 659. Split Array into Consecutive Subsequences $\\star\\star$ 660. Remove 9 $\\star\\star\\star$ \ud83d\udd12","title":"0651-0660"},{"location":"java/0601-0700/0651-0660/#651-4-keys-keyboard-starstar","text":"","title":"651. 4 Keys Keyboard $\\star\\star$ \ud83d\udd12"},{"location":"java/0601-0700/0651-0660/#652-find-duplicate-subtrees-starstar","text":"","title":"652. Find Duplicate Subtrees $\\star\\star$"},{"location":"java/0601-0700/0651-0660/#653-two-sum-iv-input-is-a-bst-star","text":"","title":"653. Two Sum IV - Input is a BST $\\star$"},{"location":"java/0601-0700/0651-0660/#654-maximum-binary-tree-starstar","text":"","title":"654. Maximum Binary Tree $\\star\\star$"},{"location":"java/0601-0700/0651-0660/#655-print-binary-tree-starstar","text":"","title":"655. Print Binary Tree $\\star\\star$"},{"location":"java/0601-0700/0651-0660/#656-coin-path-starstarstar","text":"","title":"656. Coin Path $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/0601-0700/0651-0660/#657-robot-return-to-origin-star","text":"class Solution { public boolean judgeCircle ( String moves ) { int right = 0 ; int up = 0 ; for ( char move : moves . toCharArray ()) { switch ( move ) { case 'R' : ++ right ; break ; case 'L' : -- right ; break ; case 'U' : ++ up ; break ; case 'D' : -- up ; break ; } } return right == 0 && up == 0 ; } }","title":"657. Robot Return to Origin $\\star$"},{"location":"java/0601-0700/0651-0660/#658-find-k-closest-elements-starstar","text":"","title":"658. Find K Closest Elements $\\star\\star$"},{"location":"java/0601-0700/0651-0660/#659-split-array-into-consecutive-subsequences-starstar","text":"","title":"659. Split Array into Consecutive Subsequences $\\star\\star$"},{"location":"java/0601-0700/0651-0660/#660-remove-9-starstarstar","text":"","title":"660. Remove 9 $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/0601-0700/0661-0670/","text":"661. Image Smoother $\\star$ class Solution { public int [][] imageSmoother ( int [][] M ) { final int m = M . length ; final int n = M [ 0 ] . length ; int ans [][] = new int [ m ][ n ] ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int ones = 0 ; int count = 0 ; for ( int y = Math . max ( 0 , i - 1 ); y < Math . min ( m , i + 2 ); ++ y ) for ( int x = Math . max ( 0 , j - 1 ); x < Math . min ( n , j + 2 ); ++ x ) { ones += M [ y ][ x ] ; ++ count ; } ans [ i ][ j ] = ones / count ; } return ans ; } } 662. Maximum Width of Binary Tree $\\star\\star$ 663. Equal Tree Partition $\\star\\star$ \ud83d\udd12 664. Strange Printer $\\star\\star\\star$ 665. Non-decreasing Array $\\star$ class Solution { public boolean checkPossibility ( int [] nums ) { int j = - 1 ; for ( int i = 0 ; i + 1 < nums . length ; ++ i ) if ( nums [ i ] > nums [ i + 1 ] ) { if ( j != - 1 ) return false ; j = i ; } return j == - 1 || j == 0 || j == nums . length - 2 || nums [ j - 1 ] <= nums [ j + 1 ] || nums [ j ] <= nums [ j + 2 ] ; } } 666. Path Sum IV $\\star\\star$ \ud83d\udd12 667. Beautiful Arrangement II $\\star\\star$ class Solution { public int [] constructArray ( int n , int k ) { int [] ans = new int [ n ] ; for ( int i = 0 ; i < n - k ; ++ i ) ans [ i ] = i + 1 ; for ( int i = 0 ; i < k ; ++ i ) { if ( i % 2 == 0 ) ans [ n - k + i ] = n - i / 2 ; else ans [ n - k + i ] = n - k + ( i + 1 ) / 2 ; } return ans ; } } 668. Kth Smallest Number in Multiplication Table $\\star\\star\\star$ 669. Trim a Binary Search Tree $\\star$ 670. Maximum Swap $\\star\\star$ class Solution { public int maximumSwap ( int num ) { char [] s = Integer . toString ( num ). toCharArray (); int [] map = new int [ 10 ] ; for ( int i = 0 ; i < s . length ; ++ i ) map [ s [ i ] - '0' ] = i ; for ( int i = 0 ; i < s . length ; ++ i ) for ( int j = 9 ; j > s [ i ] - '0' ; -- j ) if ( map [ j ] > i ) { s [ map [ j ]] = s [ i ] ; s [ i ] = ( char ) ( '0' + j ); return Integer . valueOf ( new String ( s )); } return num ; } }","title":"0661-0670"},{"location":"java/0601-0700/0661-0670/#661-image-smoother-star","text":"class Solution { public int [][] imageSmoother ( int [][] M ) { final int m = M . length ; final int n = M [ 0 ] . length ; int ans [][] = new int [ m ][ n ] ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int ones = 0 ; int count = 0 ; for ( int y = Math . max ( 0 , i - 1 ); y < Math . min ( m , i + 2 ); ++ y ) for ( int x = Math . max ( 0 , j - 1 ); x < Math . min ( n , j + 2 ); ++ x ) { ones += M [ y ][ x ] ; ++ count ; } ans [ i ][ j ] = ones / count ; } return ans ; } }","title":"661. Image Smoother $\\star$"},{"location":"java/0601-0700/0661-0670/#662-maximum-width-of-binary-tree-starstar","text":"","title":"662. Maximum Width of Binary Tree $\\star\\star$"},{"location":"java/0601-0700/0661-0670/#663-equal-tree-partition-starstar","text":"","title":"663. Equal Tree Partition $\\star\\star$ \ud83d\udd12"},{"location":"java/0601-0700/0661-0670/#664-strange-printer-starstarstar","text":"","title":"664. Strange Printer $\\star\\star\\star$"},{"location":"java/0601-0700/0661-0670/#665-non-decreasing-array-star","text":"class Solution { public boolean checkPossibility ( int [] nums ) { int j = - 1 ; for ( int i = 0 ; i + 1 < nums . length ; ++ i ) if ( nums [ i ] > nums [ i + 1 ] ) { if ( j != - 1 ) return false ; j = i ; } return j == - 1 || j == 0 || j == nums . length - 2 || nums [ j - 1 ] <= nums [ j + 1 ] || nums [ j ] <= nums [ j + 2 ] ; } }","title":"665. Non-decreasing Array $\\star$"},{"location":"java/0601-0700/0661-0670/#666-path-sum-iv-starstar","text":"","title":"666. Path Sum IV $\\star\\star$ \ud83d\udd12"},{"location":"java/0601-0700/0661-0670/#667-beautiful-arrangement-ii-starstar","text":"class Solution { public int [] constructArray ( int n , int k ) { int [] ans = new int [ n ] ; for ( int i = 0 ; i < n - k ; ++ i ) ans [ i ] = i + 1 ; for ( int i = 0 ; i < k ; ++ i ) { if ( i % 2 == 0 ) ans [ n - k + i ] = n - i / 2 ; else ans [ n - k + i ] = n - k + ( i + 1 ) / 2 ; } return ans ; } }","title":"667. Beautiful Arrangement II $\\star\\star$"},{"location":"java/0601-0700/0661-0670/#668-kth-smallest-number-in-multiplication-table-starstarstar","text":"","title":"668. Kth Smallest Number in Multiplication Table $\\star\\star\\star$"},{"location":"java/0601-0700/0661-0670/#669-trim-a-binary-search-tree-star","text":"","title":"669. Trim a Binary Search Tree $\\star$"},{"location":"java/0601-0700/0661-0670/#670-maximum-swap-starstar","text":"class Solution { public int maximumSwap ( int num ) { char [] s = Integer . toString ( num ). toCharArray (); int [] map = new int [ 10 ] ; for ( int i = 0 ; i < s . length ; ++ i ) map [ s [ i ] - '0' ] = i ; for ( int i = 0 ; i < s . length ; ++ i ) for ( int j = 9 ; j > s [ i ] - '0' ; -- j ) if ( map [ j ] > i ) { s [ map [ j ]] = s [ i ] ; s [ i ] = ( char ) ( '0' + j ); return Integer . valueOf ( new String ( s )); } return num ; } }","title":"670. Maximum Swap $\\star\\star$"},{"location":"java/0601-0700/0671-0680/","text":"671. Second Minimum Node In a Binary Tree $\\star$ 672. Bulb Switcher II $\\star\\star$ class Solution { public int flipLights ( int n , int m ) { n = Math . min ( n , 3 ); if ( m == 0 ) return 1 ; if ( m == 1 ) return new int [] { 2 , 3 , 4 } [ n - 1 ] ; if ( m == 2 ) return new int [] { 2 , 4 , 7 } [ n - 1 ] ; return ( int ) Math . pow ( 2 , n ); } } 673. Number of Longest Increasing Subsequence $\\star\\star$ class Solution { public int findNumberOfLIS ( int [] nums ) { int ans = 0 ; int maxLength = 0 ; int [] length = new int [ nums . length ] ; int [] count = new int [ nums . length ] ; Arrays . fill ( length , 1 ); Arrays . fill ( count , 1 ); for ( int i = 0 ; i < nums . length ; ++ i ) { for ( int j = 0 ; j < i ; ++ j ) if ( nums [ j ] < nums [ i ] ) { if ( length [ i ] == length [ j ] + 1 ) count [ i ] += count [ j ] ; else if ( length [ i ] < length [ j ] + 1 ) { length [ i ] = length [ j ] + 1 ; count [ i ] = count [ j ] ; } } if ( maxLength == length [ i ] ) ans += count [ i ] ; else if ( maxLength < length [ i ] ) { maxLength = length [ i ] ; ans = count [ i ] ; } } return ans ; } } 674. Longest Continuous Increasing Subsequence $\\star$ class Solution { public int findLengthOfLCIS ( int [] nums ) { int ans = 0 ; for ( int i = 0 , j = 0 ; i < nums . length ; ++ i ) { if ( i > 0 && nums [ i ] <= nums [ i - 1 ] ) j = i ; ans = Math . max ( ans , i - j + 1 ); } return ans ; } } 675. Cut Off Trees for Golf Event $\\star\\star\\star$ 676. Implement Magic Dictionary $\\star\\star$ class MagicDictionary { public void buildDict ( String [] dict ) { for ( final String word : dict ) for ( int i = 0 ; i < word . length (); ++ i ) { String modifiedWord = word . substring ( 0 , i ) + '*' + word . substring ( i + 1 , word . length ()); if ( ! map . containsKey ( modifiedWord )) map . put ( modifiedWord , word . charAt ( i )); else if ( map . get ( modifiedWord ) != word . charAt ( i )) map . put ( modifiedWord , '*' ); } } public boolean search ( String word ) { for ( int i = 0 ; i < word . length (); ++ i ) { String modifiedWord = word . substring ( 0 , i ) + '*' + word . substring ( i + 1 , word . length ()); if ( map . containsKey ( modifiedWord ) && map . get ( modifiedWord ) != word . charAt ( i )) return true ; } return false ; } private Map < String , Character > map = new HashMap <> (); } 677. Map Sum Pairs $\\star\\star$ 678. Valid Parenthesis String $\\star\\star$ class Solution { public boolean checkValidString ( String s ) { int low = 0 ; int high = 0 ; for ( char c : s . toCharArray ()) { switch ( c ) { case '(' : ++ low ; ++ high ; break ; case ')' : low = Math . max ( 0 , -- low ); -- high ; break ; case '*' : low = Math . max ( 0 , -- low ); ++ high ; break ; } if ( high < 0 ) return false ; } return low == 0 ; } } 679. 24 Game $\\star\\star\\star$ class Solution { public boolean judgePoint24 ( int [] nums ) { List < Double > doubleNums = new ArrayList <> (); for ( int num : nums ) doubleNums . add (( double ) num ); return dfs ( doubleNums ); } private boolean dfs ( List < Double > nums ) { if ( nums . size () == 1 ) return Math . abs ( nums . get ( 0 ) - 24.0 ) < 0.001 ; for ( int i = 0 ; i < nums . size (); ++ i ) for ( int j = i + 1 ; j < nums . size (); ++ j ) for ( double num : generate ( nums . get ( i ), nums . get ( j ))) { List < Double > nextRound = new ArrayList <> ( Arrays . asList ( num )); for ( int k = 0 ; k < nums . size (); ++ k ) { if ( k == i || k == j ) continue ; nextRound . add ( nums . get ( k )); } if ( dfs ( nextRound )) return true ; } return false ; } private List < Double > generate ( double a , double b ) { return new ArrayList <> ( Arrays . asList ( a * b , a / b , b / a , a + b , a - b , b - a )); } } 680. Valid Palindrome II $\\star$","title":"0671-0680"},{"location":"java/0601-0700/0671-0680/#671-second-minimum-node-in-a-binary-tree-star","text":"","title":"671. Second Minimum Node In a Binary Tree $\\star$"},{"location":"java/0601-0700/0671-0680/#672-bulb-switcher-ii-starstar","text":"class Solution { public int flipLights ( int n , int m ) { n = Math . min ( n , 3 ); if ( m == 0 ) return 1 ; if ( m == 1 ) return new int [] { 2 , 3 , 4 } [ n - 1 ] ; if ( m == 2 ) return new int [] { 2 , 4 , 7 } [ n - 1 ] ; return ( int ) Math . pow ( 2 , n ); } }","title":"672. Bulb Switcher II $\\star\\star$"},{"location":"java/0601-0700/0671-0680/#673-number-of-longest-increasing-subsequence-starstar","text":"class Solution { public int findNumberOfLIS ( int [] nums ) { int ans = 0 ; int maxLength = 0 ; int [] length = new int [ nums . length ] ; int [] count = new int [ nums . length ] ; Arrays . fill ( length , 1 ); Arrays . fill ( count , 1 ); for ( int i = 0 ; i < nums . length ; ++ i ) { for ( int j = 0 ; j < i ; ++ j ) if ( nums [ j ] < nums [ i ] ) { if ( length [ i ] == length [ j ] + 1 ) count [ i ] += count [ j ] ; else if ( length [ i ] < length [ j ] + 1 ) { length [ i ] = length [ j ] + 1 ; count [ i ] = count [ j ] ; } } if ( maxLength == length [ i ] ) ans += count [ i ] ; else if ( maxLength < length [ i ] ) { maxLength = length [ i ] ; ans = count [ i ] ; } } return ans ; } }","title":"673. Number of Longest Increasing Subsequence $\\star\\star$"},{"location":"java/0601-0700/0671-0680/#674-longest-continuous-increasing-subsequence-star","text":"class Solution { public int findLengthOfLCIS ( int [] nums ) { int ans = 0 ; for ( int i = 0 , j = 0 ; i < nums . length ; ++ i ) { if ( i > 0 && nums [ i ] <= nums [ i - 1 ] ) j = i ; ans = Math . max ( ans , i - j + 1 ); } return ans ; } }","title":"674. Longest Continuous Increasing Subsequence $\\star$"},{"location":"java/0601-0700/0671-0680/#675-cut-off-trees-for-golf-event-starstarstar","text":"","title":"675. Cut Off Trees for Golf Event $\\star\\star\\star$"},{"location":"java/0601-0700/0671-0680/#676-implement-magic-dictionary-starstar","text":"class MagicDictionary { public void buildDict ( String [] dict ) { for ( final String word : dict ) for ( int i = 0 ; i < word . length (); ++ i ) { String modifiedWord = word . substring ( 0 , i ) + '*' + word . substring ( i + 1 , word . length ()); if ( ! map . containsKey ( modifiedWord )) map . put ( modifiedWord , word . charAt ( i )); else if ( map . get ( modifiedWord ) != word . charAt ( i )) map . put ( modifiedWord , '*' ); } } public boolean search ( String word ) { for ( int i = 0 ; i < word . length (); ++ i ) { String modifiedWord = word . substring ( 0 , i ) + '*' + word . substring ( i + 1 , word . length ()); if ( map . containsKey ( modifiedWord ) && map . get ( modifiedWord ) != word . charAt ( i )) return true ; } return false ; } private Map < String , Character > map = new HashMap <> (); }","title":"676. Implement Magic Dictionary $\\star\\star$"},{"location":"java/0601-0700/0671-0680/#677-map-sum-pairs-starstar","text":"","title":"677. Map Sum Pairs $\\star\\star$"},{"location":"java/0601-0700/0671-0680/#678-valid-parenthesis-string-starstar","text":"class Solution { public boolean checkValidString ( String s ) { int low = 0 ; int high = 0 ; for ( char c : s . toCharArray ()) { switch ( c ) { case '(' : ++ low ; ++ high ; break ; case ')' : low = Math . max ( 0 , -- low ); -- high ; break ; case '*' : low = Math . max ( 0 , -- low ); ++ high ; break ; } if ( high < 0 ) return false ; } return low == 0 ; } }","title":"678. Valid Parenthesis String $\\star\\star$"},{"location":"java/0601-0700/0671-0680/#679-24-game-starstarstar","text":"class Solution { public boolean judgePoint24 ( int [] nums ) { List < Double > doubleNums = new ArrayList <> (); for ( int num : nums ) doubleNums . add (( double ) num ); return dfs ( doubleNums ); } private boolean dfs ( List < Double > nums ) { if ( nums . size () == 1 ) return Math . abs ( nums . get ( 0 ) - 24.0 ) < 0.001 ; for ( int i = 0 ; i < nums . size (); ++ i ) for ( int j = i + 1 ; j < nums . size (); ++ j ) for ( double num : generate ( nums . get ( i ), nums . get ( j ))) { List < Double > nextRound = new ArrayList <> ( Arrays . asList ( num )); for ( int k = 0 ; k < nums . size (); ++ k ) { if ( k == i || k == j ) continue ; nextRound . add ( nums . get ( k )); } if ( dfs ( nextRound )) return true ; } return false ; } private List < Double > generate ( double a , double b ) { return new ArrayList <> ( Arrays . asList ( a * b , a / b , b / a , a + b , a - b , b - a )); } }","title":"679. 24 Game $\\star\\star\\star$"},{"location":"java/0601-0700/0671-0680/#680-valid-palindrome-ii-star","text":"","title":"680. Valid Palindrome II $\\star$"},{"location":"java/0601-0700/0681-0690/","text":"681. Next Closest Time $\\star\\star$ \ud83d\udd12 682. Baseball Game $\\star$ 683. K Empty Slots $\\star\\star\\star$ \ud83d\udd12 684. Redundant Connection $\\star\\star$ class Solution { public int [] findRedundantConnection ( int [][] edges ) { UF uf = new UF ( edges . length ); for ( int [] edge : edges ) if ( ! uf . union ( edge [ 0 ] , edge [ 1 ] )) return edge ; throw new IllegalArgumentException (); } } class UF { public UF ( int n ) { rank = new int [ n + 1 ] ; parent = new int [ n + 1 ] ; for ( int i = 0 ; i < parent . length ; ++ i ) parent [ i ] = i ; } public boolean union ( int u , int v ) { int pu = find ( u ); int pv = find ( v ); if ( pu == pv ) return false ; if ( rank [ pu ] < rank [ pv ] ) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ] ) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ] ; } return true ; } public int find ( int u ) { while ( u != parent [ u ] ) { parent [ u ] = parent [ parent [ u ]] ; u = parent [ u ] ; } return u ; } private int [] rank ; private int [] parent ; } 685. Redundant Connection II $\\star\\star\\star$ class Solution { public int [] findRedundantDirectedConnection ( int [][] edges ) { int [] parents = new int [ edges . length + 1 ] ; int nodeWithTwoParents = 0 ; for ( int [] edge : edges ) { int u = edge [ 0 ] ; int v = edge [ 1 ] ; if ( ++ parents [ v ] == 2 ) nodeWithTwoParents = v ; } if ( nodeWithTwoParents == 0 ) return findRedundantDirectedConnection ( edges , - 1 ); for ( int i = edges . length - 1 ; i >= 0 ; -- i ) { int u = edges [ i ][ 0 ] ; int v = edges [ i ][ 1 ] ; if ( v == nodeWithTwoParents ) if ( findRedundantDirectedConnection ( edges , i ). length == 0 ) return edges [ i ] ; } throw new IllegalArgumentException (); } private int [] findRedundantDirectedConnection ( int [][] edges , int skippedEdgeIndex ) { UF uf = new UF ( edges . length ); for ( int i = 0 ; i < edges . length ; ++ i ) { if ( i == skippedEdgeIndex ) continue ; if ( ! uf . union ( edges [ i ][ 0 ] , edges [ i ][ 1 ] )) return edges [ i ] ; } return new int [] {}; } } class UF { public UF ( int n ) { rank = new int [ n + 1 ] ; parent = new int [ n + 1 ] ; for ( int i = 0 ; i < parent . length ; ++ i ) parent [ i ] = i ; } public boolean union ( int u , int v ) { int pu = find ( u ); int pv = find ( v ); if ( pu == pv ) return false ; if ( rank [ pu ] < rank [ pv ] ) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ] ) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ] ; } return true ; } public int find ( int u ) { while ( u != parent [ u ] ) { parent [ u ] = parent [ parent [ u ]] ; u = parent [ u ] ; } return u ; } private int [] rank ; private int [] parent ; } 686. Repeated String Match $\\star$ class Solution { public int repeatedStringMatch ( String A , String B ) { final int n = ( int ) Math . ceil (( double ) B . length () / ( double ) A . length ()); String s = String . join ( \"\" , Collections . nCopies ( n , A )); if ( s . contains ( B )) return n ; if (( s + A ). contains ( B )) return n + 1 ; return - 1 ; } } 687. Longest Univalue Path $\\star$ 688. Knight Probability in Chessboard $\\star\\star$ 689. Maximum Sum of 3 Non-Overlapping Subarrays $\\star\\star\\star$ class Solution { public int [] maxSumOfThreeSubarrays ( int [] nums , int k ) { int [] ans = new int [] { - 1 , - 1 , - 1 }; int subarrayCount = nums . length - k + 1 ; int [] dp = new int [ subarrayCount ] ; int sum = 0 ; for ( int i = 0 ; i < nums . length ; ++ i ) { sum += nums [ i ] ; if ( i >= k ) sum -= nums [ i - k ] ; if ( i >= k - 1 ) dp [ i - k + 1 ] = sum ; } int [] left = new int [ subarrayCount ] ; int maxIndex = 0 ; for ( int i = 0 ; i < subarrayCount ; ++ i ) { if ( dp [ i ] > dp [ maxIndex ] ) maxIndex = i ; left [ i ] = maxIndex ; } int [] right = new int [ subarrayCount ] ; maxIndex = subarrayCount - 1 ; for ( int i = subarrayCount - 1 ; i >= 0 ; -- i ) { if ( dp [ i ] >= dp [ maxIndex ] ) maxIndex = i ; right [ i ] = maxIndex ; } for ( int i = k ; i < subarrayCount - k ; ++ i ) if ( ans [ 0 ] == - 1 || dp [ left [ i - k ]] + dp [ i ] + dp [ right [ i + k ]] > dp [ ans [ 0 ]] + dp [ ans [ 1 ]] + dp [ ans [ 2 ]] ) { ans [ 0 ] = left [ i - k ] ; ans [ 1 ] = i ; ans [ 2 ] = right [ i + k ] ; } return ans ; } } 690. Employee Importance $\\star$ class Solution { public int getImportance ( List < Employee > employees , int id ) { Map < Integer , Employee > idToEmployee = new HashMap <> (); for ( Employee employee : employees ) idToEmployee . put ( employee . id , employee ); return dfs ( idToEmployee , id ); } private int dfs ( Map < Integer , Employee > idToEmployee , int id ) { int subordinatesImportance = 0 ; for ( int subordinate : idToEmployee . get ( id ). subordinates ) subordinatesImportance += dfs ( idToEmployee , subordinate ); return idToEmployee . get ( id ). importance + subordinatesImportance ; } }","title":"0681-0690"},{"location":"java/0601-0700/0681-0690/#681-next-closest-time-starstar","text":"","title":"681. Next Closest Time $\\star\\star$ \ud83d\udd12"},{"location":"java/0601-0700/0681-0690/#682-baseball-game-star","text":"","title":"682. Baseball Game $\\star$"},{"location":"java/0601-0700/0681-0690/#683-k-empty-slots-starstarstar","text":"","title":"683. K Empty Slots $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/0601-0700/0681-0690/#684-redundant-connection-starstar","text":"class Solution { public int [] findRedundantConnection ( int [][] edges ) { UF uf = new UF ( edges . length ); for ( int [] edge : edges ) if ( ! uf . union ( edge [ 0 ] , edge [ 1 ] )) return edge ; throw new IllegalArgumentException (); } } class UF { public UF ( int n ) { rank = new int [ n + 1 ] ; parent = new int [ n + 1 ] ; for ( int i = 0 ; i < parent . length ; ++ i ) parent [ i ] = i ; } public boolean union ( int u , int v ) { int pu = find ( u ); int pv = find ( v ); if ( pu == pv ) return false ; if ( rank [ pu ] < rank [ pv ] ) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ] ) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ] ; } return true ; } public int find ( int u ) { while ( u != parent [ u ] ) { parent [ u ] = parent [ parent [ u ]] ; u = parent [ u ] ; } return u ; } private int [] rank ; private int [] parent ; }","title":"684. Redundant Connection $\\star\\star$"},{"location":"java/0601-0700/0681-0690/#685-redundant-connection-ii-starstarstar","text":"class Solution { public int [] findRedundantDirectedConnection ( int [][] edges ) { int [] parents = new int [ edges . length + 1 ] ; int nodeWithTwoParents = 0 ; for ( int [] edge : edges ) { int u = edge [ 0 ] ; int v = edge [ 1 ] ; if ( ++ parents [ v ] == 2 ) nodeWithTwoParents = v ; } if ( nodeWithTwoParents == 0 ) return findRedundantDirectedConnection ( edges , - 1 ); for ( int i = edges . length - 1 ; i >= 0 ; -- i ) { int u = edges [ i ][ 0 ] ; int v = edges [ i ][ 1 ] ; if ( v == nodeWithTwoParents ) if ( findRedundantDirectedConnection ( edges , i ). length == 0 ) return edges [ i ] ; } throw new IllegalArgumentException (); } private int [] findRedundantDirectedConnection ( int [][] edges , int skippedEdgeIndex ) { UF uf = new UF ( edges . length ); for ( int i = 0 ; i < edges . length ; ++ i ) { if ( i == skippedEdgeIndex ) continue ; if ( ! uf . union ( edges [ i ][ 0 ] , edges [ i ][ 1 ] )) return edges [ i ] ; } return new int [] {}; } } class UF { public UF ( int n ) { rank = new int [ n + 1 ] ; parent = new int [ n + 1 ] ; for ( int i = 0 ; i < parent . length ; ++ i ) parent [ i ] = i ; } public boolean union ( int u , int v ) { int pu = find ( u ); int pv = find ( v ); if ( pu == pv ) return false ; if ( rank [ pu ] < rank [ pv ] ) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ] ) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ] ; } return true ; } public int find ( int u ) { while ( u != parent [ u ] ) { parent [ u ] = parent [ parent [ u ]] ; u = parent [ u ] ; } return u ; } private int [] rank ; private int [] parent ; }","title":"685. Redundant Connection II $\\star\\star\\star$"},{"location":"java/0601-0700/0681-0690/#686-repeated-string-match-star","text":"class Solution { public int repeatedStringMatch ( String A , String B ) { final int n = ( int ) Math . ceil (( double ) B . length () / ( double ) A . length ()); String s = String . join ( \"\" , Collections . nCopies ( n , A )); if ( s . contains ( B )) return n ; if (( s + A ). contains ( B )) return n + 1 ; return - 1 ; } }","title":"686. Repeated String Match $\\star$"},{"location":"java/0601-0700/0681-0690/#687-longest-univalue-path-star","text":"","title":"687. Longest Univalue Path $\\star$"},{"location":"java/0601-0700/0681-0690/#688-knight-probability-in-chessboard-starstar","text":"","title":"688. Knight Probability in Chessboard $\\star\\star$"},{"location":"java/0601-0700/0681-0690/#689-maximum-sum-of-3-non-overlapping-subarrays-starstarstar","text":"class Solution { public int [] maxSumOfThreeSubarrays ( int [] nums , int k ) { int [] ans = new int [] { - 1 , - 1 , - 1 }; int subarrayCount = nums . length - k + 1 ; int [] dp = new int [ subarrayCount ] ; int sum = 0 ; for ( int i = 0 ; i < nums . length ; ++ i ) { sum += nums [ i ] ; if ( i >= k ) sum -= nums [ i - k ] ; if ( i >= k - 1 ) dp [ i - k + 1 ] = sum ; } int [] left = new int [ subarrayCount ] ; int maxIndex = 0 ; for ( int i = 0 ; i < subarrayCount ; ++ i ) { if ( dp [ i ] > dp [ maxIndex ] ) maxIndex = i ; left [ i ] = maxIndex ; } int [] right = new int [ subarrayCount ] ; maxIndex = subarrayCount - 1 ; for ( int i = subarrayCount - 1 ; i >= 0 ; -- i ) { if ( dp [ i ] >= dp [ maxIndex ] ) maxIndex = i ; right [ i ] = maxIndex ; } for ( int i = k ; i < subarrayCount - k ; ++ i ) if ( ans [ 0 ] == - 1 || dp [ left [ i - k ]] + dp [ i ] + dp [ right [ i + k ]] > dp [ ans [ 0 ]] + dp [ ans [ 1 ]] + dp [ ans [ 2 ]] ) { ans [ 0 ] = left [ i - k ] ; ans [ 1 ] = i ; ans [ 2 ] = right [ i + k ] ; } return ans ; } }","title":"689. Maximum Sum of 3 Non-Overlapping Subarrays $\\star\\star\\star$"},{"location":"java/0601-0700/0681-0690/#690-employee-importance-star","text":"class Solution { public int getImportance ( List < Employee > employees , int id ) { Map < Integer , Employee > idToEmployee = new HashMap <> (); for ( Employee employee : employees ) idToEmployee . put ( employee . id , employee ); return dfs ( idToEmployee , id ); } private int dfs ( Map < Integer , Employee > idToEmployee , int id ) { int subordinatesImportance = 0 ; for ( int subordinate : idToEmployee . get ( id ). subordinates ) subordinatesImportance += dfs ( idToEmployee , subordinate ); return idToEmployee . get ( id ). importance + subordinatesImportance ; } }","title":"690. Employee Importance $\\star$"},{"location":"java/0601-0700/0691-0700/","text":"691. Stickers to Spell Word $\\star\\star\\star$ 692. Top K Frequent Words $\\star\\star$ class Solution { public List < String > topKFrequent ( String [] words , int k ) { List < String > ans = new ArrayList <> (); List < String >[] bucket = new List [ words . length + 1 ] ; Map < String , Integer > count = new HashMap <> (); for ( final String word : words ) count . put ( word , count . getOrDefault ( word , 0 ) + 1 ); for ( final String word : count . keySet ()) { int freq = count . get ( word ); if ( bucket [ freq ] == null ) bucket [ freq ] = new ArrayList <> (); bucket [ freq ] . add ( word ); } for ( int freq = bucket . length - 1 ; freq >= 0 ; -- freq ) if ( bucket [ freq ] != null ) { Collections . sort ( bucket [ freq ] ); for ( final String word : bucket [ freq ] ) { ans . add ( word ); if ( ans . size () == k ) return ans ; } } throw new IllegalArgumentException (); } } 693. Binary Number with Alternating Bits $\\star$ 694. Number of Distinct Islands $\\star\\star$ \ud83d\udd12 695. Max Area of Island $\\star\\star$ class Solution { public int maxAreaOfIsland ( int [][] grid ) { int ans = 0 ; boolean [][] seen = new boolean [ grid . length ][ grid [ 0 ] . length ] ; for ( int i = 0 ; i < grid . length ; ++ i ) for ( int j = 0 ; j < grid [ 0 ] . length ; ++ j ) ans = Math . max ( ans , dfs ( grid , i , j , seen )); return ans ; } private int dfs ( int [][] grid , int i , int j , boolean [][] seen ) { if ( i < 0 || i >= grid . length || j < 0 || j >= grid [ 0 ] . length ) return 0 ; if ( grid [ i ][ j ] == 0 || seen [ i ][ j ] ) return 0 ; seen [ i ][ j ] = true ; return 1 + dfs ( grid , i + 1 , j , seen ) + dfs ( grid , i - 1 , j , seen ) + dfs ( grid , i , j + 1 , seen ) + dfs ( grid , i , j - 1 , seen ); } } 696. Count Binary Substrings $\\star$ class Solution { public int countBinarySubstrings ( String s ) { int ans = 0 ; int prevCount = 0 ; int equals = 1 ; for ( int i = 0 ; i + 1 < s . length (); ++ i ) if ( s . charAt ( i ) == s . charAt ( i + 1 )) ++ equals ; else { ans += Math . min ( prevCount , equals ); prevCount = equals ; equals = 1 ; } return ans + Math . min ( prevCount , equals ); } } 697. Degree of an Array $\\star$ class Solution { public int findShortestSubArray ( int [] nums ) { int ans = 0 ; int degree = 0 ; Map < Integer , Integer > firstSeen = new HashMap <> (); Map < Integer , Integer > numCounts = new HashMap <> (); for ( int i = 0 ; i < nums . length ; ++ i ) { firstSeen . putIfAbsent ( nums [ i ] , i ); numCounts . put ( nums [ i ] , numCounts . getOrDefault ( nums [ i ] , 0 ) + 1 ); if ( numCounts . get ( nums [ i ] ) > degree ) { degree = numCounts . get ( nums [ i ] ); ans = i - firstSeen . get ( nums [ i ] ) + 1 ; } else if ( numCounts . get ( nums [ i ] ) == degree ) ans = Math . min ( ans , i - firstSeen . get ( nums [ i ] ) + 1 ); } return ans ; } } 698. Partition to K Equal Sum Subsets $\\star\\star$ 699. Falling Squares $\\star\\star\\star$ 700. Search in a Binary Search Tree $\\star$","title":"0691-0700"},{"location":"java/0601-0700/0691-0700/#691-stickers-to-spell-word-starstarstar","text":"","title":"691. Stickers to Spell Word $\\star\\star\\star$"},{"location":"java/0601-0700/0691-0700/#692-top-k-frequent-words-starstar","text":"class Solution { public List < String > topKFrequent ( String [] words , int k ) { List < String > ans = new ArrayList <> (); List < String >[] bucket = new List [ words . length + 1 ] ; Map < String , Integer > count = new HashMap <> (); for ( final String word : words ) count . put ( word , count . getOrDefault ( word , 0 ) + 1 ); for ( final String word : count . keySet ()) { int freq = count . get ( word ); if ( bucket [ freq ] == null ) bucket [ freq ] = new ArrayList <> (); bucket [ freq ] . add ( word ); } for ( int freq = bucket . length - 1 ; freq >= 0 ; -- freq ) if ( bucket [ freq ] != null ) { Collections . sort ( bucket [ freq ] ); for ( final String word : bucket [ freq ] ) { ans . add ( word ); if ( ans . size () == k ) return ans ; } } throw new IllegalArgumentException (); } }","title":"692. Top K Frequent Words $\\star\\star$"},{"location":"java/0601-0700/0691-0700/#693-binary-number-with-alternating-bits-star","text":"","title":"693. Binary Number with Alternating Bits $\\star$"},{"location":"java/0601-0700/0691-0700/#694-number-of-distinct-islands-starstar","text":"","title":"694. Number of Distinct Islands $\\star\\star$ \ud83d\udd12"},{"location":"java/0601-0700/0691-0700/#695-max-area-of-island-starstar","text":"class Solution { public int maxAreaOfIsland ( int [][] grid ) { int ans = 0 ; boolean [][] seen = new boolean [ grid . length ][ grid [ 0 ] . length ] ; for ( int i = 0 ; i < grid . length ; ++ i ) for ( int j = 0 ; j < grid [ 0 ] . length ; ++ j ) ans = Math . max ( ans , dfs ( grid , i , j , seen )); return ans ; } private int dfs ( int [][] grid , int i , int j , boolean [][] seen ) { if ( i < 0 || i >= grid . length || j < 0 || j >= grid [ 0 ] . length ) return 0 ; if ( grid [ i ][ j ] == 0 || seen [ i ][ j ] ) return 0 ; seen [ i ][ j ] = true ; return 1 + dfs ( grid , i + 1 , j , seen ) + dfs ( grid , i - 1 , j , seen ) + dfs ( grid , i , j + 1 , seen ) + dfs ( grid , i , j - 1 , seen ); } }","title":"695. Max Area of Island $\\star\\star$"},{"location":"java/0601-0700/0691-0700/#696-count-binary-substrings-star","text":"class Solution { public int countBinarySubstrings ( String s ) { int ans = 0 ; int prevCount = 0 ; int equals = 1 ; for ( int i = 0 ; i + 1 < s . length (); ++ i ) if ( s . charAt ( i ) == s . charAt ( i + 1 )) ++ equals ; else { ans += Math . min ( prevCount , equals ); prevCount = equals ; equals = 1 ; } return ans + Math . min ( prevCount , equals ); } }","title":"696. Count Binary Substrings $\\star$"},{"location":"java/0601-0700/0691-0700/#697-degree-of-an-array-star","text":"class Solution { public int findShortestSubArray ( int [] nums ) { int ans = 0 ; int degree = 0 ; Map < Integer , Integer > firstSeen = new HashMap <> (); Map < Integer , Integer > numCounts = new HashMap <> (); for ( int i = 0 ; i < nums . length ; ++ i ) { firstSeen . putIfAbsent ( nums [ i ] , i ); numCounts . put ( nums [ i ] , numCounts . getOrDefault ( nums [ i ] , 0 ) + 1 ); if ( numCounts . get ( nums [ i ] ) > degree ) { degree = numCounts . get ( nums [ i ] ); ans = i - firstSeen . get ( nums [ i ] ) + 1 ; } else if ( numCounts . get ( nums [ i ] ) == degree ) ans = Math . min ( ans , i - firstSeen . get ( nums [ i ] ) + 1 ); } return ans ; } }","title":"697. Degree of an Array $\\star$"},{"location":"java/0601-0700/0691-0700/#698-partition-to-k-equal-sum-subsets-starstar","text":"","title":"698. Partition to K Equal Sum Subsets $\\star\\star$"},{"location":"java/0601-0700/0691-0700/#699-falling-squares-starstarstar","text":"","title":"699. Falling Squares $\\star\\star\\star$"},{"location":"java/0601-0700/0691-0700/#700-search-in-a-binary-search-tree-star","text":"","title":"700. Search in a Binary Search Tree $\\star$"},{"location":"java/0701-0800/0701-0710/","text":"701. Insert into a Binary Search Tree $\\star\\star$ 702. Search in a Sorted Array of Unknown Size $\\star\\star$ \ud83d\udd12 703. Kth Largest Element in a Stream $\\star$ 704. Binary Search $\\star$ 705. Design HashSet $\\star$ class MyHashSet { public void add ( int key ) { set [ key ] = true ; } public void remove ( int key ) { set [ key ] = false ; } public boolean contains ( int key ) { return set [ key ] ; } private boolean [] set = new boolean [ 1000001 ] ; } 706. Design HashMap $\\star$ 707. Design Linked List $\\star\\star$ class MyLinkedList { public int get ( int index ) { if ( index < 0 || index >= length ) return - 1 ; ListNode curr = dummy . next ; for ( int i = 0 ; i < index ; ++ i ) curr = curr . next ; return curr . val ; } public void addAtHead ( int val ) { ListNode curr = dummy . next ; dummy . next = new ListNode ( val ); dummy . next . next = curr ; ++ length ; } public void addAtTail ( int val ) { ListNode curr = dummy . next ; while ( curr . next != null ) curr = curr . next ; curr . next = new ListNode ( val ); ++ length ; } public void addAtIndex ( int index , int val ) { if ( index > length ) return ; ListNode curr = dummy ; for ( int i = 0 ; i < index ; ++ i ) curr = curr . next ; ListNode temp = curr . next ; curr . next = new ListNode ( val ); curr . next . next = temp ; ++ length ; } public void deleteAtIndex ( int index ) { if ( index < 0 || index >= length ) return ; ListNode curr = dummy ; for ( int i = 0 ; i < index ; ++ i ) curr = curr . next ; ListNode temp = curr . next ; curr . next = temp . next ; -- length ; } private class ListNode { int val ; ListNode next ; public ListNode ( int val ) { this . val = val ; } } int length = 0 ; ListNode dummy = new ListNode ( 0 ); } 708. Insert into a Sorted Circular Linked List $\\star\\star$ \ud83d\udd12 709. To Lower Case $\\star$ 710. Random Pick with Blacklist $\\star\\star\\star$ class Solution { public Solution ( int N , int [] blacklist ) { validRange = N - blacklist . length ; for ( int b : blacklist ) map . put ( b , - 1 ); for ( int b : blacklist ) if ( b < validRange ) { while ( map . containsKey ( N - 1 )) -- N ; map . put ( b , -- N ); } } public int pick () { int value = rand . nextInt ( validRange ); return map . getOrDefault ( value , value ); } private int validRange ; private Map < Integer , Integer > map = new HashMap <> (); private Random rand = new Random (); }","title":"0701-0710"},{"location":"java/0701-0800/0701-0710/#701-insert-into-a-binary-search-tree-starstar","text":"","title":"701. Insert into a Binary Search Tree $\\star\\star$"},{"location":"java/0701-0800/0701-0710/#702-search-in-a-sorted-array-of-unknown-size-starstar","text":"","title":"702. Search in a Sorted Array of Unknown Size $\\star\\star$ \ud83d\udd12"},{"location":"java/0701-0800/0701-0710/#703-kth-largest-element-in-a-stream-star","text":"","title":"703. Kth Largest Element in a Stream $\\star$"},{"location":"java/0701-0800/0701-0710/#704-binary-search-star","text":"","title":"704. Binary Search $\\star$"},{"location":"java/0701-0800/0701-0710/#705-design-hashset-star","text":"class MyHashSet { public void add ( int key ) { set [ key ] = true ; } public void remove ( int key ) { set [ key ] = false ; } public boolean contains ( int key ) { return set [ key ] ; } private boolean [] set = new boolean [ 1000001 ] ; }","title":"705. Design HashSet $\\star$"},{"location":"java/0701-0800/0701-0710/#706-design-hashmap-star","text":"","title":"706. Design HashMap $\\star$"},{"location":"java/0701-0800/0701-0710/#707-design-linked-list-starstar","text":"class MyLinkedList { public int get ( int index ) { if ( index < 0 || index >= length ) return - 1 ; ListNode curr = dummy . next ; for ( int i = 0 ; i < index ; ++ i ) curr = curr . next ; return curr . val ; } public void addAtHead ( int val ) { ListNode curr = dummy . next ; dummy . next = new ListNode ( val ); dummy . next . next = curr ; ++ length ; } public void addAtTail ( int val ) { ListNode curr = dummy . next ; while ( curr . next != null ) curr = curr . next ; curr . next = new ListNode ( val ); ++ length ; } public void addAtIndex ( int index , int val ) { if ( index > length ) return ; ListNode curr = dummy ; for ( int i = 0 ; i < index ; ++ i ) curr = curr . next ; ListNode temp = curr . next ; curr . next = new ListNode ( val ); curr . next . next = temp ; ++ length ; } public void deleteAtIndex ( int index ) { if ( index < 0 || index >= length ) return ; ListNode curr = dummy ; for ( int i = 0 ; i < index ; ++ i ) curr = curr . next ; ListNode temp = curr . next ; curr . next = temp . next ; -- length ; } private class ListNode { int val ; ListNode next ; public ListNode ( int val ) { this . val = val ; } } int length = 0 ; ListNode dummy = new ListNode ( 0 ); }","title":"707. Design Linked List $\\star\\star$"},{"location":"java/0701-0800/0701-0710/#708-insert-into-a-sorted-circular-linked-list-starstar","text":"","title":"708. Insert into a Sorted Circular Linked List $\\star\\star$ \ud83d\udd12"},{"location":"java/0701-0800/0701-0710/#709-to-lower-case-star","text":"","title":"709. To Lower Case $\\star$"},{"location":"java/0701-0800/0701-0710/#710-random-pick-with-blacklist-starstarstar","text":"class Solution { public Solution ( int N , int [] blacklist ) { validRange = N - blacklist . length ; for ( int b : blacklist ) map . put ( b , - 1 ); for ( int b : blacklist ) if ( b < validRange ) { while ( map . containsKey ( N - 1 )) -- N ; map . put ( b , -- N ); } } public int pick () { int value = rand . nextInt ( validRange ); return map . getOrDefault ( value , value ); } private int validRange ; private Map < Integer , Integer > map = new HashMap <> (); private Random rand = new Random (); }","title":"710. Random Pick with Blacklist $\\star\\star\\star$"},{"location":"java/0701-0800/0711-0720/","text":"711. Number of Distinct Islands II $\\star\\star\\star$ \ud83d\udd12 712. Minimum ASCII Delete Sum for Two Strings $\\star\\star$ 713. Subarray Product Less Than K $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution { public int numSubarrayProductLessThanK ( int [] nums , int k ) { if ( k <= 1 ) return 0 ; int ans = 0 ; int prod = 1 ; for ( int i = 0 , j = 0 ; i < nums . length ; ++ i ) { prod *= nums [ i ] ; while ( prod >= k ) prod /= nums [ j ++] ; ans += i - j + 1 ; } return ans ; } } 714. Best Time to Buy and Sell Stock with Transaction Fee $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public int maxProfit ( int [] prices , int fee ) { int sell = 0 ; int hold = Integer . MIN_VALUE ; for ( int price : prices ) { sell = Math . max ( sell , hold + price ); hold = Math . max ( hold , sell - price - fee ); } return sell ; } } 715. Range Module $\\star\\star\\star$ 716. Max Stack $\\star$ \ud83d\udd12 717. 1-bit and 2-bit Characters $\\star$ class Solution { public boolean isOneBitCharacter ( int [] bits ) { int i = 0 ; while ( i < bits . length - 1 ) i += bits [ i ] + 1 ; return i == bits . length - 1 ; } } 718. Maximum Length of Repeated Subarray $\\star\\star$ class Solution { public int findLength ( int [] A , int [] B ) { int ans = 0 ; int [] dp = new int [ B . length + 1 ] ; for ( int i = A . length - 1 ; i >= 0 ; -- i ) for ( int j = 0 ; j < B . length ; ++ j ) { dp [ j ] = A [ i ] == B [ j ] ? dp [ j + 1 ] + 1 : 0 ; ans = Math . max ( ans , dp [ j ] ); } return ans ; } } 719. Find K-th Smallest Pair Distance $\\star\\star\\star$ class Solution { public int smallestDistancePair ( int [] nums , int k ) { Arrays . sort ( nums ); int l = 0 ; int r = nums [ nums . length - 1 ] - nums [ 0 ] ; while ( l < r ) { int m = l + ( r - l ) / 2 ; int count = 0 ; for ( int i = 0 , j = 0 ; i < nums . length ; ++ i ) { while ( j < nums . length && nums [ j ] <= nums [ i ] + m ) ++ j ; count += j - i - 1 ; } if ( count < k ) l = m + 1 ; else r = m ; } return l ; } } 720. Longest Word in Dictionary $\\star$ class Solution { public String longestWord ( String [] words ) { for ( final String word : words ) insert ( word ); return dfs ( root ); } private class TrieNode { private TrieNode [] children = new TrieNode [ 26 ] ; private String word ; } private TrieNode root = new TrieNode (); private void insert ( final String word ) { TrieNode node = root ; for ( char c : word . toCharArray ()) { int index = c - 'a' ; if ( node . children [ index ] == null ) node . children [ index ] = new TrieNode (); node = node . children [ index ] ; } node . word = word ; } private String dfs ( TrieNode node ) { String ans = node . word == null ? \"\" : node . word ; for ( TrieNode child : node . children ) if ( child != null && child . word != null && child . word . length () > 0 ) { String childWord = dfs ( child ); if ( childWord . length () > ans . length ()) ans = childWord ; } return ans ; } }","title":"0711-0720"},{"location":"java/0701-0800/0711-0720/#711-number-of-distinct-islands-ii-starstarstar","text":"","title":"711. Number of Distinct Islands II $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/0701-0800/0711-0720/#712-minimum-ascii-delete-sum-for-two-strings-starstar","text":"","title":"712. Minimum ASCII Delete Sum for Two Strings $\\star\\star$"},{"location":"java/0701-0800/0711-0720/#713-subarray-product-less-than-k-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution { public int numSubarrayProductLessThanK ( int [] nums , int k ) { if ( k <= 1 ) return 0 ; int ans = 0 ; int prod = 1 ; for ( int i = 0 , j = 0 ; i < nums . length ; ++ i ) { prod *= nums [ i ] ; while ( prod >= k ) prod /= nums [ j ++] ; ans += i - j + 1 ; } return ans ; } }","title":"713. Subarray Product Less Than K $\\star\\star$"},{"location":"java/0701-0800/0711-0720/#714-best-time-to-buy-and-sell-stock-with-transaction-fee-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public int maxProfit ( int [] prices , int fee ) { int sell = 0 ; int hold = Integer . MIN_VALUE ; for ( int price : prices ) { sell = Math . max ( sell , hold + price ); hold = Math . max ( hold , sell - price - fee ); } return sell ; } }","title":"714. Best Time to Buy and Sell Stock with Transaction Fee $\\star\\star$"},{"location":"java/0701-0800/0711-0720/#715-range-module-starstarstar","text":"","title":"715. Range Module $\\star\\star\\star$"},{"location":"java/0701-0800/0711-0720/#716-max-stack-star","text":"","title":"716. Max Stack $\\star$ \ud83d\udd12"},{"location":"java/0701-0800/0711-0720/#717-1-bit-and-2-bit-characters-star","text":"class Solution { public boolean isOneBitCharacter ( int [] bits ) { int i = 0 ; while ( i < bits . length - 1 ) i += bits [ i ] + 1 ; return i == bits . length - 1 ; } }","title":"717. 1-bit and 2-bit Characters $\\star$"},{"location":"java/0701-0800/0711-0720/#718-maximum-length-of-repeated-subarray-starstar","text":"class Solution { public int findLength ( int [] A , int [] B ) { int ans = 0 ; int [] dp = new int [ B . length + 1 ] ; for ( int i = A . length - 1 ; i >= 0 ; -- i ) for ( int j = 0 ; j < B . length ; ++ j ) { dp [ j ] = A [ i ] == B [ j ] ? dp [ j + 1 ] + 1 : 0 ; ans = Math . max ( ans , dp [ j ] ); } return ans ; } }","title":"718. Maximum Length of Repeated Subarray $\\star\\star$"},{"location":"java/0701-0800/0711-0720/#719-find-k-th-smallest-pair-distance-starstarstar","text":"class Solution { public int smallestDistancePair ( int [] nums , int k ) { Arrays . sort ( nums ); int l = 0 ; int r = nums [ nums . length - 1 ] - nums [ 0 ] ; while ( l < r ) { int m = l + ( r - l ) / 2 ; int count = 0 ; for ( int i = 0 , j = 0 ; i < nums . length ; ++ i ) { while ( j < nums . length && nums [ j ] <= nums [ i ] + m ) ++ j ; count += j - i - 1 ; } if ( count < k ) l = m + 1 ; else r = m ; } return l ; } }","title":"719. Find K-th Smallest Pair Distance $\\star\\star\\star$"},{"location":"java/0701-0800/0711-0720/#720-longest-word-in-dictionary-star","text":"class Solution { public String longestWord ( String [] words ) { for ( final String word : words ) insert ( word ); return dfs ( root ); } private class TrieNode { private TrieNode [] children = new TrieNode [ 26 ] ; private String word ; } private TrieNode root = new TrieNode (); private void insert ( final String word ) { TrieNode node = root ; for ( char c : word . toCharArray ()) { int index = c - 'a' ; if ( node . children [ index ] == null ) node . children [ index ] = new TrieNode (); node = node . children [ index ] ; } node . word = word ; } private String dfs ( TrieNode node ) { String ans = node . word == null ? \"\" : node . word ; for ( TrieNode child : node . children ) if ( child != null && child . word != null && child . word . length () > 0 ) { String childWord = dfs ( child ); if ( childWord . length () > ans . length ()) ans = childWord ; } return ans ; } }","title":"720. Longest Word in Dictionary $\\star$"},{"location":"java/0701-0800/0721-0730/","text":"721. Accounts Merge $\\star\\star$ 722. Remove Comments $\\star\\star$ class Solution { public List < String > removeComments ( String [] source ) { List < String > ans = new ArrayList <> (); boolean commenting = false ; String modified = \"\" ; for ( final String line : source ) { for ( int i = 0 ; i < line . length ();) { if ( i + 1 == line . length ()) { if ( ! commenting ) modified += line . charAt ( i ); ++ i ; break ; } String twoChars = line . substring ( i , i + 2 ); if ( twoChars . equals ( \"/*\" ) && ! commenting ) { commenting = true ; i += 2 ; } else if ( twoChars . equals ( \"*/\" ) && commenting ) { commenting = false ; i += 2 ; } else if ( twoChars . equals ( \"//\" )) { if ( ! commenting ) break ; else i += 2 ; } else { if ( ! commenting ) modified += line . charAt ( i ); ++ i ; } } if ( modified . length () > 0 && ! commenting ) { ans . add ( modified ); modified = \"\" ; } } return ans ; } } 723. Candy Crush $\\star\\star$ \ud83d\udd12 724. Find Pivot Index $\\star$ class Solution { public int pivotIndex ( int [] nums ) { int sum = 0 ; int prefixSum = 0 ; for ( int num : nums ) sum += num ; for ( int i = 0 ; i < nums . length ; ++ i ) { if ( prefixSum == sum - prefixSum - nums [ i ] ) return i ; prefixSum += nums [ i ] ; } return - 1 ; } } 725. Split Linked List in Parts $\\star\\star$ class Solution { public ListNode [] splitListToParts ( ListNode root , int k ) { ListNode [] ans = new ListNode [ k ] ; int length = 0 ; for ( ListNode curr = root ; curr != null ; curr = curr . next ) ++ length ; int subLength = length / k ; int remainder = length % k ; ListNode prev = null ; ListNode head = root ; for ( int i = 0 ; i < k ; ++ i , -- remainder ) { ans [ i ] = head ; for ( int j = 0 ; j < subLength + ( remainder > 0 ? 1 : 0 ); ++ j ) { prev = head ; head = head . next ; } if ( prev != null ) prev . next = null ; } return ans ; } } 726. Number of Atoms $\\star\\star\\star$ class Solution { public String countOfAtoms ( String formula ) { String ans = \"\" ; i = 0 ; Map < String , Integer > count = parse ( formula ); for ( String elem : count . keySet ()) ans += elem + ( count . get ( elem ) == 1 ? \"\" : String . valueOf ( count . get ( elem ))); return ans ; } private int i ; private Map < String , Integer > parse ( String formula ) { final int n = formula . length (); Map < String , Integer > count = new TreeMap <> (); while ( i < n ) { if ( formula . charAt ( i ) == '(' ) { ++ i ; for ( Map . Entry < String , Integer > entry : parse ( formula ). entrySet ()) { String elem = entry . getKey (); Integer freq = entry . getValue (); count . put ( elem , count . getOrDefault ( elem , 0 ) + freq ); } } else if ( formula . charAt ( i ) == ')' ) { int numStart = ++ i ; while ( i < n && Character . isDigit ( formula . charAt ( i ))) ++ i ; int factor = Integer . valueOf ( formula . substring ( numStart , i )); for ( String elem : count . keySet ()) count . put ( elem , count . get ( elem ) * factor ); return count ; } else if ( Character . isUpperCase ( formula . charAt ( i ))) { int elemStart = i ++ ; while ( i < n && Character . isLowerCase ( formula . charAt ( i ))) ++ i ; String elem = formula . substring ( elemStart , i ); int numStart = i ; while ( i < n && Character . isDigit ( formula . charAt ( i ))) ++ i ; String numString = formula . substring ( numStart , i ); Integer num = numString . isEmpty () ? 1 : Integer . valueOf ( numString ); count . put ( elem , count . getOrDefault ( elem , 0 ) + num ); } } return count ; } } 727. Minimum Window Subsequence $\\star\\star\\star$ \ud83d\udd12 728. Self Dividing Numbers $\\star$ class Solution { public List < Integer > selfDividingNumbers ( int left , int right ) { List < Integer > ans = new ArrayList <> (); for ( int num = left ; num <= right ; ++ num ) if ( dividingNumber ( num )) ans . add ( num ); return ans ; } private boolean dividingNumber ( int num ) { for ( int n = num ; n > 0 ; n /= 10 ) if ( n % 10 == 0 || num % ( n % 10 ) != 0 ) return false ; return true ; } } 729. My Calendar I $\\star\\star$ class MyCalendar { public boolean book ( int start , int end ) { for ( int [] book : books ) if ( Math . max ( book [ 0 ] , start ) < Math . min ( book [ 1 ] , end )) return false ; books . add ( new int [] { start , end }); return true ; } private List < int []> books = new ArrayList <> (); } 730. Count Different Palindromic Subsequences $\\star\\star\\star$ class Solution { public int countPalindromicSubsequences ( String S ) { final int n = S . length (); final long kMod = ( long ) 1e9 + 7 ; long [][] dp = new long [ n ][ n ] ; for ( int i = 0 ; i < n ; ++ i ) dp [ i ][ i ] = 1 ; for ( int length = 2 ; length <= n ; ++ length ) for ( int i = 0 ; i <= n - length ; ++ i ) { final int j = i + length - 1 ; if ( S . charAt ( i ) == S . charAt ( j )) { int lo = i + 1 ; int hi = j - 1 ; while ( lo <= hi && S . charAt ( lo ) != S . charAt ( i )) ++ lo ; while ( lo <= hi && S . charAt ( hi ) != S . charAt ( i )) -- hi ; if ( lo > hi ) dp [ i ][ j ] = dp [ i + 1 ][ j - 1 ] * 2 + 2 ; else if ( lo == hi ) dp [ i ][ j ] = dp [ i + 1 ][ j - 1 ] * 2 + 1 ; else dp [ i ][ j ] = dp [ i + 1 ][ j - 1 ] * 2 - dp [ lo + 1 ][ hi - 1 ] ; } else dp [ i ][ j ] = dp [ i ][ j - 1 ] + dp [ i + 1 ][ j ] - dp [ i + 1 ][ j - 1 ] ; dp [ i ][ j ] = ( dp [ i ][ j ] + kMod ) % kMod ; } return ( int ) dp [ 0 ][ n - 1 ] ; } }","title":"0721-0730"},{"location":"java/0701-0800/0721-0730/#721-accounts-merge-starstar","text":"","title":"721. Accounts Merge $\\star\\star$"},{"location":"java/0701-0800/0721-0730/#722-remove-comments-starstar","text":"class Solution { public List < String > removeComments ( String [] source ) { List < String > ans = new ArrayList <> (); boolean commenting = false ; String modified = \"\" ; for ( final String line : source ) { for ( int i = 0 ; i < line . length ();) { if ( i + 1 == line . length ()) { if ( ! commenting ) modified += line . charAt ( i ); ++ i ; break ; } String twoChars = line . substring ( i , i + 2 ); if ( twoChars . equals ( \"/*\" ) && ! commenting ) { commenting = true ; i += 2 ; } else if ( twoChars . equals ( \"*/\" ) && commenting ) { commenting = false ; i += 2 ; } else if ( twoChars . equals ( \"//\" )) { if ( ! commenting ) break ; else i += 2 ; } else { if ( ! commenting ) modified += line . charAt ( i ); ++ i ; } } if ( modified . length () > 0 && ! commenting ) { ans . add ( modified ); modified = \"\" ; } } return ans ; } }","title":"722. Remove Comments $\\star\\star$"},{"location":"java/0701-0800/0721-0730/#723-candy-crush-starstar","text":"","title":"723. Candy Crush $\\star\\star$ \ud83d\udd12"},{"location":"java/0701-0800/0721-0730/#724-find-pivot-index-star","text":"class Solution { public int pivotIndex ( int [] nums ) { int sum = 0 ; int prefixSum = 0 ; for ( int num : nums ) sum += num ; for ( int i = 0 ; i < nums . length ; ++ i ) { if ( prefixSum == sum - prefixSum - nums [ i ] ) return i ; prefixSum += nums [ i ] ; } return - 1 ; } }","title":"724. Find Pivot Index $\\star$"},{"location":"java/0701-0800/0721-0730/#725-split-linked-list-in-parts-starstar","text":"class Solution { public ListNode [] splitListToParts ( ListNode root , int k ) { ListNode [] ans = new ListNode [ k ] ; int length = 0 ; for ( ListNode curr = root ; curr != null ; curr = curr . next ) ++ length ; int subLength = length / k ; int remainder = length % k ; ListNode prev = null ; ListNode head = root ; for ( int i = 0 ; i < k ; ++ i , -- remainder ) { ans [ i ] = head ; for ( int j = 0 ; j < subLength + ( remainder > 0 ? 1 : 0 ); ++ j ) { prev = head ; head = head . next ; } if ( prev != null ) prev . next = null ; } return ans ; } }","title":"725. Split Linked List in Parts $\\star\\star$"},{"location":"java/0701-0800/0721-0730/#726-number-of-atoms-starstarstar","text":"class Solution { public String countOfAtoms ( String formula ) { String ans = \"\" ; i = 0 ; Map < String , Integer > count = parse ( formula ); for ( String elem : count . keySet ()) ans += elem + ( count . get ( elem ) == 1 ? \"\" : String . valueOf ( count . get ( elem ))); return ans ; } private int i ; private Map < String , Integer > parse ( String formula ) { final int n = formula . length (); Map < String , Integer > count = new TreeMap <> (); while ( i < n ) { if ( formula . charAt ( i ) == '(' ) { ++ i ; for ( Map . Entry < String , Integer > entry : parse ( formula ). entrySet ()) { String elem = entry . getKey (); Integer freq = entry . getValue (); count . put ( elem , count . getOrDefault ( elem , 0 ) + freq ); } } else if ( formula . charAt ( i ) == ')' ) { int numStart = ++ i ; while ( i < n && Character . isDigit ( formula . charAt ( i ))) ++ i ; int factor = Integer . valueOf ( formula . substring ( numStart , i )); for ( String elem : count . keySet ()) count . put ( elem , count . get ( elem ) * factor ); return count ; } else if ( Character . isUpperCase ( formula . charAt ( i ))) { int elemStart = i ++ ; while ( i < n && Character . isLowerCase ( formula . charAt ( i ))) ++ i ; String elem = formula . substring ( elemStart , i ); int numStart = i ; while ( i < n && Character . isDigit ( formula . charAt ( i ))) ++ i ; String numString = formula . substring ( numStart , i ); Integer num = numString . isEmpty () ? 1 : Integer . valueOf ( numString ); count . put ( elem , count . getOrDefault ( elem , 0 ) + num ); } } return count ; } }","title":"726. Number of Atoms $\\star\\star\\star$"},{"location":"java/0701-0800/0721-0730/#727-minimum-window-subsequence-starstarstar","text":"","title":"727. Minimum Window Subsequence $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/0701-0800/0721-0730/#728-self-dividing-numbers-star","text":"class Solution { public List < Integer > selfDividingNumbers ( int left , int right ) { List < Integer > ans = new ArrayList <> (); for ( int num = left ; num <= right ; ++ num ) if ( dividingNumber ( num )) ans . add ( num ); return ans ; } private boolean dividingNumber ( int num ) { for ( int n = num ; n > 0 ; n /= 10 ) if ( n % 10 == 0 || num % ( n % 10 ) != 0 ) return false ; return true ; } }","title":"728. Self Dividing Numbers $\\star$"},{"location":"java/0701-0800/0721-0730/#729-my-calendar-i-starstar","text":"class MyCalendar { public boolean book ( int start , int end ) { for ( int [] book : books ) if ( Math . max ( book [ 0 ] , start ) < Math . min ( book [ 1 ] , end )) return false ; books . add ( new int [] { start , end }); return true ; } private List < int []> books = new ArrayList <> (); }","title":"729. My Calendar I $\\star\\star$"},{"location":"java/0701-0800/0721-0730/#730-count-different-palindromic-subsequences-starstarstar","text":"class Solution { public int countPalindromicSubsequences ( String S ) { final int n = S . length (); final long kMod = ( long ) 1e9 + 7 ; long [][] dp = new long [ n ][ n ] ; for ( int i = 0 ; i < n ; ++ i ) dp [ i ][ i ] = 1 ; for ( int length = 2 ; length <= n ; ++ length ) for ( int i = 0 ; i <= n - length ; ++ i ) { final int j = i + length - 1 ; if ( S . charAt ( i ) == S . charAt ( j )) { int lo = i + 1 ; int hi = j - 1 ; while ( lo <= hi && S . charAt ( lo ) != S . charAt ( i )) ++ lo ; while ( lo <= hi && S . charAt ( hi ) != S . charAt ( i )) -- hi ; if ( lo > hi ) dp [ i ][ j ] = dp [ i + 1 ][ j - 1 ] * 2 + 2 ; else if ( lo == hi ) dp [ i ][ j ] = dp [ i + 1 ][ j - 1 ] * 2 + 1 ; else dp [ i ][ j ] = dp [ i + 1 ][ j - 1 ] * 2 - dp [ lo + 1 ][ hi - 1 ] ; } else dp [ i ][ j ] = dp [ i ][ j - 1 ] + dp [ i + 1 ][ j ] - dp [ i + 1 ][ j - 1 ] ; dp [ i ][ j ] = ( dp [ i ][ j ] + kMod ) % kMod ; } return ( int ) dp [ 0 ][ n - 1 ] ; } }","title":"730. Count Different Palindromic Subsequences $\\star\\star\\star$"},{"location":"java/0701-0800/0731-0740/","text":"731. My Calendar II $\\star\\star$ 732. My Calendar III $\\star\\star\\star$ 733. Flood Fill $\\star$ class Solution { public int [][] floodFill ( int [][] image , int sr , int sc , int newColor ) { boolean [][] seen = new boolean [ image . length ][ image [ 0 ] . length ] ; dfs ( image , sr , sc , seen , image [ sr ][ sc ] , newColor ); return image ; } private void dfs ( int [][] image , int i , int j , boolean [][] seen , int startColor , int newColor ) { if ( i < 0 || i >= image . length || j < 0 || j >= image [ 0 ] . length ) return ; if ( image [ i ][ j ] != startColor || seen [ i ][ j ] ) return ; image [ i ][ j ] = newColor ; seen [ i ][ j ] = true ; dfs ( image , i + 1 , j , seen , startColor , newColor ); dfs ( image , i - 1 , j , seen , startColor , newColor ); dfs ( image , i , j + 1 , seen , startColor , newColor ); dfs ( image , i , j - 1 , seen , startColor , newColor ); } } 734. Sentence Similarity $\\star$ \ud83d\udd12 735. Asteroid Collision $\\star\\star$ 736. Parse Lisp Expression $\\star\\star\\star$ class Solution { public int evaluate ( String expression ) { return evaluate ( expression , new HashMap <> ()); } private int evaluate ( final String e , Map < String , Integer > prevScope ) { if ( Character . isDigit ( e . charAt ( 0 )) || e . charAt ( 0 ) == '-' ) return Integer . parseInt ( e ); if ( prevScope . containsKey ( e )) return prevScope . get ( e ); Map < String , Integer > scope = new HashMap <> (); scope . putAll ( prevScope ); String nextExpression = e . substring ( e . indexOf ( ' ' ) + 1 , e . length () - 1 ); List < String > tokens = parse ( nextExpression ); if ( e . startsWith ( \"(a\" )) return evaluate ( tokens . get ( 0 ), scope ) + evaluate ( tokens . get ( 1 ), scope ); if ( e . startsWith ( \"(m\" )) return evaluate ( tokens . get ( 0 ), scope ) * evaluate ( tokens . get ( 1 ), scope ); for ( int i = 0 ; i < tokens . size () - 2 ; i += 2 ) // let scope . put ( tokens . get ( i ), evaluate ( tokens . get ( i + 1 ), scope )); return evaluate ( tokens . get ( tokens . size () - 1 ), scope ); } private List < String > parse ( final String s ) { List < String > tokens = new ArrayList <> (); StringBuilder sb = new StringBuilder (); int parenthesis = 0 ; for ( char c : s . toCharArray ()) { if ( c == '(' ) ++ parenthesis ; else if ( c == ')' ) -- parenthesis ; if ( parenthesis == 0 && c == ' ' ) { tokens . add ( new String ( sb )); sb = new StringBuilder (); } else sb . append ( c ); } if ( sb . length () > 0 ) tokens . add ( new String ( sb )); return tokens ; } } 737. Sentence Similarity II $\\star\\star$ \ud83d\udd12 738. Monotone Increasing Digits $\\star\\star$ 739. Daily Temperatures $\\star\\star$ class Solution { public int [] dailyTemperatures ( int [] T ) { int [] ans = new int [ T . length ] ; Stack < Integer > stack = new Stack <> (); for ( int i = 0 ; i < T . length ; ++ i ) { while ( ! stack . isEmpty () && T [ i ] > T [ stack . peek () ] ) { int index = stack . pop (); ans [ index ] = i - index ; } stack . push ( i ); } return ans ; } } 740. Delete and Earn $\\star\\star$","title":"0731-0740"},{"location":"java/0701-0800/0731-0740/#731-my-calendar-ii-starstar","text":"","title":"731. My Calendar II $\\star\\star$"},{"location":"java/0701-0800/0731-0740/#732-my-calendar-iii-starstarstar","text":"","title":"732. My Calendar III $\\star\\star\\star$"},{"location":"java/0701-0800/0731-0740/#733-flood-fill-star","text":"class Solution { public int [][] floodFill ( int [][] image , int sr , int sc , int newColor ) { boolean [][] seen = new boolean [ image . length ][ image [ 0 ] . length ] ; dfs ( image , sr , sc , seen , image [ sr ][ sc ] , newColor ); return image ; } private void dfs ( int [][] image , int i , int j , boolean [][] seen , int startColor , int newColor ) { if ( i < 0 || i >= image . length || j < 0 || j >= image [ 0 ] . length ) return ; if ( image [ i ][ j ] != startColor || seen [ i ][ j ] ) return ; image [ i ][ j ] = newColor ; seen [ i ][ j ] = true ; dfs ( image , i + 1 , j , seen , startColor , newColor ); dfs ( image , i - 1 , j , seen , startColor , newColor ); dfs ( image , i , j + 1 , seen , startColor , newColor ); dfs ( image , i , j - 1 , seen , startColor , newColor ); } }","title":"733. Flood Fill $\\star$"},{"location":"java/0701-0800/0731-0740/#734-sentence-similarity-star","text":"","title":"734. Sentence Similarity $\\star$ \ud83d\udd12"},{"location":"java/0701-0800/0731-0740/#735-asteroid-collision-starstar","text":"","title":"735. Asteroid Collision $\\star\\star$"},{"location":"java/0701-0800/0731-0740/#736-parse-lisp-expression-starstarstar","text":"class Solution { public int evaluate ( String expression ) { return evaluate ( expression , new HashMap <> ()); } private int evaluate ( final String e , Map < String , Integer > prevScope ) { if ( Character . isDigit ( e . charAt ( 0 )) || e . charAt ( 0 ) == '-' ) return Integer . parseInt ( e ); if ( prevScope . containsKey ( e )) return prevScope . get ( e ); Map < String , Integer > scope = new HashMap <> (); scope . putAll ( prevScope ); String nextExpression = e . substring ( e . indexOf ( ' ' ) + 1 , e . length () - 1 ); List < String > tokens = parse ( nextExpression ); if ( e . startsWith ( \"(a\" )) return evaluate ( tokens . get ( 0 ), scope ) + evaluate ( tokens . get ( 1 ), scope ); if ( e . startsWith ( \"(m\" )) return evaluate ( tokens . get ( 0 ), scope ) * evaluate ( tokens . get ( 1 ), scope ); for ( int i = 0 ; i < tokens . size () - 2 ; i += 2 ) // let scope . put ( tokens . get ( i ), evaluate ( tokens . get ( i + 1 ), scope )); return evaluate ( tokens . get ( tokens . size () - 1 ), scope ); } private List < String > parse ( final String s ) { List < String > tokens = new ArrayList <> (); StringBuilder sb = new StringBuilder (); int parenthesis = 0 ; for ( char c : s . toCharArray ()) { if ( c == '(' ) ++ parenthesis ; else if ( c == ')' ) -- parenthesis ; if ( parenthesis == 0 && c == ' ' ) { tokens . add ( new String ( sb )); sb = new StringBuilder (); } else sb . append ( c ); } if ( sb . length () > 0 ) tokens . add ( new String ( sb )); return tokens ; } }","title":"736. Parse Lisp Expression $\\star\\star\\star$"},{"location":"java/0701-0800/0731-0740/#737-sentence-similarity-ii-starstar","text":"","title":"737. Sentence Similarity II $\\star\\star$ \ud83d\udd12"},{"location":"java/0701-0800/0731-0740/#738-monotone-increasing-digits-starstar","text":"","title":"738. Monotone Increasing Digits $\\star\\star$"},{"location":"java/0701-0800/0731-0740/#739-daily-temperatures-starstar","text":"class Solution { public int [] dailyTemperatures ( int [] T ) { int [] ans = new int [ T . length ] ; Stack < Integer > stack = new Stack <> (); for ( int i = 0 ; i < T . length ; ++ i ) { while ( ! stack . isEmpty () && T [ i ] > T [ stack . peek () ] ) { int index = stack . pop (); ans [ index ] = i - index ; } stack . push ( i ); } return ans ; } }","title":"739. Daily Temperatures $\\star\\star$"},{"location":"java/0701-0800/0731-0740/#740-delete-and-earn-starstar","text":"","title":"740. Delete and Earn $\\star\\star$"},{"location":"java/0701-0800/0741-0750/","text":"741. Cherry Pickup $\\star\\star\\star$ 742. Closest Leaf in a Binary Tree $\\star\\star$ \ud83d\udd12 743. Network Delay Time $\\star\\star$ 744. Find Smallest Letter Greater Than Target $\\star$ 745. Prefix and Suffix Search $\\star\\star\\star$ 746. Min Cost Climbing Stairs $\\star$ class Solution { public int minCostClimbingStairs ( int [] cost ) { final int n = cost . length ; for ( int i = 2 ; i < n ; ++ i ) cost [ i ] += Math . min ( cost [ i - 1 ] , cost [ i - 2 ] ); return Math . min ( cost [ n - 1 ] , cost [ n - 2 ] ); } } 747. Largest Number At Least Twice of Others $\\star$ class Solution { public int dominantIndex ( int [] nums ) { int ans = 0 ; int max = 0 ; int secondMax = 0 ; for ( int i = 0 ; i < nums . length ; ++ i ) { if ( nums [ i ] > max ) { secondMax = max ; max = nums [ i ] ; ans = i ; } else if ( nums [ i ] > secondMax ) secondMax = nums [ i ] ; } return max >= 2 * secondMax ? ans : - 1 ; } } 748. Shortest Completing Word $\\star$ class Solution { public String shortestCompletingWord ( String licensePlate , String [] words ) { String ans = \"****************\" ; int [] count = new int [ 26 ] ; for ( char c : licensePlate . toCharArray ()) if ( Character . isLetter ( c )) ++ count [ Character . toLowerCase ( c ) - 'a' ] ; for ( final String word : words ) if ( word . length () < ans . length () && isMatch ( word , count )) ans = word ; return ans ; } private boolean isMatch ( final String word , int [] count ) { int [] wordCount = new int [ 26 ] ; for ( char c : word . toCharArray ()) ++ wordCount [ c - 'a' ] ; for ( int i = 0 ; i < 26 ; ++ i ) if ( wordCount [ i ] < count [ i ] ) return false ; return true ; } } 749. Contain Virus $\\star\\star\\star$ 750. Number Of Corner Rectangles $\\star\\star$ \ud83d\udd12","title":"0741-0750"},{"location":"java/0701-0800/0741-0750/#741-cherry-pickup-starstarstar","text":"","title":"741. Cherry Pickup $\\star\\star\\star$"},{"location":"java/0701-0800/0741-0750/#742-closest-leaf-in-a-binary-tree-starstar","text":"","title":"742. Closest Leaf in a Binary Tree $\\star\\star$ \ud83d\udd12"},{"location":"java/0701-0800/0741-0750/#743-network-delay-time-starstar","text":"","title":"743. Network Delay Time $\\star\\star$"},{"location":"java/0701-0800/0741-0750/#744-find-smallest-letter-greater-than-target-star","text":"","title":"744. Find Smallest Letter Greater Than Target $\\star$"},{"location":"java/0701-0800/0741-0750/#745-prefix-and-suffix-search-starstarstar","text":"","title":"745. Prefix and Suffix Search $\\star\\star\\star$"},{"location":"java/0701-0800/0741-0750/#746-min-cost-climbing-stairs-star","text":"class Solution { public int minCostClimbingStairs ( int [] cost ) { final int n = cost . length ; for ( int i = 2 ; i < n ; ++ i ) cost [ i ] += Math . min ( cost [ i - 1 ] , cost [ i - 2 ] ); return Math . min ( cost [ n - 1 ] , cost [ n - 2 ] ); } }","title":"746. Min Cost Climbing Stairs $\\star$"},{"location":"java/0701-0800/0741-0750/#747-largest-number-at-least-twice-of-others-star","text":"class Solution { public int dominantIndex ( int [] nums ) { int ans = 0 ; int max = 0 ; int secondMax = 0 ; for ( int i = 0 ; i < nums . length ; ++ i ) { if ( nums [ i ] > max ) { secondMax = max ; max = nums [ i ] ; ans = i ; } else if ( nums [ i ] > secondMax ) secondMax = nums [ i ] ; } return max >= 2 * secondMax ? ans : - 1 ; } }","title":"747. Largest Number At Least Twice of Others $\\star$"},{"location":"java/0701-0800/0741-0750/#748-shortest-completing-word-star","text":"class Solution { public String shortestCompletingWord ( String licensePlate , String [] words ) { String ans = \"****************\" ; int [] count = new int [ 26 ] ; for ( char c : licensePlate . toCharArray ()) if ( Character . isLetter ( c )) ++ count [ Character . toLowerCase ( c ) - 'a' ] ; for ( final String word : words ) if ( word . length () < ans . length () && isMatch ( word , count )) ans = word ; return ans ; } private boolean isMatch ( final String word , int [] count ) { int [] wordCount = new int [ 26 ] ; for ( char c : word . toCharArray ()) ++ wordCount [ c - 'a' ] ; for ( int i = 0 ; i < 26 ; ++ i ) if ( wordCount [ i ] < count [ i ] ) return false ; return true ; } }","title":"748. Shortest Completing Word $\\star$"},{"location":"java/0701-0800/0741-0750/#749-contain-virus-starstarstar","text":"","title":"749. Contain Virus $\\star\\star\\star$"},{"location":"java/0701-0800/0741-0750/#750-number-of-corner-rectangles-starstar","text":"","title":"750. Number Of Corner Rectangles $\\star\\star$ \ud83d\udd12"},{"location":"java/0701-0800/0751-0760/","text":"751. IP to CIDR $\\star$ \ud83d\udd12 752. Open the Lock $\\star\\star$ 753. Cracking the Safe $\\star\\star\\star$ class Solution { public String crackSafe ( int n , int k ) { passwordSize = ( int ) Math . pow ( k , n ); String path = new String ( new char [ n ] ). replace ( '\\0' , '0' ); Set < String > seen = new HashSet <> ( Arrays . asList ( path )); dfs ( n , k , seen , path ); return ans ; } private String ans ; private Integer passwordSize ; private boolean dfs ( int n , int k , Set < String > seen , String path ) { if ( seen . size () == passwordSize ) { ans = path ; return true ; } String prefix = path . substring ( path . length () - n + 1 ); for ( char c = '0' ; c < '0' + k ; ++ c ) { String next = prefix + c ; if ( ! seen . contains ( next )) { seen . add ( next ); if ( dfs ( n , k , seen , path + c )) return true ; seen . remove ( next ); } } return false ; } } 754. Reach a Number $\\star\\star$ class Solution { public int reachNumber ( int target ) { int ans = 0 ; int pos = 0 ; target = Math . abs ( target ); while ( pos < target ) pos += ++ ans ; while (( pos - target ) % 2 == 1 ) pos += ++ ans ; return ans ; } } 755. Pour Water $\\star\\star$ \ud83d\udd12 756. Pyramid Transition Matrix $\\star\\star$ class Solution { public boolean pyramidTransition ( String bottom , List < String > allowed ) { Map < String , List < Character >> prefixToBlocks = new HashMap <> (); for ( final String a : allowed ) prefixToBlocks . computeIfAbsent ( a . substring ( 0 , 2 ), k -> new LinkedList <> ()). add ( a . charAt ( 2 )); return dfs ( bottom , \"\" , prefixToBlocks , 0 ); } private boolean dfs ( final String row , final String nextRow , Map < String , List < Character >> prefixToBlocks , int i ) { if ( row . length () == 1 ) return true ; if ( nextRow . length () + 1 == row . length ()) return dfs ( nextRow , \"\" , prefixToBlocks , 0 ); for ( char c : prefixToBlocks . getOrDefault ( row . substring ( i , i + 2 ), new LinkedList <> ())) if ( dfs ( row , nextRow + c , prefixToBlocks , i + 1 )) return true ; return false ; } } 757. Set Intersection Size At Least Two $\\star\\star\\star$ 758. Bold Words in String $\\star$ \ud83d\udd12 759. Employee Free Time $\\star\\star\\star$ \ud83d\udd12 760. Find Anagram Mappings $\\star$ \ud83d\udd12","title":"0751-0760"},{"location":"java/0701-0800/0751-0760/#751-ip-to-cidr-star","text":"","title":"751. IP to CIDR $\\star$ \ud83d\udd12"},{"location":"java/0701-0800/0751-0760/#752-open-the-lock-starstar","text":"","title":"752. Open the Lock $\\star\\star$"},{"location":"java/0701-0800/0751-0760/#753-cracking-the-safe-starstarstar","text":"class Solution { public String crackSafe ( int n , int k ) { passwordSize = ( int ) Math . pow ( k , n ); String path = new String ( new char [ n ] ). replace ( '\\0' , '0' ); Set < String > seen = new HashSet <> ( Arrays . asList ( path )); dfs ( n , k , seen , path ); return ans ; } private String ans ; private Integer passwordSize ; private boolean dfs ( int n , int k , Set < String > seen , String path ) { if ( seen . size () == passwordSize ) { ans = path ; return true ; } String prefix = path . substring ( path . length () - n + 1 ); for ( char c = '0' ; c < '0' + k ; ++ c ) { String next = prefix + c ; if ( ! seen . contains ( next )) { seen . add ( next ); if ( dfs ( n , k , seen , path + c )) return true ; seen . remove ( next ); } } return false ; } }","title":"753. Cracking the Safe $\\star\\star\\star$"},{"location":"java/0701-0800/0751-0760/#754-reach-a-number-starstar","text":"class Solution { public int reachNumber ( int target ) { int ans = 0 ; int pos = 0 ; target = Math . abs ( target ); while ( pos < target ) pos += ++ ans ; while (( pos - target ) % 2 == 1 ) pos += ++ ans ; return ans ; } }","title":"754. Reach a Number $\\star\\star$"},{"location":"java/0701-0800/0751-0760/#755-pour-water-starstar","text":"","title":"755. Pour Water $\\star\\star$ \ud83d\udd12"},{"location":"java/0701-0800/0751-0760/#756-pyramid-transition-matrix-starstar","text":"class Solution { public boolean pyramidTransition ( String bottom , List < String > allowed ) { Map < String , List < Character >> prefixToBlocks = new HashMap <> (); for ( final String a : allowed ) prefixToBlocks . computeIfAbsent ( a . substring ( 0 , 2 ), k -> new LinkedList <> ()). add ( a . charAt ( 2 )); return dfs ( bottom , \"\" , prefixToBlocks , 0 ); } private boolean dfs ( final String row , final String nextRow , Map < String , List < Character >> prefixToBlocks , int i ) { if ( row . length () == 1 ) return true ; if ( nextRow . length () + 1 == row . length ()) return dfs ( nextRow , \"\" , prefixToBlocks , 0 ); for ( char c : prefixToBlocks . getOrDefault ( row . substring ( i , i + 2 ), new LinkedList <> ())) if ( dfs ( row , nextRow + c , prefixToBlocks , i + 1 )) return true ; return false ; } }","title":"756. Pyramid Transition Matrix $\\star\\star$"},{"location":"java/0701-0800/0751-0760/#757-set-intersection-size-at-least-two-starstarstar","text":"","title":"757. Set Intersection Size At Least Two $\\star\\star\\star$"},{"location":"java/0701-0800/0751-0760/#758-bold-words-in-string-star","text":"","title":"758. Bold Words in String $\\star$ \ud83d\udd12"},{"location":"java/0701-0800/0751-0760/#759-employee-free-time-starstarstar","text":"","title":"759. Employee Free Time $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/0701-0800/0751-0760/#760-find-anagram-mappings-star","text":"","title":"760. Find Anagram Mappings $\\star$ \ud83d\udd12"},{"location":"java/0701-0800/0761-0770/","text":"761. Special Binary String $\\star\\star\\star$ class Solution { public String makeLargestSpecial ( String S ) { List < String > specials = new ArrayList <> (); int count = 0 ; for ( int i = 0 , j = 0 ; j < S . length (); ++ j ) { count += S . charAt ( j ) == '1' ? 1 : - 1 ; if ( count == 0 ) { specials . add ( \"1\" + makeLargestSpecial ( S . substring ( i + 1 , j )) + \"0\" ); i = j + 1 ; } } Collections . sort ( specials , Collections . reverseOrder ()); return String . join ( \"\" , specials ); } } 762. Prime Number of Set Bits in Binary Representation $\\star$ 763. Partition Labels $\\star\\star$ 764. Largest Plus Sign $\\star\\star$ 765. Couples Holding Hands $\\star\\star\\star$ 766. Toeplitz Matrix $\\star$ class Solution { public boolean isToeplitzMatrix ( int [][] matrix ) { for ( int i = 0 ; i < matrix . length - 1 ; ++ i ) for ( int j = 0 ; j < matrix [ 0 ] . length - 1 ; ++ j ) if ( matrix [ i ][ j ] != matrix [ i + 1 ][ j + 1 ] ) return false ; return true ; } } 767. Reorganize String $\\star\\star$ class Solution { public String reorganizeString ( String S ) { final int n = S . length (); int [] count = new int [ 26 ] ; for ( char c : S . toCharArray ()) ++ count [ c - 'a' ] ; int maxCount = Arrays . stream ( count ). max (). getAsInt (); if ( maxCount > ( n + 1 ) / 2 ) return \"\" ; char [] ans = new char [ n ] ; if ( maxCount == ( n + 1 ) / 2 ) for ( char c = 'a' ; c <= 'z' ; ++ c ) if ( count [ c - 'a' ] == maxCount ) { for ( int i = 0 ; i < n ; i += 2 ) ans [ i ] = c ; count [ c - 'a' ] = 0 ; break ; } int i = maxCount == ( n + 1 ) / 2 ? 1 : 0 ; for ( char c = 'a' ; c <= 'z' ; ++ c ) while ( count [ c - 'a' ]-- > 0 ) { ans [ i ] = c ; i += 2 ; if ( i >= n ) i = 1 ; } return new String ( ans ); } } 768. Max Chunks To Make Sorted II $\\star\\star\\star$ class Solution { public int maxChunksToSorted ( int [] arr ) { final int n = arr . length ; int ans = 0 ; int max = Integer . MIN_VALUE ; int [] min = new int [ n ] ; min [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; -- i ) min [ i ] = Math . min ( min [ i + 1 ] , arr [ i ] ); for ( int i = 0 ; i < n - 1 ; ++ i ) { max = Math . max ( max , arr [ i ] ); if ( max <= min [ i + 1 ] ) ++ ans ; } return ans + 1 ; } } 769. Max Chunks To Make Sorted $\\star\\star$ class Solution { public int maxChunksToSorted ( int [] arr ) { int ans = 0 ; int max = Integer . MIN_VALUE ; for ( int i = 0 ; i < arr . length ; ++ i ) { max = Math . max ( max , arr [ i ] ); if ( max == i ) ++ ans ; } return ans ; } } 770. Basic Calculator IV $\\star\\star\\star$","title":"0761-0770"},{"location":"java/0701-0800/0761-0770/#761-special-binary-string-starstarstar","text":"class Solution { public String makeLargestSpecial ( String S ) { List < String > specials = new ArrayList <> (); int count = 0 ; for ( int i = 0 , j = 0 ; j < S . length (); ++ j ) { count += S . charAt ( j ) == '1' ? 1 : - 1 ; if ( count == 0 ) { specials . add ( \"1\" + makeLargestSpecial ( S . substring ( i + 1 , j )) + \"0\" ); i = j + 1 ; } } Collections . sort ( specials , Collections . reverseOrder ()); return String . join ( \"\" , specials ); } }","title":"761. Special Binary String $\\star\\star\\star$"},{"location":"java/0701-0800/0761-0770/#762-prime-number-of-set-bits-in-binary-representation-star","text":"","title":"762. Prime Number of Set Bits in Binary Representation $\\star$"},{"location":"java/0701-0800/0761-0770/#763-partition-labels-starstar","text":"","title":"763. Partition Labels $\\star\\star$"},{"location":"java/0701-0800/0761-0770/#764-largest-plus-sign-starstar","text":"","title":"764. Largest Plus Sign $\\star\\star$"},{"location":"java/0701-0800/0761-0770/#765-couples-holding-hands-starstarstar","text":"","title":"765. Couples Holding Hands $\\star\\star\\star$"},{"location":"java/0701-0800/0761-0770/#766-toeplitz-matrix-star","text":"class Solution { public boolean isToeplitzMatrix ( int [][] matrix ) { for ( int i = 0 ; i < matrix . length - 1 ; ++ i ) for ( int j = 0 ; j < matrix [ 0 ] . length - 1 ; ++ j ) if ( matrix [ i ][ j ] != matrix [ i + 1 ][ j + 1 ] ) return false ; return true ; } }","title":"766. Toeplitz Matrix $\\star$"},{"location":"java/0701-0800/0761-0770/#767-reorganize-string-starstar","text":"class Solution { public String reorganizeString ( String S ) { final int n = S . length (); int [] count = new int [ 26 ] ; for ( char c : S . toCharArray ()) ++ count [ c - 'a' ] ; int maxCount = Arrays . stream ( count ). max (). getAsInt (); if ( maxCount > ( n + 1 ) / 2 ) return \"\" ; char [] ans = new char [ n ] ; if ( maxCount == ( n + 1 ) / 2 ) for ( char c = 'a' ; c <= 'z' ; ++ c ) if ( count [ c - 'a' ] == maxCount ) { for ( int i = 0 ; i < n ; i += 2 ) ans [ i ] = c ; count [ c - 'a' ] = 0 ; break ; } int i = maxCount == ( n + 1 ) / 2 ? 1 : 0 ; for ( char c = 'a' ; c <= 'z' ; ++ c ) while ( count [ c - 'a' ]-- > 0 ) { ans [ i ] = c ; i += 2 ; if ( i >= n ) i = 1 ; } return new String ( ans ); } }","title":"767. Reorganize String $\\star\\star$"},{"location":"java/0701-0800/0761-0770/#768-max-chunks-to-make-sorted-ii-starstarstar","text":"class Solution { public int maxChunksToSorted ( int [] arr ) { final int n = arr . length ; int ans = 0 ; int max = Integer . MIN_VALUE ; int [] min = new int [ n ] ; min [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; -- i ) min [ i ] = Math . min ( min [ i + 1 ] , arr [ i ] ); for ( int i = 0 ; i < n - 1 ; ++ i ) { max = Math . max ( max , arr [ i ] ); if ( max <= min [ i + 1 ] ) ++ ans ; } return ans + 1 ; } }","title":"768. Max Chunks To Make Sorted II $\\star\\star\\star$"},{"location":"java/0701-0800/0761-0770/#769-max-chunks-to-make-sorted-starstar","text":"class Solution { public int maxChunksToSorted ( int [] arr ) { int ans = 0 ; int max = Integer . MIN_VALUE ; for ( int i = 0 ; i < arr . length ; ++ i ) { max = Math . max ( max , arr [ i ] ); if ( max == i ) ++ ans ; } return ans ; } }","title":"769. Max Chunks To Make Sorted $\\star\\star$"},{"location":"java/0701-0800/0761-0770/#770-basic-calculator-iv-starstarstar","text":"","title":"770. Basic Calculator IV $\\star\\star\\star$"},{"location":"java/0701-0800/0771-0780/","text":"771. Jewels and Stones $\\star$ class Solution { public int numJewelsInStones ( String J , String S ) { int ans = 0 ; Set < Character > jewels = new HashSet <> (); for ( char j : J . toCharArray ()) jewels . add ( j ); for ( char s : S . toCharArray ()) if ( jewels . contains ( s )) ++ ans ; return ans ; } } 772. Basic Calculator III $\\star\\star\\star$ \ud83d\udd12 773. Sliding Puzzle $\\star\\star\\star$ 774. Minimize Max Distance to Gas Station $\\star\\star\\star$ \ud83d\udd12 775. Global and Local Inversions $\\star\\star$ class Solution { public boolean isIdealPermutation ( int [] A ) { for ( int i = 0 ; i < A . length ; ++ i ) if ( Math . abs ( A [ i ] - i ) > 1 ) return false ; return true ; } } 776. Split BST $\\star\\star$ \ud83d\udd12 777. Swap Adjacent in LR String $\\star\\star$ 778. Swim in Rising Water $\\star\\star\\star$ 779. K-th Symbol in Grammar $\\star\\star$ 780. Reaching Points $\\star\\star\\star$ class Solution { public boolean reachingPoints ( int sx , int sy , int tx , int ty ) { while ( sx < tx && sy < ty ) if ( tx > ty ) tx %= ty ; else ty %= tx ; return sx == tx && sy <= ty && ( ty - sy ) % tx == 0 || sy == ty && sx <= tx && ( tx - sx ) % ty == 0 ; } }","title":"0771-0780"},{"location":"java/0701-0800/0771-0780/#771-jewels-and-stones-star","text":"class Solution { public int numJewelsInStones ( String J , String S ) { int ans = 0 ; Set < Character > jewels = new HashSet <> (); for ( char j : J . toCharArray ()) jewels . add ( j ); for ( char s : S . toCharArray ()) if ( jewels . contains ( s )) ++ ans ; return ans ; } }","title":"771. Jewels and Stones $\\star$"},{"location":"java/0701-0800/0771-0780/#772-basic-calculator-iii-starstarstar","text":"","title":"772. Basic Calculator III $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/0701-0800/0771-0780/#773-sliding-puzzle-starstarstar","text":"","title":"773. Sliding Puzzle $\\star\\star\\star$"},{"location":"java/0701-0800/0771-0780/#774-minimize-max-distance-to-gas-station-starstarstar","text":"","title":"774. Minimize Max Distance to Gas Station $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/0701-0800/0771-0780/#775-global-and-local-inversions-starstar","text":"class Solution { public boolean isIdealPermutation ( int [] A ) { for ( int i = 0 ; i < A . length ; ++ i ) if ( Math . abs ( A [ i ] - i ) > 1 ) return false ; return true ; } }","title":"775. Global and Local Inversions $\\star\\star$"},{"location":"java/0701-0800/0771-0780/#776-split-bst-starstar","text":"","title":"776. Split BST $\\star\\star$ \ud83d\udd12"},{"location":"java/0701-0800/0771-0780/#777-swap-adjacent-in-lr-string-starstar","text":"","title":"777. Swap Adjacent in LR String $\\star\\star$"},{"location":"java/0701-0800/0771-0780/#778-swim-in-rising-water-starstarstar","text":"","title":"778. Swim in Rising Water $\\star\\star\\star$"},{"location":"java/0701-0800/0771-0780/#779-k-th-symbol-in-grammar-starstar","text":"","title":"779. K-th Symbol in Grammar $\\star\\star$"},{"location":"java/0701-0800/0771-0780/#780-reaching-points-starstarstar","text":"class Solution { public boolean reachingPoints ( int sx , int sy , int tx , int ty ) { while ( sx < tx && sy < ty ) if ( tx > ty ) tx %= ty ; else ty %= tx ; return sx == tx && sy <= ty && ( ty - sy ) % tx == 0 || sy == ty && sx <= tx && ( tx - sx ) % ty == 0 ; } }","title":"780. Reaching Points $\\star\\star\\star$"},{"location":"java/0701-0800/0781-0790/","text":"781. Rabbits in Forest $\\star\\star$ class Solution { public int numRabbits ( int [] answers ) { int ans = 0 ; int [] count = new int [ 1000 ] ; for ( int answer : answers ) { if ( count [ answer ] % ( answer + 1 ) == 0 ) ans += answer + 1 ; ++ count [ answer ] ; } return ans ; } } 782. Transform to Chessboard $\\star\\star\\star$ class Solution { public int movesToChessboard ( int [][] board ) { final int n = board . length ; int rowSum = 0 ; int colSum = 0 ; int rowSwaps = 0 ; int colSwaps = 0 ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if (( board [ 0 ][ 0 ] ^ board [ i ][ 0 ] ^ board [ 0 ][ j ] ^ board [ i ][ j ] ) == 1 ) return - 1 ; for ( int i = 0 ; i < n ; ++ i ) { rowSum += board [ 0 ][ i ] ; colSum += board [ i ][ 0 ] ; } if ( rowSum != n / 2 && rowSum != ( n + 1 ) / 2 ) return - 1 ; if ( colSum != n / 2 && colSum != ( n + 1 ) / 2 ) return - 1 ; for ( int i = 0 ; i < n ; ++ i ) { if ( board [ i ][ 0 ] == ( i & 1 )) ++ rowSwaps ; if ( board [ 0 ][ i ] == ( i & 1 )) ++ colSwaps ; } if ( n % 2 == 1 ) { if ( rowSwaps % 2 == 1 ) rowSwaps = n - rowSwaps ; if ( colSwaps % 2 == 1 ) colSwaps = n - colSwaps ; } else { rowSwaps = Math . min ( rowSwaps , n - rowSwaps ); colSwaps = Math . min ( colSwaps , n - colSwaps ); } return ( rowSwaps + colSwaps ) / 2 ; } } 783. Minimum Distance Between BST Nodes $\\star$ 784. Letter Case Permutation $\\star$ 785. Is Graph Bipartite? $\\star\\star$ 786. K-th Smallest Prime Fraction $\\star\\star\\star$ 787. Cheapest Flights Within K Stops $\\star\\star$ 788. Rotated Digits $\\star$ class Solution { public int rotatedDigits ( int N ) { int ans = 0 ; for ( int i = 1 ; i <= N ; ++ i ) if ( isGoodNumber ( i )) ++ ans ; return ans ; } private boolean isGoodNumber ( int i ) { boolean isRotated = false ; for ( char c : String . valueOf ( i ). toCharArray ()) { if ( c == '0' || c == '1' || c == '8' ) continue ; if ( c == '2' || c == '5' || c == '6' || c == '9' ) isRotated = true ; else return false ; } return isRotated ; } } 789. Escape The Ghosts $\\star\\star$ class Solution { public boolean escapeGhosts ( int [][] ghosts , int [] target ) { int ghostSteps = Integer . MAX_VALUE ; for ( int [] ghost : ghosts ) ghostSteps = Math . min ( ghostSteps , Math . abs ( ghost [ 0 ] - target [ 0 ] ) + Math . abs ( ghost [ 1 ] - target [ 1 ] )); return Math . abs ( target [ 0 ] ) + Math . abs ( target [ 1 ] ) < ghostSteps ; } } 790. Domino and Tromino Tiling $\\star\\star$ class Solution { public int numTilings ( int N ) { final int kMod = ( int ) 1e9 + 7 ; long [] dp = new long [ 1001 ] ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 5 ; for ( int i = 4 ; i <= N ; ++ i ) dp [ i ] = ( 2 * dp [ i - 1 ] + dp [ i - 3 ] ) % kMod ; return ( int ) dp [ N ] ; } }","title":"0781-0790"},{"location":"java/0701-0800/0781-0790/#781-rabbits-in-forest-starstar","text":"class Solution { public int numRabbits ( int [] answers ) { int ans = 0 ; int [] count = new int [ 1000 ] ; for ( int answer : answers ) { if ( count [ answer ] % ( answer + 1 ) == 0 ) ans += answer + 1 ; ++ count [ answer ] ; } return ans ; } }","title":"781. Rabbits in Forest $\\star\\star$"},{"location":"java/0701-0800/0781-0790/#782-transform-to-chessboard-starstarstar","text":"class Solution { public int movesToChessboard ( int [][] board ) { final int n = board . length ; int rowSum = 0 ; int colSum = 0 ; int rowSwaps = 0 ; int colSwaps = 0 ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if (( board [ 0 ][ 0 ] ^ board [ i ][ 0 ] ^ board [ 0 ][ j ] ^ board [ i ][ j ] ) == 1 ) return - 1 ; for ( int i = 0 ; i < n ; ++ i ) { rowSum += board [ 0 ][ i ] ; colSum += board [ i ][ 0 ] ; } if ( rowSum != n / 2 && rowSum != ( n + 1 ) / 2 ) return - 1 ; if ( colSum != n / 2 && colSum != ( n + 1 ) / 2 ) return - 1 ; for ( int i = 0 ; i < n ; ++ i ) { if ( board [ i ][ 0 ] == ( i & 1 )) ++ rowSwaps ; if ( board [ 0 ][ i ] == ( i & 1 )) ++ colSwaps ; } if ( n % 2 == 1 ) { if ( rowSwaps % 2 == 1 ) rowSwaps = n - rowSwaps ; if ( colSwaps % 2 == 1 ) colSwaps = n - colSwaps ; } else { rowSwaps = Math . min ( rowSwaps , n - rowSwaps ); colSwaps = Math . min ( colSwaps , n - colSwaps ); } return ( rowSwaps + colSwaps ) / 2 ; } }","title":"782. Transform to Chessboard $\\star\\star\\star$"},{"location":"java/0701-0800/0781-0790/#783-minimum-distance-between-bst-nodes-star","text":"","title":"783. Minimum Distance Between BST Nodes $\\star$"},{"location":"java/0701-0800/0781-0790/#784-letter-case-permutation-star","text":"","title":"784. Letter Case Permutation $\\star$"},{"location":"java/0701-0800/0781-0790/#785-is-graph-bipartite-starstar","text":"","title":"785. Is Graph Bipartite? $\\star\\star$"},{"location":"java/0701-0800/0781-0790/#786-k-th-smallest-prime-fraction-starstarstar","text":"","title":"786. K-th Smallest Prime Fraction $\\star\\star\\star$"},{"location":"java/0701-0800/0781-0790/#787-cheapest-flights-within-k-stops-starstar","text":"","title":"787. Cheapest Flights Within K Stops $\\star\\star$"},{"location":"java/0701-0800/0781-0790/#788-rotated-digits-star","text":"class Solution { public int rotatedDigits ( int N ) { int ans = 0 ; for ( int i = 1 ; i <= N ; ++ i ) if ( isGoodNumber ( i )) ++ ans ; return ans ; } private boolean isGoodNumber ( int i ) { boolean isRotated = false ; for ( char c : String . valueOf ( i ). toCharArray ()) { if ( c == '0' || c == '1' || c == '8' ) continue ; if ( c == '2' || c == '5' || c == '6' || c == '9' ) isRotated = true ; else return false ; } return isRotated ; } }","title":"788. Rotated Digits $\\star$"},{"location":"java/0701-0800/0781-0790/#789-escape-the-ghosts-starstar","text":"class Solution { public boolean escapeGhosts ( int [][] ghosts , int [] target ) { int ghostSteps = Integer . MAX_VALUE ; for ( int [] ghost : ghosts ) ghostSteps = Math . min ( ghostSteps , Math . abs ( ghost [ 0 ] - target [ 0 ] ) + Math . abs ( ghost [ 1 ] - target [ 1 ] )); return Math . abs ( target [ 0 ] ) + Math . abs ( target [ 1 ] ) < ghostSteps ; } }","title":"789. Escape The Ghosts $\\star\\star$"},{"location":"java/0701-0800/0781-0790/#790-domino-and-tromino-tiling-starstar","text":"class Solution { public int numTilings ( int N ) { final int kMod = ( int ) 1e9 + 7 ; long [] dp = new long [ 1001 ] ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 5 ; for ( int i = 4 ; i <= N ; ++ i ) dp [ i ] = ( 2 * dp [ i - 1 ] + dp [ i - 3 ] ) % kMod ; return ( int ) dp [ N ] ; } }","title":"790. Domino and Tromino Tiling $\\star\\star$"},{"location":"java/0701-0800/0791-0800/","text":"791. Custom Sort String $\\star\\star$ class Solution { public String customSortString ( String S , String T ) { String ans = new String ( \"\" ); int [] count = new int [ 26 ] ; for ( char c : T . toCharArray ()) ++ count [ c - 'a' ] ; for ( char c : S . toCharArray ()) while ( count [ c - 'a' ]-- > 0 ) ans += c ; for ( char c = 'a' ; c <= 'z' ; ++ c ) while ( count [ c - 'a' ]-- > 0 ) ans += c ; return ans ; } } 792. Number of Matching Subsequences $\\star\\star$ class Solution { public int numMatchingSubseq ( String S , String [] words ) { for ( String word : words ) insert ( word ); return dfs ( S , 0 , root ); } private class TrieNode { private TrieNode [] children = new TrieNode [ 26 ] ; private int count = 0 ; } private TrieNode root = new TrieNode (); private void insert ( String word ) { TrieNode node = root ; for ( char c : word . toCharArray ()) { int index = c - 'a' ; if ( node . children [ index ] == null ) node . children [ index ] = new TrieNode (); node = node . children [ index ] ; } ++ node . count ; } private int dfs ( String S , int s , TrieNode node ) { int ans = node . count ; if ( s >= S . length ()) return ans ; for ( int i = 0 ; i < 26 ; ++ i ) if ( node . children [ i ] != null ) { int index = S . indexOf ( i + 'a' , s ); if ( index != - 1 ) ans += dfs ( S , index + 1 , node . children [ i ] ); } return ans ; } } 793. Preimage Size of Factorial Zeroes Function $\\star\\star\\star$ 794. Valid Tic-Tac-Toe State $\\star\\star$ class Solution { public boolean validTicTacToe ( String [] board ) { int countX = sum ( board , 'X' ); int countO = sum ( board , 'O' ); if ( countX < countO || countX - countO > 1 ) return false ; if ( isWinned ( board , 'X' ) && countX == countO || isWinned ( board , 'O' ) && countX != countO ) return false ; return true ; } private int sum ( final String [] board , char c ) { int ans = 0 ; for ( final String row : board ) ans += row . chars (). filter ( i -> i == c ). count (); return ans ; } private boolean isWinned ( final String [] board , char c ) { String [] rotated = rotate ( board ); return Arrays . stream ( board ). anyMatch ( row -> row . chars (). filter ( i -> i == c ). count () == 3 ) || Arrays . stream ( rotated ). anyMatch ( row -> row . chars (). filter ( i -> i == c ). count () == 3 ) || board [ 0 ] . charAt ( 0 ) == c && board [ 1 ] . charAt ( 1 ) == c && board [ 2 ] . charAt ( 2 ) == c || board [ 0 ] . charAt ( 2 ) == c && board [ 1 ] . charAt ( 1 ) == c && board [ 2 ] . charAt ( 0 ) == c ; } private String [] rotate ( final String [] board ) { String [] rotated = new String [ 3 ] ; for ( final String row : board ) for ( int i = 0 ; i < 3 ; ++ i ) rotated [ i ] += row . charAt ( i ); return rotated ; } } 795. Number of Subarrays with Bounded Maximum $\\star\\star$ class Solution { public int numSubarrayBoundedMax ( int [] A , int L , int R ) { int ans = 0 ; int l = - 1 ; int r = - 1 ; for ( int i = 0 ; i < A . length ; ++ i ) { if ( A [ i ] > R ) l = i ; if ( A [ i ] >= L ) r = i ; ans += r - l ; } return ans ; } } 796. Rotate String $\\star$ 797. All Paths From Source to Target $\\star\\star$ 798. Smallest Rotation with Highest Score $\\star\\star\\star$ 799. Champagne Tower $\\star\\star$ 800. Similar RGB Color $\\star$ \ud83d\udd12","title":"0791-0800"},{"location":"java/0701-0800/0791-0800/#791-custom-sort-string-starstar","text":"class Solution { public String customSortString ( String S , String T ) { String ans = new String ( \"\" ); int [] count = new int [ 26 ] ; for ( char c : T . toCharArray ()) ++ count [ c - 'a' ] ; for ( char c : S . toCharArray ()) while ( count [ c - 'a' ]-- > 0 ) ans += c ; for ( char c = 'a' ; c <= 'z' ; ++ c ) while ( count [ c - 'a' ]-- > 0 ) ans += c ; return ans ; } }","title":"791. Custom Sort String $\\star\\star$"},{"location":"java/0701-0800/0791-0800/#792-number-of-matching-subsequences-starstar","text":"class Solution { public int numMatchingSubseq ( String S , String [] words ) { for ( String word : words ) insert ( word ); return dfs ( S , 0 , root ); } private class TrieNode { private TrieNode [] children = new TrieNode [ 26 ] ; private int count = 0 ; } private TrieNode root = new TrieNode (); private void insert ( String word ) { TrieNode node = root ; for ( char c : word . toCharArray ()) { int index = c - 'a' ; if ( node . children [ index ] == null ) node . children [ index ] = new TrieNode (); node = node . children [ index ] ; } ++ node . count ; } private int dfs ( String S , int s , TrieNode node ) { int ans = node . count ; if ( s >= S . length ()) return ans ; for ( int i = 0 ; i < 26 ; ++ i ) if ( node . children [ i ] != null ) { int index = S . indexOf ( i + 'a' , s ); if ( index != - 1 ) ans += dfs ( S , index + 1 , node . children [ i ] ); } return ans ; } }","title":"792. Number of Matching Subsequences $\\star\\star$"},{"location":"java/0701-0800/0791-0800/#793-preimage-size-of-factorial-zeroes-function-starstarstar","text":"","title":"793. Preimage Size of Factorial Zeroes Function $\\star\\star\\star$"},{"location":"java/0701-0800/0791-0800/#794-valid-tic-tac-toe-state-starstar","text":"class Solution { public boolean validTicTacToe ( String [] board ) { int countX = sum ( board , 'X' ); int countO = sum ( board , 'O' ); if ( countX < countO || countX - countO > 1 ) return false ; if ( isWinned ( board , 'X' ) && countX == countO || isWinned ( board , 'O' ) && countX != countO ) return false ; return true ; } private int sum ( final String [] board , char c ) { int ans = 0 ; for ( final String row : board ) ans += row . chars (). filter ( i -> i == c ). count (); return ans ; } private boolean isWinned ( final String [] board , char c ) { String [] rotated = rotate ( board ); return Arrays . stream ( board ). anyMatch ( row -> row . chars (). filter ( i -> i == c ). count () == 3 ) || Arrays . stream ( rotated ). anyMatch ( row -> row . chars (). filter ( i -> i == c ). count () == 3 ) || board [ 0 ] . charAt ( 0 ) == c && board [ 1 ] . charAt ( 1 ) == c && board [ 2 ] . charAt ( 2 ) == c || board [ 0 ] . charAt ( 2 ) == c && board [ 1 ] . charAt ( 1 ) == c && board [ 2 ] . charAt ( 0 ) == c ; } private String [] rotate ( final String [] board ) { String [] rotated = new String [ 3 ] ; for ( final String row : board ) for ( int i = 0 ; i < 3 ; ++ i ) rotated [ i ] += row . charAt ( i ); return rotated ; } }","title":"794. Valid Tic-Tac-Toe State $\\star\\star$"},{"location":"java/0701-0800/0791-0800/#795-number-of-subarrays-with-bounded-maximum-starstar","text":"class Solution { public int numSubarrayBoundedMax ( int [] A , int L , int R ) { int ans = 0 ; int l = - 1 ; int r = - 1 ; for ( int i = 0 ; i < A . length ; ++ i ) { if ( A [ i ] > R ) l = i ; if ( A [ i ] >= L ) r = i ; ans += r - l ; } return ans ; } }","title":"795. Number of Subarrays with Bounded Maximum $\\star\\star$"},{"location":"java/0701-0800/0791-0800/#796-rotate-string-star","text":"","title":"796. Rotate String $\\star$"},{"location":"java/0701-0800/0791-0800/#797-all-paths-from-source-to-target-starstar","text":"","title":"797. All Paths From Source to Target $\\star\\star$"},{"location":"java/0701-0800/0791-0800/#798-smallest-rotation-with-highest-score-starstarstar","text":"","title":"798. Smallest Rotation with Highest Score $\\star\\star\\star$"},{"location":"java/0701-0800/0791-0800/#799-champagne-tower-starstar","text":"","title":"799. Champagne Tower $\\star\\star$"},{"location":"java/0701-0800/0791-0800/#800-similar-rgb-color-star","text":"","title":"800. Similar RGB Color $\\star$ \ud83d\udd12"},{"location":"java/0801-0900/0801-0810/","text":"801. Minimum Swaps To Make Sequences Increasing $\\star\\star$ class Solution { public int minSwap ( int [] A , int [] B ) { int keepAt = 0 ; int swapAt = 1 ; int prevKeepAt = 0 ; int prevSwapAt = 1 ; for ( int i = 1 ; i < A . length ; ++ i ) { keepAt = Integer . MAX_VALUE ; swapAt = Integer . MAX_VALUE ; if ( A [ i ] > A [ i - 1 ] && B [ i ] > B [ i - 1 ] ) { keepAt = prevKeepAt ; swapAt = prevSwapAt + 1 ; } if ( A [ i ] > B [ i - 1 ] && B [ i ] > A [ i - 1 ] ) { keepAt = Math . min ( keepAt , prevSwapAt ); swapAt = Math . min ( swapAt , prevKeepAt + 1 ); } prevKeepAt = keepAt ; prevSwapAt = swapAt ; } return Math . min ( keepAt , swapAt ); } } 802. Find Eventual Safe States $\\star\\star$ 803. Bricks Falling When Hit $\\star\\star\\star$ 804. Unique Morse Code Words $\\star$ class Solution { public int uniqueMorseRepresentations ( String [] words ) { String [] morse = { \".-\" , \"-...\" , \"-.-.\" , \"-..\" , \".\" , \"..-.\" , \"--.\" , \"....\" , \"..\" , \".---\" , \"-.-\" , \".-..\" , \"--\" , \"-.\" , \"---\" , \".--.\" , \"--.-\" , \".-.\" , \"...\" , \"-\" , \"..-\" , \"...-\" , \".--\" , \"-..-\" , \"-.--\" , \"--..\" }; Set < String > transformations = new HashSet <> (); for ( final String word : words ) { StringBuilder transformation = new StringBuilder (); for ( char c : word . toCharArray ()) transformation . append ( morse [ c - 'a' ] ); transformations . add ( transformation . toString ()); } return transformations . size (); } } 805. Split Array With Same Average $\\star\\star\\star$ class Solution { public boolean splitArraySameAverage ( int [] A ) { final int n = A . length ; final int sum = Arrays . stream ( A ). sum (); if ( ! isPossible ( sum , n )) return false ; List < Set < Integer >> sums = new ArrayList <> (); for ( int i = 0 ; i < n / 2 + 1 ; ++ i ) sums . add ( new HashSet <> ()); sums . get ( 0 ). add ( 0 ); for ( int a : A ) for ( int i = n / 2 ; i > 0 ; -- i ) for ( int num : sums . get ( i - 1 )) sums . get ( i ). add ( a + num ); for ( int i = 1 ; i < n / 2 + 1 ; ++ i ) if ( i * sum % n == 0 && sums . get ( i ). contains ( i * sum / n )) return true ; return false ; } private boolean isPossible ( int sum , int n ) { for ( int i = 1 ; i < n / 2 + 1 ; ++ i ) if ( i * sum % n == 0 ) return true ; return false ; } } 806. Number of Lines To Write String $\\star$ 807. Max Increase to Keep City Skyline $\\star\\star$ 808. Soup Servings $\\star\\star$ class Solution { public double soupServings ( int N ) { return N >= 4800 ? 1.0 : dfs (( N + 24 ) / 25 , ( N + 24 ) / 25 ); } private double [][] memo = new double [ 192 ][ 192 ] ; private double dfs ( int a , int b ) { if ( a <= 0 && b <= 0 ) return 0.5 ; if ( a <= 0 ) return 1.0 ; if ( b <= 0 ) return 0.0 ; if ( memo [ a ][ b ] > 0 ) return memo [ a ][ b ] ; memo [ a ][ b ] = 0.25 * ( dfs ( a - 4 , b ) + dfs ( a - 3 , b - 1 ) + dfs ( a - 2 , b - 2 ) + dfs ( a - 1 , b - 3 )); return memo [ a ][ b ] ; } } 809. Expressive Words $\\star\\star$ class Solution { public int expressiveWords ( String S , String [] words ) { int ans = 0 ; for ( final String word : words ) if ( isStretchy ( S , word )) ++ ans ; return ans ; } private boolean isStretchy ( final String S , final String word ) { final int n = S . length (); final int m = word . length (); int j = 0 ; for ( int i = 0 ; i < n ; ++ i ) if ( j < m && S . charAt ( i ) == word . charAt ( j )) ++ j ; else if ( i > 1 && S . charAt ( i ) == S . charAt ( i - 1 ) && S . charAt ( i - 1 ) == S . charAt ( i - 2 )) continue ; else if ( 0 < i && i + 1 < n && S . charAt ( i - 1 ) == S . charAt ( i ) && S . charAt ( i ) == S . charAt ( i + 1 )) continue ; else return false ; return j == m ; } } 810. Chalkboard XOR Game $\\star\\star\\star$ class Solution { public boolean xorGame ( int [] nums ) { int xors = 0 ; for ( int num : nums ) xors ^= num ; return xors == 0 || nums . length % 2 == 0 ; } }","title":"0801-0810"},{"location":"java/0801-0900/0801-0810/#801-minimum-swaps-to-make-sequences-increasing-starstar","text":"class Solution { public int minSwap ( int [] A , int [] B ) { int keepAt = 0 ; int swapAt = 1 ; int prevKeepAt = 0 ; int prevSwapAt = 1 ; for ( int i = 1 ; i < A . length ; ++ i ) { keepAt = Integer . MAX_VALUE ; swapAt = Integer . MAX_VALUE ; if ( A [ i ] > A [ i - 1 ] && B [ i ] > B [ i - 1 ] ) { keepAt = prevKeepAt ; swapAt = prevSwapAt + 1 ; } if ( A [ i ] > B [ i - 1 ] && B [ i ] > A [ i - 1 ] ) { keepAt = Math . min ( keepAt , prevSwapAt ); swapAt = Math . min ( swapAt , prevKeepAt + 1 ); } prevKeepAt = keepAt ; prevSwapAt = swapAt ; } return Math . min ( keepAt , swapAt ); } }","title":"801. Minimum Swaps To Make Sequences Increasing $\\star\\star$"},{"location":"java/0801-0900/0801-0810/#802-find-eventual-safe-states-starstar","text":"","title":"802. Find Eventual Safe States $\\star\\star$"},{"location":"java/0801-0900/0801-0810/#803-bricks-falling-when-hit-starstarstar","text":"","title":"803. Bricks Falling When Hit $\\star\\star\\star$"},{"location":"java/0801-0900/0801-0810/#804-unique-morse-code-words-star","text":"class Solution { public int uniqueMorseRepresentations ( String [] words ) { String [] morse = { \".-\" , \"-...\" , \"-.-.\" , \"-..\" , \".\" , \"..-.\" , \"--.\" , \"....\" , \"..\" , \".---\" , \"-.-\" , \".-..\" , \"--\" , \"-.\" , \"---\" , \".--.\" , \"--.-\" , \".-.\" , \"...\" , \"-\" , \"..-\" , \"...-\" , \".--\" , \"-..-\" , \"-.--\" , \"--..\" }; Set < String > transformations = new HashSet <> (); for ( final String word : words ) { StringBuilder transformation = new StringBuilder (); for ( char c : word . toCharArray ()) transformation . append ( morse [ c - 'a' ] ); transformations . add ( transformation . toString ()); } return transformations . size (); } }","title":"804. Unique Morse Code Words $\\star$"},{"location":"java/0801-0900/0801-0810/#805-split-array-with-same-average-starstarstar","text":"class Solution { public boolean splitArraySameAverage ( int [] A ) { final int n = A . length ; final int sum = Arrays . stream ( A ). sum (); if ( ! isPossible ( sum , n )) return false ; List < Set < Integer >> sums = new ArrayList <> (); for ( int i = 0 ; i < n / 2 + 1 ; ++ i ) sums . add ( new HashSet <> ()); sums . get ( 0 ). add ( 0 ); for ( int a : A ) for ( int i = n / 2 ; i > 0 ; -- i ) for ( int num : sums . get ( i - 1 )) sums . get ( i ). add ( a + num ); for ( int i = 1 ; i < n / 2 + 1 ; ++ i ) if ( i * sum % n == 0 && sums . get ( i ). contains ( i * sum / n )) return true ; return false ; } private boolean isPossible ( int sum , int n ) { for ( int i = 1 ; i < n / 2 + 1 ; ++ i ) if ( i * sum % n == 0 ) return true ; return false ; } }","title":"805. Split Array With Same Average $\\star\\star\\star$"},{"location":"java/0801-0900/0801-0810/#806-number-of-lines-to-write-string-star","text":"","title":"806. Number of Lines To Write String $\\star$"},{"location":"java/0801-0900/0801-0810/#807-max-increase-to-keep-city-skyline-starstar","text":"","title":"807. Max Increase to Keep City Skyline $\\star\\star$"},{"location":"java/0801-0900/0801-0810/#808-soup-servings-starstar","text":"class Solution { public double soupServings ( int N ) { return N >= 4800 ? 1.0 : dfs (( N + 24 ) / 25 , ( N + 24 ) / 25 ); } private double [][] memo = new double [ 192 ][ 192 ] ; private double dfs ( int a , int b ) { if ( a <= 0 && b <= 0 ) return 0.5 ; if ( a <= 0 ) return 1.0 ; if ( b <= 0 ) return 0.0 ; if ( memo [ a ][ b ] > 0 ) return memo [ a ][ b ] ; memo [ a ][ b ] = 0.25 * ( dfs ( a - 4 , b ) + dfs ( a - 3 , b - 1 ) + dfs ( a - 2 , b - 2 ) + dfs ( a - 1 , b - 3 )); return memo [ a ][ b ] ; } }","title":"808. Soup Servings $\\star\\star$"},{"location":"java/0801-0900/0801-0810/#809-expressive-words-starstar","text":"class Solution { public int expressiveWords ( String S , String [] words ) { int ans = 0 ; for ( final String word : words ) if ( isStretchy ( S , word )) ++ ans ; return ans ; } private boolean isStretchy ( final String S , final String word ) { final int n = S . length (); final int m = word . length (); int j = 0 ; for ( int i = 0 ; i < n ; ++ i ) if ( j < m && S . charAt ( i ) == word . charAt ( j )) ++ j ; else if ( i > 1 && S . charAt ( i ) == S . charAt ( i - 1 ) && S . charAt ( i - 1 ) == S . charAt ( i - 2 )) continue ; else if ( 0 < i && i + 1 < n && S . charAt ( i - 1 ) == S . charAt ( i ) && S . charAt ( i ) == S . charAt ( i + 1 )) continue ; else return false ; return j == m ; } }","title":"809. Expressive Words $\\star\\star$"},{"location":"java/0801-0900/0801-0810/#810-chalkboard-xor-game-starstarstar","text":"class Solution { public boolean xorGame ( int [] nums ) { int xors = 0 ; for ( int num : nums ) xors ^= num ; return xors == 0 || nums . length % 2 == 0 ; } }","title":"810. Chalkboard XOR Game $\\star\\star\\star$"},{"location":"java/0801-0900/0811-0820/","text":"811. Subdomain Visit Count $\\star$ class Solution { public List < String > subdomainVisits ( String [] cpdomains ) { List < String > ans = new ArrayList <> (); Map < String , Integer > count = new HashMap <> (); for ( final String cpdomain : cpdomains ) { int space = cpdomain . indexOf ( ' ' ); int num = Integer . valueOf ( cpdomain . substring ( 0 , space )); String domain = cpdomain . substring ( space + 1 ); count . put ( domain , count . getOrDefault ( domain , 0 ) + num ); for ( int i = 0 ; i < domain . length (); ++ i ) if ( domain . charAt ( i ) == '.' ) { String subdomain = domain . substring ( i + 1 ); count . put ( subdomain , count . getOrDefault ( subdomain , 0 ) + num ); } } for ( final String subdomain : count . keySet ()) ans . add ( String . valueOf ( count . get ( subdomain )) + ' ' + subdomain ); return ans ; } } 812. Largest Triangle Area $\\star$ class Solution { public double largestTriangleArea ( int [][] points ) { double ans = 0 ; for ( int [] A : points ) for ( int [] B : points ) for ( int [] C : points ) ans = Math . max ( ans , 0.5 * Math . abs (( B [ 0 ] - A [ 0 ] ) * ( C [ 1 ] - A [ 1 ] ) - ( C [ 0 ] - A [ 0 ] ) * ( B [ 1 ] - A [ 1 ] ))); return ans ; } } 813. Largest Sum of Averages $\\star\\star$ 814. Binary Tree Pruning $\\star\\star$ 815. Bus Routes $\\star\\star\\star$ 816. Ambiguous Coordinates $\\star\\star$ class Solution { public List < String > ambiguousCoordinates ( String S ) { List < String > ans = new ArrayList <> (); S = S . substring ( 1 , S . length () - 1 ); for ( int i = 1 ; i < S . length (); ++ i ) for ( final String x : splits ( S . substring ( 0 , i ))) for ( final String y : splits ( S . substring ( i ))) ans . add ( \"(\" + x + \", \" + y + \")\" ); return ans ; } private List < String > splits ( final String S ) { if ( S . isEmpty () || S . length () > 1 && S . charAt ( 0 ) == '0' && S . charAt ( S . length () - 1 ) == '0' ) return new ArrayList <> (); if ( S . charAt ( S . length () - 1 ) == '0' ) return new ArrayList <> ( Arrays . asList ( S )); if ( S . charAt ( 0 ) == '0' ) return new ArrayList <> ( Arrays . asList ( \"0.\" + S . substring ( 1 ))); List < String > res = new ArrayList <> (); res . add ( S ); for ( int i = 1 ; i < S . length (); ++ i ) res . add ( S . substring ( 0 , i ) + \".\" + S . substring ( i )); return res ; } } 817. Linked List Components $\\star\\star$ class Solution { public int numComponents ( ListNode head , int [] G ) { int ans = 0 ; Set < Integer > setG = new HashSet <> (); for ( int g : G ) setG . add ( g ); for (; head != null ; head = head . next ) if ( setG . contains ( head . val ) && ( head . next == null || ! setG . contains ( head . next . val ))) ++ ans ; return ans ; } } 818. Race Car $\\star\\star\\star$ 819. Most Common Word $\\star$ class Solution { public String mostCommonWord ( String paragraph , String [] banned ) { Pair < String , Integer > ans = new Pair <> ( \"\" , 0 ); Set < String > bannedSet = new HashSet <> ( Arrays . asList ( banned )); Map < String , Integer > count = new HashMap <> (); String [] words = paragraph . replaceAll ( \"\\\\W+\" , \" \" ). toLowerCase (). split ( \"\\\\s+\" ); for ( final String word : words ) if ( ! bannedSet . contains ( word )) { count . put ( word , count . getOrDefault ( word , 0 ) + 1 ); if ( count . get ( word ) > ans . getValue ()) ans = new Pair <> ( word , count . get ( word )); } return ans . getKey (); } } 820. Short Encoding of Words $\\star\\star$","title":"0811-0820"},{"location":"java/0801-0900/0811-0820/#811-subdomain-visit-count-star","text":"class Solution { public List < String > subdomainVisits ( String [] cpdomains ) { List < String > ans = new ArrayList <> (); Map < String , Integer > count = new HashMap <> (); for ( final String cpdomain : cpdomains ) { int space = cpdomain . indexOf ( ' ' ); int num = Integer . valueOf ( cpdomain . substring ( 0 , space )); String domain = cpdomain . substring ( space + 1 ); count . put ( domain , count . getOrDefault ( domain , 0 ) + num ); for ( int i = 0 ; i < domain . length (); ++ i ) if ( domain . charAt ( i ) == '.' ) { String subdomain = domain . substring ( i + 1 ); count . put ( subdomain , count . getOrDefault ( subdomain , 0 ) + num ); } } for ( final String subdomain : count . keySet ()) ans . add ( String . valueOf ( count . get ( subdomain )) + ' ' + subdomain ); return ans ; } }","title":"811. Subdomain Visit Count $\\star$"},{"location":"java/0801-0900/0811-0820/#812-largest-triangle-area-star","text":"class Solution { public double largestTriangleArea ( int [][] points ) { double ans = 0 ; for ( int [] A : points ) for ( int [] B : points ) for ( int [] C : points ) ans = Math . max ( ans , 0.5 * Math . abs (( B [ 0 ] - A [ 0 ] ) * ( C [ 1 ] - A [ 1 ] ) - ( C [ 0 ] - A [ 0 ] ) * ( B [ 1 ] - A [ 1 ] ))); return ans ; } }","title":"812. Largest Triangle Area $\\star$"},{"location":"java/0801-0900/0811-0820/#813-largest-sum-of-averages-starstar","text":"","title":"813. Largest Sum of Averages $\\star\\star$"},{"location":"java/0801-0900/0811-0820/#814-binary-tree-pruning-starstar","text":"","title":"814. Binary Tree Pruning $\\star\\star$"},{"location":"java/0801-0900/0811-0820/#815-bus-routes-starstarstar","text":"","title":"815. Bus Routes $\\star\\star\\star$"},{"location":"java/0801-0900/0811-0820/#816-ambiguous-coordinates-starstar","text":"class Solution { public List < String > ambiguousCoordinates ( String S ) { List < String > ans = new ArrayList <> (); S = S . substring ( 1 , S . length () - 1 ); for ( int i = 1 ; i < S . length (); ++ i ) for ( final String x : splits ( S . substring ( 0 , i ))) for ( final String y : splits ( S . substring ( i ))) ans . add ( \"(\" + x + \", \" + y + \")\" ); return ans ; } private List < String > splits ( final String S ) { if ( S . isEmpty () || S . length () > 1 && S . charAt ( 0 ) == '0' && S . charAt ( S . length () - 1 ) == '0' ) return new ArrayList <> (); if ( S . charAt ( S . length () - 1 ) == '0' ) return new ArrayList <> ( Arrays . asList ( S )); if ( S . charAt ( 0 ) == '0' ) return new ArrayList <> ( Arrays . asList ( \"0.\" + S . substring ( 1 ))); List < String > res = new ArrayList <> (); res . add ( S ); for ( int i = 1 ; i < S . length (); ++ i ) res . add ( S . substring ( 0 , i ) + \".\" + S . substring ( i )); return res ; } }","title":"816. Ambiguous Coordinates $\\star\\star$"},{"location":"java/0801-0900/0811-0820/#817-linked-list-components-starstar","text":"class Solution { public int numComponents ( ListNode head , int [] G ) { int ans = 0 ; Set < Integer > setG = new HashSet <> (); for ( int g : G ) setG . add ( g ); for (; head != null ; head = head . next ) if ( setG . contains ( head . val ) && ( head . next == null || ! setG . contains ( head . next . val ))) ++ ans ; return ans ; } }","title":"817. Linked List Components $\\star\\star$"},{"location":"java/0801-0900/0811-0820/#818-race-car-starstarstar","text":"","title":"818. Race Car $\\star\\star\\star$"},{"location":"java/0801-0900/0811-0820/#819-most-common-word-star","text":"class Solution { public String mostCommonWord ( String paragraph , String [] banned ) { Pair < String , Integer > ans = new Pair <> ( \"\" , 0 ); Set < String > bannedSet = new HashSet <> ( Arrays . asList ( banned )); Map < String , Integer > count = new HashMap <> (); String [] words = paragraph . replaceAll ( \"\\\\W+\" , \" \" ). toLowerCase (). split ( \"\\\\s+\" ); for ( final String word : words ) if ( ! bannedSet . contains ( word )) { count . put ( word , count . getOrDefault ( word , 0 ) + 1 ); if ( count . get ( word ) > ans . getValue ()) ans = new Pair <> ( word , count . get ( word )); } return ans . getKey (); } }","title":"819. Most Common Word $\\star$"},{"location":"java/0801-0900/0811-0820/#820-short-encoding-of-words-starstar","text":"","title":"820. Short Encoding of Words $\\star\\star$"},{"location":"java/0801-0900/0821-0830/","text":"821. Shortest Distance to a Character $\\star$ 822. Card Flipping Game $\\star\\star$ 823. Binary Trees With Factors $\\star\\star$ 824. Goat Latin $\\star$ class Solution { public String toGoatLatin ( String S ) { String ans = \"\" ; String vowels = \"aeiouAEIOU\" ; String [] words = S . split ( \" \" ); int i = 1 ; for ( final String word : words ) { if ( i > 1 ) ans += \" \" ; if ( vowels . contains ( \"\" + word . charAt ( 0 ))) ans += word ; else ans += word . substring ( 1 ) + word . charAt ( 0 ); ans += \"ma\" + new String ( new char [ i ++] ). replace ( '\\0' , 'a' ); } return ans ; } } 825. Friends Of Appropriate Ages $\\star\\star$ class Solution { public int numFriendRequests ( int [] ages ) { int ans = 0 ; int [] count = new int [ 121 ] ; for ( int age : ages ) ++ count [ age ] ; for ( int i = 15 ; i <= 120 ; ++ i ) ans += count [ i ] * ( count [ i ] - 1 ); for ( int i = 15 ; i <= 120 ; ++ i ) for ( int j = i / 2 + 8 ; j < i ; ++ j ) ans += count [ i ] * count [ j ] ; return ans ; } } 826. Most Profit Assigning Work $\\star\\star$ class Solution { public int maxProfitAssignment ( int [] difficulty , int [] profit , int [] worker ) { int ans = 0 ; List < Pair < Integer , Integer >> jobs = new ArrayList <> (); for ( int i = 0 ; i < difficulty . length ; ++ i ) jobs . add ( new Pair <> ( difficulty [ i ] , profit [ i ] )); Collections . sort ( jobs , Comparator . comparing ( Pair :: getKey )); Arrays . sort ( worker ); int i = 0 ; int maxProfit = 0 ; for ( int w : worker ) { for (; i < jobs . size () && w >= jobs . get ( i ). getKey (); ++ i ) maxProfit = Math . max ( maxProfit , jobs . get ( i ). getValue ()); ans += maxProfit ; } return ans ; } } 827. Making A Large Island $\\star\\star\\star$ 828. Count Unique Characters of All Substrings of a Given String $\\star\\star\\star$ class Solution { public int uniqueLetterString ( String s ) { int ans = 0 ; int count = 0 ; int [] lastCount = new int [ 26 ] ; int [] lastSeen = new int [ 26 ] ; Arrays . fill ( lastSeen , - 1 ); for ( int i = 0 ; i < s . length (); ++ i ) { int c = s . charAt ( i ) - 'A' ; int currentCount = i - lastSeen [ c ] ; count = count - lastCount [ c ] + currentCount ; lastCount [ c ] = currentCount ; lastSeen [ c ] = i ; ans += count ; } return ans ; } } 829. Consecutive Numbers Sum $\\star\\star\\star$ class Solution { public int consecutiveNumbersSum ( int N ) { int ans = 0 ; for ( int i = 1 , triangleNum = i ; triangleNum <= N ; ++ i , triangleNum += i ) if (( N - triangleNum ) % i == 0 ) ++ ans ; return ans ; } } 830. Positions of Large Groups $\\star$ class Solution { public List < List < Integer >> largeGroupPositions ( String S ) { final int n = S . length (); List < List < Integer >> ans = new ArrayList <> (); for ( int i = 0 , j = 0 ; i < n ; i = j ) { while ( j < n && S . charAt ( j ) == S . charAt ( i )) ++ j ; if ( j - i >= 3 ) ans . add ( Arrays . asList ( i , j - 1 )); } return ans ; } }","title":"0821-0830"},{"location":"java/0801-0900/0821-0830/#821-shortest-distance-to-a-character-star","text":"","title":"821. Shortest Distance to a Character $\\star$"},{"location":"java/0801-0900/0821-0830/#822-card-flipping-game-starstar","text":"","title":"822. Card Flipping Game $\\star\\star$"},{"location":"java/0801-0900/0821-0830/#823-binary-trees-with-factors-starstar","text":"","title":"823. Binary Trees With Factors $\\star\\star$"},{"location":"java/0801-0900/0821-0830/#824-goat-latin-star","text":"class Solution { public String toGoatLatin ( String S ) { String ans = \"\" ; String vowels = \"aeiouAEIOU\" ; String [] words = S . split ( \" \" ); int i = 1 ; for ( final String word : words ) { if ( i > 1 ) ans += \" \" ; if ( vowels . contains ( \"\" + word . charAt ( 0 ))) ans += word ; else ans += word . substring ( 1 ) + word . charAt ( 0 ); ans += \"ma\" + new String ( new char [ i ++] ). replace ( '\\0' , 'a' ); } return ans ; } }","title":"824. Goat Latin $\\star$"},{"location":"java/0801-0900/0821-0830/#825-friends-of-appropriate-ages-starstar","text":"class Solution { public int numFriendRequests ( int [] ages ) { int ans = 0 ; int [] count = new int [ 121 ] ; for ( int age : ages ) ++ count [ age ] ; for ( int i = 15 ; i <= 120 ; ++ i ) ans += count [ i ] * ( count [ i ] - 1 ); for ( int i = 15 ; i <= 120 ; ++ i ) for ( int j = i / 2 + 8 ; j < i ; ++ j ) ans += count [ i ] * count [ j ] ; return ans ; } }","title":"825. Friends Of Appropriate Ages $\\star\\star$"},{"location":"java/0801-0900/0821-0830/#826-most-profit-assigning-work-starstar","text":"class Solution { public int maxProfitAssignment ( int [] difficulty , int [] profit , int [] worker ) { int ans = 0 ; List < Pair < Integer , Integer >> jobs = new ArrayList <> (); for ( int i = 0 ; i < difficulty . length ; ++ i ) jobs . add ( new Pair <> ( difficulty [ i ] , profit [ i ] )); Collections . sort ( jobs , Comparator . comparing ( Pair :: getKey )); Arrays . sort ( worker ); int i = 0 ; int maxProfit = 0 ; for ( int w : worker ) { for (; i < jobs . size () && w >= jobs . get ( i ). getKey (); ++ i ) maxProfit = Math . max ( maxProfit , jobs . get ( i ). getValue ()); ans += maxProfit ; } return ans ; } }","title":"826. Most Profit Assigning Work $\\star\\star$"},{"location":"java/0801-0900/0821-0830/#827-making-a-large-island-starstarstar","text":"","title":"827. Making A Large Island $\\star\\star\\star$"},{"location":"java/0801-0900/0821-0830/#828-count-unique-characters-of-all-substrings-of-a-given-string-starstarstar","text":"class Solution { public int uniqueLetterString ( String s ) { int ans = 0 ; int count = 0 ; int [] lastCount = new int [ 26 ] ; int [] lastSeen = new int [ 26 ] ; Arrays . fill ( lastSeen , - 1 ); for ( int i = 0 ; i < s . length (); ++ i ) { int c = s . charAt ( i ) - 'A' ; int currentCount = i - lastSeen [ c ] ; count = count - lastCount [ c ] + currentCount ; lastCount [ c ] = currentCount ; lastSeen [ c ] = i ; ans += count ; } return ans ; } }","title":"828. Count Unique Characters of All Substrings of a Given String $\\star\\star\\star$"},{"location":"java/0801-0900/0821-0830/#829-consecutive-numbers-sum-starstarstar","text":"class Solution { public int consecutiveNumbersSum ( int N ) { int ans = 0 ; for ( int i = 1 , triangleNum = i ; triangleNum <= N ; ++ i , triangleNum += i ) if (( N - triangleNum ) % i == 0 ) ++ ans ; return ans ; } }","title":"829. Consecutive Numbers Sum $\\star\\star\\star$"},{"location":"java/0801-0900/0821-0830/#830-positions-of-large-groups-star","text":"class Solution { public List < List < Integer >> largeGroupPositions ( String S ) { final int n = S . length (); List < List < Integer >> ans = new ArrayList <> (); for ( int i = 0 , j = 0 ; i < n ; i = j ) { while ( j < n && S . charAt ( j ) == S . charAt ( i )) ++ j ; if ( j - i >= 3 ) ans . add ( Arrays . asList ( i , j - 1 )); } return ans ; } }","title":"830. Positions of Large Groups $\\star$"},{"location":"java/0801-0900/0831-0840/","text":"831. Masking Personal Information $\\star\\star$ class Solution { public String maskPII ( String S ) { int atIndex = S . indexOf ( '@' ); if ( atIndex > 0 ) { S = S . toLowerCase (); return S . charAt ( 0 ) + \"*****\" + S . substring ( atIndex - 1 ); } String ans = \"\" ; for ( char c : S . toCharArray ()) if ( Character . isDigit ( c )) ans += c ; if ( ans . length () == 10 ) return \"***-***-\" + ans . substring ( ans . length () - 4 ); return '+' + new String ( new char [ ans . length () - 10 ] ). replace ( '\\0' , '*' ) + \"-***-***-\" + ans . substring ( ans . length () - 4 ); } } 832. Flipping an Image $\\star$ class Solution { public int [][] flipAndInvertImage ( int [][] A ) { final int n = A . length ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < ( n + 1 ) / 2 ; ++ j ) { int temp = A [ i ][ j ] ; A [ i ][ j ] = A [ i ][ n - j - 1 ] ^ 1 ; A [ i ][ n - j - 1 ] = temp ^ 1 ; } return A ; } } 833. Find And Replace in String $\\star\\star$ class Solution { public String findReplaceString ( String S , int [] indexes , String [] sources , String [] targets ) { List < int []> sortedIndexes = new ArrayList <> (); for ( int i = 0 ; i < indexes . length ; ++ i ) sortedIndexes . add ( new int [] { indexes [ i ] , i }); Collections . sort ( sortedIndexes , Comparator . comparing ( i -> - i [ 0 ] )); for ( int [] sortedIndex : sortedIndexes ) { int index = sortedIndex [ 0 ] ; int i = sortedIndex [ 1 ] ; String source = sources [ i ] ; String target = targets [ i ] ; if ( S . substring ( index , index + source . length ()). equals ( source )) S = S . substring ( 0 , index ) + target + S . substring ( index + source . length ()); } return S ; } } 834. Sum of Distances in Tree $\\star\\star\\star$ 835. Image Overlap $\\star\\star$ class Solution { public int largestOverlap ( int [][] A , int [][] B ) { final int n = A . length ; final int magic = 100 ; int ans = 0 ; List < int []> onesA = new ArrayList <> (); List < int []> onesB = new ArrayList <> (); Map < Integer , Integer > map = new HashMap <> (); for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { if ( A [ i ][ j ] == 1 ) onesA . add ( new int [] { i , j }); if ( B [ i ][ j ] == 1 ) onesB . add ( new int [] { i , j }); } for ( int [] a : onesA ) for ( int [] b : onesB ) { int key = ( a [ 0 ] - b [ 0 ] ) * magic + a [ 1 ] - b [ 1 ] ; map . put ( key , map . getOrDefault ( key , 0 ) + 1 ); } for ( int value : map . values ()) ans = Math . max ( ans , value ); return ans ; } } 836. Rectangle Overlap $\\star$ class Solution { public boolean isRectangleOverlap ( int [] rec1 , int [] rec2 ) { return rec1 [ 0 ] < rec2 [ 2 ] && rec2 [ 0 ] < rec1 [ 2 ] && rec1 [ 1 ] < rec2 [ 3 ] && rec2 [ 1 ] < rec1 [ 3 ] ; } } 837. New 21 Game $\\star\\star$ 838. Push Dominoes $\\star\\star$ class Solution { public String pushDominoes ( String dominoes ) { char [] ans = dominoes . toCharArray (); int L = - 1 ; int R = - 1 ; for ( int i = 0 ; i <= dominoes . length (); ++ i ) if ( i == dominoes . length () || ans [ i ] == 'R' ) { if ( L < R ) while ( R < i ) ans [ R ++] = 'R' ; R = i ; } else if ( ans [ i ] == 'L' ) { if ( R < L || L == - 1 && R == - 1 ) { if ( L == - 1 && R == - 1 ) ++ L ; while ( L < i ) ans [ L ++] = 'L' ; } else { int l = R + 1 ; int r = i - 1 ; while ( l < r ) { ans [ l ++] = 'R' ; ans [ r --] = 'L' ; } } L = i ; } return new String ( ans ); } } 839. Similar String Groups $\\star\\star\\star$ 840. Magic Squares In Grid $\\star$ class Solution { public int numMagicSquaresInside ( int [][] grid ) { int ans = 0 ; for ( int i = 0 ; i + 2 < grid . length ; ++ i ) for ( int j = 0 ; j + 2 < grid [ 0 ] . length ; ++ j ) if ( grid [ i ][ j ] % 2 == 0 && grid [ i + 1 ][ j + 1 ] == 5 ) ans += isMagic ( grid , i , j ); return ans ; } private int isMagic ( int [][] grid , int i , int j ) { String s = new String ( \"\" ); for ( int num : new int [] { 0 , 1 , 2 , 5 , 8 , 7 , 6 , 3 }) s += Integer . toString ( grid [ i + num / 3 ][ j + num % 3 ] ); return new String ( \"4381672943816729\" ). contains ( s ) || new String ( \"9276183492761834\" ). contains ( s ) ? 1 : 0 ; } }","title":"0831-0840"},{"location":"java/0801-0900/0831-0840/#831-masking-personal-information-starstar","text":"class Solution { public String maskPII ( String S ) { int atIndex = S . indexOf ( '@' ); if ( atIndex > 0 ) { S = S . toLowerCase (); return S . charAt ( 0 ) + \"*****\" + S . substring ( atIndex - 1 ); } String ans = \"\" ; for ( char c : S . toCharArray ()) if ( Character . isDigit ( c )) ans += c ; if ( ans . length () == 10 ) return \"***-***-\" + ans . substring ( ans . length () - 4 ); return '+' + new String ( new char [ ans . length () - 10 ] ). replace ( '\\0' , '*' ) + \"-***-***-\" + ans . substring ( ans . length () - 4 ); } }","title":"831. Masking Personal Information $\\star\\star$"},{"location":"java/0801-0900/0831-0840/#832-flipping-an-image-star","text":"class Solution { public int [][] flipAndInvertImage ( int [][] A ) { final int n = A . length ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < ( n + 1 ) / 2 ; ++ j ) { int temp = A [ i ][ j ] ; A [ i ][ j ] = A [ i ][ n - j - 1 ] ^ 1 ; A [ i ][ n - j - 1 ] = temp ^ 1 ; } return A ; } }","title":"832. Flipping an Image $\\star$"},{"location":"java/0801-0900/0831-0840/#833-find-and-replace-in-string-starstar","text":"class Solution { public String findReplaceString ( String S , int [] indexes , String [] sources , String [] targets ) { List < int []> sortedIndexes = new ArrayList <> (); for ( int i = 0 ; i < indexes . length ; ++ i ) sortedIndexes . add ( new int [] { indexes [ i ] , i }); Collections . sort ( sortedIndexes , Comparator . comparing ( i -> - i [ 0 ] )); for ( int [] sortedIndex : sortedIndexes ) { int index = sortedIndex [ 0 ] ; int i = sortedIndex [ 1 ] ; String source = sources [ i ] ; String target = targets [ i ] ; if ( S . substring ( index , index + source . length ()). equals ( source )) S = S . substring ( 0 , index ) + target + S . substring ( index + source . length ()); } return S ; } }","title":"833. Find And Replace in String $\\star\\star$"},{"location":"java/0801-0900/0831-0840/#834-sum-of-distances-in-tree-starstarstar","text":"","title":"834. Sum of Distances in Tree $\\star\\star\\star$"},{"location":"java/0801-0900/0831-0840/#835-image-overlap-starstar","text":"class Solution { public int largestOverlap ( int [][] A , int [][] B ) { final int n = A . length ; final int magic = 100 ; int ans = 0 ; List < int []> onesA = new ArrayList <> (); List < int []> onesB = new ArrayList <> (); Map < Integer , Integer > map = new HashMap <> (); for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { if ( A [ i ][ j ] == 1 ) onesA . add ( new int [] { i , j }); if ( B [ i ][ j ] == 1 ) onesB . add ( new int [] { i , j }); } for ( int [] a : onesA ) for ( int [] b : onesB ) { int key = ( a [ 0 ] - b [ 0 ] ) * magic + a [ 1 ] - b [ 1 ] ; map . put ( key , map . getOrDefault ( key , 0 ) + 1 ); } for ( int value : map . values ()) ans = Math . max ( ans , value ); return ans ; } }","title":"835. Image Overlap $\\star\\star$"},{"location":"java/0801-0900/0831-0840/#836-rectangle-overlap-star","text":"class Solution { public boolean isRectangleOverlap ( int [] rec1 , int [] rec2 ) { return rec1 [ 0 ] < rec2 [ 2 ] && rec2 [ 0 ] < rec1 [ 2 ] && rec1 [ 1 ] < rec2 [ 3 ] && rec2 [ 1 ] < rec1 [ 3 ] ; } }","title":"836. Rectangle Overlap $\\star$"},{"location":"java/0801-0900/0831-0840/#837-new-21-game-starstar","text":"","title":"837. New 21 Game $\\star\\star$"},{"location":"java/0801-0900/0831-0840/#838-push-dominoes-starstar","text":"class Solution { public String pushDominoes ( String dominoes ) { char [] ans = dominoes . toCharArray (); int L = - 1 ; int R = - 1 ; for ( int i = 0 ; i <= dominoes . length (); ++ i ) if ( i == dominoes . length () || ans [ i ] == 'R' ) { if ( L < R ) while ( R < i ) ans [ R ++] = 'R' ; R = i ; } else if ( ans [ i ] == 'L' ) { if ( R < L || L == - 1 && R == - 1 ) { if ( L == - 1 && R == - 1 ) ++ L ; while ( L < i ) ans [ L ++] = 'L' ; } else { int l = R + 1 ; int r = i - 1 ; while ( l < r ) { ans [ l ++] = 'R' ; ans [ r --] = 'L' ; } } L = i ; } return new String ( ans ); } }","title":"838. Push Dominoes $\\star\\star$"},{"location":"java/0801-0900/0831-0840/#839-similar-string-groups-starstarstar","text":"","title":"839. Similar String Groups $\\star\\star\\star$"},{"location":"java/0801-0900/0831-0840/#840-magic-squares-in-grid-star","text":"class Solution { public int numMagicSquaresInside ( int [][] grid ) { int ans = 0 ; for ( int i = 0 ; i + 2 < grid . length ; ++ i ) for ( int j = 0 ; j + 2 < grid [ 0 ] . length ; ++ j ) if ( grid [ i ][ j ] % 2 == 0 && grid [ i + 1 ][ j + 1 ] == 5 ) ans += isMagic ( grid , i , j ); return ans ; } private int isMagic ( int [][] grid , int i , int j ) { String s = new String ( \"\" ); for ( int num : new int [] { 0 , 1 , 2 , 5 , 8 , 7 , 6 , 3 }) s += Integer . toString ( grid [ i + num / 3 ][ j + num % 3 ] ); return new String ( \"4381672943816729\" ). contains ( s ) || new String ( \"9276183492761834\" ). contains ( s ) ? 1 : 0 ; } }","title":"840. Magic Squares In Grid $\\star$"},{"location":"java/0801-0900/0841-0850/","text":"841. Keys and Rooms $\\star\\star$ 842. Split Array into Fibonacci Sequence $\\star\\star$ class Solution { public List < Integer > splitIntoFibonacci ( String S ) { List < Integer > ans = new ArrayList <> (); dfs ( S , 0 , ans ); return ans ; } private boolean dfs ( final String S , int s , List < Integer > ans ) { if ( s == S . length () && ans . size () >= 3 ) return true ; for ( int i = s ; i < S . length (); ++ i ) { if ( S . charAt ( s ) == '0' && i > s ) break ; long num = Long . valueOf ( S . substring ( s , i + 1 )); if ( num > Integer . MAX_VALUE ) break ; if ( ans . size () >= 2 && num > ans . get ( ans . size () - 2 ) + ans . get ( ans . size () - 1 )) break ; if ( ans . size () <= 1 || num == ans . get ( ans . size () - 2 ) + ans . get ( ans . size () - 1 )) { ans . add (( int ) num ); if ( dfs ( S , i + 1 , ans )) return true ; ans . remove ( ans . size () - 1 ); } } return false ; } } 843. Guess the Word $\\star\\star\\star$ 844. Backspace String Compare $\\star$ class Solution { public boolean backspaceCompare ( String S , String T ) { for ( int i = S . length () - 1 , j = T . length () - 1 ; i >= 0 || j >= 0 ; -- i , -- j ) { for ( int backspace = 0 ; i >= 0 && ( S . charAt ( i ) == '#' || backspace > 0 ); -- i ) backspace += S . charAt ( i ) == '#' ? 1 : - 1 ; for ( int backspace = 0 ; j >= 0 && ( T . charAt ( j ) == '#' || backspace > 0 ); -- j ) backspace += T . charAt ( j ) == '#' ? 1 : - 1 ; if ( i >= 0 && j >= 0 && S . charAt ( i ) != T . charAt ( j )) return false ; if ( i < 0 && j >= 0 && T . charAt ( j ) != '#' || j < 0 && i >= 0 && S . charAt ( i ) != '#' ) return false ; } return true ; } } 845. Longest Mountain in Array $\\star\\star$ class Solution { public int longestMountain ( int [] A ) { int ans = 0 ; for ( int i = 0 ; i + 1 < A . length ;) { while ( i + 1 < A . length && A [ i ] == A [ i + 1 ] ) ++ i ; int increasing = 0 ; int decreasing = 0 ; while ( i + 1 < A . length && A [ i ] < A [ i + 1 ] ) { ++ increasing ; ++ i ; } while ( i + 1 < A . length && A [ i ] > A [ i + 1 ] ) { ++ decreasing ; ++ i ; } if ( increasing > 0 && decreasing > 0 ) ans = Math . max ( ans , increasing + decreasing + 1 ); } return ans ; } } 846. Hand of Straights $\\star\\star$ 847. Shortest Path Visiting All Nodes $\\star\\star\\star$ 848. Shifting Letters $\\star\\star$ class Solution { public String shiftingLetters ( String S , int [] shifts ) { StringBuilder ans = new StringBuilder (); for ( int i = shifts . length - 2 ; i >= 0 ; -- i ) shifts [ i ] = ( shifts [ i ] + shifts [ i + 1 ] ) % 26 ; for ( int i = 0 ; i < S . length (); ++ i ) ans . append (( char ) (( S . charAt ( i ) - 'a' + shifts [ i ] ) % 26 + 'a' )); return ans . toString (); } } 849. Maximize Distance to Closest Person $\\star$ class Solution { public int maxDistToClosest ( int [] seats ) { final int n = seats . length ; int ans = 0 ; int j = - 1 ; for ( int i = 0 ; i < n ; ++ i ) if ( seats [ i ] == 1 ) { ans = j == - 1 ? i : Math . max ( ans , ( i - j ) / 2 ); j = i ; } return Math . max ( ans , n - j - 1 ); } } 850. Rectangle Area II $\\star\\star\\star$","title":"0841-0850"},{"location":"java/0801-0900/0841-0850/#841-keys-and-rooms-starstar","text":"","title":"841. Keys and Rooms $\\star\\star$"},{"location":"java/0801-0900/0841-0850/#842-split-array-into-fibonacci-sequence-starstar","text":"class Solution { public List < Integer > splitIntoFibonacci ( String S ) { List < Integer > ans = new ArrayList <> (); dfs ( S , 0 , ans ); return ans ; } private boolean dfs ( final String S , int s , List < Integer > ans ) { if ( s == S . length () && ans . size () >= 3 ) return true ; for ( int i = s ; i < S . length (); ++ i ) { if ( S . charAt ( s ) == '0' && i > s ) break ; long num = Long . valueOf ( S . substring ( s , i + 1 )); if ( num > Integer . MAX_VALUE ) break ; if ( ans . size () >= 2 && num > ans . get ( ans . size () - 2 ) + ans . get ( ans . size () - 1 )) break ; if ( ans . size () <= 1 || num == ans . get ( ans . size () - 2 ) + ans . get ( ans . size () - 1 )) { ans . add (( int ) num ); if ( dfs ( S , i + 1 , ans )) return true ; ans . remove ( ans . size () - 1 ); } } return false ; } }","title":"842. Split Array into Fibonacci Sequence $\\star\\star$"},{"location":"java/0801-0900/0841-0850/#843-guess-the-word-starstarstar","text":"","title":"843. Guess the Word $\\star\\star\\star$"},{"location":"java/0801-0900/0841-0850/#844-backspace-string-compare-star","text":"class Solution { public boolean backspaceCompare ( String S , String T ) { for ( int i = S . length () - 1 , j = T . length () - 1 ; i >= 0 || j >= 0 ; -- i , -- j ) { for ( int backspace = 0 ; i >= 0 && ( S . charAt ( i ) == '#' || backspace > 0 ); -- i ) backspace += S . charAt ( i ) == '#' ? 1 : - 1 ; for ( int backspace = 0 ; j >= 0 && ( T . charAt ( j ) == '#' || backspace > 0 ); -- j ) backspace += T . charAt ( j ) == '#' ? 1 : - 1 ; if ( i >= 0 && j >= 0 && S . charAt ( i ) != T . charAt ( j )) return false ; if ( i < 0 && j >= 0 && T . charAt ( j ) != '#' || j < 0 && i >= 0 && S . charAt ( i ) != '#' ) return false ; } return true ; } }","title":"844. Backspace String Compare $\\star$"},{"location":"java/0801-0900/0841-0850/#845-longest-mountain-in-array-starstar","text":"class Solution { public int longestMountain ( int [] A ) { int ans = 0 ; for ( int i = 0 ; i + 1 < A . length ;) { while ( i + 1 < A . length && A [ i ] == A [ i + 1 ] ) ++ i ; int increasing = 0 ; int decreasing = 0 ; while ( i + 1 < A . length && A [ i ] < A [ i + 1 ] ) { ++ increasing ; ++ i ; } while ( i + 1 < A . length && A [ i ] > A [ i + 1 ] ) { ++ decreasing ; ++ i ; } if ( increasing > 0 && decreasing > 0 ) ans = Math . max ( ans , increasing + decreasing + 1 ); } return ans ; } }","title":"845. Longest Mountain in Array $\\star\\star$"},{"location":"java/0801-0900/0841-0850/#846-hand-of-straights-starstar","text":"","title":"846. Hand of Straights $\\star\\star$"},{"location":"java/0801-0900/0841-0850/#847-shortest-path-visiting-all-nodes-starstarstar","text":"","title":"847. Shortest Path Visiting All Nodes $\\star\\star\\star$"},{"location":"java/0801-0900/0841-0850/#848-shifting-letters-starstar","text":"class Solution { public String shiftingLetters ( String S , int [] shifts ) { StringBuilder ans = new StringBuilder (); for ( int i = shifts . length - 2 ; i >= 0 ; -- i ) shifts [ i ] = ( shifts [ i ] + shifts [ i + 1 ] ) % 26 ; for ( int i = 0 ; i < S . length (); ++ i ) ans . append (( char ) (( S . charAt ( i ) - 'a' + shifts [ i ] ) % 26 + 'a' )); return ans . toString (); } }","title":"848. Shifting Letters $\\star\\star$"},{"location":"java/0801-0900/0841-0850/#849-maximize-distance-to-closest-person-star","text":"class Solution { public int maxDistToClosest ( int [] seats ) { final int n = seats . length ; int ans = 0 ; int j = - 1 ; for ( int i = 0 ; i < n ; ++ i ) if ( seats [ i ] == 1 ) { ans = j == - 1 ? i : Math . max ( ans , ( i - j ) / 2 ); j = i ; } return Math . max ( ans , n - j - 1 ); } }","title":"849. Maximize Distance to Closest Person $\\star$"},{"location":"java/0801-0900/0841-0850/#850-rectangle-area-ii-starstarstar","text":"","title":"850. Rectangle Area II $\\star\\star\\star$"},{"location":"java/0801-0900/0851-0860/","text":"851. Loud and Rich $\\star\\star$ 852. Peak Index in a Mountain Array $\\star$ 853. Car Fleet $\\star\\star$ 854. K-Similar Strings $\\star\\star\\star$ 855. Exam Room $\\star\\star$ 856. Score of Parentheses $\\star\\star$ class Solution { public int scoreOfParentheses ( String S ) { int ans = 0 ; int layer = 0 ; for ( int i = 0 ; i < S . length (); ++ i ) { layer += S . charAt ( i ) == '(' ? 1 : - 1 ; if ( S . charAt ( i ) == ')' && S . charAt ( i - 1 ) == '(' ) ans += 1 << layer ; } return ans ; } } 857. Minimum Cost to Hire K Workers $\\star\\star\\star$ 858. Mirror Reflection $\\star\\star$ class Solution { public int mirrorReflection ( int p , int q ) { int m = 1 ; int n = 1 ; while ( m * p != n * q ) m = ++ n * q / p ; if ( m % 2 == 0 && n % 2 == 1 ) return 0 ; if ( m % 2 == 1 && n % 2 == 1 ) return 1 ; if ( m % 2 == 1 && n % 2 == 0 ) return 2 ; throw new IllegalArgumentException (); } } 859. Buddy Strings $\\star$ class Solution { public boolean buddyStrings ( String A , String B ) { if ( A . length () != B . length ()) return false ; if ( A . equals ( B )) { Set < Character > set = new HashSet <> (); for ( char c : A . toCharArray ()) set . add ( c ); return set . size () < A . length (); } List < Integer > diff = new ArrayList <> (); for ( int i = 0 ; i < A . length (); ++ i ) if ( A . charAt ( i ) != B . charAt ( i )) diff . add ( i ); return diff . size () == 2 && A . charAt ( diff . get ( 0 )) == B . charAt ( diff . get ( 1 )) && A . charAt ( diff . get ( 1 )) == B . charAt ( diff . get ( 0 )); } } 860. Lemonade Change $\\star$","title":"0851-0860"},{"location":"java/0801-0900/0851-0860/#851-loud-and-rich-starstar","text":"","title":"851. Loud and Rich $\\star\\star$"},{"location":"java/0801-0900/0851-0860/#852-peak-index-in-a-mountain-array-star","text":"","title":"852. Peak Index in a Mountain Array $\\star$"},{"location":"java/0801-0900/0851-0860/#853-car-fleet-starstar","text":"","title":"853. Car Fleet $\\star\\star$"},{"location":"java/0801-0900/0851-0860/#854-k-similar-strings-starstarstar","text":"","title":"854. K-Similar Strings $\\star\\star\\star$"},{"location":"java/0801-0900/0851-0860/#855-exam-room-starstar","text":"","title":"855. Exam Room $\\star\\star$"},{"location":"java/0801-0900/0851-0860/#856-score-of-parentheses-starstar","text":"class Solution { public int scoreOfParentheses ( String S ) { int ans = 0 ; int layer = 0 ; for ( int i = 0 ; i < S . length (); ++ i ) { layer += S . charAt ( i ) == '(' ? 1 : - 1 ; if ( S . charAt ( i ) == ')' && S . charAt ( i - 1 ) == '(' ) ans += 1 << layer ; } return ans ; } }","title":"856. Score of Parentheses $\\star\\star$"},{"location":"java/0801-0900/0851-0860/#857-minimum-cost-to-hire-k-workers-starstarstar","text":"","title":"857. Minimum Cost to Hire K Workers $\\star\\star\\star$"},{"location":"java/0801-0900/0851-0860/#858-mirror-reflection-starstar","text":"class Solution { public int mirrorReflection ( int p , int q ) { int m = 1 ; int n = 1 ; while ( m * p != n * q ) m = ++ n * q / p ; if ( m % 2 == 0 && n % 2 == 1 ) return 0 ; if ( m % 2 == 1 && n % 2 == 1 ) return 1 ; if ( m % 2 == 1 && n % 2 == 0 ) return 2 ; throw new IllegalArgumentException (); } }","title":"858. Mirror Reflection $\\star\\star$"},{"location":"java/0801-0900/0851-0860/#859-buddy-strings-star","text":"class Solution { public boolean buddyStrings ( String A , String B ) { if ( A . length () != B . length ()) return false ; if ( A . equals ( B )) { Set < Character > set = new HashSet <> (); for ( char c : A . toCharArray ()) set . add ( c ); return set . size () < A . length (); } List < Integer > diff = new ArrayList <> (); for ( int i = 0 ; i < A . length (); ++ i ) if ( A . charAt ( i ) != B . charAt ( i )) diff . add ( i ); return diff . size () == 2 && A . charAt ( diff . get ( 0 )) == B . charAt ( diff . get ( 1 )) && A . charAt ( diff . get ( 1 )) == B . charAt ( diff . get ( 0 )); } }","title":"859. Buddy Strings $\\star$"},{"location":"java/0801-0900/0851-0860/#860-lemonade-change-star","text":"","title":"860. Lemonade Change $\\star$"},{"location":"java/0801-0900/0861-0870/","text":"861. Score After Flipping Matrix $\\star\\star$ 862. Shortest Subarray with Sum at Least K $\\star\\star\\star$ class Solution { public int shortestSubarray ( int [] A , int K ) { final int n = A . length ; int ans = n + 1 ; Deque < Integer > deque = new ArrayDeque <> (); int [] prefixSum = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; ++ i ) prefixSum [ i + 1 ] = prefixSum [ i ] + A [ i ] ; for ( int i = 0 ; i < n + 1 ; ++ i ) { while ( ! deque . isEmpty () && prefixSum [ i ] - prefixSum [ deque . getFirst () ] >= K ) ans = Math . min ( ans , i - deque . pollFirst ()); while ( ! deque . isEmpty () && prefixSum [ i ] <= prefixSum [ deque . getLast () ] ) deque . pollLast (); deque . addLast ( i ); } return ans <= n ? ans : - 1 ; } } 863. All Nodes Distance K in Binary Tree $\\star\\star$ 864. Shortest Path to Get All Keys $\\star\\star\\star$ 865. Smallest Subtree with all the Deepest Nodes $\\star\\star$ 866. Prime Palindrome $\\star\\star$ class Solution { public int primePalindrome ( int N ) { if ( N <= 2 ) return 2 ; if ( N == 3 ) return 3 ; if ( N <= 5 ) return 5 ; if ( N <= 7 ) return 7 ; if ( N <= 11 ) return 11 ; int n = String . valueOf ( N ). length (); while ( true ) { for ( int num : getPalindromes ( n )) if ( num >= N && isPrime ( num )) return num ; ++ n ; } } private List < Integer > getPalindromes ( int n ) { List < Integer > palindromes = new ArrayList <> (); int length = n / 2 ; for ( int i = ( int ) Math . pow ( 10 , length - 1 ); i < ( int ) Math . pow ( 10 , length ); ++ i ) { String s = String . valueOf ( i ); String reversedS = new StringBuilder ( s ). reverse (). toString (); for ( int j = 0 ; j < 10 ; ++ j ) palindromes . add ( Integer . valueOf ( s + String . valueOf ( j ) + reversedS )); } return palindromes ; } private boolean isPrime ( int num ) { for ( int i = 2 ; i < ( int ) Math . sqrt ( num ) + 1 ; ++ i ) if ( num % i == 0 ) return false ; return true ; } } 867. Transpose Matrix $\\star$ class Solution { public int [][] transpose ( int [][] A ) { int [][] ans = new int [ A [ 0 ] . length ][ A . length ] ; for ( int i = 0 ; i < A . length ; ++ i ) for ( int j = 0 ; j < A [ 0 ] . length ; ++ j ) ans [ j ][ i ] = A [ i ][ j ] ; return ans ; } } 868. Binary Gap $\\star$ class Solution { public int binaryGap ( int N ) { int ans = 0 ; int prevOneIndex = 30 ; for ( int n = N , i = 0 ; n > 0 ; n >>= 1 , ++ i ) if ( n % 2 == 1 ) { ans = Math . max ( ans , i - prevOneIndex ); prevOneIndex = i ; } return ans ; } } 869. Reordered Power of 2 $\\star\\star$ class Solution { public boolean reorderedPowerOf2 ( int N ) { int count = counter ( N ); for ( int i = 0 ; i < 30 ; ++ i ) if ( counter ( 1 << i ) == count ) return true ; return false ; } private int counter ( int n ) { int count = 0 ; for (; n > 0 ; n /= 10 ) count += Math . pow ( 10 , n % 10 ); return count ; } } 870. Advantage Shuffle $\\star\\star$ class Solution { public int [] advantageCount ( int [] A , int [] B ) { TreeMap < Integer , Integer > map = new TreeMap <> (); for ( int a : A ) map . put ( a , map . getOrDefault ( a , 0 ) + 1 ); for ( int i = 0 ; i < B . length ; i ++ ) { Integer key = map . higherKey ( B [ i ] ); if ( key == null ) key = map . firstKey (); map . put ( key , map . get ( key ) - 1 ); if ( map . get ( key ) == 0 ) map . remove ( key ); A [ i ] = key ; } return A ; } }","title":"0861-0870"},{"location":"java/0801-0900/0861-0870/#861-score-after-flipping-matrix-starstar","text":"","title":"861. Score After Flipping Matrix $\\star\\star$"},{"location":"java/0801-0900/0861-0870/#862-shortest-subarray-with-sum-at-least-k-starstarstar","text":"class Solution { public int shortestSubarray ( int [] A , int K ) { final int n = A . length ; int ans = n + 1 ; Deque < Integer > deque = new ArrayDeque <> (); int [] prefixSum = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; ++ i ) prefixSum [ i + 1 ] = prefixSum [ i ] + A [ i ] ; for ( int i = 0 ; i < n + 1 ; ++ i ) { while ( ! deque . isEmpty () && prefixSum [ i ] - prefixSum [ deque . getFirst () ] >= K ) ans = Math . min ( ans , i - deque . pollFirst ()); while ( ! deque . isEmpty () && prefixSum [ i ] <= prefixSum [ deque . getLast () ] ) deque . pollLast (); deque . addLast ( i ); } return ans <= n ? ans : - 1 ; } }","title":"862. Shortest Subarray with Sum at Least K $\\star\\star\\star$"},{"location":"java/0801-0900/0861-0870/#863-all-nodes-distance-k-in-binary-tree-starstar","text":"","title":"863. All Nodes Distance K in Binary Tree $\\star\\star$"},{"location":"java/0801-0900/0861-0870/#864-shortest-path-to-get-all-keys-starstarstar","text":"","title":"864. Shortest Path to Get All Keys $\\star\\star\\star$"},{"location":"java/0801-0900/0861-0870/#865-smallest-subtree-with-all-the-deepest-nodes-starstar","text":"","title":"865. Smallest Subtree with all the Deepest Nodes $\\star\\star$"},{"location":"java/0801-0900/0861-0870/#866-prime-palindrome-starstar","text":"class Solution { public int primePalindrome ( int N ) { if ( N <= 2 ) return 2 ; if ( N == 3 ) return 3 ; if ( N <= 5 ) return 5 ; if ( N <= 7 ) return 7 ; if ( N <= 11 ) return 11 ; int n = String . valueOf ( N ). length (); while ( true ) { for ( int num : getPalindromes ( n )) if ( num >= N && isPrime ( num )) return num ; ++ n ; } } private List < Integer > getPalindromes ( int n ) { List < Integer > palindromes = new ArrayList <> (); int length = n / 2 ; for ( int i = ( int ) Math . pow ( 10 , length - 1 ); i < ( int ) Math . pow ( 10 , length ); ++ i ) { String s = String . valueOf ( i ); String reversedS = new StringBuilder ( s ). reverse (). toString (); for ( int j = 0 ; j < 10 ; ++ j ) palindromes . add ( Integer . valueOf ( s + String . valueOf ( j ) + reversedS )); } return palindromes ; } private boolean isPrime ( int num ) { for ( int i = 2 ; i < ( int ) Math . sqrt ( num ) + 1 ; ++ i ) if ( num % i == 0 ) return false ; return true ; } }","title":"866. Prime Palindrome $\\star\\star$"},{"location":"java/0801-0900/0861-0870/#867-transpose-matrix-star","text":"class Solution { public int [][] transpose ( int [][] A ) { int [][] ans = new int [ A [ 0 ] . length ][ A . length ] ; for ( int i = 0 ; i < A . length ; ++ i ) for ( int j = 0 ; j < A [ 0 ] . length ; ++ j ) ans [ j ][ i ] = A [ i ][ j ] ; return ans ; } }","title":"867. Transpose Matrix $\\star$"},{"location":"java/0801-0900/0861-0870/#868-binary-gap-star","text":"class Solution { public int binaryGap ( int N ) { int ans = 0 ; int prevOneIndex = 30 ; for ( int n = N , i = 0 ; n > 0 ; n >>= 1 , ++ i ) if ( n % 2 == 1 ) { ans = Math . max ( ans , i - prevOneIndex ); prevOneIndex = i ; } return ans ; } }","title":"868. Binary Gap $\\star$"},{"location":"java/0801-0900/0861-0870/#869-reordered-power-of-2-starstar","text":"class Solution { public boolean reorderedPowerOf2 ( int N ) { int count = counter ( N ); for ( int i = 0 ; i < 30 ; ++ i ) if ( counter ( 1 << i ) == count ) return true ; return false ; } private int counter ( int n ) { int count = 0 ; for (; n > 0 ; n /= 10 ) count += Math . pow ( 10 , n % 10 ); return count ; } }","title":"869. Reordered Power of 2 $\\star\\star$"},{"location":"java/0801-0900/0861-0870/#870-advantage-shuffle-starstar","text":"class Solution { public int [] advantageCount ( int [] A , int [] B ) { TreeMap < Integer , Integer > map = new TreeMap <> (); for ( int a : A ) map . put ( a , map . getOrDefault ( a , 0 ) + 1 ); for ( int i = 0 ; i < B . length ; i ++ ) { Integer key = map . higherKey ( B [ i ] ); if ( key == null ) key = map . firstKey (); map . put ( key , map . get ( key ) - 1 ); if ( map . get ( key ) == 0 ) map . remove ( key ); A [ i ] = key ; } return A ; } }","title":"870. Advantage Shuffle $\\star\\star$"},{"location":"java/0801-0900/0871-0880/","text":"871. Minimum Number of Refueling Stops $\\star\\star\\star$ 872. Leaf-Similar Trees $\\star$ 873. Length of Longest Fibonacci Subsequence $\\star\\star$ class Solution { public int lenLongestFibSubseq ( int [] A ) { final int n = A . length ; int ans = 0 ; Map < Integer , Integer > indices = new HashMap <> (); int [][] dp = new int [ n ][ n ] ; for ( int i = 0 ; i < n ; ++ i ) indices . put ( A [ i ] , i ); for ( int [] row : dp ) Arrays . fill ( row , 2 ); for ( int j = 0 ; j < n ; ++ j ) for ( int k = j + 1 ; k < n ; ++ k ) { int ai = A [ k ] - A [ j ] ; if ( ai < A [ j ] && indices . containsKey ( ai )) { int i = indices . get ( ai ); dp [ j ][ k ] = dp [ i ][ j ] + 1 ; ans = Math . max ( ans , dp [ j ][ k ] ); } } return ans ; } } 874. Walking Robot Simulation $\\star$ 875. Koko Eating Bananas $\\star\\star$ 876. Middle of the Linked List $\\star$ class Solution { public ListNode middleNode ( ListNode head ) { ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; } return slow ; } } 877. Stone Game $\\star\\star$ class Solution { public boolean stoneGame ( int [] piles ) { final int n = piles . length ; int [] dp = Arrays . copyOf ( piles , n ); for ( int d = 1 ; d < n ; ++ d ) for ( int i = n - d - 1 ; i >= 0 ; -- i ) dp [ i + d ] = Math . max ( piles [ i ] - dp [ i + d ] , piles [ i + d ] - dp [ i + d - 1 ] ); return dp [ n - 1 ] > 0 ; } } 878. Nth Magical Number $\\star\\star\\star$ class Solution { public int nthMagicalNumber ( long N , long A , long B ) { final long kMod = ( long ) 1e9 + 7 ; long lcm = A * B / gcd ( A , B ); long l = Math . min ( A , B ); long r = Math . min ( A , B ) * N ; while ( l < r ) { long m = l + ( r - l ) / 2 ; if ( m / A + m / B - m / lcm < N ) l = m + 1 ; else r = m ; } return ( int ) ( l % kMod ); } private long gcd ( long a , long b ) { return b == 0 ? a : gcd ( b , a % b ); } } 879. Profitable Schemes $\\star\\star\\star$ 880. Decoded String at Index $\\star\\star$","title":"0871-0880"},{"location":"java/0801-0900/0871-0880/#871-minimum-number-of-refueling-stops-starstarstar","text":"","title":"871. Minimum Number of Refueling Stops $\\star\\star\\star$"},{"location":"java/0801-0900/0871-0880/#872-leaf-similar-trees-star","text":"","title":"872. Leaf-Similar Trees $\\star$"},{"location":"java/0801-0900/0871-0880/#873-length-of-longest-fibonacci-subsequence-starstar","text":"class Solution { public int lenLongestFibSubseq ( int [] A ) { final int n = A . length ; int ans = 0 ; Map < Integer , Integer > indices = new HashMap <> (); int [][] dp = new int [ n ][ n ] ; for ( int i = 0 ; i < n ; ++ i ) indices . put ( A [ i ] , i ); for ( int [] row : dp ) Arrays . fill ( row , 2 ); for ( int j = 0 ; j < n ; ++ j ) for ( int k = j + 1 ; k < n ; ++ k ) { int ai = A [ k ] - A [ j ] ; if ( ai < A [ j ] && indices . containsKey ( ai )) { int i = indices . get ( ai ); dp [ j ][ k ] = dp [ i ][ j ] + 1 ; ans = Math . max ( ans , dp [ j ][ k ] ); } } return ans ; } }","title":"873. Length of Longest Fibonacci Subsequence $\\star\\star$"},{"location":"java/0801-0900/0871-0880/#874-walking-robot-simulation-star","text":"","title":"874. Walking Robot Simulation $\\star$"},{"location":"java/0801-0900/0871-0880/#875-koko-eating-bananas-starstar","text":"","title":"875. Koko Eating Bananas $\\star\\star$"},{"location":"java/0801-0900/0871-0880/#876-middle-of-the-linked-list-star","text":"class Solution { public ListNode middleNode ( ListNode head ) { ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; } return slow ; } }","title":"876. Middle of the Linked List $\\star$"},{"location":"java/0801-0900/0871-0880/#877-stone-game-starstar","text":"class Solution { public boolean stoneGame ( int [] piles ) { final int n = piles . length ; int [] dp = Arrays . copyOf ( piles , n ); for ( int d = 1 ; d < n ; ++ d ) for ( int i = n - d - 1 ; i >= 0 ; -- i ) dp [ i + d ] = Math . max ( piles [ i ] - dp [ i + d ] , piles [ i + d ] - dp [ i + d - 1 ] ); return dp [ n - 1 ] > 0 ; } }","title":"877. Stone Game $\\star\\star$"},{"location":"java/0801-0900/0871-0880/#878-nth-magical-number-starstarstar","text":"class Solution { public int nthMagicalNumber ( long N , long A , long B ) { final long kMod = ( long ) 1e9 + 7 ; long lcm = A * B / gcd ( A , B ); long l = Math . min ( A , B ); long r = Math . min ( A , B ) * N ; while ( l < r ) { long m = l + ( r - l ) / 2 ; if ( m / A + m / B - m / lcm < N ) l = m + 1 ; else r = m ; } return ( int ) ( l % kMod ); } private long gcd ( long a , long b ) { return b == 0 ? a : gcd ( b , a % b ); } }","title":"878. Nth Magical Number $\\star\\star\\star$"},{"location":"java/0801-0900/0871-0880/#879-profitable-schemes-starstarstar","text":"","title":"879. Profitable Schemes $\\star\\star\\star$"},{"location":"java/0801-0900/0871-0880/#880-decoded-string-at-index-starstar","text":"","title":"880. Decoded String at Index $\\star\\star$"},{"location":"java/0801-0900/0881-0890/","text":"881. Boats to Save People $\\star\\star$ class Solution { public int numRescueBoats ( int [] people , int limit ) { int ans = 0 ; Arrays . sort ( people ); for ( int i = 0 , j = people . length - 1 ; i <= j ; ++ ans ) { int remain = limit - people [ j --] ; if ( people [ i ] <= remain ) ++ i ; } return ans ; } } 882. Reachable Nodes In Subdivided Graph $\\star\\star\\star$ 883. Projection Area of 3D Shapes $\\star$ class Solution { public int projectionArea ( int [][] grid ) { int ans = 0 ; for ( int i = 0 ; i < grid . length ; ++ i ) { int maxOfRow = 0 ; int maxOfCol = 0 ; for ( int j = 0 ; j < grid . length ; ++ j ) { maxOfRow = Math . max ( maxOfRow , grid [ i ][ j ] ); maxOfCol = Math . max ( maxOfCol , grid [ j ][ i ] ); if ( grid [ i ][ j ] > 0 ) ++ ans ; } ans += maxOfRow + maxOfCol ; } return ans ; } } 884. Uncommon Words from Two Sentences $\\star$ class Solution { public String [] uncommonFromSentences ( String A , String B ) { List < String > ans = new ArrayList <> (); Map < String , Integer > count = new HashMap <> (); for ( final String word : ( A + ' ' + B ). split ( \" \" )) count . put ( word , count . getOrDefault ( word , 0 ) + 1 ); for ( final String word : count . keySet ()) if ( count . get ( word ) == 1 ) ans . add ( word ); return ans . toArray ( new String [ 0 ] ); } } 885. Spiral Matrix III $\\star\\star$ class Solution { public int [][] spiralMatrixIII ( int R , int C , int r0 , int c0 ) { List < int []> ans = new ArrayList <> (); int [] dx = new int [] { 1 , 0 , - 1 , 0 }; int [] dy = new int [] { 0 , 1 , 0 , - 1 }; ans . add ( new int [] { r0 , c0 }); for ( int i = 0 ; ans . size () < R * C ; ++ i ) for ( int step = 0 ; step < i / 2 + 1 ; ++ step ) { r0 += dy [ i % 4 ] ; c0 += dx [ i % 4 ] ; if ( 0 <= r0 && r0 < R && 0 <= c0 && c0 < C ) ans . add ( new int [] { r0 , c0 }); } return ans . toArray ( new int [ ans . size () ][] ); } } 886. Possible Bipartition $\\star\\star$ 887. Super Egg Drop $\\star\\star\\star$ class Solution { public int superEggDrop ( int K , int N ) { int moves = 0 ; int [][] dp = new int [ N + 1 ][ K + 1 ] ; while ( dp [ moves ][ K ] < N ) { ++ moves ; for ( int eggs = 1 ; eggs <= K ; ++ eggs ) dp [ moves ][ eggs ] = dp [ moves - 1 ][ eggs - 1 ] + dp [ moves - 1 ][ eggs ] + 1 ; } return moves ; } } 888. Fair Candy Swap $\\star$ class Solution { public int [] fairCandySwap ( int [] A , int [] B ) { int diff = ( IntStream . of ( A ). sum () - IntStream . of ( B ). sum ()) / 2 ; Set < Integer > set = new HashSet <> (); for ( int b : B ) set . add ( b ); for ( int a : A ) if ( set . contains ( a - diff )) return new int [] { a , a - diff }; throw new IllegalArgumentException (); } } 889. Construct Binary Tree from Preorder and Postorder Traversal $\\star\\star$ 890. Find and Replace Pattern $\\star\\star$ class Solution { public List < String > findAndReplacePattern ( String [] words , String pattern ) { List < String > ans = new ArrayList <> (); for ( final String word : words ) if ( isIsomorphic ( word , pattern )) ans . add ( word ); return ans ; } private boolean isIsomorphic ( final String w , final String p ) { Map < Character , Integer > map_w = new HashMap <> (); Map < Character , Integer > map_p = new HashMap <> (); for ( Integer i = 0 ; i < w . length (); ++ i ) if ( map_w . put ( w . charAt ( i ), i ) != map_p . put ( p . charAt ( i ), i )) return false ; return true ; } }","title":"0881-0890"},{"location":"java/0801-0900/0881-0890/#881-boats-to-save-people-starstar","text":"class Solution { public int numRescueBoats ( int [] people , int limit ) { int ans = 0 ; Arrays . sort ( people ); for ( int i = 0 , j = people . length - 1 ; i <= j ; ++ ans ) { int remain = limit - people [ j --] ; if ( people [ i ] <= remain ) ++ i ; } return ans ; } }","title":"881. Boats to Save People $\\star\\star$"},{"location":"java/0801-0900/0881-0890/#882-reachable-nodes-in-subdivided-graph-starstarstar","text":"","title":"882. Reachable Nodes In Subdivided Graph $\\star\\star\\star$"},{"location":"java/0801-0900/0881-0890/#883-projection-area-of-3d-shapes-star","text":"class Solution { public int projectionArea ( int [][] grid ) { int ans = 0 ; for ( int i = 0 ; i < grid . length ; ++ i ) { int maxOfRow = 0 ; int maxOfCol = 0 ; for ( int j = 0 ; j < grid . length ; ++ j ) { maxOfRow = Math . max ( maxOfRow , grid [ i ][ j ] ); maxOfCol = Math . max ( maxOfCol , grid [ j ][ i ] ); if ( grid [ i ][ j ] > 0 ) ++ ans ; } ans += maxOfRow + maxOfCol ; } return ans ; } }","title":"883. Projection Area of 3D Shapes $\\star$"},{"location":"java/0801-0900/0881-0890/#884-uncommon-words-from-two-sentences-star","text":"class Solution { public String [] uncommonFromSentences ( String A , String B ) { List < String > ans = new ArrayList <> (); Map < String , Integer > count = new HashMap <> (); for ( final String word : ( A + ' ' + B ). split ( \" \" )) count . put ( word , count . getOrDefault ( word , 0 ) + 1 ); for ( final String word : count . keySet ()) if ( count . get ( word ) == 1 ) ans . add ( word ); return ans . toArray ( new String [ 0 ] ); } }","title":"884. Uncommon Words from Two Sentences $\\star$"},{"location":"java/0801-0900/0881-0890/#885-spiral-matrix-iii-starstar","text":"class Solution { public int [][] spiralMatrixIII ( int R , int C , int r0 , int c0 ) { List < int []> ans = new ArrayList <> (); int [] dx = new int [] { 1 , 0 , - 1 , 0 }; int [] dy = new int [] { 0 , 1 , 0 , - 1 }; ans . add ( new int [] { r0 , c0 }); for ( int i = 0 ; ans . size () < R * C ; ++ i ) for ( int step = 0 ; step < i / 2 + 1 ; ++ step ) { r0 += dy [ i % 4 ] ; c0 += dx [ i % 4 ] ; if ( 0 <= r0 && r0 < R && 0 <= c0 && c0 < C ) ans . add ( new int [] { r0 , c0 }); } return ans . toArray ( new int [ ans . size () ][] ); } }","title":"885. Spiral Matrix III $\\star\\star$"},{"location":"java/0801-0900/0881-0890/#886-possible-bipartition-starstar","text":"","title":"886. Possible Bipartition $\\star\\star$"},{"location":"java/0801-0900/0881-0890/#887-super-egg-drop-starstarstar","text":"class Solution { public int superEggDrop ( int K , int N ) { int moves = 0 ; int [][] dp = new int [ N + 1 ][ K + 1 ] ; while ( dp [ moves ][ K ] < N ) { ++ moves ; for ( int eggs = 1 ; eggs <= K ; ++ eggs ) dp [ moves ][ eggs ] = dp [ moves - 1 ][ eggs - 1 ] + dp [ moves - 1 ][ eggs ] + 1 ; } return moves ; } }","title":"887. Super Egg Drop $\\star\\star\\star$"},{"location":"java/0801-0900/0881-0890/#888-fair-candy-swap-star","text":"class Solution { public int [] fairCandySwap ( int [] A , int [] B ) { int diff = ( IntStream . of ( A ). sum () - IntStream . of ( B ). sum ()) / 2 ; Set < Integer > set = new HashSet <> (); for ( int b : B ) set . add ( b ); for ( int a : A ) if ( set . contains ( a - diff )) return new int [] { a , a - diff }; throw new IllegalArgumentException (); } }","title":"888. Fair Candy Swap $\\star$"},{"location":"java/0801-0900/0881-0890/#889-construct-binary-tree-from-preorder-and-postorder-traversal-starstar","text":"","title":"889. Construct Binary Tree from Preorder and Postorder Traversal $\\star\\star$"},{"location":"java/0801-0900/0881-0890/#890-find-and-replace-pattern-starstar","text":"class Solution { public List < String > findAndReplacePattern ( String [] words , String pattern ) { List < String > ans = new ArrayList <> (); for ( final String word : words ) if ( isIsomorphic ( word , pattern )) ans . add ( word ); return ans ; } private boolean isIsomorphic ( final String w , final String p ) { Map < Character , Integer > map_w = new HashMap <> (); Map < Character , Integer > map_p = new HashMap <> (); for ( Integer i = 0 ; i < w . length (); ++ i ) if ( map_w . put ( w . charAt ( i ), i ) != map_p . put ( p . charAt ( i ), i )) return false ; return true ; } }","title":"890. Find and Replace Pattern $\\star\\star$"},{"location":"java/0801-0900/0891-0900/","text":"891. Sum of Subsequence Widths $\\star\\star\\star$ class Solution { public int sumSubseqWidths ( int [] A ) { final int n = A . length ; final int kMod = ( int ) 1e9 + 7 ; long ans = 0 ; long exp = 1 ; Arrays . sort ( A ); for ( int i = 0 ; i < n ; ++ i , exp = exp * 2 % kMod ) ans = ( ans + A [ i ] * exp - A [ n - i - 1 ] * exp ) % kMod ; return ( int ) ans ; } } 892. Surface Area of 3D Shapes $\\star$ class Solution { public int surfaceArea ( int [][] grid ) { int ans = 0 ; for ( int i = 0 ; i < grid . length ; ++ i ) for ( int j = 0 ; j < grid . length ; ++ j ) { if ( grid [ i ][ j ] > 0 ) ans += grid [ i ][ j ] * 4 + 2 ; if ( i > 0 ) ans -= Math . min ( grid [ i ][ j ] , grid [ i - 1 ][ j ] ) * 2 ; if ( j > 0 ) ans -= Math . min ( grid [ i ][ j ] , grid [ i ][ j - 1 ] ) * 2 ; } return ans ; } } 893. Groups of Special-Equivalent Strings $\\star$ class Solution { public int numSpecialEquivGroups ( String [] A ) { Set < String > set = new HashSet <> (); for ( final String s : A ) { String even = \"\" ; String odd = \"\" ; for ( int i = 0 ; i < s . length (); ++ i ) if ( i % 2 == 0 ) even += s . charAt ( i ); else odd += s . charAt ( i ); char [] evenCharArray = even . toCharArray (); char [] oddCharArray = odd . toCharArray (); Arrays . sort ( evenCharArray ); Arrays . sort ( oddCharArray ); set . add ( new String ( evenCharArray ) + new String ( oddCharArray )); } return set . size (); } } 894. All Possible Full Binary Trees $\\star\\star$ 895. Maximum Frequency Stack $\\star\\star\\star$ class FreqStack { public void push ( int x ) { count . put ( x , count . getOrDefault ( x , 0 ) + 1 ); maxFreq = Math . max ( maxFreq , count . get ( x )); if ( ! countToStack . containsKey ( count . get ( x ))) countToStack . put ( count . get ( x ), new Stack <> ()); countToStack . get ( count . get ( x )). add ( x ); } public int pop () { int value = countToStack . get ( maxFreq ). pop (); count . put ( value , count . get ( value ) - 1 ); if ( countToStack . get ( maxFreq ). isEmpty ()) -- maxFreq ; return value ; } private int maxFreq = 0 ; private Map < Integer , Integer > count = new HashMap <> (); private Map < Integer , Stack < Integer >> countToStack = new HashMap <> (); } 896. Monotonic Array $\\star$ class Solution { public boolean isMonotonic ( int [] A ) { boolean increasing = true ; boolean decreasing = true ; for ( int i = 1 ; i < A . length ; ++ i ) { increasing &= A [ i - 1 ] <= A [ i ] ; decreasing &= A [ i - 1 ] >= A [ i ] ; } return increasing || decreasing ; } } 897. Increasing Order Search Tree $\\star$ 898. Bitwise ORs of Subarrays $\\star\\star$ 899. Orderly Queue $\\star\\star\\star$ class Solution { public String orderlyQueue ( String S , int K ) { if ( K > 1 ) { char [] charArray = S . toCharArray (); Arrays . sort ( charArray ); return String . valueOf ( charArray ); } String ans = S ; for ( int i = 1 ; i < S . length (); ++ i ) { String S2 = S . substring ( i ) + S . substring ( 0 , i ); if ( ans . compareTo ( S2 ) > 0 ) ans = S2 ; } return ans ; } } 900. RLE Iterator $\\star\\star$ class RLEIterator { public RLEIterator ( int [] A ) { this . A = A ; } public int next ( int n ) { while ( index < A . length && A [ index ] < n ) { n -= A [ index ] ; index += 2 ; } if ( index == A . length ) return - 1 ; A [ index ] -= n ; return A [ index + 1 ] ; } private int index = 0 ; private int [] A ; }","title":"0891-0900"},{"location":"java/0801-0900/0891-0900/#891-sum-of-subsequence-widths-starstarstar","text":"class Solution { public int sumSubseqWidths ( int [] A ) { final int n = A . length ; final int kMod = ( int ) 1e9 + 7 ; long ans = 0 ; long exp = 1 ; Arrays . sort ( A ); for ( int i = 0 ; i < n ; ++ i , exp = exp * 2 % kMod ) ans = ( ans + A [ i ] * exp - A [ n - i - 1 ] * exp ) % kMod ; return ( int ) ans ; } }","title":"891. Sum of Subsequence Widths $\\star\\star\\star$"},{"location":"java/0801-0900/0891-0900/#892-surface-area-of-3d-shapes-star","text":"class Solution { public int surfaceArea ( int [][] grid ) { int ans = 0 ; for ( int i = 0 ; i < grid . length ; ++ i ) for ( int j = 0 ; j < grid . length ; ++ j ) { if ( grid [ i ][ j ] > 0 ) ans += grid [ i ][ j ] * 4 + 2 ; if ( i > 0 ) ans -= Math . min ( grid [ i ][ j ] , grid [ i - 1 ][ j ] ) * 2 ; if ( j > 0 ) ans -= Math . min ( grid [ i ][ j ] , grid [ i ][ j - 1 ] ) * 2 ; } return ans ; } }","title":"892. Surface Area of 3D Shapes $\\star$"},{"location":"java/0801-0900/0891-0900/#893-groups-of-special-equivalent-strings-star","text":"class Solution { public int numSpecialEquivGroups ( String [] A ) { Set < String > set = new HashSet <> (); for ( final String s : A ) { String even = \"\" ; String odd = \"\" ; for ( int i = 0 ; i < s . length (); ++ i ) if ( i % 2 == 0 ) even += s . charAt ( i ); else odd += s . charAt ( i ); char [] evenCharArray = even . toCharArray (); char [] oddCharArray = odd . toCharArray (); Arrays . sort ( evenCharArray ); Arrays . sort ( oddCharArray ); set . add ( new String ( evenCharArray ) + new String ( oddCharArray )); } return set . size (); } }","title":"893. Groups of Special-Equivalent Strings $\\star$"},{"location":"java/0801-0900/0891-0900/#894-all-possible-full-binary-trees-starstar","text":"","title":"894. All Possible Full Binary Trees $\\star\\star$"},{"location":"java/0801-0900/0891-0900/#895-maximum-frequency-stack-starstarstar","text":"class FreqStack { public void push ( int x ) { count . put ( x , count . getOrDefault ( x , 0 ) + 1 ); maxFreq = Math . max ( maxFreq , count . get ( x )); if ( ! countToStack . containsKey ( count . get ( x ))) countToStack . put ( count . get ( x ), new Stack <> ()); countToStack . get ( count . get ( x )). add ( x ); } public int pop () { int value = countToStack . get ( maxFreq ). pop (); count . put ( value , count . get ( value ) - 1 ); if ( countToStack . get ( maxFreq ). isEmpty ()) -- maxFreq ; return value ; } private int maxFreq = 0 ; private Map < Integer , Integer > count = new HashMap <> (); private Map < Integer , Stack < Integer >> countToStack = new HashMap <> (); }","title":"895. Maximum Frequency Stack $\\star\\star\\star$"},{"location":"java/0801-0900/0891-0900/#896-monotonic-array-star","text":"class Solution { public boolean isMonotonic ( int [] A ) { boolean increasing = true ; boolean decreasing = true ; for ( int i = 1 ; i < A . length ; ++ i ) { increasing &= A [ i - 1 ] <= A [ i ] ; decreasing &= A [ i - 1 ] >= A [ i ] ; } return increasing || decreasing ; } }","title":"896. Monotonic Array $\\star$"},{"location":"java/0801-0900/0891-0900/#897-increasing-order-search-tree-star","text":"","title":"897. Increasing Order Search Tree $\\star$"},{"location":"java/0801-0900/0891-0900/#898-bitwise-ors-of-subarrays-starstar","text":"","title":"898. Bitwise ORs of Subarrays $\\star\\star$"},{"location":"java/0801-0900/0891-0900/#899-orderly-queue-starstarstar","text":"class Solution { public String orderlyQueue ( String S , int K ) { if ( K > 1 ) { char [] charArray = S . toCharArray (); Arrays . sort ( charArray ); return String . valueOf ( charArray ); } String ans = S ; for ( int i = 1 ; i < S . length (); ++ i ) { String S2 = S . substring ( i ) + S . substring ( 0 , i ); if ( ans . compareTo ( S2 ) > 0 ) ans = S2 ; } return ans ; } }","title":"899. Orderly Queue $\\star\\star\\star$"},{"location":"java/0801-0900/0891-0900/#900-rle-iterator-starstar","text":"class RLEIterator { public RLEIterator ( int [] A ) { this . A = A ; } public int next ( int n ) { while ( index < A . length && A [ index ] < n ) { n -= A [ index ] ; index += 2 ; } if ( index == A . length ) return - 1 ; A [ index ] -= n ; return A [ index + 1 ] ; } private int index = 0 ; private int [] A ; }","title":"900. RLE Iterator $\\star\\star$"},{"location":"java/0901-1000/0901-0910/","text":"901. Online Stock Span $\\star\\star$ 902. Numbers At Most N Given Digit Set $\\star\\star\\star$ class Solution { public int atMostNGivenDigitSet ( String [] D , int N ) { int ans = 0 ; String num = String . valueOf ( N ); for ( int i = 1 ; i < num . length (); ++ i ) ans += Math . pow ( D . length , i ); for ( int i = 0 ; i < num . length (); ++ i ) { boolean dHasSameNum = false ; for ( final String digit : D ) { if ( digit . charAt ( 0 ) < num . charAt ( i )) ans += Math . pow ( D . length , num . length () - i - 1 ); else if ( digit . charAt ( 0 ) == num . charAt ( i )) dHasSameNum = true ; } if ( ! dHasSameNum ) return ans ; } return ans + 1 ; } } 903. Valid Permutations for DI Sequence $\\star\\star\\star$ 904. Fruit Into Baskets $\\star\\star$ class Solution { public int totalFruit ( int [] tree ) { int ans = 0 ; Map < Integer , Integer > count = new HashMap <> (); for ( int l = 0 , r = 0 ; r < tree . length ; ++ r ) { count . put ( tree [ r ] , count . getOrDefault ( tree [ r ] , 0 ) + 1 ); while ( count . size () > 2 ) { count . put ( tree [ l ] , count . get ( tree [ l ] ) - 1 ); count . remove ( tree [ l ] , 0 ); ++ l ; } ans = Math . max ( ans , r - l + 1 ); } return ans ; } } 905. Sort Array By Parity $\\star$ class Solution { public int [] sortArrayByParity ( int [] A ) { int l = 0 ; int r = A . length - 1 ; while ( l < r ) { if ( A [ l ] % 2 == 1 && A [ r ] % 2 == 0 ) { int temp = A [ l ] ; A [ l ] = A [ r ] ; A [ r ] = temp ; } if ( A [ l ] % 2 == 0 ) ++ l ; if ( A [ r ] % 2 == 1 ) -- r ; } return A ; } } 906. Super Palindromes $\\star\\star\\star$ class Solution { public int superpalindromesInRange ( String L , String R ) { int ans = 0 ; Long l = Long . valueOf ( L ); Long r = Long . valueOf ( R ); for ( long i = ( long ) Math . sqrt ( l ); i * i <= r ;) { long palindrome = nextPalindrome ( i ); long squared = palindrome * palindrome ; if ( squared <= r && isPalindrome ( squared )) ++ ans ; i = palindrome + 1 ; } return ans ; } private long nextPalindrome ( long num ) { final String s = String . valueOf ( num ); final int n = s . length (); String half = s . substring ( 0 , ( n + 1 ) / 2 ); String reversedHalf = new StringBuilder ( half . substring ( 0 , n / 2 )). reverse (). toString (); long candidate = Long . valueOf ( half + reversedHalf ); if ( candidate >= num ) return candidate ; half = String . valueOf ( Long . valueOf ( half ) + 1 ); reversedHalf = new StringBuilder ( half . substring ( 0 , n / 2 )). reverse (). toString (); return Long . valueOf ( half + reversedHalf ); } private boolean isPalindrome ( long num ) { final String s = String . valueOf ( num ); int l = 0 ; int r = s . length () - 1 ; while ( l < r ) if ( s . charAt ( l ++ ) != s . charAt ( r -- )) return false ; return true ; } } 907. Sum of Subarray Minimums $\\star\\star$ class Solution { public int sumSubarrayMins ( int [] A ) { final int n = A . length ; final int kMod = ( int ) 1e9 + 7 ; int ans = 0 ; int [] prev = new int [ n ] ; int [] next = new int [ n ] ; Stack < Integer > stack1 = new Stack <> (); Stack < Integer > stack2 = new Stack <> (); Arrays . fill ( prev , - 1 ); Arrays . fill ( next , n ); for ( int i = 0 ; i < A . length ; ++ i ) { while ( ! stack1 . isEmpty () && A [ stack1 . peek () ] > A [ i ] ) stack1 . pop (); prev [ i ] = stack1 . isEmpty () ? - 1 : stack1 . peek (); stack1 . add ( i ); while ( ! stack2 . isEmpty () && A [ stack2 . peek () ] > A [ i ] ) { int index = stack2 . pop (); next [ index ] = i ; } stack2 . add ( i ); } for ( int i = 0 ; i < A . length ; ++ i ) ans = ( ans + A [ i ] * ( i - prev [ i ] ) * ( next [ i ] - i )) % kMod ; return ans ; } } 908. Smallest Range I $\\star$ class Solution { public int smallestRangeI ( int [] A , int K ) { int max = Arrays . stream ( A ). max (). getAsInt (); int min = Arrays . stream ( A ). min (). getAsInt (); return Math . max ( 0 , max - min - 2 * K ); } } 909. Snakes and Ladders $\\star\\star$ 910. Smallest Range II $\\star\\star$ class Solution { public int smallestRangeII ( int [] A , int K ) { Arrays . sort ( A ); int ans = A [ A . length - 1 ] - A [ 0 ] ; int left = A [ 0 ] + K ; int right = A [ A . length - 1 ] - K ; for ( int i = 0 ; i + 1 < A . length ; ++ i ) { int min = Math . min ( left , A [ i + 1 ] - K ); int max = Math . max ( right , A [ i ] + K ); ans = Math . min ( ans , max - min ); } return ans ; } }","title":"0901-0910"},{"location":"java/0901-1000/0901-0910/#901-online-stock-span-starstar","text":"","title":"901. Online Stock Span $\\star\\star$"},{"location":"java/0901-1000/0901-0910/#902-numbers-at-most-n-given-digit-set-starstarstar","text":"class Solution { public int atMostNGivenDigitSet ( String [] D , int N ) { int ans = 0 ; String num = String . valueOf ( N ); for ( int i = 1 ; i < num . length (); ++ i ) ans += Math . pow ( D . length , i ); for ( int i = 0 ; i < num . length (); ++ i ) { boolean dHasSameNum = false ; for ( final String digit : D ) { if ( digit . charAt ( 0 ) < num . charAt ( i )) ans += Math . pow ( D . length , num . length () - i - 1 ); else if ( digit . charAt ( 0 ) == num . charAt ( i )) dHasSameNum = true ; } if ( ! dHasSameNum ) return ans ; } return ans + 1 ; } }","title":"902. Numbers At Most N Given Digit Set $\\star\\star\\star$"},{"location":"java/0901-1000/0901-0910/#903-valid-permutations-for-di-sequence-starstarstar","text":"","title":"903. Valid Permutations for DI Sequence $\\star\\star\\star$"},{"location":"java/0901-1000/0901-0910/#904-fruit-into-baskets-starstar","text":"class Solution { public int totalFruit ( int [] tree ) { int ans = 0 ; Map < Integer , Integer > count = new HashMap <> (); for ( int l = 0 , r = 0 ; r < tree . length ; ++ r ) { count . put ( tree [ r ] , count . getOrDefault ( tree [ r ] , 0 ) + 1 ); while ( count . size () > 2 ) { count . put ( tree [ l ] , count . get ( tree [ l ] ) - 1 ); count . remove ( tree [ l ] , 0 ); ++ l ; } ans = Math . max ( ans , r - l + 1 ); } return ans ; } }","title":"904. Fruit Into Baskets $\\star\\star$"},{"location":"java/0901-1000/0901-0910/#905-sort-array-by-parity-star","text":"class Solution { public int [] sortArrayByParity ( int [] A ) { int l = 0 ; int r = A . length - 1 ; while ( l < r ) { if ( A [ l ] % 2 == 1 && A [ r ] % 2 == 0 ) { int temp = A [ l ] ; A [ l ] = A [ r ] ; A [ r ] = temp ; } if ( A [ l ] % 2 == 0 ) ++ l ; if ( A [ r ] % 2 == 1 ) -- r ; } return A ; } }","title":"905. Sort Array By Parity $\\star$"},{"location":"java/0901-1000/0901-0910/#906-super-palindromes-starstarstar","text":"class Solution { public int superpalindromesInRange ( String L , String R ) { int ans = 0 ; Long l = Long . valueOf ( L ); Long r = Long . valueOf ( R ); for ( long i = ( long ) Math . sqrt ( l ); i * i <= r ;) { long palindrome = nextPalindrome ( i ); long squared = palindrome * palindrome ; if ( squared <= r && isPalindrome ( squared )) ++ ans ; i = palindrome + 1 ; } return ans ; } private long nextPalindrome ( long num ) { final String s = String . valueOf ( num ); final int n = s . length (); String half = s . substring ( 0 , ( n + 1 ) / 2 ); String reversedHalf = new StringBuilder ( half . substring ( 0 , n / 2 )). reverse (). toString (); long candidate = Long . valueOf ( half + reversedHalf ); if ( candidate >= num ) return candidate ; half = String . valueOf ( Long . valueOf ( half ) + 1 ); reversedHalf = new StringBuilder ( half . substring ( 0 , n / 2 )). reverse (). toString (); return Long . valueOf ( half + reversedHalf ); } private boolean isPalindrome ( long num ) { final String s = String . valueOf ( num ); int l = 0 ; int r = s . length () - 1 ; while ( l < r ) if ( s . charAt ( l ++ ) != s . charAt ( r -- )) return false ; return true ; } }","title":"906. Super Palindromes $\\star\\star\\star$"},{"location":"java/0901-1000/0901-0910/#907-sum-of-subarray-minimums-starstar","text":"class Solution { public int sumSubarrayMins ( int [] A ) { final int n = A . length ; final int kMod = ( int ) 1e9 + 7 ; int ans = 0 ; int [] prev = new int [ n ] ; int [] next = new int [ n ] ; Stack < Integer > stack1 = new Stack <> (); Stack < Integer > stack2 = new Stack <> (); Arrays . fill ( prev , - 1 ); Arrays . fill ( next , n ); for ( int i = 0 ; i < A . length ; ++ i ) { while ( ! stack1 . isEmpty () && A [ stack1 . peek () ] > A [ i ] ) stack1 . pop (); prev [ i ] = stack1 . isEmpty () ? - 1 : stack1 . peek (); stack1 . add ( i ); while ( ! stack2 . isEmpty () && A [ stack2 . peek () ] > A [ i ] ) { int index = stack2 . pop (); next [ index ] = i ; } stack2 . add ( i ); } for ( int i = 0 ; i < A . length ; ++ i ) ans = ( ans + A [ i ] * ( i - prev [ i ] ) * ( next [ i ] - i )) % kMod ; return ans ; } }","title":"907. Sum of Subarray Minimums $\\star\\star$"},{"location":"java/0901-1000/0901-0910/#908-smallest-range-i-star","text":"class Solution { public int smallestRangeI ( int [] A , int K ) { int max = Arrays . stream ( A ). max (). getAsInt (); int min = Arrays . stream ( A ). min (). getAsInt (); return Math . max ( 0 , max - min - 2 * K ); } }","title":"908. Smallest Range I $\\star$"},{"location":"java/0901-1000/0901-0910/#909-snakes-and-ladders-starstar","text":"","title":"909. Snakes and Ladders $\\star\\star$"},{"location":"java/0901-1000/0901-0910/#910-smallest-range-ii-starstar","text":"class Solution { public int smallestRangeII ( int [] A , int K ) { Arrays . sort ( A ); int ans = A [ A . length - 1 ] - A [ 0 ] ; int left = A [ 0 ] + K ; int right = A [ A . length - 1 ] - K ; for ( int i = 0 ; i + 1 < A . length ; ++ i ) { int min = Math . min ( left , A [ i + 1 ] - K ); int max = Math . max ( right , A [ i ] + K ); ans = Math . min ( ans , max - min ); } return ans ; } }","title":"910. Smallest Range II $\\star\\star$"},{"location":"java/0901-1000/0911-0920/","text":"911. Online Election $\\star\\star$ 912. Sort an Array $\\star\\star$ 913. Cat and Mouse $\\star\\star\\star$ 914. X of a Kind in a Deck of Cards $\\star$ class Solution { public boolean hasGroupsSizeX ( int [] deck ) { Map < Integer , Integer > count = new HashMap <> (); int gcd = 0 ; for ( int d : deck ) count . put ( d , count . getOrDefault ( d , 0 ) + 1 ); for ( int value : count . values ()) gcd = __gcd ( gcd , value ); return gcd >= 2 ; } private int __gcd ( int a , int b ) { return b > 0 ? __gcd ( b , a % b ) : a ; } } 915. Partition Array into Disjoint Intervals $\\star\\star$ class Solution { public int partitionDisjoint ( int [] A ) { final int n = A . length ; int [] min = new int [ n ] ; min [ n - 1 ] = A [ n - 1 ] ; int max = Integer . MIN_VALUE ; for ( int i = n - 2 ; i >= 0 ; -- i ) min [ i ] = Math . min ( min [ i + 1 ] , A [ i ] ); for ( int i = 0 ; i < n ; ++ i ) { max = Math . max ( max , A [ i ] ); if ( max <= min [ i + 1 ] ) return i + 1 ; } throw new IllegalArgumentException (); } } 916. Word Subsets $\\star\\star$ class Solution { public List < String > wordSubsets ( String [] A , String [] B ) { List < String > ans = new ArrayList <> (); int [] countB = new int [ 26 ] ; for ( final String b : B ) { int [] temp = counter ( b ); for ( int i = 0 ; i < 26 ; ++ i ) countB [ i ] = Math . max ( countB [ i ] , temp [ i ] ); } for ( final String a : A ) if ( isUniversal ( counter ( a ), countB )) ans . add ( a ); return ans ; } private int [] counter ( final String s ) { int [] count = new int [ 26 ] ; for ( char c : s . toCharArray ()) ++ count [ c - 'a' ] ; return count ; } private boolean isUniversal ( int [] countA , int [] countB ) { for ( int i = 0 ; i < 26 ; ++ i ) if ( countA [ i ] < countB [ i ] ) return false ; return true ; } } 917. Reverse Only Letters $\\star$ class Solution { public String reverseOnlyLetters ( String S ) { StringBuilder ans = new StringBuilder ( S ); for ( int i = 0 , j = S . length () - 1 ; i < j ; ++ i , -- j ) { while ( i < j && ! Character . isLetter ( S . charAt ( i ))) ++ i ; while ( i < j && ! Character . isLetter ( S . charAt ( j ))) -- j ; ans . setCharAt ( i , S . charAt ( j )); ans . setCharAt ( j , S . charAt ( i )); } return ans . toString (); } } 918. Maximum Sum Circular Subarray $\\star\\star$ class Solution { public int maxSubarraySumCircular ( int [] A ) { int totalSum = 0 ; int currMaxSum = 0 ; int currMinSum = 0 ; int maxSum = Integer . MIN_VALUE ; int minSum = Integer . MAX_VALUE ; for ( int a : A ) { totalSum += a ; currMaxSum = Math . max ( currMaxSum + a , a ); currMinSum = Math . min ( currMinSum + a , a ); maxSum = Math . max ( maxSum , currMaxSum ); minSum = Math . min ( minSum , currMinSum ); } return maxSum < 0 ? maxSum : Math . max ( maxSum , totalSum - minSum ); } } 919. Complete Binary Tree Inserter $\\star\\star$ 920. Number of Music Playlists $\\star\\star\\star$","title":"0911-0920"},{"location":"java/0901-1000/0911-0920/#911-online-election-starstar","text":"","title":"911. Online Election $\\star\\star$"},{"location":"java/0901-1000/0911-0920/#912-sort-an-array-starstar","text":"","title":"912. Sort an Array $\\star\\star$"},{"location":"java/0901-1000/0911-0920/#913-cat-and-mouse-starstarstar","text":"","title":"913. Cat and Mouse $\\star\\star\\star$"},{"location":"java/0901-1000/0911-0920/#914-x-of-a-kind-in-a-deck-of-cards-star","text":"class Solution { public boolean hasGroupsSizeX ( int [] deck ) { Map < Integer , Integer > count = new HashMap <> (); int gcd = 0 ; for ( int d : deck ) count . put ( d , count . getOrDefault ( d , 0 ) + 1 ); for ( int value : count . values ()) gcd = __gcd ( gcd , value ); return gcd >= 2 ; } private int __gcd ( int a , int b ) { return b > 0 ? __gcd ( b , a % b ) : a ; } }","title":"914. X of a Kind in a Deck of Cards $\\star$"},{"location":"java/0901-1000/0911-0920/#915-partition-array-into-disjoint-intervals-starstar","text":"class Solution { public int partitionDisjoint ( int [] A ) { final int n = A . length ; int [] min = new int [ n ] ; min [ n - 1 ] = A [ n - 1 ] ; int max = Integer . MIN_VALUE ; for ( int i = n - 2 ; i >= 0 ; -- i ) min [ i ] = Math . min ( min [ i + 1 ] , A [ i ] ); for ( int i = 0 ; i < n ; ++ i ) { max = Math . max ( max , A [ i ] ); if ( max <= min [ i + 1 ] ) return i + 1 ; } throw new IllegalArgumentException (); } }","title":"915. Partition Array into Disjoint Intervals $\\star\\star$"},{"location":"java/0901-1000/0911-0920/#916-word-subsets-starstar","text":"class Solution { public List < String > wordSubsets ( String [] A , String [] B ) { List < String > ans = new ArrayList <> (); int [] countB = new int [ 26 ] ; for ( final String b : B ) { int [] temp = counter ( b ); for ( int i = 0 ; i < 26 ; ++ i ) countB [ i ] = Math . max ( countB [ i ] , temp [ i ] ); } for ( final String a : A ) if ( isUniversal ( counter ( a ), countB )) ans . add ( a ); return ans ; } private int [] counter ( final String s ) { int [] count = new int [ 26 ] ; for ( char c : s . toCharArray ()) ++ count [ c - 'a' ] ; return count ; } private boolean isUniversal ( int [] countA , int [] countB ) { for ( int i = 0 ; i < 26 ; ++ i ) if ( countA [ i ] < countB [ i ] ) return false ; return true ; } }","title":"916. Word Subsets $\\star\\star$"},{"location":"java/0901-1000/0911-0920/#917-reverse-only-letters-star","text":"class Solution { public String reverseOnlyLetters ( String S ) { StringBuilder ans = new StringBuilder ( S ); for ( int i = 0 , j = S . length () - 1 ; i < j ; ++ i , -- j ) { while ( i < j && ! Character . isLetter ( S . charAt ( i ))) ++ i ; while ( i < j && ! Character . isLetter ( S . charAt ( j ))) -- j ; ans . setCharAt ( i , S . charAt ( j )); ans . setCharAt ( j , S . charAt ( i )); } return ans . toString (); } }","title":"917. Reverse Only Letters $\\star$"},{"location":"java/0901-1000/0911-0920/#918-maximum-sum-circular-subarray-starstar","text":"class Solution { public int maxSubarraySumCircular ( int [] A ) { int totalSum = 0 ; int currMaxSum = 0 ; int currMinSum = 0 ; int maxSum = Integer . MIN_VALUE ; int minSum = Integer . MAX_VALUE ; for ( int a : A ) { totalSum += a ; currMaxSum = Math . max ( currMaxSum + a , a ); currMinSum = Math . min ( currMinSum + a , a ); maxSum = Math . max ( maxSum , currMaxSum ); minSum = Math . min ( minSum , currMinSum ); } return maxSum < 0 ? maxSum : Math . max ( maxSum , totalSum - minSum ); } }","title":"918. Maximum Sum Circular Subarray $\\star\\star$"},{"location":"java/0901-1000/0911-0920/#919-complete-binary-tree-inserter-starstar","text":"","title":"919. Complete Binary Tree Inserter $\\star\\star$"},{"location":"java/0901-1000/0911-0920/#920-number-of-music-playlists-starstarstar","text":"","title":"920. Number of Music Playlists $\\star\\star\\star$"},{"location":"java/0901-1000/0921-0930/","text":"921. Minimum Add to Make Parentheses Valid $\\star\\star$ 922. Sort Array By Parity II $\\star$ class Solution { public int [] sortArrayByParityII ( int [] A ) { final int n = A . length ; for ( int i = 0 , j = 1 ; i < n ; i += 2 , j += 2 ) { while ( i < n && A [ i ] % 2 == 0 ) i += 2 ; while ( j < n && A [ j ] % 2 == 1 ) j += 2 ; if ( i < n ) { int temp = A [ i ] ; A [ i ] = A [ j ] ; A [ j ] = temp ; } } return A ; } } 923. 3Sum With Multiplicity $\\star\\star$ 924. Minimize Malware Spread $\\star\\star\\star$ 925. Long Pressed Name $\\star$ class Solution { public boolean isLongPressedName ( String name , String typed ) { int i = 0 ; for ( int j = 0 ; j < typed . length (); ++ j ) if ( i < name . length () && name . charAt ( i ) == typed . charAt ( j )) ++ i ; else if ( j == 0 || typed . charAt ( j ) != typed . charAt ( j - 1 )) return false ; return i == name . length (); } } 926. Flip String to Monotone Increasing $\\star\\star$ class Solution { public int minFlipsMonoIncr ( String S ) { int [] dp = new int [ 2 ] ; for ( int i = 0 ; i < S . length (); ++ i ) { int temp = dp [ 0 ] + ( S . charAt ( i ) == '1' ? 1 : 0 ); dp [ 1 ] = Math . min ( dp [ 0 ] , dp [ 1 ] ) + ( S . charAt ( i ) == '0' ? 1 : 0 ); dp [ 0 ] = temp ; } return Math . min ( dp [ 0 ] , dp [ 1 ] ); } } 927. Three Equal Parts $\\star\\star\\star$ class Solution { public int [] threeEqualParts ( int [] A ) { int ones = 0 ; for ( int a : A ) if ( a == 1 ) ++ ones ; if ( ones == 0 ) return new int [] { 0 , A . length - 1 }; if ( ones % 3 != 0 ) return new int [] { - 1 , - 1 }; int k = ones / 3 ; int i = 0 ; int j = 0 ; int first = 0 ; int second = 0 ; int third = 0 ; for ( i = 0 ; i < A . length ; ++ i ) if ( A [ i ] == 1 ) { first = i ; break ; } int gapOnes = k ; for ( j = i + 1 ; j < A . length ; ++ j ) if ( A [ j ] == 1 && -- gapOnes == 0 ) { second = j ; break ; } gapOnes = k ; for ( i = j + 1 ; i < A . length ; ++ i ) if ( A [ i ] == 1 && -- gapOnes == 0 ) { third = i ; break ; } while ( third < A . length && A [ first ] == A [ second ] && A [ second ] == A [ third ] ) { ++ first ; ++ second ; ++ third ; } if ( third == A . length ) return new int [] { first - 1 , second }; return new int [] { - 1 , - 1 }; } } 928. Minimize Malware Spread II $\\star\\star\\star$ 929. Unique Email Addresses $\\star$ class Solution { public int numUniqueEmails ( String [] emails ) { Set < String > seen = new HashSet <> (); for ( final String email : emails ) { String [] parts = email . split ( \"@\" ); String [] local = parts [ 0 ] . split ( \"\\\\+\" ); seen . add ( local [ 0 ] . replace ( \".\" , \"\" ) + \"@\" + parts [ 1 ] ); } return seen . size (); } } 930. Binary Subarrays With Sum $\\star\\star$ class Solution { public int numSubarraysWithSum ( int [] A , int S ) { int ans = 0 ; int prefixSum = 0 ; Map < Integer , Integer > count = new HashMap <> (); count . put ( 0 , 1 ); for ( int a : A ) { prefixSum += a ; if ( count . containsKey ( prefixSum - S )) ans += count . get ( prefixSum - S ); count . put ( prefixSum , count . getOrDefault ( prefixSum , 0 ) + 1 ); } return ans ; } }","title":"0921-0930"},{"location":"java/0901-1000/0921-0930/#921-minimum-add-to-make-parentheses-valid-starstar","text":"","title":"921. Minimum Add to Make Parentheses Valid $\\star\\star$"},{"location":"java/0901-1000/0921-0930/#922-sort-array-by-parity-ii-star","text":"class Solution { public int [] sortArrayByParityII ( int [] A ) { final int n = A . length ; for ( int i = 0 , j = 1 ; i < n ; i += 2 , j += 2 ) { while ( i < n && A [ i ] % 2 == 0 ) i += 2 ; while ( j < n && A [ j ] % 2 == 1 ) j += 2 ; if ( i < n ) { int temp = A [ i ] ; A [ i ] = A [ j ] ; A [ j ] = temp ; } } return A ; } }","title":"922. Sort Array By Parity II $\\star$"},{"location":"java/0901-1000/0921-0930/#923-3sum-with-multiplicity-starstar","text":"","title":"923. 3Sum With Multiplicity $\\star\\star$"},{"location":"java/0901-1000/0921-0930/#924-minimize-malware-spread-starstarstar","text":"","title":"924. Minimize Malware Spread $\\star\\star\\star$"},{"location":"java/0901-1000/0921-0930/#925-long-pressed-name-star","text":"class Solution { public boolean isLongPressedName ( String name , String typed ) { int i = 0 ; for ( int j = 0 ; j < typed . length (); ++ j ) if ( i < name . length () && name . charAt ( i ) == typed . charAt ( j )) ++ i ; else if ( j == 0 || typed . charAt ( j ) != typed . charAt ( j - 1 )) return false ; return i == name . length (); } }","title":"925. Long Pressed Name $\\star$"},{"location":"java/0901-1000/0921-0930/#926-flip-string-to-monotone-increasing-starstar","text":"class Solution { public int minFlipsMonoIncr ( String S ) { int [] dp = new int [ 2 ] ; for ( int i = 0 ; i < S . length (); ++ i ) { int temp = dp [ 0 ] + ( S . charAt ( i ) == '1' ? 1 : 0 ); dp [ 1 ] = Math . min ( dp [ 0 ] , dp [ 1 ] ) + ( S . charAt ( i ) == '0' ? 1 : 0 ); dp [ 0 ] = temp ; } return Math . min ( dp [ 0 ] , dp [ 1 ] ); } }","title":"926. Flip String to Monotone Increasing $\\star\\star$"},{"location":"java/0901-1000/0921-0930/#927-three-equal-parts-starstarstar","text":"class Solution { public int [] threeEqualParts ( int [] A ) { int ones = 0 ; for ( int a : A ) if ( a == 1 ) ++ ones ; if ( ones == 0 ) return new int [] { 0 , A . length - 1 }; if ( ones % 3 != 0 ) return new int [] { - 1 , - 1 }; int k = ones / 3 ; int i = 0 ; int j = 0 ; int first = 0 ; int second = 0 ; int third = 0 ; for ( i = 0 ; i < A . length ; ++ i ) if ( A [ i ] == 1 ) { first = i ; break ; } int gapOnes = k ; for ( j = i + 1 ; j < A . length ; ++ j ) if ( A [ j ] == 1 && -- gapOnes == 0 ) { second = j ; break ; } gapOnes = k ; for ( i = j + 1 ; i < A . length ; ++ i ) if ( A [ i ] == 1 && -- gapOnes == 0 ) { third = i ; break ; } while ( third < A . length && A [ first ] == A [ second ] && A [ second ] == A [ third ] ) { ++ first ; ++ second ; ++ third ; } if ( third == A . length ) return new int [] { first - 1 , second }; return new int [] { - 1 , - 1 }; } }","title":"927. Three Equal Parts $\\star\\star\\star$"},{"location":"java/0901-1000/0921-0930/#928-minimize-malware-spread-ii-starstarstar","text":"","title":"928. Minimize Malware Spread II $\\star\\star\\star$"},{"location":"java/0901-1000/0921-0930/#929-unique-email-addresses-star","text":"class Solution { public int numUniqueEmails ( String [] emails ) { Set < String > seen = new HashSet <> (); for ( final String email : emails ) { String [] parts = email . split ( \"@\" ); String [] local = parts [ 0 ] . split ( \"\\\\+\" ); seen . add ( local [ 0 ] . replace ( \".\" , \"\" ) + \"@\" + parts [ 1 ] ); } return seen . size (); } }","title":"929. Unique Email Addresses $\\star$"},{"location":"java/0901-1000/0921-0930/#930-binary-subarrays-with-sum-starstar","text":"class Solution { public int numSubarraysWithSum ( int [] A , int S ) { int ans = 0 ; int prefixSum = 0 ; Map < Integer , Integer > count = new HashMap <> (); count . put ( 0 , 1 ); for ( int a : A ) { prefixSum += a ; if ( count . containsKey ( prefixSum - S )) ans += count . get ( prefixSum - S ); count . put ( prefixSum , count . getOrDefault ( prefixSum , 0 ) + 1 ); } return ans ; } }","title":"930. Binary Subarrays With Sum $\\star\\star$"},{"location":"java/0901-1000/0931-0940/","text":"931. Minimum Falling Path Sum $\\star\\star$ class Solution { public int minFallingPathSum ( int [][] A ) { final int n = A . length ; for ( int i = 1 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int min = Integer . MAX_VALUE ; for ( int k = Math . max ( 0 , j - 1 ); k < Math . min ( n , j + 2 ); ++ k ) min = Math . min ( min , A [ i - 1 ][ k ] ); A [ i ][ j ] += min ; } return Arrays . stream ( A [ n - 1 ] ). min (). getAsInt (); } } 932. Beautiful Array $\\star\\star$ 933. Number of Recent Calls $\\star$ 934. Shortest Bridge $\\star\\star$ 935. Knight Dialer $\\star\\star$ 936. Stamping The Sequence $\\star\\star\\star$ class Solution { public int [] movesToStamp ( String stamp , String target ) { List < Integer > ans = new ArrayList <> (); char [] targetCharArray = target . toCharArray (); boolean [] stamped = new boolean [ target . length () ] ; int stampedCount = 0 ; while ( stampedCount < targetCharArray . length ) { boolean isStamped = false ; for ( int i = 0 ; i <= targetCharArray . length - stamp . length (); ++ i ) { if ( stamped [ i ] ) continue ; int stampified = stampify ( stamp , targetCharArray , i ); if ( stampified == 0 ) continue ; stampedCount += stampified ; isStamped = true ; stamped [ i ] = true ; ans . add ( i ); } if ( ! isStamped ) return new int [] {}; } Collections . reverse ( ans ); return ans . stream (). mapToInt ( i -> i ). toArray (); } private int stampify ( final String stamp , char [] targetCharArray , int s ) { int stampified = stamp . length (); for ( int i = 0 ; i < stamp . length (); ++ i ) if ( targetCharArray [ s + i ] == '*' ) -- stampified ; else if ( targetCharArray [ s + i ] != stamp . charAt ( i )) return 0 ; Arrays . fill ( targetCharArray , s , s + stamp . length (), '*' ); return stampified ; } } 937. Reorder Data in Log Files $\\star$ class Solution { public String [] reorderLogFiles ( String [] logs ) { List < String > ans = new ArrayList <> (); List < String > digitLogs = new ArrayList <> (); List < String []> letterLogs = new ArrayList <> (); for ( final String log : logs ) { int i = log . indexOf ( ' ' ); if ( Character . isDigit ( log . charAt ( i + 1 ))) digitLogs . add ( log ); else letterLogs . add ( new String [] { log . substring ( 0 , i ), log . substring ( i + 1 ) }); } Collections . sort ( letterLogs , new Comparator < String []> () { @Override public int compare ( String [] l1 , String [] l2 ) { return l1 [ 1 ] . compareTo ( l2 [ 1 ] ) == 0 ? l1 [ 0 ] . compareTo ( l2 [ 0 ] ) : l1 [ 1 ] . compareTo ( l2 [ 1 ] ); } }); for ( final String [] letterLog : letterLogs ) ans . add ( letterLog [ 0 ] + \" \" + letterLog [ 1 ] ); for ( final String digitLog : digitLogs ) ans . add ( digitLog ); return ans . toArray ( new String [ 0 ] ); } } 938. Range Sum of BST $\\star$ 939. Minimum Area Rectangle $\\star\\star$ class Solution { public int minAreaRect ( int [][] points ) { int ans = Integer . MAX_VALUE ; Map < Integer , Set < Integer >> xToYs = new HashMap <> (); for ( int [] point : points ) { if ( ! xToYs . containsKey ( point [ 0 ] )) xToYs . put ( point [ 0 ] , new HashSet <> ()); xToYs . get ( point [ 0 ] ). add ( point [ 1 ] ); } for ( int i = 0 ; i < points . length ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) { if ( points [ i ][ 0 ] == points [ j ][ 0 ] || points [ i ][ 1 ] == points [ j ][ 1 ] ) continue ; if ( xToYs . get ( points [ i ][ 0 ] ). contains ( points [ j ][ 1 ] ) && xToYs . get ( points [ j ][ 0 ] ). contains ( points [ i ][ 1 ] )) ans = Math . min ( ans , Math . abs ( points [ i ][ 0 ] - points [ j ][ 0 ] ) * Math . abs ( points [ i ][ 1 ] - points [ j ][ 1 ] )); } return ans < Integer . MAX_VALUE ? ans : 0 ; } } 940. Distinct Subsequences II $\\star\\star\\star$","title":"0931-0940"},{"location":"java/0901-1000/0931-0940/#931-minimum-falling-path-sum-starstar","text":"class Solution { public int minFallingPathSum ( int [][] A ) { final int n = A . length ; for ( int i = 1 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int min = Integer . MAX_VALUE ; for ( int k = Math . max ( 0 , j - 1 ); k < Math . min ( n , j + 2 ); ++ k ) min = Math . min ( min , A [ i - 1 ][ k ] ); A [ i ][ j ] += min ; } return Arrays . stream ( A [ n - 1 ] ). min (). getAsInt (); } }","title":"931. Minimum Falling Path Sum $\\star\\star$"},{"location":"java/0901-1000/0931-0940/#932-beautiful-array-starstar","text":"","title":"932. Beautiful Array $\\star\\star$"},{"location":"java/0901-1000/0931-0940/#933-number-of-recent-calls-star","text":"","title":"933. Number of Recent Calls $\\star$"},{"location":"java/0901-1000/0931-0940/#934-shortest-bridge-starstar","text":"","title":"934. Shortest Bridge $\\star\\star$"},{"location":"java/0901-1000/0931-0940/#935-knight-dialer-starstar","text":"","title":"935. Knight Dialer $\\star\\star$"},{"location":"java/0901-1000/0931-0940/#936-stamping-the-sequence-starstarstar","text":"class Solution { public int [] movesToStamp ( String stamp , String target ) { List < Integer > ans = new ArrayList <> (); char [] targetCharArray = target . toCharArray (); boolean [] stamped = new boolean [ target . length () ] ; int stampedCount = 0 ; while ( stampedCount < targetCharArray . length ) { boolean isStamped = false ; for ( int i = 0 ; i <= targetCharArray . length - stamp . length (); ++ i ) { if ( stamped [ i ] ) continue ; int stampified = stampify ( stamp , targetCharArray , i ); if ( stampified == 0 ) continue ; stampedCount += stampified ; isStamped = true ; stamped [ i ] = true ; ans . add ( i ); } if ( ! isStamped ) return new int [] {}; } Collections . reverse ( ans ); return ans . stream (). mapToInt ( i -> i ). toArray (); } private int stampify ( final String stamp , char [] targetCharArray , int s ) { int stampified = stamp . length (); for ( int i = 0 ; i < stamp . length (); ++ i ) if ( targetCharArray [ s + i ] == '*' ) -- stampified ; else if ( targetCharArray [ s + i ] != stamp . charAt ( i )) return 0 ; Arrays . fill ( targetCharArray , s , s + stamp . length (), '*' ); return stampified ; } }","title":"936. Stamping The Sequence $\\star\\star\\star$"},{"location":"java/0901-1000/0931-0940/#937-reorder-data-in-log-files-star","text":"class Solution { public String [] reorderLogFiles ( String [] logs ) { List < String > ans = new ArrayList <> (); List < String > digitLogs = new ArrayList <> (); List < String []> letterLogs = new ArrayList <> (); for ( final String log : logs ) { int i = log . indexOf ( ' ' ); if ( Character . isDigit ( log . charAt ( i + 1 ))) digitLogs . add ( log ); else letterLogs . add ( new String [] { log . substring ( 0 , i ), log . substring ( i + 1 ) }); } Collections . sort ( letterLogs , new Comparator < String []> () { @Override public int compare ( String [] l1 , String [] l2 ) { return l1 [ 1 ] . compareTo ( l2 [ 1 ] ) == 0 ? l1 [ 0 ] . compareTo ( l2 [ 0 ] ) : l1 [ 1 ] . compareTo ( l2 [ 1 ] ); } }); for ( final String [] letterLog : letterLogs ) ans . add ( letterLog [ 0 ] + \" \" + letterLog [ 1 ] ); for ( final String digitLog : digitLogs ) ans . add ( digitLog ); return ans . toArray ( new String [ 0 ] ); } }","title":"937. Reorder Data in Log Files $\\star$"},{"location":"java/0901-1000/0931-0940/#938-range-sum-of-bst-star","text":"","title":"938. Range Sum of BST $\\star$"},{"location":"java/0901-1000/0931-0940/#939-minimum-area-rectangle-starstar","text":"class Solution { public int minAreaRect ( int [][] points ) { int ans = Integer . MAX_VALUE ; Map < Integer , Set < Integer >> xToYs = new HashMap <> (); for ( int [] point : points ) { if ( ! xToYs . containsKey ( point [ 0 ] )) xToYs . put ( point [ 0 ] , new HashSet <> ()); xToYs . get ( point [ 0 ] ). add ( point [ 1 ] ); } for ( int i = 0 ; i < points . length ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) { if ( points [ i ][ 0 ] == points [ j ][ 0 ] || points [ i ][ 1 ] == points [ j ][ 1 ] ) continue ; if ( xToYs . get ( points [ i ][ 0 ] ). contains ( points [ j ][ 1 ] ) && xToYs . get ( points [ j ][ 0 ] ). contains ( points [ i ][ 1 ] )) ans = Math . min ( ans , Math . abs ( points [ i ][ 0 ] - points [ j ][ 0 ] ) * Math . abs ( points [ i ][ 1 ] - points [ j ][ 1 ] )); } return ans < Integer . MAX_VALUE ? ans : 0 ; } }","title":"939. Minimum Area Rectangle $\\star\\star$"},{"location":"java/0901-1000/0931-0940/#940-distinct-subsequences-ii-starstarstar","text":"","title":"940. Distinct Subsequences II $\\star\\star\\star$"},{"location":"java/0901-1000/0941-0950/","text":"941. Valid Mountain Array $\\star$ class Solution { public boolean validMountainArray ( int [] A ) { if ( A . length < 3 ) return false ; int l = 0 ; int r = A . length - 1 ; while ( l + 1 < A . length && A [ l ] < A [ l + 1 ] ) ++ l ; while ( r > 0 && A [ r ] < A [ r - 1 ] ) -- r ; return l > 0 && r < A . length - 1 && l == r ; } } 942. DI String Match $\\star$ class Solution { public int [] diStringMatch ( String S ) { final int n = S . length (); int [] ans = new int [ n + 1 ] ; int min = 0 ; int max = n ; for ( int i = 0 ; i < n ; ++ i ) ans [ i ] = S . charAt ( i ) == 'I' ? min ++ : max -- ; ans [ n ] = min ; return ans ; } } 943. Find the Shortest Superstring $\\star\\star\\star$ 944. Delete Columns to Make Sorted $\\star$ 945. Minimum Increment to Make Array Unique $\\star\\star$ class Solution { public int minIncrementForUnique ( int [] A ) { int ans = 0 ; int minAvailable = 0 ; Arrays . sort ( A ); for ( int a : A ) { ans += Math . max ( minAvailable - a , 0 ); minAvailable = Math . max ( minAvailable , a ) + 1 ; } return ans ; } } 946. Validate Stack Sequences $\\star\\star$ 947. Most Stones Removed with Same Row or Column $\\star\\star$ 948. Bag of Tokens $\\star\\star$ 949. Largest Time for Given Digits $\\star$ class Solution { public String largestTimeFromDigits ( int [] A ) { String ans = \"\" ; for ( int i = 0 ; i < 4 ; ++ i ) for ( int j = 0 ; j < 4 ; ++ j ) for ( int k = 0 ; k < 4 ; ++ k ) { if ( i == j || i == k || j == k ) continue ; String hours = \"\" + A [ i ] + A [ j ] ; String minutes = \"\" + A [ k ] + A [ 6 - i - j - k ] ; String time = hours + ':' + minutes ; if ( hours . compareTo ( \"24\" ) < 0 && minutes . compareTo ( \"60\" ) < 0 && ans . compareTo ( time ) < 0 ) ans = time ; } return ans ; } } 950. Reveal Cards In Increasing Order $\\star\\star$ class Solution { public int [] deckRevealedIncreasing ( int [] deck ) { final int n = deck . length ; Arrays . sort ( deck ); Deque < Integer > deque = new ArrayDeque <> (); deque . addFirst ( deck [ n - 1 ] ); for ( int i = n - 2 ; i >= 0 ; -- i ) { deque . addFirst ( deque . getLast ()); deque . pollLast (); deque . addFirst ( deck [ i ] ); } for ( int i = 0 ; i < n ; ++ i ) deck [ i ] = deque . pollFirst (); return deck ; } }","title":"0941-0950"},{"location":"java/0901-1000/0941-0950/#941-valid-mountain-array-star","text":"class Solution { public boolean validMountainArray ( int [] A ) { if ( A . length < 3 ) return false ; int l = 0 ; int r = A . length - 1 ; while ( l + 1 < A . length && A [ l ] < A [ l + 1 ] ) ++ l ; while ( r > 0 && A [ r ] < A [ r - 1 ] ) -- r ; return l > 0 && r < A . length - 1 && l == r ; } }","title":"941. Valid Mountain Array $\\star$"},{"location":"java/0901-1000/0941-0950/#942-di-string-match-star","text":"class Solution { public int [] diStringMatch ( String S ) { final int n = S . length (); int [] ans = new int [ n + 1 ] ; int min = 0 ; int max = n ; for ( int i = 0 ; i < n ; ++ i ) ans [ i ] = S . charAt ( i ) == 'I' ? min ++ : max -- ; ans [ n ] = min ; return ans ; } }","title":"942. DI String Match $\\star$"},{"location":"java/0901-1000/0941-0950/#943-find-the-shortest-superstring-starstarstar","text":"","title":"943. Find the Shortest Superstring $\\star\\star\\star$"},{"location":"java/0901-1000/0941-0950/#944-delete-columns-to-make-sorted-star","text":"","title":"944. Delete Columns to Make Sorted $\\star$"},{"location":"java/0901-1000/0941-0950/#945-minimum-increment-to-make-array-unique-starstar","text":"class Solution { public int minIncrementForUnique ( int [] A ) { int ans = 0 ; int minAvailable = 0 ; Arrays . sort ( A ); for ( int a : A ) { ans += Math . max ( minAvailable - a , 0 ); minAvailable = Math . max ( minAvailable , a ) + 1 ; } return ans ; } }","title":"945. Minimum Increment to Make Array Unique $\\star\\star$"},{"location":"java/0901-1000/0941-0950/#946-validate-stack-sequences-starstar","text":"","title":"946. Validate Stack Sequences $\\star\\star$"},{"location":"java/0901-1000/0941-0950/#947-most-stones-removed-with-same-row-or-column-starstar","text":"","title":"947. Most Stones Removed with Same Row or Column $\\star\\star$"},{"location":"java/0901-1000/0941-0950/#948-bag-of-tokens-starstar","text":"","title":"948. Bag of Tokens $\\star\\star$"},{"location":"java/0901-1000/0941-0950/#949-largest-time-for-given-digits-star","text":"class Solution { public String largestTimeFromDigits ( int [] A ) { String ans = \"\" ; for ( int i = 0 ; i < 4 ; ++ i ) for ( int j = 0 ; j < 4 ; ++ j ) for ( int k = 0 ; k < 4 ; ++ k ) { if ( i == j || i == k || j == k ) continue ; String hours = \"\" + A [ i ] + A [ j ] ; String minutes = \"\" + A [ k ] + A [ 6 - i - j - k ] ; String time = hours + ':' + minutes ; if ( hours . compareTo ( \"24\" ) < 0 && minutes . compareTo ( \"60\" ) < 0 && ans . compareTo ( time ) < 0 ) ans = time ; } return ans ; } }","title":"949. Largest Time for Given Digits $\\star$"},{"location":"java/0901-1000/0941-0950/#950-reveal-cards-in-increasing-order-starstar","text":"class Solution { public int [] deckRevealedIncreasing ( int [] deck ) { final int n = deck . length ; Arrays . sort ( deck ); Deque < Integer > deque = new ArrayDeque <> (); deque . addFirst ( deck [ n - 1 ] ); for ( int i = n - 2 ; i >= 0 ; -- i ) { deque . addFirst ( deque . getLast ()); deque . pollLast (); deque . addFirst ( deck [ i ] ); } for ( int i = 0 ; i < n ; ++ i ) deck [ i ] = deque . pollFirst (); return deck ; } }","title":"950. Reveal Cards In Increasing Order $\\star\\star$"},{"location":"java/0901-1000/0951-0960/","text":"951. Flip Equivalent Binary Trees $\\star\\star$ 952. Largest Component Size by Common Factor $\\star\\star\\star$ class Solution { public int largestComponentSize ( int [] A ) { final int n = Arrays . stream ( A ). max (). getAsInt (); int ans = 0 ; UF uf = new UF ( n ); Map < Integer , Integer > count = new HashMap <> (); for ( int a : A ) for ( int num = 2 ; num <= ( int ) Math . sqrt ( a ); ++ num ) if ( a % num == 0 ) { uf . union ( a , num ); uf . union ( a , a / num ); } for ( int a : A ) { int pa = uf . find ( a ); count . put ( pa , count . getOrDefault ( pa , 0 ) + 1 ); ans = Math . max ( ans , count . get ( pa )); } return ans ; } } class UF { public UF ( int n ) { rank = new int [ n + 1 ] ; parent = new int [ n + 1 ] ; for ( int i = 0 ; i < parent . length ; ++ i ) parent [ i ] = i ; } public void union ( int u , int v ) { int pu = find ( u ); int pv = find ( v ); if ( pu == pv ) return ; if ( rank [ pu ] < rank [ pv ] ) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ] ) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ] ; } } public int find ( int u ) { while ( u != parent [ u ] ) { parent [ u ] = parent [ parent [ u ]] ; u = parent [ u ] ; } return u ; } private int [] rank ; private int [] parent ; } 953. Verifying an Alien Dictionary $\\star$ class Solution { public boolean isAlienSorted ( String [] words , String order ) { for ( int i = 0 ; i < order . length (); ++ i ) map . put ( order . charAt ( i ), ( char ) ( i + 'a' )); for ( int i = 0 ; i + 1 < words . length ; ++ i ) if ( bigger ( words [ i ] , words [ i + 1 ] )) return false ; return true ; } private Map < Character , Character > map = new HashMap <> (); private boolean bigger ( String s1 , String s2 ) { for ( int i = 0 ; i < s1 . length () && i < s2 . length (); ++ i ) if ( s1 . charAt ( i ) != s2 . charAt ( i )) return map . get ( s1 . charAt ( i )) > map . get ( s2 . charAt ( i )); return s1 . length () > s2 . length (); } } 954. Array of Doubled Pairs $\\star\\star$ class Solution { public boolean canReorderDoubled ( int [] A ) { Map < Integer , Integer > count = new HashMap <> (); for ( int a : A ) count . put ( a , count . getOrDefault ( a , 0 ) + 1 ); A = Arrays . stream ( A ). boxed (). sorted (( a , b ) -> Math . abs ( a ) - Math . abs ( b )). mapToInt ( i -> i ). toArray (); for ( int a : A ) { if ( count . get ( a ) == 0 ) continue ; if ( count . getOrDefault ( 2 * a , 0 ) == 0 ) return false ; count . put ( a , count . get ( a ) - 1 ); count . put ( 2 * a , count . get ( 2 * a ) - 1 ); } return true ; } } 955. Delete Columns to Make Sorted II $\\star\\star$ 956. Tallest Billboard $\\star\\star\\star$ 957. Prison Cells After N Days $\\star\\star$ class Solution { public int [] prisonAfterNDays ( int [] cells , int N ) { int [] firstDayCells = new int [ cells . length ] ; int [] nextDayCells = new int [ cells . length ] ; for ( int day = 0 ; N -- > 0 ; cells = nextDayCells . clone (), ++ day ) { for ( int i = 1 ; i + 1 < cells . length ; ++ i ) nextDayCells [ i ] = cells [ i - 1 ] == cells [ i + 1 ] ? 1 : 0 ; if ( day == 0 ) firstDayCells = nextDayCells . clone (); else if ( Arrays . equals ( nextDayCells , firstDayCells )) N %= day ; } return cells ; } } 958. Check Completeness of a Binary Tree $\\star\\star$ 959. Regions Cut By Slashes $\\star\\star$ 960. Delete Columns to Make Sorted III $\\star\\star\\star$","title":"0951-0960"},{"location":"java/0901-1000/0951-0960/#951-flip-equivalent-binary-trees-starstar","text":"","title":"951. Flip Equivalent Binary Trees $\\star\\star$"},{"location":"java/0901-1000/0951-0960/#952-largest-component-size-by-common-factor-starstarstar","text":"class Solution { public int largestComponentSize ( int [] A ) { final int n = Arrays . stream ( A ). max (). getAsInt (); int ans = 0 ; UF uf = new UF ( n ); Map < Integer , Integer > count = new HashMap <> (); for ( int a : A ) for ( int num = 2 ; num <= ( int ) Math . sqrt ( a ); ++ num ) if ( a % num == 0 ) { uf . union ( a , num ); uf . union ( a , a / num ); } for ( int a : A ) { int pa = uf . find ( a ); count . put ( pa , count . getOrDefault ( pa , 0 ) + 1 ); ans = Math . max ( ans , count . get ( pa )); } return ans ; } } class UF { public UF ( int n ) { rank = new int [ n + 1 ] ; parent = new int [ n + 1 ] ; for ( int i = 0 ; i < parent . length ; ++ i ) parent [ i ] = i ; } public void union ( int u , int v ) { int pu = find ( u ); int pv = find ( v ); if ( pu == pv ) return ; if ( rank [ pu ] < rank [ pv ] ) parent [ pu ] = pv ; else if ( rank [ pv ] < rank [ pu ] ) parent [ pv ] = pu ; else { parent [ pu ] = pv ; ++ rank [ pv ] ; } } public int find ( int u ) { while ( u != parent [ u ] ) { parent [ u ] = parent [ parent [ u ]] ; u = parent [ u ] ; } return u ; } private int [] rank ; private int [] parent ; }","title":"952. Largest Component Size by Common Factor $\\star\\star\\star$"},{"location":"java/0901-1000/0951-0960/#953-verifying-an-alien-dictionary-star","text":"class Solution { public boolean isAlienSorted ( String [] words , String order ) { for ( int i = 0 ; i < order . length (); ++ i ) map . put ( order . charAt ( i ), ( char ) ( i + 'a' )); for ( int i = 0 ; i + 1 < words . length ; ++ i ) if ( bigger ( words [ i ] , words [ i + 1 ] )) return false ; return true ; } private Map < Character , Character > map = new HashMap <> (); private boolean bigger ( String s1 , String s2 ) { for ( int i = 0 ; i < s1 . length () && i < s2 . length (); ++ i ) if ( s1 . charAt ( i ) != s2 . charAt ( i )) return map . get ( s1 . charAt ( i )) > map . get ( s2 . charAt ( i )); return s1 . length () > s2 . length (); } }","title":"953. Verifying an Alien Dictionary $\\star$"},{"location":"java/0901-1000/0951-0960/#954-array-of-doubled-pairs-starstar","text":"class Solution { public boolean canReorderDoubled ( int [] A ) { Map < Integer , Integer > count = new HashMap <> (); for ( int a : A ) count . put ( a , count . getOrDefault ( a , 0 ) + 1 ); A = Arrays . stream ( A ). boxed (). sorted (( a , b ) -> Math . abs ( a ) - Math . abs ( b )). mapToInt ( i -> i ). toArray (); for ( int a : A ) { if ( count . get ( a ) == 0 ) continue ; if ( count . getOrDefault ( 2 * a , 0 ) == 0 ) return false ; count . put ( a , count . get ( a ) - 1 ); count . put ( 2 * a , count . get ( 2 * a ) - 1 ); } return true ; } }","title":"954. Array of Doubled Pairs $\\star\\star$"},{"location":"java/0901-1000/0951-0960/#955-delete-columns-to-make-sorted-ii-starstar","text":"","title":"955. Delete Columns to Make Sorted II $\\star\\star$"},{"location":"java/0901-1000/0951-0960/#956-tallest-billboard-starstarstar","text":"","title":"956. Tallest Billboard $\\star\\star\\star$"},{"location":"java/0901-1000/0951-0960/#957-prison-cells-after-n-days-starstar","text":"class Solution { public int [] prisonAfterNDays ( int [] cells , int N ) { int [] firstDayCells = new int [ cells . length ] ; int [] nextDayCells = new int [ cells . length ] ; for ( int day = 0 ; N -- > 0 ; cells = nextDayCells . clone (), ++ day ) { for ( int i = 1 ; i + 1 < cells . length ; ++ i ) nextDayCells [ i ] = cells [ i - 1 ] == cells [ i + 1 ] ? 1 : 0 ; if ( day == 0 ) firstDayCells = nextDayCells . clone (); else if ( Arrays . equals ( nextDayCells , firstDayCells )) N %= day ; } return cells ; } }","title":"957. Prison Cells After N Days $\\star\\star$"},{"location":"java/0901-1000/0951-0960/#958-check-completeness-of-a-binary-tree-starstar","text":"","title":"958. Check Completeness of a Binary Tree $\\star\\star$"},{"location":"java/0901-1000/0951-0960/#959-regions-cut-by-slashes-starstar","text":"","title":"959. Regions Cut By Slashes $\\star\\star$"},{"location":"java/0901-1000/0951-0960/#960-delete-columns-to-make-sorted-iii-starstarstar","text":"","title":"960. Delete Columns to Make Sorted III $\\star\\star\\star$"},{"location":"java/0901-1000/0961-0970/","text":"961. N-Repeated Element in Size 2N Array $\\star$ class Solution { public int repeatedNTimes ( int [] A ) { for ( int i = 0 ; i + 2 < A . length ; ++ i ) if ( A [ i ] == A [ i + 1 ] || A [ i ] == A [ i + 2 ] ) return A [ i ] ; return A [ A . length - 1 ] ; } } 962. Maximum Width Ramp $\\star\\star$ class Solution { public int maxWidthRamp ( int [] A ) { int ans = 0 ; Stack < Integer > stack = new Stack <> (); for ( int i = 0 ; i < A . length ; ++ i ) if ( stack . isEmpty () || A [ i ] < A [ stack . peek () ] ) stack . push ( i ); for ( int i = A . length - 1 ; i > ans ; -- i ) while ( ! stack . isEmpty () && A [ i ] >= A [ stack . peek () ] ) ans = Math . max ( ans , i - stack . pop ()); return ans ; } } 963. Minimum Area Rectangle II $\\star\\star$ class Solution { public double minAreaFreeRect ( int [][] points ) { Long ans = Long . MAX_VALUE ; Map < Integer , List < int []>> centerToPoints = new HashMap <> (); for ( int [] A : points ) for ( int [] B : points ) { int center = hash ( A , B ); if ( centerToPoints . get ( center ) == null ) centerToPoints . put ( center , new ArrayList <> ()); centerToPoints . get ( center ). add ( new int [] { A [ 0 ] , A [ 1 ] , B [ 0 ] , B [ 1 ] }); } for ( List < int []> pointPairs : centerToPoints . values ()) for ( int [] ab : pointPairs ) for ( int [] cd : pointPairs ) { int ax = ab [ 0 ] , ay = ab [ 1 ] ; int cx = cd [ 0 ] , cy = cd [ 1 ] , dx = cd [ 2 ] , dy = cd [ 3 ] ; if (( cx - ax ) * ( dx - ax ) + ( cy - ay ) * ( dy - ay ) == 0 ) { Long squaredArea = dist ( ax , ay , cx , cy ) * dist ( ax , ay , dx , dy ); if ( squaredArea > 0 ) ans = Math . min ( ans , squaredArea ); } } return ans == Long . MAX_VALUE ? 0 : Math . sqrt ( ans ); } private int hash ( int [] p , int [] q ) { return (( p [ 0 ] + q [ 0 ] ) << 16 ) + ( p [ 1 ] + q [ 1 ] ); } private Long dist ( long px , long py , long qx , long qy ) { return ( px - qx ) * ( px - qx ) + ( py - qy ) * ( py - qy ); } } 964. Least Operators to Express Number $\\star\\star\\star$ class Solution { public int leastOpsExpressTarget ( int x , int target ) { return dfs ( x , target ); } private Map < Integer , Integer > memo = new HashMap <> (); private int dfs ( int x , int target ) { if ( memo . containsKey ( target )) return memo . get ( target ); if ( x > target ) return Math . min ( 2 * target - 1 , 2 * ( x - target )); if ( x == target ) return 0 ; long prod = x ; int n = 0 ; while ( prod < target ) { prod *= x ; ++ n ; } if ( prod == target ) { memo . put ( target , n ); return memo . get ( target ); } memo . put ( target , Integer . MAX_VALUE ); if ( prod < 2 * target ) memo . put ( target , dfs ( x , ( int ) ( prod - ( long ) target )) + n + 1 ); memo . put ( target , Math . min ( memo . get ( target ), dfs ( x , target - ( int ) ( prod / ( long ) x )) + n )); return memo . get ( target ); } } 965. Univalued Binary Tree $\\star$ 966. Vowel Spellchecker $\\star\\star$ class Solution { public String [] spellchecker ( String [] wordlist , String [] queries ) { List < String > ans = new ArrayList <> (); Map < String , String > dict = new HashMap <> (); for ( final String word : wordlist ) { dict . putIfAbsent ( word , word ); dict . putIfAbsent ( lowerKey ( word ), word ); dict . putIfAbsent ( vowelKey ( word ), word ); } for ( final String query : queries ) if ( dict . containsKey ( query )) ans . add ( dict . get ( query )); else if ( dict . containsKey ( lowerKey ( query ))) ans . add ( dict . get ( lowerKey ( query ))); else if ( dict . containsKey ( vowelKey ( query ))) ans . add ( dict . get ( vowelKey ( query ))); else ans . add ( \"\" ); return ans . toArray ( new String [ 0 ] ); } private String lowerKey ( final String word ) { return \"$\" + word . toLowerCase (); } private String vowelKey ( final String word ) { String s = \"\" ; for ( char c : word . toCharArray ()) s += isVowel ( c ) ? '*' : Character . toLowerCase ( c ); return s ; } private boolean isVowel ( char c ) { c = Character . toLowerCase ( c ); return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ; } } 967. Numbers With Same Consecutive Differences $\\star\\star$ 968. Binary Tree Cameras $\\star\\star\\star$ 969. Pancake Sorting $\\star\\star$ class Solution { public List < Integer > pancakeSort ( int [] A ) { List < Integer > ans = new ArrayList <> (); for ( int target = A . length ; target >= 1 ; -- target ) { int index = find ( A , target ); reverse ( A , 0 , index ); reverse ( A , 0 , target - 1 ); ans . add ( index + 1 ); ans . add ( target ); } return ans ; } private int find ( int [] A , int target ) { for ( int i = 0 ; i < A . length ; ++ i ) if ( A [ i ] == target ) return i ; throw new IllegalArgumentException (); } private void reverse ( int [] A , int l , int r ) { while ( l < r ) swap ( A , l ++ , r -- ); } private void swap ( int [] A , int l , int r ) { int temp = A [ l ] ; A [ l ] = A [ r ] ; A [ r ] = temp ; } } 970. Powerful Integers $\\star$ class Solution { public List < Integer > powerfulIntegers ( int x , int y , int bound ) { Set < Integer > ans = new HashSet <> (); for ( int i = 1 ; i < bound ; i *= x ) { for ( int j = 1 ; i + j <= bound ; j *= y ) { ans . add ( i + j ); if ( y == 1 ) break ; } if ( x == 1 ) break ; } return new ArrayList <> ( ans ); } }","title":"0961-0970"},{"location":"java/0901-1000/0961-0970/#961-n-repeated-element-in-size-2n-array-star","text":"class Solution { public int repeatedNTimes ( int [] A ) { for ( int i = 0 ; i + 2 < A . length ; ++ i ) if ( A [ i ] == A [ i + 1 ] || A [ i ] == A [ i + 2 ] ) return A [ i ] ; return A [ A . length - 1 ] ; } }","title":"961. N-Repeated Element in Size 2N Array $\\star$"},{"location":"java/0901-1000/0961-0970/#962-maximum-width-ramp-starstar","text":"class Solution { public int maxWidthRamp ( int [] A ) { int ans = 0 ; Stack < Integer > stack = new Stack <> (); for ( int i = 0 ; i < A . length ; ++ i ) if ( stack . isEmpty () || A [ i ] < A [ stack . peek () ] ) stack . push ( i ); for ( int i = A . length - 1 ; i > ans ; -- i ) while ( ! stack . isEmpty () && A [ i ] >= A [ stack . peek () ] ) ans = Math . max ( ans , i - stack . pop ()); return ans ; } }","title":"962. Maximum Width Ramp $\\star\\star$"},{"location":"java/0901-1000/0961-0970/#963-minimum-area-rectangle-ii-starstar","text":"class Solution { public double minAreaFreeRect ( int [][] points ) { Long ans = Long . MAX_VALUE ; Map < Integer , List < int []>> centerToPoints = new HashMap <> (); for ( int [] A : points ) for ( int [] B : points ) { int center = hash ( A , B ); if ( centerToPoints . get ( center ) == null ) centerToPoints . put ( center , new ArrayList <> ()); centerToPoints . get ( center ). add ( new int [] { A [ 0 ] , A [ 1 ] , B [ 0 ] , B [ 1 ] }); } for ( List < int []> pointPairs : centerToPoints . values ()) for ( int [] ab : pointPairs ) for ( int [] cd : pointPairs ) { int ax = ab [ 0 ] , ay = ab [ 1 ] ; int cx = cd [ 0 ] , cy = cd [ 1 ] , dx = cd [ 2 ] , dy = cd [ 3 ] ; if (( cx - ax ) * ( dx - ax ) + ( cy - ay ) * ( dy - ay ) == 0 ) { Long squaredArea = dist ( ax , ay , cx , cy ) * dist ( ax , ay , dx , dy ); if ( squaredArea > 0 ) ans = Math . min ( ans , squaredArea ); } } return ans == Long . MAX_VALUE ? 0 : Math . sqrt ( ans ); } private int hash ( int [] p , int [] q ) { return (( p [ 0 ] + q [ 0 ] ) << 16 ) + ( p [ 1 ] + q [ 1 ] ); } private Long dist ( long px , long py , long qx , long qy ) { return ( px - qx ) * ( px - qx ) + ( py - qy ) * ( py - qy ); } }","title":"963. Minimum Area Rectangle II $\\star\\star$"},{"location":"java/0901-1000/0961-0970/#964-least-operators-to-express-number-starstarstar","text":"class Solution { public int leastOpsExpressTarget ( int x , int target ) { return dfs ( x , target ); } private Map < Integer , Integer > memo = new HashMap <> (); private int dfs ( int x , int target ) { if ( memo . containsKey ( target )) return memo . get ( target ); if ( x > target ) return Math . min ( 2 * target - 1 , 2 * ( x - target )); if ( x == target ) return 0 ; long prod = x ; int n = 0 ; while ( prod < target ) { prod *= x ; ++ n ; } if ( prod == target ) { memo . put ( target , n ); return memo . get ( target ); } memo . put ( target , Integer . MAX_VALUE ); if ( prod < 2 * target ) memo . put ( target , dfs ( x , ( int ) ( prod - ( long ) target )) + n + 1 ); memo . put ( target , Math . min ( memo . get ( target ), dfs ( x , target - ( int ) ( prod / ( long ) x )) + n )); return memo . get ( target ); } }","title":"964. Least Operators to Express Number $\\star\\star\\star$"},{"location":"java/0901-1000/0961-0970/#965-univalued-binary-tree-star","text":"","title":"965. Univalued Binary Tree $\\star$"},{"location":"java/0901-1000/0961-0970/#966-vowel-spellchecker-starstar","text":"class Solution { public String [] spellchecker ( String [] wordlist , String [] queries ) { List < String > ans = new ArrayList <> (); Map < String , String > dict = new HashMap <> (); for ( final String word : wordlist ) { dict . putIfAbsent ( word , word ); dict . putIfAbsent ( lowerKey ( word ), word ); dict . putIfAbsent ( vowelKey ( word ), word ); } for ( final String query : queries ) if ( dict . containsKey ( query )) ans . add ( dict . get ( query )); else if ( dict . containsKey ( lowerKey ( query ))) ans . add ( dict . get ( lowerKey ( query ))); else if ( dict . containsKey ( vowelKey ( query ))) ans . add ( dict . get ( vowelKey ( query ))); else ans . add ( \"\" ); return ans . toArray ( new String [ 0 ] ); } private String lowerKey ( final String word ) { return \"$\" + word . toLowerCase (); } private String vowelKey ( final String word ) { String s = \"\" ; for ( char c : word . toCharArray ()) s += isVowel ( c ) ? '*' : Character . toLowerCase ( c ); return s ; } private boolean isVowel ( char c ) { c = Character . toLowerCase ( c ); return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ; } }","title":"966. Vowel Spellchecker $\\star\\star$"},{"location":"java/0901-1000/0961-0970/#967-numbers-with-same-consecutive-differences-starstar","text":"","title":"967. Numbers With Same Consecutive Differences $\\star\\star$"},{"location":"java/0901-1000/0961-0970/#968-binary-tree-cameras-starstarstar","text":"","title":"968. Binary Tree Cameras $\\star\\star\\star$"},{"location":"java/0901-1000/0961-0970/#969-pancake-sorting-starstar","text":"class Solution { public List < Integer > pancakeSort ( int [] A ) { List < Integer > ans = new ArrayList <> (); for ( int target = A . length ; target >= 1 ; -- target ) { int index = find ( A , target ); reverse ( A , 0 , index ); reverse ( A , 0 , target - 1 ); ans . add ( index + 1 ); ans . add ( target ); } return ans ; } private int find ( int [] A , int target ) { for ( int i = 0 ; i < A . length ; ++ i ) if ( A [ i ] == target ) return i ; throw new IllegalArgumentException (); } private void reverse ( int [] A , int l , int r ) { while ( l < r ) swap ( A , l ++ , r -- ); } private void swap ( int [] A , int l , int r ) { int temp = A [ l ] ; A [ l ] = A [ r ] ; A [ r ] = temp ; } }","title":"969. Pancake Sorting $\\star\\star$"},{"location":"java/0901-1000/0961-0970/#970-powerful-integers-star","text":"class Solution { public List < Integer > powerfulIntegers ( int x , int y , int bound ) { Set < Integer > ans = new HashSet <> (); for ( int i = 1 ; i < bound ; i *= x ) { for ( int j = 1 ; i + j <= bound ; j *= y ) { ans . add ( i + j ); if ( y == 1 ) break ; } if ( x == 1 ) break ; } return new ArrayList <> ( ans ); } }","title":"970. Powerful Integers $\\star$"},{"location":"java/0901-1000/0971-0980/","text":"971. Flip Binary Tree To Match Preorder Traversal $\\star\\star$ 972. Equal Rational Numbers $\\star\\star\\star$ class Solution { public boolean isRationalEqual ( String S , String T ) { return Math . abs ( valueOf ( S ) - valueOf ( T )) < 1e-9 ; } private double [] ratios = new double [] { 1.0 , 1.0 / 9 , 1.0 / 99 , 1.0 / 999 , 1.0 / 9999 }; private double valueOf ( final String s ) { if ( ! s . contains ( \"(\" )) return Double . valueOf ( s ); double integer_nonRepeating = Double . valueOf ( s . substring ( 0 , s . indexOf ( '(' ))); int nonRepeatingLength = s . indexOf ( '(' ) - s . indexOf ( '.' ) - 1 ; int repeating = Integer . parseInt ( s . substring ( s . indexOf ( '(' ) + 1 , s . indexOf ( ')' ))); int repeatingLength = s . indexOf ( ')' ) - s . indexOf ( '(' ) - 1 ; return integer_nonRepeating + repeating * Math . pow ( 0.1 , nonRepeatingLength ) * ratios [ repeatingLength ] ; } } 973. K Closest Points to Origin $\\star\\star$ 974. Subarray Sums Divisible by K $\\star\\star$ class Solution { public int subarraysDivByK ( int [] A , int K ) { int ans = 0 ; int prefixSum = 0 ; int [] count = new int [ K ] ; count [ 0 ] = 1 ; for ( int a : A ) { prefixSum = ( prefixSum + a % K + K ) % K ; ans += count [ prefixSum ] ; ++ count [ prefixSum ] ; } return ans ; } } 975. Odd Even Jump $\\star\\star\\star$ 976. Largest Perimeter Triangle $\\star$ class Solution { public int largestPerimeter ( int [] A ) { Arrays . sort ( A ); for ( int i = A . length - 1 ; i > 1 ; -- i ) if ( A [ i - 2 ] + A [ i - 1 ] > A [ i ] ) return A [ i - 2 ] + A [ i - 1 ] + A [ i ] ; return 0 ; } } 977. Squares of a Sorted Array $\\star$ class Solution { public int [] sortedSquares ( int [] A ) { int n = A . length ; int l = 0 ; int r = n - 1 ; int [] ans = new int [ n ] ; while ( l <= r ) ans [-- n ] = Math . abs ( A [ l ] ) > Math . abs ( A [ r ] ) ? A [ l ] * A [ l ++] : A [ r ] * A [ r --] ; return ans ; } } 978. Longest Turbulent Subarray $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution { public int maxTurbulenceSize ( int [] A ) { int ans = 1 ; int increasing = 1 ; int decreasing = 1 ; for ( int i = 1 ; i < A . length ; ++ i ) { if ( A [ i ] > A [ i - 1 ] ) { increasing = decreasing + 1 ; decreasing = 1 ; } else if ( A [ i ] < A [ i - 1 ] ) { decreasing = increasing + 1 ; increasing = 1 ; } else { increasing = 1 ; decreasing = 1 ; } ans = Math . max ( ans , Math . max ( increasing , decreasing )); } return ans ; } } 979. Distribute Coins in Binary Tree $\\star\\star$ 980. Unique Paths III $\\star\\star\\star$","title":"0971-0980"},{"location":"java/0901-1000/0971-0980/#971-flip-binary-tree-to-match-preorder-traversal-starstar","text":"","title":"971. Flip Binary Tree To Match Preorder Traversal $\\star\\star$"},{"location":"java/0901-1000/0971-0980/#972-equal-rational-numbers-starstarstar","text":"class Solution { public boolean isRationalEqual ( String S , String T ) { return Math . abs ( valueOf ( S ) - valueOf ( T )) < 1e-9 ; } private double [] ratios = new double [] { 1.0 , 1.0 / 9 , 1.0 / 99 , 1.0 / 999 , 1.0 / 9999 }; private double valueOf ( final String s ) { if ( ! s . contains ( \"(\" )) return Double . valueOf ( s ); double integer_nonRepeating = Double . valueOf ( s . substring ( 0 , s . indexOf ( '(' ))); int nonRepeatingLength = s . indexOf ( '(' ) - s . indexOf ( '.' ) - 1 ; int repeating = Integer . parseInt ( s . substring ( s . indexOf ( '(' ) + 1 , s . indexOf ( ')' ))); int repeatingLength = s . indexOf ( ')' ) - s . indexOf ( '(' ) - 1 ; return integer_nonRepeating + repeating * Math . pow ( 0.1 , nonRepeatingLength ) * ratios [ repeatingLength ] ; } }","title":"972. Equal Rational Numbers $\\star\\star\\star$"},{"location":"java/0901-1000/0971-0980/#973-k-closest-points-to-origin-starstar","text":"","title":"973. K Closest Points to Origin $\\star\\star$"},{"location":"java/0901-1000/0971-0980/#974-subarray-sums-divisible-by-k-starstar","text":"class Solution { public int subarraysDivByK ( int [] A , int K ) { int ans = 0 ; int prefixSum = 0 ; int [] count = new int [ K ] ; count [ 0 ] = 1 ; for ( int a : A ) { prefixSum = ( prefixSum + a % K + K ) % K ; ans += count [ prefixSum ] ; ++ count [ prefixSum ] ; } return ans ; } }","title":"974. Subarray Sums Divisible by K $\\star\\star$"},{"location":"java/0901-1000/0971-0980/#975-odd-even-jump-starstarstar","text":"","title":"975. Odd Even Jump $\\star\\star\\star$"},{"location":"java/0901-1000/0971-0980/#976-largest-perimeter-triangle-star","text":"class Solution { public int largestPerimeter ( int [] A ) { Arrays . sort ( A ); for ( int i = A . length - 1 ; i > 1 ; -- i ) if ( A [ i - 2 ] + A [ i - 1 ] > A [ i ] ) return A [ i - 2 ] + A [ i - 1 ] + A [ i ] ; return 0 ; } }","title":"976. Largest Perimeter Triangle $\\star$"},{"location":"java/0901-1000/0971-0980/#977-squares-of-a-sorted-array-star","text":"class Solution { public int [] sortedSquares ( int [] A ) { int n = A . length ; int l = 0 ; int r = n - 1 ; int [] ans = new int [ n ] ; while ( l <= r ) ans [-- n ] = Math . abs ( A [ l ] ) > Math . abs ( A [ r ] ) ? A [ l ] * A [ l ++] : A [ r ] * A [ r --] ; return ans ; } }","title":"977. Squares of a Sorted Array $\\star$"},{"location":"java/0901-1000/0971-0980/#978-longest-turbulent-subarray-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution { public int maxTurbulenceSize ( int [] A ) { int ans = 1 ; int increasing = 1 ; int decreasing = 1 ; for ( int i = 1 ; i < A . length ; ++ i ) { if ( A [ i ] > A [ i - 1 ] ) { increasing = decreasing + 1 ; decreasing = 1 ; } else if ( A [ i ] < A [ i - 1 ] ) { decreasing = increasing + 1 ; increasing = 1 ; } else { increasing = 1 ; decreasing = 1 ; } ans = Math . max ( ans , Math . max ( increasing , decreasing )); } return ans ; } }","title":"978. Longest Turbulent Subarray $\\star\\star$"},{"location":"java/0901-1000/0971-0980/#979-distribute-coins-in-binary-tree-starstar","text":"","title":"979. Distribute Coins in Binary Tree $\\star\\star$"},{"location":"java/0901-1000/0971-0980/#980-unique-paths-iii-starstarstar","text":"","title":"980. Unique Paths III $\\star\\star\\star$"},{"location":"java/0901-1000/0981-0990/","text":"981. Time Based Key-Value Store $\\star\\star$ class TimeMap { public void set ( String key , String value , int timestamp ) { if ( ! map . containsKey ( key )) map . put ( key , new TreeMap <> ()); map . get ( key ). put ( timestamp , value ); } public String get ( String key , int timestamp ) { Integer floorKey = map . get ( key ). floorKey ( timestamp ); return floorKey == null ? \"\" : map . get ( key ). get ( floorKey ); } private Map < String , TreeMap < Integer , String >> map = new HashMap <> (); } 982. Triples with Bitwise AND Equal To Zero $\\star\\star\\star$ 983. Minimum Cost For Tickets $\\star\\star$ class Solution { public int mincostTickets ( int [] days , int [] costs ) { int ans = 0 ; Queue < int []> last7 = new LinkedList <> (); // [day, cost] Queue < int []> last30 = new LinkedList <> (); for ( int day : days ) { while ( ! last7 . isEmpty () && last7 . peek () [ 0 ] + 7 <= day ) last7 . poll (); while ( ! last30 . isEmpty () && last30 . peek () [ 0 ] + 30 <= day ) last30 . poll (); last7 . offer ( new int [] { day , ans + costs [ 1 ] }); last30 . offer ( new int [] { day , ans + costs [ 2 ] }); ans = Math . min ( ans + costs [ 0 ] , Math . min ( last7 . peek () [ 1 ] , last30 . peek () [ 1 ] )); } return ans ; } } 984. String Without AAA or BBB $\\star\\star$ 985. Sum of Even Numbers After Queries $\\star$ class Solution { public int [] sumEvenAfterQueries ( int [] A , int [][] queries ) { int [] ans = new int [ queries . length ] ; int sum = 0 ; for ( int a : A ) sum += a % 2 == 0 ? a : 0 ; for ( int i = 0 ; i < queries . length ; ++ i ) { if ( A [ queries [ i ][ 1 ]] % 2 == 0 ) sum -= A [ queries [ i ][ 1 ]] ; A [ queries [ i ][ 1 ]] += queries [ i ][ 0 ] ; if ( A [ queries [ i ][ 1 ]] % 2 == 0 ) sum += A [ queries [ i ][ 1 ]] ; ans [ i ] = sum ; } return ans ; } } 986. Interval List Intersections $\\star\\star$ 987. Vertical Order Traversal of a Binary Tree $\\star\\star$ class Solution { public List < List < Integer >> verticalTraversal ( TreeNode root ) { List < List < Integer >> ans = new ArrayList <> (); TreeMap < Integer , List < int []>> xToNodes = new TreeMap <> (); dfs ( root , 0 , 0 , xToNodes ); for ( List < int []> nodes : xToNodes . values ()) { Collections . sort ( nodes , new Comparator < int []> () { @Override public int compare ( int [] n1 , int [] n2 ) { return n1 [ 0 ] == n2 [ 0 ] ? n1 [ 1 ] - n2 [ 1 ] : n2 [ 0 ] - n1 [ 0 ] ; } }); List < Integer > vals = new ArrayList <> (); for ( int [] node : nodes ) vals . add ( node [ 1 ] ); ans . add ( vals ); } return ans ; } private void dfs ( TreeNode root , int x , int y , TreeMap < Integer , List < int []>> xToNodes ) { if ( root == null ) return ; if ( ! xToNodes . containsKey ( x )) xToNodes . put ( x , new ArrayList <> ()); xToNodes . get ( x ). add ( new int [] { y , root . val }); dfs ( root . left , x - 1 , y - 1 , xToNodes ); dfs ( root . right , x + 1 , y - 1 , xToNodes ); } } 988. Smallest String Starting From Leaf $\\star\\star$ 989. Add to Array-Form of Integer $\\star$ class Solution { public List < Integer > addToArrayForm ( int [] A , int K ) { List < Integer > ans = new LinkedList <> (); for ( int i = A . length - 1 ; i >= 0 ; -- i ) { ans . add ( 0 , ( A [ i ] + K ) % 10 ); K = ( A [ i ] + K ) / 10 ; } while ( K > 0 ) { ans . add ( 0 , K % 10 ); K /= 10 ; } return ans ; } } 990. Satisfiability of Equality Equations $\\star\\star$","title":"0981-0990"},{"location":"java/0901-1000/0981-0990/#981-time-based-key-value-store-starstar","text":"class TimeMap { public void set ( String key , String value , int timestamp ) { if ( ! map . containsKey ( key )) map . put ( key , new TreeMap <> ()); map . get ( key ). put ( timestamp , value ); } public String get ( String key , int timestamp ) { Integer floorKey = map . get ( key ). floorKey ( timestamp ); return floorKey == null ? \"\" : map . get ( key ). get ( floorKey ); } private Map < String , TreeMap < Integer , String >> map = new HashMap <> (); }","title":"981. Time Based Key-Value Store $\\star\\star$"},{"location":"java/0901-1000/0981-0990/#982-triples-with-bitwise-and-equal-to-zero-starstarstar","text":"","title":"982. Triples with Bitwise AND Equal To Zero $\\star\\star\\star$"},{"location":"java/0901-1000/0981-0990/#983-minimum-cost-for-tickets-starstar","text":"class Solution { public int mincostTickets ( int [] days , int [] costs ) { int ans = 0 ; Queue < int []> last7 = new LinkedList <> (); // [day, cost] Queue < int []> last30 = new LinkedList <> (); for ( int day : days ) { while ( ! last7 . isEmpty () && last7 . peek () [ 0 ] + 7 <= day ) last7 . poll (); while ( ! last30 . isEmpty () && last30 . peek () [ 0 ] + 30 <= day ) last30 . poll (); last7 . offer ( new int [] { day , ans + costs [ 1 ] }); last30 . offer ( new int [] { day , ans + costs [ 2 ] }); ans = Math . min ( ans + costs [ 0 ] , Math . min ( last7 . peek () [ 1 ] , last30 . peek () [ 1 ] )); } return ans ; } }","title":"983. Minimum Cost For Tickets $\\star\\star$"},{"location":"java/0901-1000/0981-0990/#984-string-without-aaa-or-bbb-starstar","text":"","title":"984. String Without AAA or BBB $\\star\\star$"},{"location":"java/0901-1000/0981-0990/#985-sum-of-even-numbers-after-queries-star","text":"class Solution { public int [] sumEvenAfterQueries ( int [] A , int [][] queries ) { int [] ans = new int [ queries . length ] ; int sum = 0 ; for ( int a : A ) sum += a % 2 == 0 ? a : 0 ; for ( int i = 0 ; i < queries . length ; ++ i ) { if ( A [ queries [ i ][ 1 ]] % 2 == 0 ) sum -= A [ queries [ i ][ 1 ]] ; A [ queries [ i ][ 1 ]] += queries [ i ][ 0 ] ; if ( A [ queries [ i ][ 1 ]] % 2 == 0 ) sum += A [ queries [ i ][ 1 ]] ; ans [ i ] = sum ; } return ans ; } }","title":"985. Sum of Even Numbers After Queries $\\star$"},{"location":"java/0901-1000/0981-0990/#986-interval-list-intersections-starstar","text":"","title":"986. Interval List Intersections $\\star\\star$"},{"location":"java/0901-1000/0981-0990/#987-vertical-order-traversal-of-a-binary-tree-starstar","text":"class Solution { public List < List < Integer >> verticalTraversal ( TreeNode root ) { List < List < Integer >> ans = new ArrayList <> (); TreeMap < Integer , List < int []>> xToNodes = new TreeMap <> (); dfs ( root , 0 , 0 , xToNodes ); for ( List < int []> nodes : xToNodes . values ()) { Collections . sort ( nodes , new Comparator < int []> () { @Override public int compare ( int [] n1 , int [] n2 ) { return n1 [ 0 ] == n2 [ 0 ] ? n1 [ 1 ] - n2 [ 1 ] : n2 [ 0 ] - n1 [ 0 ] ; } }); List < Integer > vals = new ArrayList <> (); for ( int [] node : nodes ) vals . add ( node [ 1 ] ); ans . add ( vals ); } return ans ; } private void dfs ( TreeNode root , int x , int y , TreeMap < Integer , List < int []>> xToNodes ) { if ( root == null ) return ; if ( ! xToNodes . containsKey ( x )) xToNodes . put ( x , new ArrayList <> ()); xToNodes . get ( x ). add ( new int [] { y , root . val }); dfs ( root . left , x - 1 , y - 1 , xToNodes ); dfs ( root . right , x + 1 , y - 1 , xToNodes ); } }","title":"987. Vertical Order Traversal of a Binary Tree $\\star\\star$"},{"location":"java/0901-1000/0981-0990/#988-smallest-string-starting-from-leaf-starstar","text":"","title":"988. Smallest String Starting From Leaf $\\star\\star$"},{"location":"java/0901-1000/0981-0990/#989-add-to-array-form-of-integer-star","text":"class Solution { public List < Integer > addToArrayForm ( int [] A , int K ) { List < Integer > ans = new LinkedList <> (); for ( int i = A . length - 1 ; i >= 0 ; -- i ) { ans . add ( 0 , ( A [ i ] + K ) % 10 ); K = ( A [ i ] + K ) / 10 ; } while ( K > 0 ) { ans . add ( 0 , K % 10 ); K /= 10 ; } return ans ; } }","title":"989. Add to Array-Form of Integer $\\star$"},{"location":"java/0901-1000/0981-0990/#990-satisfiability-of-equality-equations-starstar","text":"","title":"990. Satisfiability of Equality Equations $\\star\\star$"},{"location":"java/0901-1000/0991-1000/","text":"991. Broken Calculator $\\star\\star$ class Solution { public int brokenCalc ( int X , int Y ) { int ops = 0 ; while ( X < Y ) { if ( Y % 2 == 0 ) Y /= 2 ; else Y += 1 ; ++ ops ; } return ops + X - Y ; } } 992. Subarrays with K Different Integers $\\star\\star\\star$ class Solution { public int subarraysWithKDistinct ( int [] A , int K ) { return subarraysWithAtMostKDistinct ( A , K ) - subarraysWithAtMostKDistinct ( A , K - 1 ); } private int subarraysWithAtMostKDistinct ( int [] A , int K ) { int ans = 0 ; int [] count = new int [ A . length + 1 ] ; for ( int l = 0 , r = 0 ; r < A . length ; ++ r ) { if ( ++ count [ A [ r ]] == 1 ) -- K ; while ( K < 0 ) if ( -- count [ A [ l ++]] == 0 ) ++ K ; ans += r - l + 1 ; } return ans ; } } 993. Cousins in Binary Tree $\\star$ 994. Rotting Oranges $\\star\\star$ 995. Minimum Number of K Consecutive Bit Flips $\\star\\star\\star$ class Solution { public int minKBitFlips ( int [] A , int K ) { int ans = 0 ; int flippedTime = 0 ; for ( int r = 0 ; r < A . length ; ++ r ) { if ( r >= K && A [ r - K ] == 2 ) -- flippedTime ; if ( flippedTime % 2 == A [ r ] ) { if ( r + K > A . length ) return - 1 ; ++ ans ; ++ flippedTime ; A [ r ] = 2 ; } } return ans ; } } 996. Number of Squareful Arrays $\\star\\star\\star$ class Solution { public int numSquarefulPerms ( int [] A ) { boolean [] used = new boolean [ A . length ] ; Arrays . sort ( A ); dfs ( A , used , new ArrayList <> ()); return ans ; } private int ans = 0 ; private void dfs ( int [] A , boolean [] used , List < Integer > path ) { if ( path . size () > 1 && ! isSquare ( path . get ( path . size () - 1 ) + path . get ( path . size () - 2 ))) return ; if ( path . size () == A . length ) { ++ ans ; return ; } for ( int i = 0 ; i < A . length ; ++ i ) { if ( used [ i ] ) continue ; if ( i > 0 && A [ i ] == A [ i - 1 ] && ! used [ i - 1 ] ) continue ; used [ i ] = true ; path . add ( A [ i ] ); dfs ( A , used , path ); path . remove ( path . size () - 1 ); used [ i ] = false ; } } private boolean isSquare ( int num ) { int root = ( int ) Math . sqrt ( num ); return root * root == num ; } } 997. Find the Town Judge $\\star$ class Solution { public int findJudge ( int N , int [][] trust ) { int [] count = new int [ N + 1 ] ; for ( int [] t : trust ) { -- count [ t [ 0 ]] ; ++ count [ t [ 1 ]] ; } for ( int i = 1 ; i < N + 1 ; ++ i ) if ( count [ i ] == N - 1 ) return i ; return - 1 ; } } 998. Maximum Binary Tree II $\\star\\star$ 999. Available Captures for Rook $\\star$ class Solution { public int numRookCaptures ( char [][] board ) { int ans = 0 ; int i0 = 0 ; int j0 = 0 ; for ( int i = 0 ; i < 8 ; ++ i ) for ( int j = 0 ; j < 8 ; ++ j ) if ( board [ i ][ j ] == 'R' ) { i0 = i ; j0 = j ; } for ( int [] d : new int [][] { { 1 , 0 }, { 0 , 1 }, { - 1 , 0 }, { 0 , - 1 } }) for ( int i = i0 + d [ 0 ] , j = j0 + d [ 1 ] ; 0 <= i && i < 8 && 0 <= j && j < 8 ; i += d [ 0 ] , j += d [ 1 ] ) { if ( board [ i ][ j ] == 'p' ) ++ ans ; if ( board [ i ][ j ] != '.' ) break ; } return ans ; } } 1000. Minimum Cost to Merge Stones $\\star\\star\\star$","title":"0991-1000"},{"location":"java/0901-1000/0991-1000/#991-broken-calculator-starstar","text":"class Solution { public int brokenCalc ( int X , int Y ) { int ops = 0 ; while ( X < Y ) { if ( Y % 2 == 0 ) Y /= 2 ; else Y += 1 ; ++ ops ; } return ops + X - Y ; } }","title":"991. Broken Calculator $\\star\\star$"},{"location":"java/0901-1000/0991-1000/#992-subarrays-with-k-different-integers-starstarstar","text":"class Solution { public int subarraysWithKDistinct ( int [] A , int K ) { return subarraysWithAtMostKDistinct ( A , K ) - subarraysWithAtMostKDistinct ( A , K - 1 ); } private int subarraysWithAtMostKDistinct ( int [] A , int K ) { int ans = 0 ; int [] count = new int [ A . length + 1 ] ; for ( int l = 0 , r = 0 ; r < A . length ; ++ r ) { if ( ++ count [ A [ r ]] == 1 ) -- K ; while ( K < 0 ) if ( -- count [ A [ l ++]] == 0 ) ++ K ; ans += r - l + 1 ; } return ans ; } }","title":"992. Subarrays with K Different Integers $\\star\\star\\star$"},{"location":"java/0901-1000/0991-1000/#993-cousins-in-binary-tree-star","text":"","title":"993. Cousins in Binary Tree $\\star$"},{"location":"java/0901-1000/0991-1000/#994-rotting-oranges-starstar","text":"","title":"994. Rotting Oranges $\\star\\star$"},{"location":"java/0901-1000/0991-1000/#995-minimum-number-of-k-consecutive-bit-flips-starstarstar","text":"class Solution { public int minKBitFlips ( int [] A , int K ) { int ans = 0 ; int flippedTime = 0 ; for ( int r = 0 ; r < A . length ; ++ r ) { if ( r >= K && A [ r - K ] == 2 ) -- flippedTime ; if ( flippedTime % 2 == A [ r ] ) { if ( r + K > A . length ) return - 1 ; ++ ans ; ++ flippedTime ; A [ r ] = 2 ; } } return ans ; } }","title":"995. Minimum Number of K Consecutive Bit Flips $\\star\\star\\star$"},{"location":"java/0901-1000/0991-1000/#996-number-of-squareful-arrays-starstarstar","text":"class Solution { public int numSquarefulPerms ( int [] A ) { boolean [] used = new boolean [ A . length ] ; Arrays . sort ( A ); dfs ( A , used , new ArrayList <> ()); return ans ; } private int ans = 0 ; private void dfs ( int [] A , boolean [] used , List < Integer > path ) { if ( path . size () > 1 && ! isSquare ( path . get ( path . size () - 1 ) + path . get ( path . size () - 2 ))) return ; if ( path . size () == A . length ) { ++ ans ; return ; } for ( int i = 0 ; i < A . length ; ++ i ) { if ( used [ i ] ) continue ; if ( i > 0 && A [ i ] == A [ i - 1 ] && ! used [ i - 1 ] ) continue ; used [ i ] = true ; path . add ( A [ i ] ); dfs ( A , used , path ); path . remove ( path . size () - 1 ); used [ i ] = false ; } } private boolean isSquare ( int num ) { int root = ( int ) Math . sqrt ( num ); return root * root == num ; } }","title":"996. Number of Squareful Arrays $\\star\\star\\star$"},{"location":"java/0901-1000/0991-1000/#997-find-the-town-judge-star","text":"class Solution { public int findJudge ( int N , int [][] trust ) { int [] count = new int [ N + 1 ] ; for ( int [] t : trust ) { -- count [ t [ 0 ]] ; ++ count [ t [ 1 ]] ; } for ( int i = 1 ; i < N + 1 ; ++ i ) if ( count [ i ] == N - 1 ) return i ; return - 1 ; } }","title":"997. Find the Town Judge $\\star$"},{"location":"java/0901-1000/0991-1000/#998-maximum-binary-tree-ii-starstar","text":"","title":"998. Maximum Binary Tree II $\\star\\star$"},{"location":"java/0901-1000/0991-1000/#999-available-captures-for-rook-star","text":"class Solution { public int numRookCaptures ( char [][] board ) { int ans = 0 ; int i0 = 0 ; int j0 = 0 ; for ( int i = 0 ; i < 8 ; ++ i ) for ( int j = 0 ; j < 8 ; ++ j ) if ( board [ i ][ j ] == 'R' ) { i0 = i ; j0 = j ; } for ( int [] d : new int [][] { { 1 , 0 }, { 0 , 1 }, { - 1 , 0 }, { 0 , - 1 } }) for ( int i = i0 + d [ 0 ] , j = j0 + d [ 1 ] ; 0 <= i && i < 8 && 0 <= j && j < 8 ; i += d [ 0 ] , j += d [ 1 ] ) { if ( board [ i ][ j ] == 'p' ) ++ ans ; if ( board [ i ][ j ] != '.' ) break ; } return ans ; } }","title":"999. Available Captures for Rook $\\star$"},{"location":"java/0901-1000/0991-1000/#1000-minimum-cost-to-merge-stones-starstarstar","text":"","title":"1000. Minimum Cost to Merge Stones $\\star\\star\\star$"},{"location":"java/1001-1100/1001-1010/","text":"1001. Grid Illumination $\\star\\star\\star$ class Solution { public int [] gridIllumination ( int N , int [][] lamps , int [][] queries ) { List < Integer > ans = new ArrayList <> (); Map < Integer , Integer > rows = new HashMap <> (); Map < Integer , Integer > cols = new HashMap <> (); Map < Integer , Integer > diag1 = new HashMap <> (); Map < Integer , Integer > diag2 = new HashMap <> (); Set < Long > lampsSet = new HashSet <> (); for ( int [] lamp : lamps ) { int i = lamp [ 0 ] ; int j = lamp [ 1 ] ; if ( lampsSet . add ( hash ( i , j ))) { rows . put ( i , rows . getOrDefault ( i , 0 ) + 1 ); cols . put ( j , cols . getOrDefault ( j , 0 ) + 1 ); diag1 . put ( i + j , diag1 . getOrDefault ( i + j , 0 ) + 1 ); diag2 . put ( i - j , diag2 . getOrDefault ( i - j , 0 ) + 1 ); } } for ( int [] query : queries ) { int i = query [ 0 ] ; int j = query [ 1 ] ; if ( rows . getOrDefault ( i , 0 ) > 0 || cols . getOrDefault ( j , 0 ) > 0 || diag1 . getOrDefault ( i + j , 0 ) > 0 || diag2 . getOrDefault ( i - j , 0 ) > 0 ) { ans . add ( 1 ); for ( int y = Math . max ( 0 , i - 1 ); y < Math . min ( N , i + 2 ); ++ y ) for ( int x = Math . max ( 0 , j - 1 ); x < Math . min ( N , j + 2 ); ++ x ) if ( lampsSet . remove ( hash ( y , x ))) { rows . put ( y , rows . getOrDefault ( y , 0 ) - 1 ); cols . put ( x , cols . getOrDefault ( x , 0 ) - 1 ); diag1 . put ( y + x , diag1 . getOrDefault ( y + x , 0 ) - 1 ); diag2 . put ( y - x , diag2 . getOrDefault ( y - x , 0 ) - 1 ); } } else ans . add ( 0 ); } return ans . stream (). mapToInt ( i -> i ). toArray (); } private long hash ( int i , int j ) { return (( long ) i << 32 ) + j ; } } 1002. Find Common Characters $\\star$ class Solution { public List < String > commonChars ( String [] A ) { List < String > ans = new ArrayList <> (); int [] commonCount = new int [ 26 ] ; Arrays . fill ( commonCount , Integer . MAX_VALUE ); for ( String a : A ) { int [] count = new int [ 26 ] ; for ( char c : a . toCharArray ()) ++ count [ c - 'a' ] ; for ( int i = 0 ; i < 26 ; ++ i ) commonCount [ i ] = Math . min ( commonCount [ i ] , count [ i ] ); } for ( char c = 'a' ; c <= 'z' ; ++ c ) for ( int i = 0 ; i < commonCount [ c - 'a' ] ; ++ i ) ans . add ( String . valueOf ( c )); return ans ; } } 1003. Check If Word Is Valid After Substitutions $\\star\\star$ class Solution { public boolean isValid ( String S ) { Stack < Character > stack = new Stack <> (); for ( char c : S . toCharArray ()) if ( c == 'c' ) { if ( stack . size () < 2 ) return false ; if ( stack . peek () != 'b' ) return false ; stack . pop (); if ( stack . peek () != 'a' ) return false ; stack . pop (); } else stack . push ( c ); return stack . isEmpty (); } } 1004. Max Consecutive Ones III $\\star\\star$ 1005. Maximize Sum Of Array After K Negations $\\star$ 1006. Clumsy Factorial $\\star\\star$ class Solution { public int clumsy ( int N ) { if ( N == 1 ) return 1 ; if ( N == 2 ) return 2 ; if ( N == 3 ) return 6 ; if ( N == 4 ) return 7 ; if ( N % 4 == 1 ) return N + 2 ; if ( N % 4 == 2 ) return N + 2 ; if ( N % 4 == 3 ) return N - 1 ; return N + 1 ; } } 1007. Minimum Domino Rotations For Equal Row $\\star\\star$ 1008. Construct Binary Search Tree from Preorder Traversal $\\star\\star$ 1009. Complement of Base 10 Integer $\\star$ class Solution { public int bitwiseComplement ( int N ) { int mask = 1 ; while ( mask < N ) mask = ( mask << 1 ) + 1 ; return mask ^ N ; } } 1010. Pairs of Songs With Total Durations Divisible by 60 $\\star$ class Solution { public int numPairsDivisibleBy60 ( int [] time ) { int ans = 0 ; int [] count = new int [ 60 ] ; for ( int t : time ) { t %= 60 ; ans += count [ ( 60 - t ) % 60 ] ; ++ count [ t ] ; } return ans ; } }","title":"1001-1010"},{"location":"java/1001-1100/1001-1010/#1001-grid-illumination-starstarstar","text":"class Solution { public int [] gridIllumination ( int N , int [][] lamps , int [][] queries ) { List < Integer > ans = new ArrayList <> (); Map < Integer , Integer > rows = new HashMap <> (); Map < Integer , Integer > cols = new HashMap <> (); Map < Integer , Integer > diag1 = new HashMap <> (); Map < Integer , Integer > diag2 = new HashMap <> (); Set < Long > lampsSet = new HashSet <> (); for ( int [] lamp : lamps ) { int i = lamp [ 0 ] ; int j = lamp [ 1 ] ; if ( lampsSet . add ( hash ( i , j ))) { rows . put ( i , rows . getOrDefault ( i , 0 ) + 1 ); cols . put ( j , cols . getOrDefault ( j , 0 ) + 1 ); diag1 . put ( i + j , diag1 . getOrDefault ( i + j , 0 ) + 1 ); diag2 . put ( i - j , diag2 . getOrDefault ( i - j , 0 ) + 1 ); } } for ( int [] query : queries ) { int i = query [ 0 ] ; int j = query [ 1 ] ; if ( rows . getOrDefault ( i , 0 ) > 0 || cols . getOrDefault ( j , 0 ) > 0 || diag1 . getOrDefault ( i + j , 0 ) > 0 || diag2 . getOrDefault ( i - j , 0 ) > 0 ) { ans . add ( 1 ); for ( int y = Math . max ( 0 , i - 1 ); y < Math . min ( N , i + 2 ); ++ y ) for ( int x = Math . max ( 0 , j - 1 ); x < Math . min ( N , j + 2 ); ++ x ) if ( lampsSet . remove ( hash ( y , x ))) { rows . put ( y , rows . getOrDefault ( y , 0 ) - 1 ); cols . put ( x , cols . getOrDefault ( x , 0 ) - 1 ); diag1 . put ( y + x , diag1 . getOrDefault ( y + x , 0 ) - 1 ); diag2 . put ( y - x , diag2 . getOrDefault ( y - x , 0 ) - 1 ); } } else ans . add ( 0 ); } return ans . stream (). mapToInt ( i -> i ). toArray (); } private long hash ( int i , int j ) { return (( long ) i << 32 ) + j ; } }","title":"1001. Grid Illumination $\\star\\star\\star$"},{"location":"java/1001-1100/1001-1010/#1002-find-common-characters-star","text":"class Solution { public List < String > commonChars ( String [] A ) { List < String > ans = new ArrayList <> (); int [] commonCount = new int [ 26 ] ; Arrays . fill ( commonCount , Integer . MAX_VALUE ); for ( String a : A ) { int [] count = new int [ 26 ] ; for ( char c : a . toCharArray ()) ++ count [ c - 'a' ] ; for ( int i = 0 ; i < 26 ; ++ i ) commonCount [ i ] = Math . min ( commonCount [ i ] , count [ i ] ); } for ( char c = 'a' ; c <= 'z' ; ++ c ) for ( int i = 0 ; i < commonCount [ c - 'a' ] ; ++ i ) ans . add ( String . valueOf ( c )); return ans ; } }","title":"1002. Find Common Characters $\\star$"},{"location":"java/1001-1100/1001-1010/#1003-check-if-word-is-valid-after-substitutions-starstar","text":"class Solution { public boolean isValid ( String S ) { Stack < Character > stack = new Stack <> (); for ( char c : S . toCharArray ()) if ( c == 'c' ) { if ( stack . size () < 2 ) return false ; if ( stack . peek () != 'b' ) return false ; stack . pop (); if ( stack . peek () != 'a' ) return false ; stack . pop (); } else stack . push ( c ); return stack . isEmpty (); } }","title":"1003. Check If Word Is Valid After Substitutions $\\star\\star$"},{"location":"java/1001-1100/1001-1010/#1004-max-consecutive-ones-iii-starstar","text":"","title":"1004. Max Consecutive Ones III $\\star\\star$"},{"location":"java/1001-1100/1001-1010/#1005-maximize-sum-of-array-after-k-negations-star","text":"","title":"1005. Maximize Sum Of Array After K Negations $\\star$"},{"location":"java/1001-1100/1001-1010/#1006-clumsy-factorial-starstar","text":"class Solution { public int clumsy ( int N ) { if ( N == 1 ) return 1 ; if ( N == 2 ) return 2 ; if ( N == 3 ) return 6 ; if ( N == 4 ) return 7 ; if ( N % 4 == 1 ) return N + 2 ; if ( N % 4 == 2 ) return N + 2 ; if ( N % 4 == 3 ) return N - 1 ; return N + 1 ; } }","title":"1006. Clumsy Factorial $\\star\\star$"},{"location":"java/1001-1100/1001-1010/#1007-minimum-domino-rotations-for-equal-row-starstar","text":"","title":"1007. Minimum Domino Rotations For Equal Row $\\star\\star$"},{"location":"java/1001-1100/1001-1010/#1008-construct-binary-search-tree-from-preorder-traversal-starstar","text":"","title":"1008. Construct Binary Search Tree from Preorder Traversal $\\star\\star$"},{"location":"java/1001-1100/1001-1010/#1009-complement-of-base-10-integer-star","text":"class Solution { public int bitwiseComplement ( int N ) { int mask = 1 ; while ( mask < N ) mask = ( mask << 1 ) + 1 ; return mask ^ N ; } }","title":"1009. Complement of Base 10 Integer $\\star$"},{"location":"java/1001-1100/1001-1010/#1010-pairs-of-songs-with-total-durations-divisible-by-60-star","text":"class Solution { public int numPairsDivisibleBy60 ( int [] time ) { int ans = 0 ; int [] count = new int [ 60 ] ; for ( int t : time ) { t %= 60 ; ans += count [ ( 60 - t ) % 60 ] ; ++ count [ t ] ; } return ans ; } }","title":"1010. Pairs of Songs With Total Durations Divisible by 60 $\\star$"},{"location":"java/1001-1100/1011-1020/","text":"1011. Capacity To Ship Packages Within D Days $\\star\\star$ class Solution { public int shipWithinDays ( int [] weights , int D ) { int l = Arrays . stream ( weights ). max (). getAsInt (); int r = Arrays . stream ( weights ). sum (); while ( l < r ) { int m = l + ( r - l ) / 2 ; int day = 1 ; int capacity = 0 ; for ( int weight : weights ) { if ( capacity + weight > m ) { ++ day ; capacity = weight ; } else capacity += weight ; } if ( day <= D ) r = m ; else l = m + 1 ; } return l ; } } 1012. Numbers With Repeated Digits $\\star\\star\\star$ class Solution { public int numDupDigitsAtMostN ( int N ) { dfs ( N , 0 , 0 ); return N - uniqueDigits + 1 ; } private int uniqueDigits = 0 ; private void dfs ( int N , int mask , long path ) { if ( path > N ) return ; ++ uniqueDigits ; for ( int digit = 0 ; digit < 10 ; ++ digit ) { if ( mask == 0 && digit == 0 ) continue ; if (( mask & ( 1 << digit )) > 0 ) continue ; dfs ( N , mask | ( 1 << digit ), path * 10 + digit ); } } } 1013. Partition Array Into Three Parts With Equal Sum $\\star$ class Solution { public boolean canThreePartsEqualSum ( int [] A ) { int sum = Arrays . stream ( A ). sum (); int prefixSum = 0 ; int parts = 1 ; for ( int a : A ) { prefixSum += a ; if ( prefixSum == sum * parts / 3 ) ++ parts ; } return sum % 3 == 0 && parts >= 3 ; } } 1014. Best Sightseeing Pair $\\star\\star$ class Solution { public int maxScoreSightseeingPair ( int [] A ) { int ans = 0 ; int bestPrev = 0 ; for ( int a : A ) { ans = Math . max ( ans , a + bestPrev ); bestPrev = Math . max ( bestPrev , a ) - 1 ; } return ans ; } } 1015. Smallest Integer Divisible by K $\\star\\star$ class Solution { public int smallestRepunitDivByK ( int K ) { if ( K % 10 != 1 && K % 10 != 3 && K % 10 != 7 && K % 10 != 9 ) return - 1 ; Set < Integer > seen = new HashSet <> (); int N = 0 ; for ( int length = 1 ; length <= K ; ++ length ) { N = ( N * 10 + 1 ) % K ; if ( N == 0 ) return length ; if ( seen . contains ( N )) return - 1 ; seen . add ( N ); } return - 1 ; } } 1016. Binary String With Substrings Representing 1 To N $\\star\\star$ class Solution { public boolean queryString ( String S , int N ) { if ( N > 1511 ) return false ; for ( int i = N ; i > N / 2 ; -- i ) if ( ! S . contains ( Integer . toBinaryString ( i ))) return false ; return true ; } } 1017. Convert to Base -2 $\\star\\star$ class Solution { public String baseNeg2 ( int N ) { StringBuilder ans = new StringBuilder (); while ( N != 0 ) { ans . append ( N & 1 ); N = - ( N >> 1 ); } return ans . length () > 0 ? ans . reverse (). toString () : \"0\" ; } } 1018. Binary Prefix Divisible By 5 $\\star$ class Solution { public List < Boolean > prefixesDivBy5 ( int [] A ) { List < Boolean > ans = new ArrayList <> (); int num = 0 ; for ( int a : A ) { num = ( num * 2 + a ) % 5 ; ans . add ( num % 5 == 0 ); } return ans ; } } 1019. Next Greater Node In Linked List $\\star\\star$ class Solution { public int [] nextLargerNodes ( ListNode head ) { List < Integer > ans = new ArrayList <> (); Stack < Integer > stack = new Stack <> (); for (; head != null ; head = head . next ) { while ( ! stack . isEmpty () && head . val > ans . get ( stack . peek ())) { int index = stack . pop (); ans . set ( index , head . val ); } stack . push ( ans . size ()); ans . add ( head . val ); } while ( ! stack . isEmpty ()) ans . set ( stack . pop (), 0 ); return ans . stream (). mapToInt ( i -> i ). toArray (); } } 1020. Number of Enclaves $\\star\\star$","title":"1011-1020"},{"location":"java/1001-1100/1011-1020/#1011-capacity-to-ship-packages-within-d-days-starstar","text":"class Solution { public int shipWithinDays ( int [] weights , int D ) { int l = Arrays . stream ( weights ). max (). getAsInt (); int r = Arrays . stream ( weights ). sum (); while ( l < r ) { int m = l + ( r - l ) / 2 ; int day = 1 ; int capacity = 0 ; for ( int weight : weights ) { if ( capacity + weight > m ) { ++ day ; capacity = weight ; } else capacity += weight ; } if ( day <= D ) r = m ; else l = m + 1 ; } return l ; } }","title":"1011. Capacity To Ship Packages Within D Days $\\star\\star$"},{"location":"java/1001-1100/1011-1020/#1012-numbers-with-repeated-digits-starstarstar","text":"class Solution { public int numDupDigitsAtMostN ( int N ) { dfs ( N , 0 , 0 ); return N - uniqueDigits + 1 ; } private int uniqueDigits = 0 ; private void dfs ( int N , int mask , long path ) { if ( path > N ) return ; ++ uniqueDigits ; for ( int digit = 0 ; digit < 10 ; ++ digit ) { if ( mask == 0 && digit == 0 ) continue ; if (( mask & ( 1 << digit )) > 0 ) continue ; dfs ( N , mask | ( 1 << digit ), path * 10 + digit ); } } }","title":"1012. Numbers With Repeated Digits $\\star\\star\\star$"},{"location":"java/1001-1100/1011-1020/#1013-partition-array-into-three-parts-with-equal-sum-star","text":"class Solution { public boolean canThreePartsEqualSum ( int [] A ) { int sum = Arrays . stream ( A ). sum (); int prefixSum = 0 ; int parts = 1 ; for ( int a : A ) { prefixSum += a ; if ( prefixSum == sum * parts / 3 ) ++ parts ; } return sum % 3 == 0 && parts >= 3 ; } }","title":"1013. Partition Array Into Three Parts With Equal Sum $\\star$"},{"location":"java/1001-1100/1011-1020/#1014-best-sightseeing-pair-starstar","text":"class Solution { public int maxScoreSightseeingPair ( int [] A ) { int ans = 0 ; int bestPrev = 0 ; for ( int a : A ) { ans = Math . max ( ans , a + bestPrev ); bestPrev = Math . max ( bestPrev , a ) - 1 ; } return ans ; } }","title":"1014. Best Sightseeing Pair $\\star\\star$"},{"location":"java/1001-1100/1011-1020/#1015-smallest-integer-divisible-by-k-starstar","text":"class Solution { public int smallestRepunitDivByK ( int K ) { if ( K % 10 != 1 && K % 10 != 3 && K % 10 != 7 && K % 10 != 9 ) return - 1 ; Set < Integer > seen = new HashSet <> (); int N = 0 ; for ( int length = 1 ; length <= K ; ++ length ) { N = ( N * 10 + 1 ) % K ; if ( N == 0 ) return length ; if ( seen . contains ( N )) return - 1 ; seen . add ( N ); } return - 1 ; } }","title":"1015. Smallest Integer Divisible by K $\\star\\star$"},{"location":"java/1001-1100/1011-1020/#1016-binary-string-with-substrings-representing-1-to-n-starstar","text":"class Solution { public boolean queryString ( String S , int N ) { if ( N > 1511 ) return false ; for ( int i = N ; i > N / 2 ; -- i ) if ( ! S . contains ( Integer . toBinaryString ( i ))) return false ; return true ; } }","title":"1016. Binary String With Substrings Representing 1 To N $\\star\\star$"},{"location":"java/1001-1100/1011-1020/#1017-convert-to-base-2-starstar","text":"class Solution { public String baseNeg2 ( int N ) { StringBuilder ans = new StringBuilder (); while ( N != 0 ) { ans . append ( N & 1 ); N = - ( N >> 1 ); } return ans . length () > 0 ? ans . reverse (). toString () : \"0\" ; } }","title":"1017. Convert to Base -2 $\\star\\star$"},{"location":"java/1001-1100/1011-1020/#1018-binary-prefix-divisible-by-5-star","text":"class Solution { public List < Boolean > prefixesDivBy5 ( int [] A ) { List < Boolean > ans = new ArrayList <> (); int num = 0 ; for ( int a : A ) { num = ( num * 2 + a ) % 5 ; ans . add ( num % 5 == 0 ); } return ans ; } }","title":"1018. Binary Prefix Divisible By 5 $\\star$"},{"location":"java/1001-1100/1011-1020/#1019-next-greater-node-in-linked-list-starstar","text":"class Solution { public int [] nextLargerNodes ( ListNode head ) { List < Integer > ans = new ArrayList <> (); Stack < Integer > stack = new Stack <> (); for (; head != null ; head = head . next ) { while ( ! stack . isEmpty () && head . val > ans . get ( stack . peek ())) { int index = stack . pop (); ans . set ( index , head . val ); } stack . push ( ans . size ()); ans . add ( head . val ); } while ( ! stack . isEmpty ()) ans . set ( stack . pop (), 0 ); return ans . stream (). mapToInt ( i -> i ). toArray (); } }","title":"1019. Next Greater Node In Linked List $\\star\\star$"},{"location":"java/1001-1100/1011-1020/#1020-number-of-enclaves-starstar","text":"","title":"1020. Number of Enclaves $\\star\\star$"},{"location":"java/1001-1100/1021-1030/","text":"1021. Remove Outermost Parentheses $\\star$ 1022. Sum of Root To Leaf Binary Numbers $\\star$ 1023. Camelcase Matching $\\star\\star$ class Solution { public List < Boolean > camelMatch ( String [] queries , String pattern ) { List < Boolean > ans = new ArrayList <> (); for ( final String query : queries ) ans . add ( isMatch ( query , pattern )); return ans ; } private boolean isMatch ( final String query , final String pattern ) { int j = 0 ; for ( int i = 0 ; i < query . length (); ++ i ) if ( j < pattern . length () && query . charAt ( i ) == pattern . charAt ( j )) ++ j ; else if ( Character . isUpperCase ( query . charAt ( i ))) return false ; return j == pattern . length (); } } 1024. Video Stitching $\\star\\star$ class Solution { public int videoStitching ( int [][] clips , int T ) { int ans = 0 ; int end = 0 ; int farthest = 0 ; Arrays . sort ( clips , ( a , b ) -> a [ 0 ] - b [ 0 ] ); int i = 0 ; while ( farthest < T ) { while ( i < clips . length && clips [ i ][ 0 ] <= end ) farthest = Math . max ( farthest , clips [ i ++][ 1 ] ); if ( end == farthest ) return - 1 ; ++ ans ; end = farthest ; } return ans ; } } 1025. Divisor Game $\\star$ class Solution { public boolean divisorGame ( int N ) { return N % 2 == 0 ; } } 1026. Maximum Difference Between Node and Ancestor $\\star\\star$ 1027. Longest Arithmetic Sequence $\\star\\star$ 1028. Recover a Tree From Preorder Traversal $\\star\\star\\star$ 1029. Two City Scheduling $\\star$ 1030. Matrix Cells in Distance Order $\\star$","title":"1021-1030"},{"location":"java/1001-1100/1021-1030/#1021-remove-outermost-parentheses-star","text":"","title":"1021. Remove Outermost Parentheses $\\star$"},{"location":"java/1001-1100/1021-1030/#1022-sum-of-root-to-leaf-binary-numbers-star","text":"","title":"1022. Sum of Root To Leaf Binary Numbers $\\star$"},{"location":"java/1001-1100/1021-1030/#1023-camelcase-matching-starstar","text":"class Solution { public List < Boolean > camelMatch ( String [] queries , String pattern ) { List < Boolean > ans = new ArrayList <> (); for ( final String query : queries ) ans . add ( isMatch ( query , pattern )); return ans ; } private boolean isMatch ( final String query , final String pattern ) { int j = 0 ; for ( int i = 0 ; i < query . length (); ++ i ) if ( j < pattern . length () && query . charAt ( i ) == pattern . charAt ( j )) ++ j ; else if ( Character . isUpperCase ( query . charAt ( i ))) return false ; return j == pattern . length (); } }","title":"1023. Camelcase Matching $\\star\\star$"},{"location":"java/1001-1100/1021-1030/#1024-video-stitching-starstar","text":"class Solution { public int videoStitching ( int [][] clips , int T ) { int ans = 0 ; int end = 0 ; int farthest = 0 ; Arrays . sort ( clips , ( a , b ) -> a [ 0 ] - b [ 0 ] ); int i = 0 ; while ( farthest < T ) { while ( i < clips . length && clips [ i ][ 0 ] <= end ) farthest = Math . max ( farthest , clips [ i ++][ 1 ] ); if ( end == farthest ) return - 1 ; ++ ans ; end = farthest ; } return ans ; } }","title":"1024. Video Stitching $\\star\\star$"},{"location":"java/1001-1100/1021-1030/#1025-divisor-game-star","text":"class Solution { public boolean divisorGame ( int N ) { return N % 2 == 0 ; } }","title":"1025. Divisor Game $\\star$"},{"location":"java/1001-1100/1021-1030/#1026-maximum-difference-between-node-and-ancestor-starstar","text":"","title":"1026. Maximum Difference Between Node and Ancestor $\\star\\star$"},{"location":"java/1001-1100/1021-1030/#1027-longest-arithmetic-sequence-starstar","text":"","title":"1027. Longest Arithmetic Sequence $\\star\\star$"},{"location":"java/1001-1100/1021-1030/#1028-recover-a-tree-from-preorder-traversal-starstarstar","text":"","title":"1028. Recover a Tree From Preorder Traversal $\\star\\star\\star$"},{"location":"java/1001-1100/1021-1030/#1029-two-city-scheduling-star","text":"","title":"1029. Two City Scheduling $\\star$"},{"location":"java/1001-1100/1021-1030/#1030-matrix-cells-in-distance-order-star","text":"","title":"1030. Matrix Cells in Distance Order $\\star$"},{"location":"java/1001-1100/1031-1040/","text":"1031. Maximum Sum of Two Non-Overlapping Subarrays $\\star\\star$ class Solution { public int maxSumTwoNoOverlap ( int [] A , int L , int M ) { return Math . max ( helper ( A , L , M ), helper ( A , M , L )); } private int helper ( int [] A , int l , int r ) { final int n = A . length ; int [] left = new int [ n ] ; int sum = 0 ; for ( int i = 0 ; i < n ; ++ i ) { sum += A [ i ] ; if ( i >= l ) sum -= A [ i - l ] ; if ( i >= l - 1 ) left [ i ] = i > 0 ? Math . max ( left [ i - 1 ] , sum ) : sum ; } int [] right = new int [ n ] ; sum = 0 ; for ( int i = n - 1 ; i >= 0 ; -- i ) { sum += A [ i ] ; if ( i <= n - r - 1 ) sum -= A [ i + r ] ; if ( i <= n - r ) right [ i ] = i < n - 1 ? Math . max ( right [ i + 1 ] , sum ) : sum ; } int ans = 0 ; for ( int i = 0 ; i < n - 1 ; ++ i ) ans = Math . max ( ans , left [ i ] + right [ i + 1 ] ); return ans ; } } 1032. Stream of Characters $\\star\\star\\star$ 1033. Moving Stones Until Consecutive $\\star$ class Solution { public int [] numMovesStones ( int a , int b , int c ) { int [] nums = new int [] { a , b , c }; Arrays . sort ( nums ); if ( nums [ 2 ] - nums [ 0 ] == 2 ) return new int [] { 0 , 0 }; return new int [] { Math . min ( nums [ 1 ] - nums [ 0 ] , nums [ 2 ] - nums [ 1 ] ) <= 2 ? 1 : 2 , nums [ 2 ] - nums [ 0 ] - 2 }; } } 1034. Coloring A Border $\\star\\star$ class Solution { public int [][] colorBorder ( int [][] grid , int r0 , int c0 , int color ) { dfs ( grid , r0 , c0 , grid [ r0 ][ c0 ] ); for ( int i = 0 ; i < grid . length ; ++ i ) for ( int j = 0 ; j < grid [ 0 ] . length ; ++ j ) if ( grid [ i ][ j ] < 0 ) grid [ i ][ j ] = color ; return grid ; } private void dfs ( int [][] grid , int i , int j , int originalColor ) { if ( i < 0 || i >= grid . length || j < 0 || j >= grid [ 0 ] . length || grid [ i ][ j ] != originalColor ) return ; grid [ i ][ j ] = - originalColor ; dfs ( grid , i + 1 , j , originalColor ); dfs ( grid , i - 1 , j , originalColor ); dfs ( grid , i , j + 1 , originalColor ); dfs ( grid , i , j - 1 , originalColor ); if ( i > 0 && i + 1 < grid . length && j > 0 && j + 1 < grid [ 0 ] . length && Math . abs ( grid [ i + 1 ][ j ] ) == originalColor && Math . abs ( grid [ i - 1 ][ j ] ) == originalColor && Math . abs ( grid [ i ][ j + 1 ] ) == originalColor && Math . abs ( grid [ i ][ j - 1 ] ) == originalColor ) grid [ i ][ j ] = originalColor ; } } 1035. Uncrossed Lines $\\star\\star$ class Solution { public int maxUncrossedLines ( int [] A , int [] B ) { final int m = A . length ; final int n = B . length ; int [][] dp = new int [ m + 1 ][ n + 1 ] ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) dp [ i ][ j ] = A [ i - 1 ] == B [ j - 1 ] ? dp [ i - 1 ][ j - 1 ] + 1 : Math . max ( dp [ i - 1 ][ j ] , dp [ i ][ j - 1 ] ); return dp [ m ][ n ] ; } } 1036. Escape a Large Maze $\\star\\star\\star$ class Solution { public boolean isEscapePossible ( int [][] blocked , int [] source , int [] target ) { Set < Long > blockedSet = new HashSet <> (); for ( int [] b : blocked ) blockedSet . add ( hash ( b [ 0 ] , b [ 1 ] )); return dfs ( blockedSet , source [ 0 ] , source [ 1 ] , hash ( target [ 0 ] , target [ 1 ] ), new HashSet <> ()) && dfs ( blockedSet , target [ 0 ] , target [ 1 ] , hash ( source [ 0 ] , source [ 1 ] ), new HashSet <> ()); } private boolean dfs ( Set < Long > blockedSet , int i , int j , long target , Set < Long > visited ) { if ( i < 0 || i >= 1e6 || j < 0 || j >= 1e6 || blockedSet . contains ( hash ( i , j )) || visited . contains ( hash ( i , j ))) return false ; visited . add ( hash ( i , j )); if ( visited . size () > ( 1 + 199 ) * 199 / 2 || hash ( i , j ) == target ) return true ; return dfs ( blockedSet , i + 1 , j , target , visited ) || dfs ( blockedSet , i - 1 , j , target , visited ) || dfs ( blockedSet , i , j + 1 , target , visited ) || dfs ( blockedSet , i , j - 1 , target , visited ); } private long hash ( int i , int j ) { return (( long ) i << 32 ) + j ; } } 1037. Valid Boomerang $\\star$ class Solution { public boolean isBoomerang ( int [][] points ) { return ( points [ 1 ][ 0 ] - points [ 0 ][ 0 ] ) * ( points [ 2 ][ 1 ] - points [ 1 ][ 1 ] ) != ( points [ 1 ][ 1 ] - points [ 0 ][ 1 ] ) * ( points [ 2 ][ 0 ] - points [ 1 ][ 0 ] ); } } 1038. Binary Search Tree to Greater Sum Tree $\\star\\star$ 1039. Minimum Score Triangulation of Polygon $\\star\\star$ 1040. Moving Stones Until Consecutive II $\\star\\star$ class Solution { public int [] numMovesStonesII ( int [] stones ) { final int n = stones . length ; int minMoves = n ; Arrays . sort ( stones ); for ( int l = 0 , r = 0 ; r < n ; ++ r ) { while ( stones [ r ] - stones [ l ] + 1 > n ) ++ l ; int alreadyStored = r - l + 1 ; if ( alreadyStored == n - 1 && stones [ r ] - stones [ l ] + 1 == n - 1 ) minMoves = Math . min ( minMoves , 2 ); else minMoves = Math . min ( minMoves , n - alreadyStored ); } return new int [] { minMoves , Math . max ( stones [ n - 1 ] - stones [ 1 ] - n + 2 , stones [ n - 2 ] - stones [ 0 ] - n + 2 ) }; } }","title":"1031-1040"},{"location":"java/1001-1100/1031-1040/#1031-maximum-sum-of-two-non-overlapping-subarrays-starstar","text":"class Solution { public int maxSumTwoNoOverlap ( int [] A , int L , int M ) { return Math . max ( helper ( A , L , M ), helper ( A , M , L )); } private int helper ( int [] A , int l , int r ) { final int n = A . length ; int [] left = new int [ n ] ; int sum = 0 ; for ( int i = 0 ; i < n ; ++ i ) { sum += A [ i ] ; if ( i >= l ) sum -= A [ i - l ] ; if ( i >= l - 1 ) left [ i ] = i > 0 ? Math . max ( left [ i - 1 ] , sum ) : sum ; } int [] right = new int [ n ] ; sum = 0 ; for ( int i = n - 1 ; i >= 0 ; -- i ) { sum += A [ i ] ; if ( i <= n - r - 1 ) sum -= A [ i + r ] ; if ( i <= n - r ) right [ i ] = i < n - 1 ? Math . max ( right [ i + 1 ] , sum ) : sum ; } int ans = 0 ; for ( int i = 0 ; i < n - 1 ; ++ i ) ans = Math . max ( ans , left [ i ] + right [ i + 1 ] ); return ans ; } }","title":"1031. Maximum Sum of Two Non-Overlapping Subarrays $\\star\\star$"},{"location":"java/1001-1100/1031-1040/#1032-stream-of-characters-starstarstar","text":"","title":"1032. Stream of Characters $\\star\\star\\star$"},{"location":"java/1001-1100/1031-1040/#1033-moving-stones-until-consecutive-star","text":"class Solution { public int [] numMovesStones ( int a , int b , int c ) { int [] nums = new int [] { a , b , c }; Arrays . sort ( nums ); if ( nums [ 2 ] - nums [ 0 ] == 2 ) return new int [] { 0 , 0 }; return new int [] { Math . min ( nums [ 1 ] - nums [ 0 ] , nums [ 2 ] - nums [ 1 ] ) <= 2 ? 1 : 2 , nums [ 2 ] - nums [ 0 ] - 2 }; } }","title":"1033. Moving Stones Until Consecutive $\\star$"},{"location":"java/1001-1100/1031-1040/#1034-coloring-a-border-starstar","text":"class Solution { public int [][] colorBorder ( int [][] grid , int r0 , int c0 , int color ) { dfs ( grid , r0 , c0 , grid [ r0 ][ c0 ] ); for ( int i = 0 ; i < grid . length ; ++ i ) for ( int j = 0 ; j < grid [ 0 ] . length ; ++ j ) if ( grid [ i ][ j ] < 0 ) grid [ i ][ j ] = color ; return grid ; } private void dfs ( int [][] grid , int i , int j , int originalColor ) { if ( i < 0 || i >= grid . length || j < 0 || j >= grid [ 0 ] . length || grid [ i ][ j ] != originalColor ) return ; grid [ i ][ j ] = - originalColor ; dfs ( grid , i + 1 , j , originalColor ); dfs ( grid , i - 1 , j , originalColor ); dfs ( grid , i , j + 1 , originalColor ); dfs ( grid , i , j - 1 , originalColor ); if ( i > 0 && i + 1 < grid . length && j > 0 && j + 1 < grid [ 0 ] . length && Math . abs ( grid [ i + 1 ][ j ] ) == originalColor && Math . abs ( grid [ i - 1 ][ j ] ) == originalColor && Math . abs ( grid [ i ][ j + 1 ] ) == originalColor && Math . abs ( grid [ i ][ j - 1 ] ) == originalColor ) grid [ i ][ j ] = originalColor ; } }","title":"1034. Coloring A Border $\\star\\star$"},{"location":"java/1001-1100/1031-1040/#1035-uncrossed-lines-starstar","text":"class Solution { public int maxUncrossedLines ( int [] A , int [] B ) { final int m = A . length ; final int n = B . length ; int [][] dp = new int [ m + 1 ][ n + 1 ] ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) dp [ i ][ j ] = A [ i - 1 ] == B [ j - 1 ] ? dp [ i - 1 ][ j - 1 ] + 1 : Math . max ( dp [ i - 1 ][ j ] , dp [ i ][ j - 1 ] ); return dp [ m ][ n ] ; } }","title":"1035. Uncrossed Lines $\\star\\star$"},{"location":"java/1001-1100/1031-1040/#1036-escape-a-large-maze-starstarstar","text":"class Solution { public boolean isEscapePossible ( int [][] blocked , int [] source , int [] target ) { Set < Long > blockedSet = new HashSet <> (); for ( int [] b : blocked ) blockedSet . add ( hash ( b [ 0 ] , b [ 1 ] )); return dfs ( blockedSet , source [ 0 ] , source [ 1 ] , hash ( target [ 0 ] , target [ 1 ] ), new HashSet <> ()) && dfs ( blockedSet , target [ 0 ] , target [ 1 ] , hash ( source [ 0 ] , source [ 1 ] ), new HashSet <> ()); } private boolean dfs ( Set < Long > blockedSet , int i , int j , long target , Set < Long > visited ) { if ( i < 0 || i >= 1e6 || j < 0 || j >= 1e6 || blockedSet . contains ( hash ( i , j )) || visited . contains ( hash ( i , j ))) return false ; visited . add ( hash ( i , j )); if ( visited . size () > ( 1 + 199 ) * 199 / 2 || hash ( i , j ) == target ) return true ; return dfs ( blockedSet , i + 1 , j , target , visited ) || dfs ( blockedSet , i - 1 , j , target , visited ) || dfs ( blockedSet , i , j + 1 , target , visited ) || dfs ( blockedSet , i , j - 1 , target , visited ); } private long hash ( int i , int j ) { return (( long ) i << 32 ) + j ; } }","title":"1036. Escape a Large Maze $\\star\\star\\star$"},{"location":"java/1001-1100/1031-1040/#1037-valid-boomerang-star","text":"class Solution { public boolean isBoomerang ( int [][] points ) { return ( points [ 1 ][ 0 ] - points [ 0 ][ 0 ] ) * ( points [ 2 ][ 1 ] - points [ 1 ][ 1 ] ) != ( points [ 1 ][ 1 ] - points [ 0 ][ 1 ] ) * ( points [ 2 ][ 0 ] - points [ 1 ][ 0 ] ); } }","title":"1037. Valid Boomerang $\\star$"},{"location":"java/1001-1100/1031-1040/#1038-binary-search-tree-to-greater-sum-tree-starstar","text":"","title":"1038. Binary Search Tree to Greater Sum Tree $\\star\\star$"},{"location":"java/1001-1100/1031-1040/#1039-minimum-score-triangulation-of-polygon-starstar","text":"","title":"1039. Minimum Score Triangulation of Polygon $\\star\\star$"},{"location":"java/1001-1100/1031-1040/#1040-moving-stones-until-consecutive-ii-starstar","text":"class Solution { public int [] numMovesStonesII ( int [] stones ) { final int n = stones . length ; int minMoves = n ; Arrays . sort ( stones ); for ( int l = 0 , r = 0 ; r < n ; ++ r ) { while ( stones [ r ] - stones [ l ] + 1 > n ) ++ l ; int alreadyStored = r - l + 1 ; if ( alreadyStored == n - 1 && stones [ r ] - stones [ l ] + 1 == n - 1 ) minMoves = Math . min ( minMoves , 2 ); else minMoves = Math . min ( minMoves , n - alreadyStored ); } return new int [] { minMoves , Math . max ( stones [ n - 1 ] - stones [ 1 ] - n + 2 , stones [ n - 2 ] - stones [ 0 ] - n + 2 ) }; } }","title":"1040. Moving Stones Until Consecutive II $\\star\\star$"},{"location":"java/1001-1100/1041-1050/","text":"1041. Robot Bounded In Circle $\\star\\star$ class Solution { public boolean isRobotBounded ( String instructions ) { int x = 0 ; int y = 0 ; int d = 0 ; int [][] directions = new int [][] { { 0 , 1 }, { 1 , 0 }, { 0 , - 1 }, { - 1 , 0 } }; for ( char instruction : instructions . toCharArray ()) { if ( instruction == 'G' ) { x += directions [ d ][ 0 ] ; y += directions [ d ][ 1 ] ; } else if ( instruction == 'L' ) d = ( d + 3 ) % 4 ; else d = ( d + 1 ) % 4 ; } return x == 0 && y == 0 || d > 0 ; } } 1042. Flower Planting With No Adjacent $\\star$ 1043. Partition Array for Maximum Sum $\\star\\star$ 1044. Longest Duplicate Substring $\\star\\star\\star$ 1045. Customers Who Bought All Products $\\star\\star$ \ud83d\udd12 1046. Last Stone Weight $\\star$ 1047. Remove All Adjacent Duplicates In String $\\star$ 1048. Longest String Chain $\\star\\star$ class Solution { public int longestStrChain ( String [] words ) { int ans = 0 ; Map < String , Integer > dp = new HashMap <> (); Arrays . sort ( words , ( a , b ) -> a . length () - b . length ()); for ( final String word : words ) { int bestLength = 0 ; for ( int i = 0 ; i < word . length (); ++ i ) { String pred = word . substring ( 0 , i ) + word . substring ( i + 1 ); bestLength = Math . max ( bestLength , dp . getOrDefault ( pred , 0 ) + 1 ); } dp . put ( word , bestLength ); ans = Math . max ( ans , bestLength ); } return ans ; } } 1049. Last Stone Weight II $\\star\\star$ class Solution { public int lastStoneWeightII ( int [] stones ) { final int sum = Arrays . stream ( stones ). sum (); boolean [] dp = new boolean [ sum + 1 ] ; dp [ 0 ] = true ; int s = 0 ; for ( int stone : stones ) for ( int w = sum / 2 ; w > 0 ; -- w ) { if ( w >= stone ) dp [ w ] = dp [ w ] || dp [ w - stone ] ; if ( dp [ w ] ) s = Math . max ( s , w ); } return sum - 2 * s ; } } 1050. Actors and Directors Who Cooperated At Least Three Times $\\star$ \ud83d\udd12","title":"1041-1050"},{"location":"java/1001-1100/1041-1050/#1041-robot-bounded-in-circle-starstar","text":"class Solution { public boolean isRobotBounded ( String instructions ) { int x = 0 ; int y = 0 ; int d = 0 ; int [][] directions = new int [][] { { 0 , 1 }, { 1 , 0 }, { 0 , - 1 }, { - 1 , 0 } }; for ( char instruction : instructions . toCharArray ()) { if ( instruction == 'G' ) { x += directions [ d ][ 0 ] ; y += directions [ d ][ 1 ] ; } else if ( instruction == 'L' ) d = ( d + 3 ) % 4 ; else d = ( d + 1 ) % 4 ; } return x == 0 && y == 0 || d > 0 ; } }","title":"1041. Robot Bounded In Circle $\\star\\star$"},{"location":"java/1001-1100/1041-1050/#1042-flower-planting-with-no-adjacent-star","text":"","title":"1042. Flower Planting With No Adjacent $\\star$"},{"location":"java/1001-1100/1041-1050/#1043-partition-array-for-maximum-sum-starstar","text":"","title":"1043. Partition Array for Maximum Sum $\\star\\star$"},{"location":"java/1001-1100/1041-1050/#1044-longest-duplicate-substring-starstarstar","text":"","title":"1044. Longest Duplicate Substring $\\star\\star\\star$"},{"location":"java/1001-1100/1041-1050/#1045-customers-who-bought-all-products-starstar","text":"","title":"1045. Customers Who Bought All Products $\\star\\star$ \ud83d\udd12"},{"location":"java/1001-1100/1041-1050/#1046-last-stone-weight-star","text":"","title":"1046. Last Stone Weight $\\star$"},{"location":"java/1001-1100/1041-1050/#1047-remove-all-adjacent-duplicates-in-string-star","text":"","title":"1047. Remove All Adjacent Duplicates In String $\\star$"},{"location":"java/1001-1100/1041-1050/#1048-longest-string-chain-starstar","text":"class Solution { public int longestStrChain ( String [] words ) { int ans = 0 ; Map < String , Integer > dp = new HashMap <> (); Arrays . sort ( words , ( a , b ) -> a . length () - b . length ()); for ( final String word : words ) { int bestLength = 0 ; for ( int i = 0 ; i < word . length (); ++ i ) { String pred = word . substring ( 0 , i ) + word . substring ( i + 1 ); bestLength = Math . max ( bestLength , dp . getOrDefault ( pred , 0 ) + 1 ); } dp . put ( word , bestLength ); ans = Math . max ( ans , bestLength ); } return ans ; } }","title":"1048. Longest String Chain $\\star\\star$"},{"location":"java/1001-1100/1041-1050/#1049-last-stone-weight-ii-starstar","text":"class Solution { public int lastStoneWeightII ( int [] stones ) { final int sum = Arrays . stream ( stones ). sum (); boolean [] dp = new boolean [ sum + 1 ] ; dp [ 0 ] = true ; int s = 0 ; for ( int stone : stones ) for ( int w = sum / 2 ; w > 0 ; -- w ) { if ( w >= stone ) dp [ w ] = dp [ w ] || dp [ w - stone ] ; if ( dp [ w ] ) s = Math . max ( s , w ); } return sum - 2 * s ; } }","title":"1049. Last Stone Weight II $\\star\\star$"},{"location":"java/1001-1100/1041-1050/#1050-actors-and-directors-who-cooperated-at-least-three-times-star","text":"","title":"1050. Actors and Directors Who Cooperated At Least Three Times $\\star$ \ud83d\udd12"},{"location":"java/1001-1100/1051-1060/","text":"1051. Height Checker $\\star$ class Solution { public int heightChecker ( int [] heights ) { int ans = 0 ; int currentHeight = 1 ; int [] count = new int [ 101 ] ; for ( int height : heights ) ++ count [ height ] ; for ( int height : heights ) { while ( count [ currentHeight ] == 0 ) ++ currentHeight ; if ( height != currentHeight ) ++ ans ; -- count [ currentHeight ] ; } return ans ; } } 1052. Grumpy Bookstore Owner $\\star\\star$ class Solution { public int maxSatisfied ( int [] customers , int [] grumpy , int X ) { int satisfied = 0 ; int madeSatisfied = 0 ; int windowSatisfied = 0 ; for ( int i = 0 ; i < customers . length ; ++ i ) { if ( grumpy [ i ] == 0 ) satisfied += customers [ i ] ; else windowSatisfied += customers [ i ] ; if ( i >= X && grumpy [ i - X ] == 1 ) windowSatisfied -= customers [ i - X ] ; madeSatisfied = Math . max ( madeSatisfied , windowSatisfied ); } return satisfied + madeSatisfied ; } } 1053. Previous Permutation With One Swap $\\star\\star$ class Solution { public int [] prevPermOpt1 ( int [] A ) { final int n = A . length ; int l = n - 2 ; int r = n - 1 ; while ( l >= 0 && A [ l ] <= A [ l + 1 ] ) l -- ; if ( l < 0 ) return A ; while ( A [ r ] >= A [ l ] || A [ r ] == A [ r - 1 ] ) r -- ; swap ( A , l , r ); return A ; } private void swap ( int [] A , int l , int r ) { int temp = A [ l ] ; A [ l ] = A [ r ] ; A [ r ] = temp ; } } 1054. Distant Barcodes $\\star\\star$ 1055. Shortest Way to Form String $\\star\\star$ \ud83d\udd12 1056. Confusing Number $\\star$ \ud83d\udd12 1057. Campus Bikes $\\star\\star$ \ud83d\udd12 1058. Minimize Rounding Error to Meet Target $\\star\\star$ \ud83d\udd12 1059. All Paths from Source Lead to Destination $\\star\\star$ \ud83d\udd12 1060. Missing Element in Sorted Array $\\star\\star$ \ud83d\udd12","title":"1051-1060"},{"location":"java/1001-1100/1051-1060/#1051-height-checker-star","text":"class Solution { public int heightChecker ( int [] heights ) { int ans = 0 ; int currentHeight = 1 ; int [] count = new int [ 101 ] ; for ( int height : heights ) ++ count [ height ] ; for ( int height : heights ) { while ( count [ currentHeight ] == 0 ) ++ currentHeight ; if ( height != currentHeight ) ++ ans ; -- count [ currentHeight ] ; } return ans ; } }","title":"1051. Height Checker $\\star$"},{"location":"java/1001-1100/1051-1060/#1052-grumpy-bookstore-owner-starstar","text":"class Solution { public int maxSatisfied ( int [] customers , int [] grumpy , int X ) { int satisfied = 0 ; int madeSatisfied = 0 ; int windowSatisfied = 0 ; for ( int i = 0 ; i < customers . length ; ++ i ) { if ( grumpy [ i ] == 0 ) satisfied += customers [ i ] ; else windowSatisfied += customers [ i ] ; if ( i >= X && grumpy [ i - X ] == 1 ) windowSatisfied -= customers [ i - X ] ; madeSatisfied = Math . max ( madeSatisfied , windowSatisfied ); } return satisfied + madeSatisfied ; } }","title":"1052. Grumpy Bookstore Owner $\\star\\star$"},{"location":"java/1001-1100/1051-1060/#1053-previous-permutation-with-one-swap-starstar","text":"class Solution { public int [] prevPermOpt1 ( int [] A ) { final int n = A . length ; int l = n - 2 ; int r = n - 1 ; while ( l >= 0 && A [ l ] <= A [ l + 1 ] ) l -- ; if ( l < 0 ) return A ; while ( A [ r ] >= A [ l ] || A [ r ] == A [ r - 1 ] ) r -- ; swap ( A , l , r ); return A ; } private void swap ( int [] A , int l , int r ) { int temp = A [ l ] ; A [ l ] = A [ r ] ; A [ r ] = temp ; } }","title":"1053. Previous Permutation With One Swap $\\star\\star$"},{"location":"java/1001-1100/1051-1060/#1054-distant-barcodes-starstar","text":"","title":"1054. Distant Barcodes $\\star\\star$"},{"location":"java/1001-1100/1051-1060/#1055-shortest-way-to-form-string-starstar","text":"","title":"1055. Shortest Way to Form String $\\star\\star$ \ud83d\udd12"},{"location":"java/1001-1100/1051-1060/#1056-confusing-number-star","text":"","title":"1056. Confusing Number $\\star$ \ud83d\udd12"},{"location":"java/1001-1100/1051-1060/#1057-campus-bikes-starstar","text":"","title":"1057. Campus Bikes $\\star\\star$ \ud83d\udd12"},{"location":"java/1001-1100/1051-1060/#1058-minimize-rounding-error-to-meet-target-starstar","text":"","title":"1058. Minimize Rounding Error to Meet Target $\\star\\star$ \ud83d\udd12"},{"location":"java/1001-1100/1051-1060/#1059-all-paths-from-source-lead-to-destination-starstar","text":"","title":"1059. All Paths from Source Lead to Destination $\\star\\star$ \ud83d\udd12"},{"location":"java/1001-1100/1051-1060/#1060-missing-element-in-sorted-array-starstar","text":"","title":"1060. Missing Element in Sorted Array $\\star\\star$ \ud83d\udd12"},{"location":"java/1001-1100/1061-1070/","text":"1061. Lexicographically Smallest Equivalent String $\\star\\star$ \ud83d\udd12 1062. Longest Repeating Substring $\\star\\star$ \ud83d\udd12 1063. Number of Valid Subarrays $\\star\\star\\star$ \ud83d\udd12 1064. Fixed Point $\\star$ \ud83d\udd12 1065. Index Pairs of a String $\\star$ \ud83d\udd12 1066. Campus Bikes II $\\star\\star$ \ud83d\udd12 1067. Digit Count in Range $\\star\\star\\star$ \ud83d\udd12 1068. Product Sales Analysis I $\\star$ \ud83d\udd12 1069. Product Sales Analysis II $\\star$ \ud83d\udd12 1070. Product Sales Analysis III $\\star\\star$ \ud83d\udd12","title":"1061-1070"},{"location":"java/1001-1100/1061-1070/#1061-lexicographically-smallest-equivalent-string-starstar","text":"","title":"1061. Lexicographically Smallest Equivalent String $\\star\\star$ \ud83d\udd12"},{"location":"java/1001-1100/1061-1070/#1062-longest-repeating-substring-starstar","text":"","title":"1062. Longest Repeating Substring $\\star\\star$ \ud83d\udd12"},{"location":"java/1001-1100/1061-1070/#1063-number-of-valid-subarrays-starstarstar","text":"","title":"1063. Number of Valid Subarrays $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/1001-1100/1061-1070/#1064-fixed-point-star","text":"","title":"1064. Fixed Point $\\star$ \ud83d\udd12"},{"location":"java/1001-1100/1061-1070/#1065-index-pairs-of-a-string-star","text":"","title":"1065. Index Pairs of a String $\\star$ \ud83d\udd12"},{"location":"java/1001-1100/1061-1070/#1066-campus-bikes-ii-starstar","text":"","title":"1066. Campus Bikes II $\\star\\star$ \ud83d\udd12"},{"location":"java/1001-1100/1061-1070/#1067-digit-count-in-range-starstarstar","text":"","title":"1067. Digit Count in Range $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/1001-1100/1061-1070/#1068-product-sales-analysis-i-star","text":"","title":"1068. Product Sales Analysis I $\\star$ \ud83d\udd12"},{"location":"java/1001-1100/1061-1070/#1069-product-sales-analysis-ii-star","text":"","title":"1069. Product Sales Analysis II $\\star$ \ud83d\udd12"},{"location":"java/1001-1100/1061-1070/#1070-product-sales-analysis-iii-starstar","text":"","title":"1070. Product Sales Analysis III $\\star\\star$ \ud83d\udd12"},{"location":"java/1001-1100/1071-1080/","text":"1071. Greatest Common Divisor of Strings $\\star$ class Solution { public String gcdOfStrings ( String str1 , String str2 ) { if ( str1 . length () < str2 . length ()) return gcdOfStrings ( str2 , str1 ); if ( ! str1 . startsWith ( str2 )) return \"\" ; if ( str2 . isEmpty ()) return str1 ; return gcdOfStrings ( str2 , mod ( str1 , str2 )); } private String mod ( String s1 , final String s2 ) { while ( s1 . startsWith ( s2 )) s1 = s1 . substring ( s2 . length ()); return s1 ; } } 1072. Flip Columns For Maximum Number of Equal Rows $\\star\\star$ class Solution { public int maxEqualRowsAfterFlips ( int [][] matrix ) { final int m = matrix . length ; final int n = matrix [ 0 ] . length ; int ans = 0 ; int [] flip = new int [ n ] ; Set < Integer > seen = new HashSet <> (); for ( int i = 0 ; i < m ; ++ i ) { if ( seen . contains ( i )) continue ; int count = 0 ; for ( int j = 0 ; j < n ; ++ j ) flip [ j ] = 1 ^ matrix [ i ][ j ] ; for ( int k = 0 ; k < m ; ++ k ) if ( Arrays . equals ( matrix [ k ] , matrix [ i ] ) || Arrays . equals ( matrix [ k ] , flip )) { seen . add ( k ); ++ count ; } ans = Math . max ( ans , count ); } return ans ; } } 1073. Adding Two Negabinary Numbers $\\star\\star$ class Solution { public int [] addNegabinary ( int [] arr1 , int [] arr2 ) { Deque < Integer > ans = new ArrayDeque <> (); int carry = 0 ; int i = arr1 . length - 1 ; int j = arr2 . length - 1 ; while ( carry != 0 || i >= 0 || j >= 0 ) { if ( i >= 0 ) carry += arr1 [ i --] ; if ( j >= 0 ) carry += arr2 [ j --] ; ans . addFirst ( carry & 1 ); carry = - ( carry >> 1 ); } while ( ans . size () > 1 && ans . getFirst () == 0 ) ans . pollFirst (); return ans . stream (). mapToInt ( Integer :: intValue ). toArray (); } } 1074. Number of Submatrices That Sum to Target $\\star\\star\\star$ class Solution { public int numSubmatrixSumTarget ( int [][] matrix , int target ) { int ans = 0 ; for ( int [] row : matrix ) for ( int i = 1 ; i < row . length ; ++ i ) row [ i ] += row [ i - 1 ] ; for ( int baseCol = 0 ; baseCol < matrix [ 0 ] . length ; ++ baseCol ) for ( int j = baseCol ; j < matrix [ 0 ] . length ; ++ j ) { Map < Integer , Integer > prefixSumCount = new HashMap <> (); prefixSumCount . put ( 0 , 1 ); int sum = 0 ; for ( int i = 0 ; i < matrix . length ; ++ i ) { if ( baseCol > 0 ) sum -= matrix [ i ][ baseCol - 1 ] ; sum += matrix [ i ][ j ] ; ans += prefixSumCount . getOrDefault ( sum - target , 0 ); prefixSumCount . put ( sum , prefixSumCount . getOrDefault ( sum , 0 ) + 1 ); } } return ans ; } } 1075. Project Employees I $\\star$ \ud83d\udd12 1076. Project Employees II $\\star$ \ud83d\udd12 1077. Project Employees III $\\star\\star$ \ud83d\udd12 1078. Occurrences After Bigram $\\star$ class Solution { public String [] findOcurrences ( String text , String first , String second ) { List < String > ans = new ArrayList <> (); String [] words = text . split ( \" \" ); for ( int i = 0 ; i + 2 < words . length ; ++ i ) if ( first . equals ( words [ i ] ) && second . equals ( words [ i + 1 ] )) ans . add ( words [ i + 2 ] ); return ans . toArray ( new String [ 0 ] ); } } 1079. Letter Tile Possibilities $\\star\\star$ 1080. Insufficient Nodes in Root to Leaf Paths $\\star\\star$","title":"1071-1080"},{"location":"java/1001-1100/1071-1080/#1071-greatest-common-divisor-of-strings-star","text":"class Solution { public String gcdOfStrings ( String str1 , String str2 ) { if ( str1 . length () < str2 . length ()) return gcdOfStrings ( str2 , str1 ); if ( ! str1 . startsWith ( str2 )) return \"\" ; if ( str2 . isEmpty ()) return str1 ; return gcdOfStrings ( str2 , mod ( str1 , str2 )); } private String mod ( String s1 , final String s2 ) { while ( s1 . startsWith ( s2 )) s1 = s1 . substring ( s2 . length ()); return s1 ; } }","title":"1071. Greatest Common Divisor of Strings $\\star$"},{"location":"java/1001-1100/1071-1080/#1072-flip-columns-for-maximum-number-of-equal-rows-starstar","text":"class Solution { public int maxEqualRowsAfterFlips ( int [][] matrix ) { final int m = matrix . length ; final int n = matrix [ 0 ] . length ; int ans = 0 ; int [] flip = new int [ n ] ; Set < Integer > seen = new HashSet <> (); for ( int i = 0 ; i < m ; ++ i ) { if ( seen . contains ( i )) continue ; int count = 0 ; for ( int j = 0 ; j < n ; ++ j ) flip [ j ] = 1 ^ matrix [ i ][ j ] ; for ( int k = 0 ; k < m ; ++ k ) if ( Arrays . equals ( matrix [ k ] , matrix [ i ] ) || Arrays . equals ( matrix [ k ] , flip )) { seen . add ( k ); ++ count ; } ans = Math . max ( ans , count ); } return ans ; } }","title":"1072. Flip Columns For Maximum Number of Equal Rows $\\star\\star$"},{"location":"java/1001-1100/1071-1080/#1073-adding-two-negabinary-numbers-starstar","text":"class Solution { public int [] addNegabinary ( int [] arr1 , int [] arr2 ) { Deque < Integer > ans = new ArrayDeque <> (); int carry = 0 ; int i = arr1 . length - 1 ; int j = arr2 . length - 1 ; while ( carry != 0 || i >= 0 || j >= 0 ) { if ( i >= 0 ) carry += arr1 [ i --] ; if ( j >= 0 ) carry += arr2 [ j --] ; ans . addFirst ( carry & 1 ); carry = - ( carry >> 1 ); } while ( ans . size () > 1 && ans . getFirst () == 0 ) ans . pollFirst (); return ans . stream (). mapToInt ( Integer :: intValue ). toArray (); } }","title":"1073. Adding Two Negabinary Numbers $\\star\\star$"},{"location":"java/1001-1100/1071-1080/#1074-number-of-submatrices-that-sum-to-target-starstarstar","text":"class Solution { public int numSubmatrixSumTarget ( int [][] matrix , int target ) { int ans = 0 ; for ( int [] row : matrix ) for ( int i = 1 ; i < row . length ; ++ i ) row [ i ] += row [ i - 1 ] ; for ( int baseCol = 0 ; baseCol < matrix [ 0 ] . length ; ++ baseCol ) for ( int j = baseCol ; j < matrix [ 0 ] . length ; ++ j ) { Map < Integer , Integer > prefixSumCount = new HashMap <> (); prefixSumCount . put ( 0 , 1 ); int sum = 0 ; for ( int i = 0 ; i < matrix . length ; ++ i ) { if ( baseCol > 0 ) sum -= matrix [ i ][ baseCol - 1 ] ; sum += matrix [ i ][ j ] ; ans += prefixSumCount . getOrDefault ( sum - target , 0 ); prefixSumCount . put ( sum , prefixSumCount . getOrDefault ( sum , 0 ) + 1 ); } } return ans ; } }","title":"1074. Number of Submatrices That Sum to Target $\\star\\star\\star$"},{"location":"java/1001-1100/1071-1080/#1075-project-employees-i-star","text":"","title":"1075. Project Employees I $\\star$ \ud83d\udd12"},{"location":"java/1001-1100/1071-1080/#1076-project-employees-ii-star","text":"","title":"1076. Project Employees II $\\star$ \ud83d\udd12"},{"location":"java/1001-1100/1071-1080/#1077-project-employees-iii-starstar","text":"","title":"1077. Project Employees III $\\star\\star$ \ud83d\udd12"},{"location":"java/1001-1100/1071-1080/#1078-occurrences-after-bigram-star","text":"class Solution { public String [] findOcurrences ( String text , String first , String second ) { List < String > ans = new ArrayList <> (); String [] words = text . split ( \" \" ); for ( int i = 0 ; i + 2 < words . length ; ++ i ) if ( first . equals ( words [ i ] ) && second . equals ( words [ i + 1 ] )) ans . add ( words [ i + 2 ] ); return ans . toArray ( new String [ 0 ] ); } }","title":"1078. Occurrences After Bigram $\\star$"},{"location":"java/1001-1100/1071-1080/#1079-letter-tile-possibilities-starstar","text":"","title":"1079. Letter Tile Possibilities $\\star\\star$"},{"location":"java/1001-1100/1071-1080/#1080-insufficient-nodes-in-root-to-leaf-paths-starstar","text":"","title":"1080. Insufficient Nodes in Root to Leaf Paths $\\star\\star$"},{"location":"java/1001-1100/1081-1090/","text":"1081. Smallest Subsequence of Distinct Characters $\\star\\star$ class Solution { public String smallestSubsequence ( String text ) { StringBuilder ans = new StringBuilder (); int [] count = new int [ 26 ] ; boolean [] used = new boolean [ 26 ] ; for ( char c : text . toCharArray ()) ++ count [ c - 'a' ] ; for ( char c : text . toCharArray ()) { -- count [ c - 'a' ] ; if ( used [ c - 'a' ] ) continue ; while ( ans . length () > 0 && ans . charAt ( ans . length () - 1 ) > c && count [ ans . charAt ( ans . length () - 1 ) - 'a' ] > 0 ) { used [ ans . charAt ( ans . length () - 1 ) - 'a' ] = false ; ans . setLength ( ans . length () - 1 ); } ans . append ( c ); used [ c - 'a' ] = true ; } return ans . toString (); } } 1082. Sales Analysis I $\\star$ \ud83d\udd12 1083. Sales Analysis II $\\star$ \ud83d\udd12 1084. Sales Analysis III $\\star$ \ud83d\udd12 1085. Sum of Digits in the Minimum Number $\\star$ \ud83d\udd12 1086. High Five $\\star$ \ud83d\udd12 1087. Brace Expansion $\\star\\star$ \ud83d\udd12 1088. Confusing Number II $\\star\\star\\star$ \ud83d\udd12 1089. Duplicate Zeros $\\star$ class Solution { public void duplicateZeros ( int [] arr ) { int zeros = 0 ; for ( int a : arr ) if ( a == 0 ) ++ zeros ; for ( int i = arr . length - 1 , j = arr . length + zeros - 1 ; i < j ; -- i , -- j ) { if ( j < arr . length ) arr [ j ] = arr [ i ] ; if ( arr [ i ] == 0 ) if ( -- j < arr . length ) arr [ j ] = arr [ i ] ; } } } 1090. Largest Values From Labels $\\star\\star$","title":"1081-1090"},{"location":"java/1001-1100/1081-1090/#1081-smallest-subsequence-of-distinct-characters-starstar","text":"class Solution { public String smallestSubsequence ( String text ) { StringBuilder ans = new StringBuilder (); int [] count = new int [ 26 ] ; boolean [] used = new boolean [ 26 ] ; for ( char c : text . toCharArray ()) ++ count [ c - 'a' ] ; for ( char c : text . toCharArray ()) { -- count [ c - 'a' ] ; if ( used [ c - 'a' ] ) continue ; while ( ans . length () > 0 && ans . charAt ( ans . length () - 1 ) > c && count [ ans . charAt ( ans . length () - 1 ) - 'a' ] > 0 ) { used [ ans . charAt ( ans . length () - 1 ) - 'a' ] = false ; ans . setLength ( ans . length () - 1 ); } ans . append ( c ); used [ c - 'a' ] = true ; } return ans . toString (); } }","title":"1081. Smallest Subsequence of Distinct Characters $\\star\\star$"},{"location":"java/1001-1100/1081-1090/#1082-sales-analysis-i-star","text":"","title":"1082. Sales Analysis I $\\star$ \ud83d\udd12"},{"location":"java/1001-1100/1081-1090/#1083-sales-analysis-ii-star","text":"","title":"1083. Sales Analysis II $\\star$ \ud83d\udd12"},{"location":"java/1001-1100/1081-1090/#1084-sales-analysis-iii-star","text":"","title":"1084. Sales Analysis III $\\star$ \ud83d\udd12"},{"location":"java/1001-1100/1081-1090/#1085-sum-of-digits-in-the-minimum-number-star","text":"","title":"1085. Sum of Digits in the Minimum Number $\\star$ \ud83d\udd12"},{"location":"java/1001-1100/1081-1090/#1086-high-five-star","text":"","title":"1086. High Five $\\star$ \ud83d\udd12"},{"location":"java/1001-1100/1081-1090/#1087-brace-expansion-starstar","text":"","title":"1087. Brace Expansion $\\star\\star$ \ud83d\udd12"},{"location":"java/1001-1100/1081-1090/#1088-confusing-number-ii-starstarstar","text":"","title":"1088. Confusing Number II $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/1001-1100/1081-1090/#1089-duplicate-zeros-star","text":"class Solution { public void duplicateZeros ( int [] arr ) { int zeros = 0 ; for ( int a : arr ) if ( a == 0 ) ++ zeros ; for ( int i = arr . length - 1 , j = arr . length + zeros - 1 ; i < j ; -- i , -- j ) { if ( j < arr . length ) arr [ j ] = arr [ i ] ; if ( arr [ i ] == 0 ) if ( -- j < arr . length ) arr [ j ] = arr [ i ] ; } } }","title":"1089. Duplicate Zeros $\\star$"},{"location":"java/1001-1100/1081-1090/#1090-largest-values-from-labels-starstar","text":"","title":"1090. Largest Values From Labels $\\star\\star$"},{"location":"java/1001-1100/1091-1100/","text":"1091. Shortest Path in Binary Matrix $\\star\\star$ 1092. Shortest Common Supersequence $\\star\\star\\star$ 1093. Statistics from a Large Sample $\\star\\star$ class Solution { public double [] sampleStats ( int [] count ) { int minimum = 0 ; int maximum = 0 ; double mean = 0 ; int leftMedian = 0 ; int rightMedian = 0 ; int mode = - 1 ; int numCount = Arrays . stream ( count ). sum (); int newNumCount = 0 ; int maxCount = 0 ; for ( int i = 0 ; i < count . length ; ++ i ) if ( count [ i ] > 0 ) { minimum = i ; break ; } for ( int i = count . length - 1 ; i >= 0 ; -- i ) if ( count [ i ] > 0 ) { maximum = i ; break ; } for ( int i = 0 ; i < count . length ; ++ i ) mean += ( double ) ( i * count [ i ] ) / ( double ) numCount ; for ( int i = 0 ; i < count . length ; ++ i ) { newNumCount += count [ i ] ; if ( newNumCount >= numCount / 2 ) { leftMedian = i ; break ; } } newNumCount = 0 ; for ( int i = count . length - 1 ; i >= 0 ; -- i ) { newNumCount += count [ i ] ; if ( newNumCount >= numCount / 2 ) { rightMedian = i ; break ; } } for ( int i = 0 ; i < count . length ; ++ i ) if ( count [ i ] > maxCount ) { maxCount = count [ i ] ; mode = i ; } return new double [] { minimum , maximum , mean , ( double ) ( leftMedian + rightMedian ) / 2.0 , mode }; } } 1094. Car Pooling $\\star\\star$ 1095. Find in Mountain Array $\\star\\star\\star$ 1096. Brace Expansion II $\\star\\star\\star$ class Solution { public List < String > braceExpansionII ( String expression ) { return dfs ( expression , 0 , expression . length () - 1 ); } private List < String > dfs ( final String expression , int s , int e ) { TreeSet < String > ans = new TreeSet <> (); List < List < String >> groups = new ArrayList <> (); groups . add ( new ArrayList <> ()); int layer = 0 ; int left = 0 ; for ( int i = s ; i <= e ; ++ i ) if ( expression . charAt ( i ) == '{' && ++ layer == 1 ) left = i + 1 ; else if ( expression . charAt ( i ) == '}' && -- layer == 0 ) merge ( groups , dfs ( expression , left , i - 1 )); else if ( expression . charAt ( i ) == ',' && layer == 0 ) groups . add ( new ArrayList <> ()); else if ( layer == 0 ) merge ( groups , new ArrayList <> ( Arrays . asList ( String . valueOf ( expression . charAt ( i ))))); for ( final List < String > group : groups ) for ( final String word : group ) ans . add ( word ); return new ArrayList <> ( ans ); } void merge ( List < List < String >> groups , List < String > group ) { if ( groups . get ( groups . size () - 1 ). isEmpty ()) { groups . set ( groups . size () - 1 , group ); return ; } List < String > mergedGroup = new ArrayList <> (); for ( final String word1 : groups . get ( groups . size () - 1 )) for ( final String word2 : group ) mergedGroup . add ( word1 + word2 ); groups . set ( groups . size () - 1 , mergedGroup ); } } 1097. Game Play Analysis V $\\star\\star\\star$ \ud83d\udd12 1098. Unpopular Books $\\star\\star$ \ud83d\udd12 1099. Two Sum Less Than K $\\star$ \ud83d\udd12 1100. Find K-Length Substrings With No Repeated Characters $\\star\\star$ \ud83d\udd12","title":"1091-1100"},{"location":"java/1001-1100/1091-1100/#1091-shortest-path-in-binary-matrix-starstar","text":"","title":"1091. Shortest Path in Binary Matrix $\\star\\star$"},{"location":"java/1001-1100/1091-1100/#1092-shortest-common-supersequence-starstarstar","text":"","title":"1092. Shortest Common Supersequence  $\\star\\star\\star$"},{"location":"java/1001-1100/1091-1100/#1093-statistics-from-a-large-sample-starstar","text":"class Solution { public double [] sampleStats ( int [] count ) { int minimum = 0 ; int maximum = 0 ; double mean = 0 ; int leftMedian = 0 ; int rightMedian = 0 ; int mode = - 1 ; int numCount = Arrays . stream ( count ). sum (); int newNumCount = 0 ; int maxCount = 0 ; for ( int i = 0 ; i < count . length ; ++ i ) if ( count [ i ] > 0 ) { minimum = i ; break ; } for ( int i = count . length - 1 ; i >= 0 ; -- i ) if ( count [ i ] > 0 ) { maximum = i ; break ; } for ( int i = 0 ; i < count . length ; ++ i ) mean += ( double ) ( i * count [ i ] ) / ( double ) numCount ; for ( int i = 0 ; i < count . length ; ++ i ) { newNumCount += count [ i ] ; if ( newNumCount >= numCount / 2 ) { leftMedian = i ; break ; } } newNumCount = 0 ; for ( int i = count . length - 1 ; i >= 0 ; -- i ) { newNumCount += count [ i ] ; if ( newNumCount >= numCount / 2 ) { rightMedian = i ; break ; } } for ( int i = 0 ; i < count . length ; ++ i ) if ( count [ i ] > maxCount ) { maxCount = count [ i ] ; mode = i ; } return new double [] { minimum , maximum , mean , ( double ) ( leftMedian + rightMedian ) / 2.0 , mode }; } }","title":"1093. Statistics from a Large Sample $\\star\\star$"},{"location":"java/1001-1100/1091-1100/#1094-car-pooling-starstar","text":"","title":"1094. Car Pooling $\\star\\star$"},{"location":"java/1001-1100/1091-1100/#1095-find-in-mountain-array-starstarstar","text":"","title":"1095. Find in Mountain Array $\\star\\star\\star$"},{"location":"java/1001-1100/1091-1100/#1096-brace-expansion-ii-starstarstar","text":"class Solution { public List < String > braceExpansionII ( String expression ) { return dfs ( expression , 0 , expression . length () - 1 ); } private List < String > dfs ( final String expression , int s , int e ) { TreeSet < String > ans = new TreeSet <> (); List < List < String >> groups = new ArrayList <> (); groups . add ( new ArrayList <> ()); int layer = 0 ; int left = 0 ; for ( int i = s ; i <= e ; ++ i ) if ( expression . charAt ( i ) == '{' && ++ layer == 1 ) left = i + 1 ; else if ( expression . charAt ( i ) == '}' && -- layer == 0 ) merge ( groups , dfs ( expression , left , i - 1 )); else if ( expression . charAt ( i ) == ',' && layer == 0 ) groups . add ( new ArrayList <> ()); else if ( layer == 0 ) merge ( groups , new ArrayList <> ( Arrays . asList ( String . valueOf ( expression . charAt ( i ))))); for ( final List < String > group : groups ) for ( final String word : group ) ans . add ( word ); return new ArrayList <> ( ans ); } void merge ( List < List < String >> groups , List < String > group ) { if ( groups . get ( groups . size () - 1 ). isEmpty ()) { groups . set ( groups . size () - 1 , group ); return ; } List < String > mergedGroup = new ArrayList <> (); for ( final String word1 : groups . get ( groups . size () - 1 )) for ( final String word2 : group ) mergedGroup . add ( word1 + word2 ); groups . set ( groups . size () - 1 , mergedGroup ); } }","title":"1096. Brace Expansion II $\\star\\star\\star$"},{"location":"java/1001-1100/1091-1100/#1097-game-play-analysis-v-starstarstar","text":"","title":"1097. Game Play Analysis V $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/1001-1100/1091-1100/#1098-unpopular-books-starstar","text":"","title":"1098. Unpopular Books $\\star\\star$ \ud83d\udd12"},{"location":"java/1001-1100/1091-1100/#1099-two-sum-less-than-k-star","text":"","title":"1099. Two Sum Less Than K $\\star$ \ud83d\udd12"},{"location":"java/1001-1100/1091-1100/#1100-find-k-length-substrings-with-no-repeated-characters-starstar","text":"","title":"1100. Find K-Length Substrings With No Repeated Characters $\\star\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1101-1110/","text":"1101. The Earliest Moment When Everyone Become Friends $\\star\\star$ \ud83d\udd12 1102. Path With Maximum Minimum Value $\\star\\star$ \ud83d\udd12 1103. Distribute Candies to People $\\star$ class Solution { public int [] distributeCandies ( int candies , int num_people ) { int [] ans = new int [ num_people ] ; long c = ( long ) candies ; long n = ( long ) num_people ; int rows = ( int ) ( - n + Math . sqrt ( n * n + 8 * n * n * c )) / ( int ) ( 2 * n * n ); int accumN = rows * ( rows - 1 ) * num_people / 2 ; for ( int i = 0 ; i < n ; ++ i ) ans [ i ] = accumN + rows * ( i + 1 ); int givenCandies = ( num_people * num_people * rows * rows + num_people * rows ) / 2 ; candies -= givenCandies ; for ( int i = 0 , lastGiven = rows * num_people + 1 ; candies > 0 ; ++ i , ++ lastGiven ) { int actualGiven = Math . min ( lastGiven , candies ); candies -= actualGiven ; ans [ i ] += actualGiven ; } return ans ; } } 1104. Path In Zigzag Labelled Binary Tree $\\star\\star$ class Solution { public List < Integer > pathInZigZagTree ( int label ) { LinkedList < Integer > ans = new LinkedList <> (); int level = 0 ; for ( int l = 0 ; l < 21 ; ++ l ) if ( Math . pow ( 2 , l ) > label ) { level = l - 1 ; break ; } if ( level % 2 == 1 ) label = boundarySum ( level ) - label ; for ( int l = level ; l >= 0 ; -- l ) { ans . addFirst ( l % 2 == 1 ? boundarySum ( l ) - label : label ); label /= 2 ; } return new ArrayList <> ( ans ); } private int boundarySum ( int level ) { return ( int ) Math . pow ( 2 , level ) + ( int ) Math . pow ( 2 , level + 1 ) - 1 ; } } 1105. Filling Bookcase Shelves $\\star\\star$ 1106. Parsing A Boolean Expression $\\star\\star\\star$ class Solution { public boolean parseBoolExpr ( String expression ) { return dfs ( expression , 0 , expression . length () - 1 ); } private boolean dfs ( final String expression , int s , int e ) { if ( s == e ) return expression . charAt ( s ) == 't' ; List < Boolean > exps = new ArrayList <> (); int layer = 0 ; int left = 0 ; char op = ' ' ; for ( int i = s ; i <= e ; ++ i ) { char c = expression . charAt ( i ); if ( layer == 0 && ( c == '!' || c == '&' || c == '|' )) op = c ; else if ( c == '(' && ++ layer == 1 ) left = i + 1 ; else if ( c == ')' && -- layer == 0 ) exps . add ( dfs ( expression , left , i - 1 )); else if ( c == ',' && layer == 1 ) { exps . add ( dfs ( expression , left , i - 1 )); left = i + 1 ; } } if ( op == '&' ) { boolean ans = true ; for ( boolean exp : exps ) ans &= exp ; return ans ; } if ( op == '|' ) { boolean ans = false ; for ( boolean exp : exps ) ans |= exp ; return ans ; } return ! exps . get ( 0 ); } } 1107. New Users Daily Count $\\star\\star$ \ud83d\udd12 1108. Defanging an IP Address $\\star$ class Solution { public String defangIPaddr ( String address ) { return address . replace ( \".\" , \"[.]\" ); } } 1109. Corporate Flight Bookings $\\star\\star$ class Solution { public int [] corpFlightBookings ( int [][] bookings , int n ) { int [] ans = new int [ n ] ; for ( int [] booking : bookings ) { ans [ booking [ 0 ] - 1 ] += booking [ 2 ] ; if ( booking [ 1 ] < n ) ans [ booking [ 1 ]] -= booking [ 2 ] ; } for ( int i = 1 ; i < n ; ++ i ) ans [ i ] += ans [ i - 1 ] ; return ans ; } } 1110. Delete Nodes And Return Forest $\\star\\star$","title":"1101-1110"},{"location":"java/1101-1200/1101-1110/#1101-the-earliest-moment-when-everyone-become-friends-starstar","text":"","title":"1101. The Earliest Moment When Everyone Become Friends $\\star\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1101-1110/#1102-path-with-maximum-minimum-value-starstar","text":"","title":"1102. Path With Maximum Minimum Value $\\star\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1101-1110/#1103-distribute-candies-to-people-star","text":"class Solution { public int [] distributeCandies ( int candies , int num_people ) { int [] ans = new int [ num_people ] ; long c = ( long ) candies ; long n = ( long ) num_people ; int rows = ( int ) ( - n + Math . sqrt ( n * n + 8 * n * n * c )) / ( int ) ( 2 * n * n ); int accumN = rows * ( rows - 1 ) * num_people / 2 ; for ( int i = 0 ; i < n ; ++ i ) ans [ i ] = accumN + rows * ( i + 1 ); int givenCandies = ( num_people * num_people * rows * rows + num_people * rows ) / 2 ; candies -= givenCandies ; for ( int i = 0 , lastGiven = rows * num_people + 1 ; candies > 0 ; ++ i , ++ lastGiven ) { int actualGiven = Math . min ( lastGiven , candies ); candies -= actualGiven ; ans [ i ] += actualGiven ; } return ans ; } }","title":"1103. Distribute Candies to People $\\star$"},{"location":"java/1101-1200/1101-1110/#1104-path-in-zigzag-labelled-binary-tree-starstar","text":"class Solution { public List < Integer > pathInZigZagTree ( int label ) { LinkedList < Integer > ans = new LinkedList <> (); int level = 0 ; for ( int l = 0 ; l < 21 ; ++ l ) if ( Math . pow ( 2 , l ) > label ) { level = l - 1 ; break ; } if ( level % 2 == 1 ) label = boundarySum ( level ) - label ; for ( int l = level ; l >= 0 ; -- l ) { ans . addFirst ( l % 2 == 1 ? boundarySum ( l ) - label : label ); label /= 2 ; } return new ArrayList <> ( ans ); } private int boundarySum ( int level ) { return ( int ) Math . pow ( 2 , level ) + ( int ) Math . pow ( 2 , level + 1 ) - 1 ; } }","title":"1104. Path In Zigzag Labelled Binary Tree $\\star\\star$"},{"location":"java/1101-1200/1101-1110/#1105-filling-bookcase-shelves-starstar","text":"","title":"1105. Filling Bookcase Shelves $\\star\\star$"},{"location":"java/1101-1200/1101-1110/#1106-parsing-a-boolean-expression-starstarstar","text":"class Solution { public boolean parseBoolExpr ( String expression ) { return dfs ( expression , 0 , expression . length () - 1 ); } private boolean dfs ( final String expression , int s , int e ) { if ( s == e ) return expression . charAt ( s ) == 't' ; List < Boolean > exps = new ArrayList <> (); int layer = 0 ; int left = 0 ; char op = ' ' ; for ( int i = s ; i <= e ; ++ i ) { char c = expression . charAt ( i ); if ( layer == 0 && ( c == '!' || c == '&' || c == '|' )) op = c ; else if ( c == '(' && ++ layer == 1 ) left = i + 1 ; else if ( c == ')' && -- layer == 0 ) exps . add ( dfs ( expression , left , i - 1 )); else if ( c == ',' && layer == 1 ) { exps . add ( dfs ( expression , left , i - 1 )); left = i + 1 ; } } if ( op == '&' ) { boolean ans = true ; for ( boolean exp : exps ) ans &= exp ; return ans ; } if ( op == '|' ) { boolean ans = false ; for ( boolean exp : exps ) ans |= exp ; return ans ; } return ! exps . get ( 0 ); } }","title":"1106. Parsing A Boolean Expression $\\star\\star\\star$"},{"location":"java/1101-1200/1101-1110/#1107-new-users-daily-count-starstar","text":"","title":"1107. New Users Daily Count $\\star\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1101-1110/#1108-defanging-an-ip-address-star","text":"class Solution { public String defangIPaddr ( String address ) { return address . replace ( \".\" , \"[.]\" ); } }","title":"1108. Defanging an IP Address $\\star$"},{"location":"java/1101-1200/1101-1110/#1109-corporate-flight-bookings-starstar","text":"class Solution { public int [] corpFlightBookings ( int [][] bookings , int n ) { int [] ans = new int [ n ] ; for ( int [] booking : bookings ) { ans [ booking [ 0 ] - 1 ] += booking [ 2 ] ; if ( booking [ 1 ] < n ) ans [ booking [ 1 ]] -= booking [ 2 ] ; } for ( int i = 1 ; i < n ; ++ i ) ans [ i ] += ans [ i - 1 ] ; return ans ; } }","title":"1109. Corporate Flight Bookings $\\star\\star$"},{"location":"java/1101-1200/1101-1110/#1110-delete-nodes-and-return-forest-starstar","text":"","title":"1110. Delete Nodes And Return Forest $\\star\\star$"},{"location":"java/1101-1200/1111-1120/","text":"1111. Maximum Nesting Depth of Two Valid Parentheses Strings $\\star\\star$ 1112. Highest Grade For Each Student $\\star\\star$ \ud83d\udd12 1113. Reported Posts $\\star$ \ud83d\udd12 1114. Print in Order $\\star$ 1115. Print FooBar Alternately $\\star\\star$ 1116. Print Zero Even Odd $\\star\\star$ 1117. Building H2O $\\star\\star$ 1118. Number of Days in a Month $\\star$ \ud83d\udd12 1119. Remove Vowels from a String $\\star$ \ud83d\udd12 1120. Maximum Average Subtree $\\star\\star$ \ud83d\udd12","title":"1111-1120"},{"location":"java/1101-1200/1111-1120/#1111-maximum-nesting-depth-of-two-valid-parentheses-strings-starstar","text":"","title":"1111. Maximum Nesting Depth of Two Valid Parentheses Strings $\\star\\star$"},{"location":"java/1101-1200/1111-1120/#1112-highest-grade-for-each-student-starstar","text":"","title":"1112. Highest Grade For Each Student $\\star\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1111-1120/#1113-reported-posts-star","text":"","title":"1113. Reported Posts $\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1111-1120/#1114-print-in-order-star","text":"","title":"1114. Print in Order $\\star$"},{"location":"java/1101-1200/1111-1120/#1115-print-foobar-alternately-starstar","text":"","title":"1115. Print FooBar Alternately $\\star\\star$"},{"location":"java/1101-1200/1111-1120/#1116-print-zero-even-odd-starstar","text":"","title":"1116. Print Zero Even Odd $\\star\\star$"},{"location":"java/1101-1200/1111-1120/#1117-building-h2o-starstar","text":"","title":"1117. Building H2O $\\star\\star$"},{"location":"java/1101-1200/1111-1120/#1118-number-of-days-in-a-month-star","text":"","title":"1118. Number of Days in a Month $\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1111-1120/#1119-remove-vowels-from-a-string-star","text":"","title":"1119. Remove Vowels from a String $\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1111-1120/#1120-maximum-average-subtree-starstar","text":"","title":"1120. Maximum Average Subtree $\\star\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1121-1130/","text":"1121. Divide Array Into Increasing Sequences $\\star\\star\\star$ \ud83d\udd12 1122. Relative Sort Array $\\star$ class Solution { public int [] relativeSortArray ( int [] arr1 , int [] arr2 ) { int [] ans = new int [ arr1 . length ] ; int [] count = new int [ 1001 ] ; int i = 0 ; for ( int a : arr1 ) ++ count [ a ] ; for ( int a : arr2 ) while ( count [ a ]-- > 0 ) ans [ i ++] = a ; for ( int num = 0 ; num < 1001 ; ++ num ) while ( count [ num ]-- > 0 ) ans [ i ++] = num ; return ans ; } } 1123. Lowest Common Ancestor of Deepest Leaves $\\star\\star$ 1124. Longest Well-Performing Interval $\\star\\star$ 1125. Smallest Sufficient Team $\\star\\star\\star$ 1126. Active Businesses $\\star\\star$ \ud83d\udd12 1127. User Purchase Platform $\\star\\star\\star$ \ud83d\udd12 1128. Number of Equivalent Domino Pairs $\\star$ class Solution { public int numEquivDominoPairs ( int [][] dominoes ) { int ans = 0 ; Map < Integer , Integer > count = new HashMap <> (); for ( int [] domino : dominoes ) { int key = Math . min ( domino [ 0 ] , domino [ 1 ] ) * 10 + Math . max ( domino [ 0 ] , domino [ 1 ] ); ans += count . getOrDefault ( key , 0 ); count . put ( key , count . getOrDefault ( key , 0 ) + 1 ); } return ans ; } } 1129. Shortest Path with Alternating Colors $\\star\\star$ 1130. Minimum Cost Tree From Leaf Values $\\star\\star$","title":"1121-1130"},{"location":"java/1101-1200/1121-1130/#1121-divide-array-into-increasing-sequences-starstarstar","text":"","title":"1121. Divide Array Into Increasing Sequences $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1121-1130/#1122-relative-sort-array-star","text":"class Solution { public int [] relativeSortArray ( int [] arr1 , int [] arr2 ) { int [] ans = new int [ arr1 . length ] ; int [] count = new int [ 1001 ] ; int i = 0 ; for ( int a : arr1 ) ++ count [ a ] ; for ( int a : arr2 ) while ( count [ a ]-- > 0 ) ans [ i ++] = a ; for ( int num = 0 ; num < 1001 ; ++ num ) while ( count [ num ]-- > 0 ) ans [ i ++] = num ; return ans ; } }","title":"1122. Relative Sort Array $\\star$"},{"location":"java/1101-1200/1121-1130/#1123-lowest-common-ancestor-of-deepest-leaves-starstar","text":"","title":"1123. Lowest Common Ancestor of Deepest Leaves $\\star\\star$"},{"location":"java/1101-1200/1121-1130/#1124-longest-well-performing-interval-starstar","text":"","title":"1124. Longest Well-Performing Interval $\\star\\star$"},{"location":"java/1101-1200/1121-1130/#1125-smallest-sufficient-team-starstarstar","text":"","title":"1125. Smallest Sufficient Team $\\star\\star\\star$"},{"location":"java/1101-1200/1121-1130/#1126-active-businesses-starstar","text":"","title":"1126. Active Businesses $\\star\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1121-1130/#1127-user-purchase-platform-starstarstar","text":"","title":"1127. User Purchase Platform $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1121-1130/#1128-number-of-equivalent-domino-pairs-star","text":"class Solution { public int numEquivDominoPairs ( int [][] dominoes ) { int ans = 0 ; Map < Integer , Integer > count = new HashMap <> (); for ( int [] domino : dominoes ) { int key = Math . min ( domino [ 0 ] , domino [ 1 ] ) * 10 + Math . max ( domino [ 0 ] , domino [ 1 ] ); ans += count . getOrDefault ( key , 0 ); count . put ( key , count . getOrDefault ( key , 0 ) + 1 ); } return ans ; } }","title":"1128. Number of Equivalent Domino Pairs $\\star$"},{"location":"java/1101-1200/1121-1130/#1129-shortest-path-with-alternating-colors-starstar","text":"","title":"1129. Shortest Path with Alternating Colors $\\star\\star$"},{"location":"java/1101-1200/1121-1130/#1130-minimum-cost-tree-from-leaf-values-starstar","text":"","title":"1130. Minimum Cost Tree From Leaf Values $\\star\\star$"},{"location":"java/1101-1200/1131-1140/","text":"1131. Maximum of Absolute Value Expression $\\star\\star$ class Solution { public int maxAbsValExpr ( int [] arr1 , int [] arr2 ) { final int n = arr1 . length ; int [] a = new int [ n ] ; int [] b = new int [ n ] ; int [] c = new int [ n ] ; int [] d = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) { a [ i ] = arr1 [ i ] + arr2 [ i ] + i ; b [ i ] = arr1 [ i ] + arr2 [ i ] - i ; c [ i ] = arr1 [ i ] - arr2 [ i ] + i ; d [ i ] = arr1 [ i ] - arr2 [ i ] - i ; } return Math . max ( Math . max ( diff ( a ), diff ( b )), Math . max ( diff ( c ), diff ( d ))); } private int diff ( int [] nums ) { final int min = Arrays . stream ( nums ). min (). getAsInt (); final int max = Arrays . stream ( nums ). max (). getAsInt (); return max - min ; } } 1132. Reported Posts II $\\star\\star$ \ud83d\udd12 1133. Largest Unique Number $\\star$ \ud83d\udd12 1134. Armstrong Number $\\star$ \ud83d\udd12 1135. Connecting Cities With Minimum Cost $\\star\\star$ \ud83d\udd12 1136. Parallel Courses $\\star\\star\\star$ \ud83d\udd12 1137. N-th Tribonacci Number $\\star$ 1138. Alphabet Board Path $\\star\\star$ 1139. Largest 1-Bordered Square $\\star\\star$ 1140. Stone Game II $\\star\\star$","title":"1131-1140"},{"location":"java/1101-1200/1131-1140/#1131-maximum-of-absolute-value-expression-starstar","text":"class Solution { public int maxAbsValExpr ( int [] arr1 , int [] arr2 ) { final int n = arr1 . length ; int [] a = new int [ n ] ; int [] b = new int [ n ] ; int [] c = new int [ n ] ; int [] d = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) { a [ i ] = arr1 [ i ] + arr2 [ i ] + i ; b [ i ] = arr1 [ i ] + arr2 [ i ] - i ; c [ i ] = arr1 [ i ] - arr2 [ i ] + i ; d [ i ] = arr1 [ i ] - arr2 [ i ] - i ; } return Math . max ( Math . max ( diff ( a ), diff ( b )), Math . max ( diff ( c ), diff ( d ))); } private int diff ( int [] nums ) { final int min = Arrays . stream ( nums ). min (). getAsInt (); final int max = Arrays . stream ( nums ). max (). getAsInt (); return max - min ; } }","title":"1131. Maximum of Absolute Value Expression $\\star\\star$"},{"location":"java/1101-1200/1131-1140/#1132-reported-posts-ii-starstar","text":"","title":"1132. Reported Posts II $\\star\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1131-1140/#1133-largest-unique-number-star","text":"","title":"1133. Largest Unique Number $\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1131-1140/#1134-armstrong-number-star","text":"","title":"1134. Armstrong Number $\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1131-1140/#1135-connecting-cities-with-minimum-cost-starstar","text":"","title":"1135. Connecting Cities With Minimum Cost $\\star\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1131-1140/#1136-parallel-courses-starstarstar","text":"","title":"1136. Parallel Courses $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1131-1140/#1137-n-th-tribonacci-number-star","text":"","title":"1137. N-th Tribonacci Number $\\star$"},{"location":"java/1101-1200/1131-1140/#1138-alphabet-board-path-starstar","text":"","title":"1138. Alphabet Board Path $\\star\\star$"},{"location":"java/1101-1200/1131-1140/#1139-largest-1-bordered-square-starstar","text":"","title":"1139. Largest 1-Bordered Square $\\star\\star$"},{"location":"java/1101-1200/1131-1140/#1140-stone-game-ii-starstar","text":"","title":"1140. Stone Game II $\\star\\star$"},{"location":"java/1101-1200/1141-1150/","text":"1141. User Activity for the Past 30 Days I $\\star$ \ud83d\udd12 1142. User Activity for the Past 30 Days II $\\star$ \ud83d\udd12 1143. Longest Common Subsequence $\\star\\star$ 1144. Decrease Elements To Make Array Zigzag $\\star\\star$ class Solution { public int movesToMakeZigzag ( int [] nums ) { int [] decreasing = new int [ 2 ] ; for ( int i = 0 ; i < nums . length ; ++ i ) { int l = i > 0 ? nums [ i - 1 ] : 1001 ; int r = i + 1 < nums . length ? nums [ i + 1 ] : 1001 ; decreasing [ i % 2 ] += Math . max ( 0 , nums [ i ] - Math . min ( l , r ) + 1 ); } return Math . min ( decreasing [ 0 ] , decreasing [ 1 ] ); } } 1145. Binary Tree Coloring Game $\\star\\star$ 1146. Snapshot Array $\\star\\star$ class SnapshotArray { public SnapshotArray ( int length ) { map = new TreeMap [ length ] ; for ( int i = 0 ; i < length ; ++ i ) { map [ i ] = new TreeMap <> (); map [ i ] . put ( 0 , 0 ); } } public void set ( int index , int val ) { map [ index ] . put ( snap_id , val ); } public int snap () { return snap_id ++ ; } public int get ( int index , int snap_id ) { return map [ index ] . floorEntry ( snap_id ). getValue (); } private TreeMap < Integer , Integer >[] map ; private int snap_id = 0 ; } 1147. Longest Chunked Palindrome Decomposition $\\star\\star\\star$ 1148. Article Views I $\\star$ \ud83d\udd12 1149. Article Views II $\\star\\star$ \ud83d\udd12 1150. Check If a Number Is Majority Element in a Sorted Array $\\star$ \ud83d\udd12","title":"1141-1150"},{"location":"java/1101-1200/1141-1150/#1141-user-activity-for-the-past-30-days-i-star","text":"","title":"1141. User Activity for the Past 30 Days I $\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1141-1150/#1142-user-activity-for-the-past-30-days-ii-star","text":"","title":"1142. User Activity for the Past 30 Days II $\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1141-1150/#1143-longest-common-subsequence-starstar","text":"","title":"1143. Longest Common Subsequence $\\star\\star$"},{"location":"java/1101-1200/1141-1150/#1144-decrease-elements-to-make-array-zigzag-starstar","text":"class Solution { public int movesToMakeZigzag ( int [] nums ) { int [] decreasing = new int [ 2 ] ; for ( int i = 0 ; i < nums . length ; ++ i ) { int l = i > 0 ? nums [ i - 1 ] : 1001 ; int r = i + 1 < nums . length ? nums [ i + 1 ] : 1001 ; decreasing [ i % 2 ] += Math . max ( 0 , nums [ i ] - Math . min ( l , r ) + 1 ); } return Math . min ( decreasing [ 0 ] , decreasing [ 1 ] ); } }","title":"1144. Decrease Elements To Make Array Zigzag $\\star\\star$"},{"location":"java/1101-1200/1141-1150/#1145-binary-tree-coloring-game-starstar","text":"","title":"1145. Binary Tree Coloring Game $\\star\\star$"},{"location":"java/1101-1200/1141-1150/#1146-snapshot-array-starstar","text":"class SnapshotArray { public SnapshotArray ( int length ) { map = new TreeMap [ length ] ; for ( int i = 0 ; i < length ; ++ i ) { map [ i ] = new TreeMap <> (); map [ i ] . put ( 0 , 0 ); } } public void set ( int index , int val ) { map [ index ] . put ( snap_id , val ); } public int snap () { return snap_id ++ ; } public int get ( int index , int snap_id ) { return map [ index ] . floorEntry ( snap_id ). getValue (); } private TreeMap < Integer , Integer >[] map ; private int snap_id = 0 ; }","title":"1146. Snapshot Array $\\star\\star$"},{"location":"java/1101-1200/1141-1150/#1147-longest-chunked-palindrome-decomposition-starstarstar","text":"","title":"1147. Longest Chunked Palindrome Decomposition $\\star\\star\\star$"},{"location":"java/1101-1200/1141-1150/#1148-article-views-i-star","text":"","title":"1148. Article Views I $\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1141-1150/#1149-article-views-ii-starstar","text":"","title":"1149. Article Views II $\\star\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1141-1150/#1150-check-if-a-number-is-majority-element-in-a-sorted-array-star","text":"","title":"1150. Check If a Number Is Majority Element in a Sorted Array $\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1151-1160/","text":"1151. Minimum Swaps to Group All 1's Together $\\star\\star$ \ud83d\udd12 1152. Analyze User Website Visit Pattern $\\star\\star$ \ud83d\udd12 1153. String Transforms Into Another String $\\star\\star\\star$ \ud83d\udd12 1154. Day of the Year $\\star$ class Solution { public int dayOfYear ( String date ) { int ans = 0 ; int year = Integer . valueOf ( date . substring ( 0 , 4 )); int month = Integer . valueOf ( date . substring ( 5 , 7 )); int day = Integer . valueOf ( date . substring ( 8 )); int [] days = new int [] { 31 , isLeapYear ( year ) ? 29 : 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 }; for ( int i = 0 ; i < month - 1 ; ++ i ) ans += days [ i ] ; return ans + day ; } private boolean isLeapYear ( int year ) { return ( year % 4 == 0 && year % 100 != 0 ) || year % 400 == 0 ; } } 1155. Number of Dice Rolls With Target Sum $\\star\\star$ class Solution { public int numRollsToTarget ( int d , int f , int target ) { final int kMod = ( int ) 1e9 + 7 ; int [] dp = new int [ target + 1 ] ; dp [ 0 ] = 1 ; while ( d -- > 0 ) { int [] newDp = new int [ target + 1 ] ; for ( int i = 1 ; i <= f ; ++ i ) for ( int t = i ; t <= target ; ++ t ) newDp [ t ] = ( newDp [ t ] + dp [ t - i ] ) % kMod ; dp = newDp ; } return dp [ target ] ; } } 1156. Swap For Longest Repeated Character Substring $\\star\\star$ class Solution { public int maxRepOpt1 ( String text ) { int ans = 0 ; int [] count = new int [ 26 ] ; List < int []> groups = new ArrayList <> (); for ( char c : text . toCharArray ()) ++ count [ c - 'a' ] ; groups . add ( new int [] { text . charAt ( 0 ), 1 }); for ( int i = 1 ; i < text . length (); ++ i ) if ( text . charAt ( i ) == text . charAt ( i - 1 )) ++ groups . get ( groups . size () - 1 ) [ 1 ] ; else groups . add ( new int [] { text . charAt ( i ), 1 }); for ( int [] group : groups ) ans = Math . max ( ans , Math . min ( group [ 1 ] + 1 , count [ group [ 0 ] - 'a' ] )); for ( int i = 1 ; i + 1 < groups . size (); ++ i ) if ( groups . get ( i - 1 ) [ 0 ] == groups . get ( i + 1 ) [ 0 ] && groups . get ( i ) [ 1 ] == 1 ) ans = Math . max ( ans , Math . min ( groups . get ( i - 1 ) [ 1 ] + groups . get ( i + 1 ) [ 1 ] + 1 , count [ groups . get ( i - 1 ) [ 0 ] - 'a' ] )); return ans ; } } 1157. Online Majority Element In Subarray $\\star\\star\\star$ class MajorityChecker { public MajorityChecker ( int [] arr ) { map = new HashMap <> (); for ( int i = 0 ; i < arr . length ; ++ i ) { List < Integer > list = map . getOrDefault ( arr [ i ] , new ArrayList <> ()); list . add ( i ); map . put ( arr [ i ] , list ); } } public int query ( int left , int right , int threshold ) { for ( int num : map . keySet ()) { if ( map . get ( num ). size () < threshold ) continue ; int l = Collections . binarySearch ( map . get ( num ), left ); int r = Collections . binarySearch ( map . get ( num ), right + 1 ); if ( l < 0 ) l = - l - 1 ; if ( r < 0 ) r = - r - 1 ; if ( r - l >= threshold ) return num ; } return - 1 ; } private Map < Integer , List < Integer >> map ; } 1158. Market Analysis I $\\star\\star$ \ud83d\udd12 1159. Market Analysis II $\\star\\star\\star$ \ud83d\udd12 1160. Find Words That Can Be Formed by Characters $\\star$ class Solution { public int countCharacters ( String [] words , String chars ) { int ans = 0 ; int [] count = new int [ 26 ] ; for ( char c : chars . toCharArray ()) ++ count [ c - 'a' ] ; for ( String word : words ) { int [] tempCount = Arrays . copyOf ( count , count . length ); for ( char c : word . toCharArray ()) if ( -- tempCount [ c - 'a' ] < 0 ) { ans -= word . length (); break ; } ans += word . length (); } return ans ; } }","title":"1151-1160"},{"location":"java/1101-1200/1151-1160/#1151-minimum-swaps-to-group-all-1s-together-starstar","text":"","title":"1151. Minimum Swaps to Group All 1's Together $\\star\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1151-1160/#1152-analyze-user-website-visit-pattern-starstar","text":"","title":"1152. Analyze User Website Visit Pattern $\\star\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1151-1160/#1153-string-transforms-into-another-string-starstarstar","text":"","title":"1153. String Transforms Into Another String $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1151-1160/#1154-day-of-the-year-star","text":"class Solution { public int dayOfYear ( String date ) { int ans = 0 ; int year = Integer . valueOf ( date . substring ( 0 , 4 )); int month = Integer . valueOf ( date . substring ( 5 , 7 )); int day = Integer . valueOf ( date . substring ( 8 )); int [] days = new int [] { 31 , isLeapYear ( year ) ? 29 : 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 }; for ( int i = 0 ; i < month - 1 ; ++ i ) ans += days [ i ] ; return ans + day ; } private boolean isLeapYear ( int year ) { return ( year % 4 == 0 && year % 100 != 0 ) || year % 400 == 0 ; } }","title":"1154. Day of the Year $\\star$"},{"location":"java/1101-1200/1151-1160/#1155-number-of-dice-rolls-with-target-sum-starstar","text":"class Solution { public int numRollsToTarget ( int d , int f , int target ) { final int kMod = ( int ) 1e9 + 7 ; int [] dp = new int [ target + 1 ] ; dp [ 0 ] = 1 ; while ( d -- > 0 ) { int [] newDp = new int [ target + 1 ] ; for ( int i = 1 ; i <= f ; ++ i ) for ( int t = i ; t <= target ; ++ t ) newDp [ t ] = ( newDp [ t ] + dp [ t - i ] ) % kMod ; dp = newDp ; } return dp [ target ] ; } }","title":"1155. Number of Dice Rolls With Target Sum $\\star\\star$"},{"location":"java/1101-1200/1151-1160/#1156-swap-for-longest-repeated-character-substring-starstar","text":"class Solution { public int maxRepOpt1 ( String text ) { int ans = 0 ; int [] count = new int [ 26 ] ; List < int []> groups = new ArrayList <> (); for ( char c : text . toCharArray ()) ++ count [ c - 'a' ] ; groups . add ( new int [] { text . charAt ( 0 ), 1 }); for ( int i = 1 ; i < text . length (); ++ i ) if ( text . charAt ( i ) == text . charAt ( i - 1 )) ++ groups . get ( groups . size () - 1 ) [ 1 ] ; else groups . add ( new int [] { text . charAt ( i ), 1 }); for ( int [] group : groups ) ans = Math . max ( ans , Math . min ( group [ 1 ] + 1 , count [ group [ 0 ] - 'a' ] )); for ( int i = 1 ; i + 1 < groups . size (); ++ i ) if ( groups . get ( i - 1 ) [ 0 ] == groups . get ( i + 1 ) [ 0 ] && groups . get ( i ) [ 1 ] == 1 ) ans = Math . max ( ans , Math . min ( groups . get ( i - 1 ) [ 1 ] + groups . get ( i + 1 ) [ 1 ] + 1 , count [ groups . get ( i - 1 ) [ 0 ] - 'a' ] )); return ans ; } }","title":"1156. Swap For Longest Repeated Character Substring $\\star\\star$"},{"location":"java/1101-1200/1151-1160/#1157-online-majority-element-in-subarray-starstarstar","text":"class MajorityChecker { public MajorityChecker ( int [] arr ) { map = new HashMap <> (); for ( int i = 0 ; i < arr . length ; ++ i ) { List < Integer > list = map . getOrDefault ( arr [ i ] , new ArrayList <> ()); list . add ( i ); map . put ( arr [ i ] , list ); } } public int query ( int left , int right , int threshold ) { for ( int num : map . keySet ()) { if ( map . get ( num ). size () < threshold ) continue ; int l = Collections . binarySearch ( map . get ( num ), left ); int r = Collections . binarySearch ( map . get ( num ), right + 1 ); if ( l < 0 ) l = - l - 1 ; if ( r < 0 ) r = - r - 1 ; if ( r - l >= threshold ) return num ; } return - 1 ; } private Map < Integer , List < Integer >> map ; }","title":"1157. Online Majority Element In Subarray $\\star\\star\\star$"},{"location":"java/1101-1200/1151-1160/#1158-market-analysis-i-starstar","text":"","title":"1158. Market Analysis I $\\star\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1151-1160/#1159-market-analysis-ii-starstarstar","text":"","title":"1159. Market Analysis II $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1151-1160/#1160-find-words-that-can-be-formed-by-characters-star","text":"class Solution { public int countCharacters ( String [] words , String chars ) { int ans = 0 ; int [] count = new int [ 26 ] ; for ( char c : chars . toCharArray ()) ++ count [ c - 'a' ] ; for ( String word : words ) { int [] tempCount = Arrays . copyOf ( count , count . length ); for ( char c : word . toCharArray ()) if ( -- tempCount [ c - 'a' ] < 0 ) { ans -= word . length (); break ; } ans += word . length (); } return ans ; } }","title":"1160. Find Words That Can Be Formed by Characters $\\star$"},{"location":"java/1101-1200/1161-1170/","text":"1161. Maximum Level Sum of a Binary Tree $\\star\\star$ 1162. As Far from Land as Possible $\\star\\star$ 1163. Last Substring in Lexicographical Order $\\star\\star\\star$ 1164. Product Price at a Given Date $\\star\\star$ \ud83d\udd12 1165. Single-Row Keyboard $\\star$ \ud83d\udd12 1166. Design File System $\\star\\star$ \ud83d\udd12 1167. Minimum Cost to Connect Sticks $\\star\\star$ \ud83d\udd12 1168. Optimize Water Distribution in a Village $\\star\\star\\star$ \ud83d\udd12 1169. Invalid Transactions $\\star\\star$ class Solution { public List < String > invalidTransactions ( String [] transactions ) { Set < String > ans = new HashSet <> (); Map < String , List < String []>> nameToTransactions = new HashMap <> (); for ( final String transaction : transactions ) { String [] token = transaction . split ( \",\" ); if ( Integer . valueOf ( token [ 2 ] ) > 1000 ) ans . add ( transaction ); if ( nameToTransactions . containsKey ( token [ 0 ] )) for ( final String [] val : nameToTransactions . get ( token [ 0 ] )) if ( Math . abs ( Integer . valueOf ( val [ 1 ] ) - Integer . valueOf ( token [ 1 ] )) <= 60 && ! val [ 3 ] . equals ( token [ 3 ] )) { ans . add ( transaction ); ans . add ( val [ 0 ] + \",\" + val [ 1 ] + \",\" + val [ 2 ] + \",\" + val [ 3 ] ); } nameToTransactions . computeIfAbsent ( token [ 0 ] , k -> new ArrayList <> ()) . add ( new String [] { token [ 0 ] , token [ 1 ] , token [ 2 ] , token [ 3 ] }); } return new ArrayList <> ( ans ); } } 1170. Compare Strings by Frequency of the Smallest Character $\\star$ class Solution { public int [] numSmallerByFrequency ( String [] queries , String [] words ) { int [] ans = new int [ queries . length ] ; int [] wordsFreq = new int [ words . length ] ; for ( int i = 0 ; i < words . length ; ++ i ) wordsFreq [ i ] = f ( words [ i ] ); Arrays . sort ( wordsFreq ); for ( int i = 0 ; i < queries . length ; ++ i ) { int freq = f ( queries [ i ] ); ans [ i ] = words . length - upper_bound ( wordsFreq , 0 , wordsFreq . length , freq ); } return ans ; } private int f ( String word ) { int count = 0 ; char currentChar = 'z' + 1 ; for ( char c : word . toCharArray ()) if ( c < currentChar ) { currentChar = c ; count = 1 ; } else if ( c == currentChar ) ++ count ; return count ; } private int upper_bound ( int [] nums , int l , int r , int value ) { while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] <= value ) l = m + 1 ; else r = m ; } return l ; } }","title":"1161-1170"},{"location":"java/1101-1200/1161-1170/#1161-maximum-level-sum-of-a-binary-tree-starstar","text":"","title":"1161. Maximum Level Sum of a Binary Tree $\\star\\star$"},{"location":"java/1101-1200/1161-1170/#1162-as-far-from-land-as-possible-starstar","text":"","title":"1162. As Far from Land as Possible $\\star\\star$"},{"location":"java/1101-1200/1161-1170/#1163-last-substring-in-lexicographical-order-starstarstar","text":"","title":"1163. Last Substring in Lexicographical Order $\\star\\star\\star$"},{"location":"java/1101-1200/1161-1170/#1164-product-price-at-a-given-date-starstar","text":"","title":"1164. Product Price at a Given Date $\\star\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1161-1170/#1165-single-row-keyboard-star","text":"","title":"1165. Single-Row Keyboard $\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1161-1170/#1166-design-file-system-starstar","text":"","title":"1166. Design File System $\\star\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1161-1170/#1167-minimum-cost-to-connect-sticks-starstar","text":"","title":"1167. Minimum Cost to Connect Sticks $\\star\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1161-1170/#1168-optimize-water-distribution-in-a-village-starstarstar","text":"","title":"1168. Optimize Water Distribution in a Village $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1161-1170/#1169-invalid-transactions-starstar","text":"class Solution { public List < String > invalidTransactions ( String [] transactions ) { Set < String > ans = new HashSet <> (); Map < String , List < String []>> nameToTransactions = new HashMap <> (); for ( final String transaction : transactions ) { String [] token = transaction . split ( \",\" ); if ( Integer . valueOf ( token [ 2 ] ) > 1000 ) ans . add ( transaction ); if ( nameToTransactions . containsKey ( token [ 0 ] )) for ( final String [] val : nameToTransactions . get ( token [ 0 ] )) if ( Math . abs ( Integer . valueOf ( val [ 1 ] ) - Integer . valueOf ( token [ 1 ] )) <= 60 && ! val [ 3 ] . equals ( token [ 3 ] )) { ans . add ( transaction ); ans . add ( val [ 0 ] + \",\" + val [ 1 ] + \",\" + val [ 2 ] + \",\" + val [ 3 ] ); } nameToTransactions . computeIfAbsent ( token [ 0 ] , k -> new ArrayList <> ()) . add ( new String [] { token [ 0 ] , token [ 1 ] , token [ 2 ] , token [ 3 ] }); } return new ArrayList <> ( ans ); } }","title":"1169. Invalid Transactions $\\star\\star$"},{"location":"java/1101-1200/1161-1170/#1170-compare-strings-by-frequency-of-the-smallest-character-star","text":"class Solution { public int [] numSmallerByFrequency ( String [] queries , String [] words ) { int [] ans = new int [ queries . length ] ; int [] wordsFreq = new int [ words . length ] ; for ( int i = 0 ; i < words . length ; ++ i ) wordsFreq [ i ] = f ( words [ i ] ); Arrays . sort ( wordsFreq ); for ( int i = 0 ; i < queries . length ; ++ i ) { int freq = f ( queries [ i ] ); ans [ i ] = words . length - upper_bound ( wordsFreq , 0 , wordsFreq . length , freq ); } return ans ; } private int f ( String word ) { int count = 0 ; char currentChar = 'z' + 1 ; for ( char c : word . toCharArray ()) if ( c < currentChar ) { currentChar = c ; count = 1 ; } else if ( c == currentChar ) ++ count ; return count ; } private int upper_bound ( int [] nums , int l , int r , int value ) { while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] <= value ) l = m + 1 ; else r = m ; } return l ; } }","title":"1170. Compare Strings by Frequency of the Smallest Character $\\star$"},{"location":"java/1101-1200/1171-1180/","text":"1171. Remove Zero Sum Consecutive Nodes from Linked List $\\star\\star$ class Solution { public ListNode removeZeroSumSublists ( ListNode head ) { ListNode dummy = new ListNode ( 0 ); dummy . next = head ; int prefixSum = 0 ; Map < Integer , ListNode > prefixSumToNode = new HashMap <> (); prefixSumToNode . put ( 0 , dummy ); for (; head != null ; head = head . next ) { prefixSum += head . val ; prefixSumToNode . put ( prefixSum , head ); } prefixSum = 0 ; for ( head = dummy ; head != null ; head = head . next ) { prefixSum += head . val ; head . next = prefixSumToNode . get ( prefixSum ). next ; } return dummy . next ; } } 1172. Dinner Plate Stacks $\\star\\star\\star$ 1173. Immediate Food Delivery I $\\star$ \ud83d\udd12 1174. Immediate Food Delivery II $\\star\\star$ \ud83d\udd12 1175. Prime Arrangements $\\star$ class Solution { public int numPrimeArrangements ( int n ) { final long kMod = ( long ) 1e9 + 7 ; int count = countPrimes ( n ); return ( int ) (( factorial ( count , kMod ) * factorial ( n - count , kMod )) % kMod ); } private int countPrimes ( int n ) { boolean [] prime = new boolean [ n + 1 ] ; Arrays . fill ( prime , 2 , n + 1 , true ); for ( int i = 0 ; i * i <= n ; ++ i ) if ( prime [ i ] ) for ( int j = i * i ; j <= n ; j += i ) prime [ j ] = false ; int count = 0 ; for ( boolean p : prime ) if ( p ) ++ count ; return count ; } long factorial ( int n , final long kMod ) { long fact = 1 ; for ( int i = 1 ; i <= n ; ++ i ) fact = fact * i % kMod ; return fact ; } } 1176. Diet Plan Performance $\\star$ \ud83d\udd12 1177. Can Make Palindrome from Substring $\\star\\star$ class Solution { public List < Boolean > canMakePaliQueries ( String s , int [][] queries ) { List < Boolean > ans = new ArrayList <> (); int [] dp = new int [ s . length () + 1 ] ; for ( int i = 1 ; i <= s . length (); ++ i ) dp [ i ] = dp [ i - 1 ] ^ ( 1 << s . charAt ( i - 1 ) - 'a' ); for ( int [] query : queries ) { int odds = Integer . bitCount ( dp [ query [ 1 ] + 1 ] ^ dp [ query [ 0 ]] ); ans . add ( odds / 2 <= query [ 2 ] ); } return ans ; } } 1178. Number of Valid Words for Each Puzzle $\\star\\star\\star$ class Solution { public List < Integer > findNumOfValidWords ( String [] words , String [] puzzles ) { List < Integer > ans = new ArrayList <> (); Map < Integer , Integer > binaryCount = new HashMap <> (); for ( final String word : words ) { int mask = 0 ; for ( char c : word . toCharArray ()) mask |= 1 << ( c - 'a' ); binaryCount . put ( mask , binaryCount . getOrDefault ( mask , 0 ) + 1 ); } for ( final String puzzle : puzzles ) { int valid = 0 ; final int n = puzzle . length () - 1 ; for ( int i = 0 ; i < ( 1 << n ); ++ i ) { int mask = 1 << ( puzzle . charAt ( 0 ) - 'a' ); for ( int j = 0 ; j < n ; ++ j ) if (( i & ( 1 << j )) > 0 ) mask |= 1 << ( puzzle . charAt ( j + 1 ) - 'a' ); if ( binaryCount . containsKey ( mask )) valid += binaryCount . get ( mask ); } ans . add ( valid ); } return ans ; } } 1179. Reformat Department Table $\\star$ 1180. Count Substrings with Only One Distinct Letter $\\star$ \ud83d\udd12","title":"1171-1180"},{"location":"java/1101-1200/1171-1180/#1171-remove-zero-sum-consecutive-nodes-from-linked-list-starstar","text":"class Solution { public ListNode removeZeroSumSublists ( ListNode head ) { ListNode dummy = new ListNode ( 0 ); dummy . next = head ; int prefixSum = 0 ; Map < Integer , ListNode > prefixSumToNode = new HashMap <> (); prefixSumToNode . put ( 0 , dummy ); for (; head != null ; head = head . next ) { prefixSum += head . val ; prefixSumToNode . put ( prefixSum , head ); } prefixSum = 0 ; for ( head = dummy ; head != null ; head = head . next ) { prefixSum += head . val ; head . next = prefixSumToNode . get ( prefixSum ). next ; } return dummy . next ; } }","title":"1171. Remove Zero Sum Consecutive Nodes from Linked List $\\star\\star$"},{"location":"java/1101-1200/1171-1180/#1172-dinner-plate-stacks-starstarstar","text":"","title":"1172. Dinner Plate Stacks $\\star\\star\\star$"},{"location":"java/1101-1200/1171-1180/#1173-immediate-food-delivery-i-star","text":"","title":"1173. Immediate Food Delivery I $\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1171-1180/#1174-immediate-food-delivery-ii-starstar","text":"","title":"1174. Immediate Food Delivery II $\\star\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1171-1180/#1175-prime-arrangements-star","text":"class Solution { public int numPrimeArrangements ( int n ) { final long kMod = ( long ) 1e9 + 7 ; int count = countPrimes ( n ); return ( int ) (( factorial ( count , kMod ) * factorial ( n - count , kMod )) % kMod ); } private int countPrimes ( int n ) { boolean [] prime = new boolean [ n + 1 ] ; Arrays . fill ( prime , 2 , n + 1 , true ); for ( int i = 0 ; i * i <= n ; ++ i ) if ( prime [ i ] ) for ( int j = i * i ; j <= n ; j += i ) prime [ j ] = false ; int count = 0 ; for ( boolean p : prime ) if ( p ) ++ count ; return count ; } long factorial ( int n , final long kMod ) { long fact = 1 ; for ( int i = 1 ; i <= n ; ++ i ) fact = fact * i % kMod ; return fact ; } }","title":"1175. Prime Arrangements $\\star$"},{"location":"java/1101-1200/1171-1180/#1176-diet-plan-performance-star","text":"","title":"1176. Diet Plan Performance $\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1171-1180/#1177-can-make-palindrome-from-substring-starstar","text":"class Solution { public List < Boolean > canMakePaliQueries ( String s , int [][] queries ) { List < Boolean > ans = new ArrayList <> (); int [] dp = new int [ s . length () + 1 ] ; for ( int i = 1 ; i <= s . length (); ++ i ) dp [ i ] = dp [ i - 1 ] ^ ( 1 << s . charAt ( i - 1 ) - 'a' ); for ( int [] query : queries ) { int odds = Integer . bitCount ( dp [ query [ 1 ] + 1 ] ^ dp [ query [ 0 ]] ); ans . add ( odds / 2 <= query [ 2 ] ); } return ans ; } }","title":"1177. Can Make Palindrome from Substring $\\star\\star$"},{"location":"java/1101-1200/1171-1180/#1178-number-of-valid-words-for-each-puzzle-starstarstar","text":"class Solution { public List < Integer > findNumOfValidWords ( String [] words , String [] puzzles ) { List < Integer > ans = new ArrayList <> (); Map < Integer , Integer > binaryCount = new HashMap <> (); for ( final String word : words ) { int mask = 0 ; for ( char c : word . toCharArray ()) mask |= 1 << ( c - 'a' ); binaryCount . put ( mask , binaryCount . getOrDefault ( mask , 0 ) + 1 ); } for ( final String puzzle : puzzles ) { int valid = 0 ; final int n = puzzle . length () - 1 ; for ( int i = 0 ; i < ( 1 << n ); ++ i ) { int mask = 1 << ( puzzle . charAt ( 0 ) - 'a' ); for ( int j = 0 ; j < n ; ++ j ) if (( i & ( 1 << j )) > 0 ) mask |= 1 << ( puzzle . charAt ( j + 1 ) - 'a' ); if ( binaryCount . containsKey ( mask )) valid += binaryCount . get ( mask ); } ans . add ( valid ); } return ans ; } }","title":"1178. Number of Valid Words for Each Puzzle $\\star\\star\\star$"},{"location":"java/1101-1200/1171-1180/#1179-reformat-department-table-star","text":"","title":"1179. Reformat Department Table $\\star$"},{"location":"java/1101-1200/1171-1180/#1180-count-substrings-with-only-one-distinct-letter-star","text":"","title":"1180. Count Substrings with Only One Distinct Letter $\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1181-1190/","text":"1181. Before and After Puzzle $\\star\\star$ \ud83d\udd12 1182. Shortest Distance to Target Color $\\star\\star$ \ud83d\udd12 1183. Maximum Number of Ones $\\star\\star\\star$ \ud83d\udd12 1184. Distance Between Bus Stops $\\star$ class Solution { public int distanceBetweenBusStops ( int [] distance , int start , int destination ) { int clockwise = 0 ; int counterclockwise = 0 ; if ( start > destination ) { int temp = start ; start = destination ; destination = temp ; } for ( int i = 0 ; i < distance . length ; ++ i ) { if ( i >= start && i < destination ) clockwise += distance [ i ] ; else counterclockwise += distance [ i ] ; } return Math . min ( clockwise , counterclockwise ); } } 1185. Day of the Week $\\star$ class Solution { public String dayOfTheWeek ( int day , int month , int year ) { String [] week = { \"Sunday\" , \"Monday\" , \"Tuesday\" , \"Wednesday\" , \"Thursday\" , \"Friday\" , \"Saturday\" }; int [] days = { 31 , isLeapYear ( year ) ? 29 : 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 }; int count = 0 ; for ( int i = 1971 ; i < year ; ++ i ) count += i % 4 == 0 ? 366 : 365 ; for ( int i = 0 ; i < month - 1 ; ++ i ) count += days [ i ] ; count += day ; return week [ ( count + 4 ) % 7 ] ; } private boolean isLeapYear ( int year ) { return ( year % 4 == 0 && year % 100 != 0 ) || year % 400 == 0 ; } } 1186. Maximum Subarray Sum with One Deletion $\\star\\star$ 1187. Make Array Strictly Increasing $\\star\\star\\star$ 1188. Design Bounded Blocking Queue $\\star\\star$ \ud83d\udd12 1189. Maximum Number of Balloons $\\star$ class Solution { public int maxNumberOfBalloons ( String text ) { int ans = Integer . MAX_VALUE ; int [] count = new int [ 26 ] ; for ( char c : text . toCharArray ()) ++ count [ c - 'a' ] ; for ( char c : new char [] { 'b' , 'a' , 'n' }) ans = Math . min ( ans , count [ c - 'a' ] ); for ( char c : new char [] { 'o' , 'l' }) ans = Math . min ( ans , count [ c - 'a' ] / 2 ); return ans ; } } 1190. Reverse Substrings Between Each Pair of Parentheses $\\star\\star$","title":"1181-1190"},{"location":"java/1101-1200/1181-1190/#1181-before-and-after-puzzle-starstar","text":"","title":"1181. Before and After Puzzle $\\star\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1181-1190/#1182-shortest-distance-to-target-color-starstar","text":"","title":"1182. Shortest Distance to Target Color $\\star\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1181-1190/#1183-maximum-number-of-ones-starstarstar","text":"","title":"1183. Maximum Number of Ones $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1181-1190/#1184-distance-between-bus-stops-star","text":"class Solution { public int distanceBetweenBusStops ( int [] distance , int start , int destination ) { int clockwise = 0 ; int counterclockwise = 0 ; if ( start > destination ) { int temp = start ; start = destination ; destination = temp ; } for ( int i = 0 ; i < distance . length ; ++ i ) { if ( i >= start && i < destination ) clockwise += distance [ i ] ; else counterclockwise += distance [ i ] ; } return Math . min ( clockwise , counterclockwise ); } }","title":"1184. Distance Between Bus Stops $\\star$"},{"location":"java/1101-1200/1181-1190/#1185-day-of-the-week-star","text":"class Solution { public String dayOfTheWeek ( int day , int month , int year ) { String [] week = { \"Sunday\" , \"Monday\" , \"Tuesday\" , \"Wednesday\" , \"Thursday\" , \"Friday\" , \"Saturday\" }; int [] days = { 31 , isLeapYear ( year ) ? 29 : 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 }; int count = 0 ; for ( int i = 1971 ; i < year ; ++ i ) count += i % 4 == 0 ? 366 : 365 ; for ( int i = 0 ; i < month - 1 ; ++ i ) count += days [ i ] ; count += day ; return week [ ( count + 4 ) % 7 ] ; } private boolean isLeapYear ( int year ) { return ( year % 4 == 0 && year % 100 != 0 ) || year % 400 == 0 ; } }","title":"1185. Day of the Week $\\star$"},{"location":"java/1101-1200/1181-1190/#1186-maximum-subarray-sum-with-one-deletion-starstar","text":"","title":"1186. Maximum Subarray Sum with One Deletion $\\star\\star$"},{"location":"java/1101-1200/1181-1190/#1187-make-array-strictly-increasing-starstarstar","text":"","title":"1187. Make Array Strictly Increasing $\\star\\star\\star$"},{"location":"java/1101-1200/1181-1190/#1188-design-bounded-blocking-queue-starstar","text":"","title":"1188. Design Bounded Blocking Queue $\\star\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1181-1190/#1189-maximum-number-of-balloons-star","text":"class Solution { public int maxNumberOfBalloons ( String text ) { int ans = Integer . MAX_VALUE ; int [] count = new int [ 26 ] ; for ( char c : text . toCharArray ()) ++ count [ c - 'a' ] ; for ( char c : new char [] { 'b' , 'a' , 'n' }) ans = Math . min ( ans , count [ c - 'a' ] ); for ( char c : new char [] { 'o' , 'l' }) ans = Math . min ( ans , count [ c - 'a' ] / 2 ); return ans ; } }","title":"1189. Maximum Number of Balloons $\\star$"},{"location":"java/1101-1200/1181-1190/#1190-reverse-substrings-between-each-pair-of-parentheses-starstar","text":"","title":"1190. Reverse Substrings Between Each Pair of Parentheses $\\star\\star$"},{"location":"java/1101-1200/1191-1200/","text":"1191. K-Concatenation Maximum Sum $\\star\\star$ 1192. Critical Connections in a Network $\\star\\star\\star$ 1193. Monthly Transactions I $\\star\\star$ \ud83d\udd12 1194. Tournament Winners $\\star\\star\\star$ \ud83d\udd12 1195. Fizz Buzz Multithreaded $\\star\\star$ 1196. How Many Apples Can You Put into the Basket $\\star$ \ud83d\udd12 1197. Minimum Knight Moves $\\star\\star$ \ud83d\udd12 1198. Find Smallest Common Element in All Rows $\\star\\star$ \ud83d\udd12 1199. Minimum Time to Build Blocks $\\star\\star\\star$ \ud83d\udd12 1200. Minimum Absolute Difference $\\star$ class Solution { public List < List < Integer >> minimumAbsDifference ( int [] arr ) { List < List < Integer >> ans = new ArrayList <> (); int min = Integer . MAX_VALUE ; Arrays . sort ( arr ); for ( int i = 0 ; i + 1 < arr . length ; ++ i ) { int diff = arr [ i + 1 ] - arr [ i ] ; if ( diff < min ) { min = diff ; ans . clear (); } if ( diff == min ) ans . add ( Arrays . asList ( arr [ i ] , arr [ i + 1 ] )); } return ans ; } }","title":"1191-1200"},{"location":"java/1101-1200/1191-1200/#1191-k-concatenation-maximum-sum-starstar","text":"","title":"1191. K-Concatenation Maximum Sum $\\star\\star$"},{"location":"java/1101-1200/1191-1200/#1192-critical-connections-in-a-network-starstarstar","text":"","title":"1192. Critical Connections in a Network $\\star\\star\\star$"},{"location":"java/1101-1200/1191-1200/#1193-monthly-transactions-i-starstar","text":"","title":"1193. Monthly Transactions I $\\star\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1191-1200/#1194-tournament-winners-starstarstar","text":"","title":"1194. Tournament Winners $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1191-1200/#1195-fizz-buzz-multithreaded-starstar","text":"","title":"1195. Fizz Buzz Multithreaded $\\star\\star$"},{"location":"java/1101-1200/1191-1200/#1196-how-many-apples-can-you-put-into-the-basket-star","text":"","title":"1196. How Many Apples Can You Put into the Basket $\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1191-1200/#1197-minimum-knight-moves-starstar","text":"","title":"1197. Minimum Knight Moves $\\star\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1191-1200/#1198-find-smallest-common-element-in-all-rows-starstar","text":"","title":"1198. Find Smallest Common Element in All Rows $\\star\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1191-1200/#1199-minimum-time-to-build-blocks-starstarstar","text":"","title":"1199. Minimum Time to Build Blocks $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/1101-1200/1191-1200/#1200-minimum-absolute-difference-star","text":"class Solution { public List < List < Integer >> minimumAbsDifference ( int [] arr ) { List < List < Integer >> ans = new ArrayList <> (); int min = Integer . MAX_VALUE ; Arrays . sort ( arr ); for ( int i = 0 ; i + 1 < arr . length ; ++ i ) { int diff = arr [ i + 1 ] - arr [ i ] ; if ( diff < min ) { min = diff ; ans . clear (); } if ( diff == min ) ans . add ( Arrays . asList ( arr [ i ] , arr [ i + 1 ] )); } return ans ; } }","title":"1200. Minimum Absolute Difference $\\star$"},{"location":"java/1201-1300/1201-1210/","text":"1201. Ugly Number III $\\star\\star$ class Solution { public int nthUglyNumber ( int n , long a , long b , long c ) { long ab = a * b / gcd ( a , b ); long ac = a * c / gcd ( a , c ); long bc = b * c / gcd ( b , c ); long abc = a * bc / gcd ( a , bc ); int l = 1 ; int r = 2 * ( int ) 1e9 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( m / a + m / b + m / c - m / ab - m / ac - m / bc + m / abc < n ) l = m + 1 ; else r = m ; } return l ; } private long gcd ( long a , long b ) { return b == 0 ? a : gcd ( b , a % b ); } } 1202. Smallest String With Swaps $\\star\\star$ class Solution { public String smallestStringWithSwaps ( String s , List < List < Integer >> pairs ) { StringBuilder ans = new StringBuilder (); UF uf = new UF ( s . length ()); Map < Integer , PriorityQueue < Character >> map = new HashMap <> (); for ( List < Integer > pair : pairs ) uf . union ( pair . get ( 0 ), pair . get ( 1 )); for ( int i = 0 ; i < s . length (); ++ i ) map . computeIfAbsent ( uf . find ( i ), k -> new PriorityQueue <> ()). offer ( s . charAt ( i )); for ( int i = 0 ; i < s . length (); ++ i ) ans . append ( map . get ( uf . find ( i )). poll ()); return ans . toString (); } private class UF { private int [] size ; private int [] id ; private UF ( int n ) { size = new int [ n ] ; id = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) { size [ i ] = 1 ; id [ i ] = i ; } } private void union ( int p , int q ) { int i = find ( p ); int j = find ( q ); if ( i == j ) return ; if ( size [ i ] < size [ j ] ) { id [ i ] = j ; size [ j ] += size [ i ] ; } else { id [ j ] = i ; size [ i ] += size [ j ] ; } } private int find ( int i ) { while ( i != id [ i ] ) { id [ i ] = id [ id [ i ]] ; i = id [ i ] ; } return i ; } } } 1203. Sort Items by Groups Respecting Dependencies $\\star\\star\\star$ 1204. Last Person to Fit in the Elevator $\\star\\star$ \ud83d\udd12 1205. Monthly Transactions II $\\star\\star$ \ud83d\udd12 1206. Design Skiplist $\\star\\star\\star$ 1207. Unique Number of Occurrences $\\star$ class Solution { public boolean uniqueOccurrences ( int [] arr ) { Map < Integer , Integer > count = new HashMap <> (); Set < Integer > occurrences = new HashSet <> (); for ( int a : arr ) count . put ( a , count . getOrDefault ( a , 0 ) + 1 ); for ( int value : count . values ()) if ( ! occurrences . add ( value )) return false ; return true ; } } 1208. Get Equal Substrings Within Budget $\\star\\star$ class Solution { public int equalSubstring ( String s , String t , int maxCost ) { int j = 0 ; for ( int i = 0 ; i < s . length (); ++ i ) { maxCost -= Math . abs ( s . charAt ( i ) - t . charAt ( i )); if ( maxCost < 0 ) maxCost += Math . abs ( s . charAt ( j ) - t . charAt ( j ++ )); } return s . length () - j ; } } 1209. Remove All Adjacent Duplicates in String II $\\star\\star$ 1210. Minimum Moves to Reach Target with Rotations $\\star\\star\\star$","title":"1201-1210"},{"location":"java/1201-1300/1201-1210/#1201-ugly-number-iii-starstar","text":"class Solution { public int nthUglyNumber ( int n , long a , long b , long c ) { long ab = a * b / gcd ( a , b ); long ac = a * c / gcd ( a , c ); long bc = b * c / gcd ( b , c ); long abc = a * bc / gcd ( a , bc ); int l = 1 ; int r = 2 * ( int ) 1e9 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( m / a + m / b + m / c - m / ab - m / ac - m / bc + m / abc < n ) l = m + 1 ; else r = m ; } return l ; } private long gcd ( long a , long b ) { return b == 0 ? a : gcd ( b , a % b ); } }","title":"1201. Ugly Number III $\\star\\star$"},{"location":"java/1201-1300/1201-1210/#1202-smallest-string-with-swaps-starstar","text":"class Solution { public String smallestStringWithSwaps ( String s , List < List < Integer >> pairs ) { StringBuilder ans = new StringBuilder (); UF uf = new UF ( s . length ()); Map < Integer , PriorityQueue < Character >> map = new HashMap <> (); for ( List < Integer > pair : pairs ) uf . union ( pair . get ( 0 ), pair . get ( 1 )); for ( int i = 0 ; i < s . length (); ++ i ) map . computeIfAbsent ( uf . find ( i ), k -> new PriorityQueue <> ()). offer ( s . charAt ( i )); for ( int i = 0 ; i < s . length (); ++ i ) ans . append ( map . get ( uf . find ( i )). poll ()); return ans . toString (); } private class UF { private int [] size ; private int [] id ; private UF ( int n ) { size = new int [ n ] ; id = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) { size [ i ] = 1 ; id [ i ] = i ; } } private void union ( int p , int q ) { int i = find ( p ); int j = find ( q ); if ( i == j ) return ; if ( size [ i ] < size [ j ] ) { id [ i ] = j ; size [ j ] += size [ i ] ; } else { id [ j ] = i ; size [ i ] += size [ j ] ; } } private int find ( int i ) { while ( i != id [ i ] ) { id [ i ] = id [ id [ i ]] ; i = id [ i ] ; } return i ; } } }","title":"1202. Smallest String With Swaps $\\star\\star$"},{"location":"java/1201-1300/1201-1210/#1203-sort-items-by-groups-respecting-dependencies-starstarstar","text":"","title":"1203. Sort Items by Groups Respecting Dependencies $\\star\\star\\star$"},{"location":"java/1201-1300/1201-1210/#1204-last-person-to-fit-in-the-elevator-starstar","text":"","title":"1204. Last Person to Fit in the Elevator $\\star\\star$ \ud83d\udd12"},{"location":"java/1201-1300/1201-1210/#1205-monthly-transactions-ii-starstar","text":"","title":"1205. Monthly Transactions II $\\star\\star$ \ud83d\udd12"},{"location":"java/1201-1300/1201-1210/#1206-design-skiplist-starstarstar","text":"","title":"1206. Design Skiplist $\\star\\star\\star$"},{"location":"java/1201-1300/1201-1210/#1207-unique-number-of-occurrences-star","text":"class Solution { public boolean uniqueOccurrences ( int [] arr ) { Map < Integer , Integer > count = new HashMap <> (); Set < Integer > occurrences = new HashSet <> (); for ( int a : arr ) count . put ( a , count . getOrDefault ( a , 0 ) + 1 ); for ( int value : count . values ()) if ( ! occurrences . add ( value )) return false ; return true ; } }","title":"1207. Unique Number of Occurrences $\\star$"},{"location":"java/1201-1300/1201-1210/#1208-get-equal-substrings-within-budget-starstar","text":"class Solution { public int equalSubstring ( String s , String t , int maxCost ) { int j = 0 ; for ( int i = 0 ; i < s . length (); ++ i ) { maxCost -= Math . abs ( s . charAt ( i ) - t . charAt ( i )); if ( maxCost < 0 ) maxCost += Math . abs ( s . charAt ( j ) - t . charAt ( j ++ )); } return s . length () - j ; } }","title":"1208. Get Equal Substrings Within Budget $\\star\\star$"},{"location":"java/1201-1300/1201-1210/#1209-remove-all-adjacent-duplicates-in-string-ii-starstar","text":"","title":"1209. Remove All Adjacent Duplicates in String II $\\star\\star$"},{"location":"java/1201-1300/1201-1210/#1210-minimum-moves-to-reach-target-with-rotations-starstarstar","text":"","title":"1210. Minimum Moves to Reach Target with Rotations $\\star\\star\\star$"},{"location":"java/1201-1300/1211-1220/","text":"1211. Queries Quality and Percentage $\\star$ \ud83d\udd12 1212. Team Scores in Football Tournament $\\star\\star$ \ud83d\udd12 1213. Intersection of Three Sorted Arrays $\\star$ \ud83d\udd12 1214. Two Sum BSTs $\\star\\star$ \ud83d\udd12 1215. Stepping Numbers $\\star\\star$ \ud83d\udd12 1216. Valid Palindrome III $\\star\\star\\star$ \ud83d\udd12 1217. Play with Chips $\\star$ class Solution { public int minCostToMoveChips ( int [] chips ) { int [] count = new int [ 2 ] ; for ( int chip : chips ) ++ count [ chip % 2 ] ; return Math . min ( count [ 0 ] , count [ 1 ] ); } } 1218. Longest Arithmetic Subsequence of Given Difference $\\star\\star$ class Solution { public int longestSubsequence ( int [] arr , int difference ) { int ans = 0 ; Map < Integer , Integer > lengthAt = new HashMap <> (); for ( int a : arr ) { lengthAt . put ( a , lengthAt . getOrDefault ( a - difference , 0 ) + 1 ); ans = Math . max ( ans , lengthAt . get ( a )); } return ans ; } } 1219. Path with Maximum Gold $\\star\\star$ 1220. Count Vowels Permutation $\\star\\star\\star$","title":"1211-1220"},{"location":"java/1201-1300/1211-1220/#1211-queries-quality-and-percentage-star","text":"","title":"1211. Queries Quality and Percentage $\\star$ \ud83d\udd12"},{"location":"java/1201-1300/1211-1220/#1212-team-scores-in-football-tournament-starstar","text":"","title":"1212. Team Scores in Football Tournament $\\star\\star$ \ud83d\udd12"},{"location":"java/1201-1300/1211-1220/#1213-intersection-of-three-sorted-arrays-star","text":"","title":"1213. Intersection of Three Sorted Arrays $\\star$ \ud83d\udd12"},{"location":"java/1201-1300/1211-1220/#1214-two-sum-bsts-starstar","text":"","title":"1214. Two Sum BSTs $\\star\\star$ \ud83d\udd12"},{"location":"java/1201-1300/1211-1220/#1215-stepping-numbers-starstar","text":"","title":"1215. Stepping Numbers $\\star\\star$ \ud83d\udd12"},{"location":"java/1201-1300/1211-1220/#1216-valid-palindrome-iii-starstarstar","text":"","title":"1216. Valid Palindrome III $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/1201-1300/1211-1220/#1217-play-with-chips-star","text":"class Solution { public int minCostToMoveChips ( int [] chips ) { int [] count = new int [ 2 ] ; for ( int chip : chips ) ++ count [ chip % 2 ] ; return Math . min ( count [ 0 ] , count [ 1 ] ); } }","title":"1217. Play with Chips $\\star$"},{"location":"java/1201-1300/1211-1220/#1218-longest-arithmetic-subsequence-of-given-difference-starstar","text":"class Solution { public int longestSubsequence ( int [] arr , int difference ) { int ans = 0 ; Map < Integer , Integer > lengthAt = new HashMap <> (); for ( int a : arr ) { lengthAt . put ( a , lengthAt . getOrDefault ( a - difference , 0 ) + 1 ); ans = Math . max ( ans , lengthAt . get ( a )); } return ans ; } }","title":"1218. Longest Arithmetic Subsequence of Given Difference $\\star\\star$"},{"location":"java/1201-1300/1211-1220/#1219-path-with-maximum-gold-starstar","text":"","title":"1219. Path with Maximum Gold $\\star\\star$"},{"location":"java/1201-1300/1211-1220/#1220-count-vowels-permutation-starstarstar","text":"","title":"1220. Count Vowels Permutation $\\star\\star\\star$"},{"location":"java/1201-1300/1221-1230/","text":"1221. Split a String in Balanced Strings $\\star$ 1222. Queens That Can Attack the King $\\star\\star$ class Solution { public List < List < Integer >> queensAttacktheKing ( int [][] queens , int [] king ) { List < List < Integer >> ans = new ArrayList <> (); Set < Integer > queensSet = new HashSet <> (); for ( int [] queen : queens ) queensSet . add ( hash ( queen [ 0 ] , queen [ 1 ] )); int [][] directions = new int [][] { { - 1 , - 1 }, { - 1 , 0 }, { - 1 , 1 }, { 0 , - 1 }, { 0 , 1 }, { 1 , - 1 }, { 1 , 0 }, { 1 , 1 } }; for ( int [] d : directions ) for ( int i = king [ 0 ] + d [ 0 ] , j = king [ 1 ] + d [ 1 ] ; 0 <= i && i < 8 && 0 <= j && j < 8 ; i += d [ 0 ] , j += d [ 1 ] ) if ( queensSet . contains ( hash ( i , j ))) { ans . add ( Arrays . asList ( i , j )); break ; } return ans ; } private int hash ( int i , int j ) { return i * 8 + j ; } } 1223. Dice Roll Simulation $\\star\\star$ 1224. Maximum Equal Frequency $\\star\\star\\star$ class Solution { public int maxEqualFreq ( int [] nums ) { int ans = 0 ; int maxFreq = 0 ; Map < Integer , Integer > count = new HashMap <> (); Map < Integer , Integer > freq = new HashMap <> (); for ( int i = 0 ; i < nums . length ; ++ i ) { int currentFreq = count . getOrDefault ( nums [ i ] , 0 ); freq . put ( currentFreq , freq . getOrDefault ( currentFreq , 0 ) - 1 ); int updatedFreq = currentFreq + 1 ; count . put ( nums [ i ] , updatedFreq ); freq . put ( updatedFreq , freq . getOrDefault ( updatedFreq , 0 ) + 1 ); maxFreq = Math . max ( maxFreq , updatedFreq ); if ( maxFreq == 1 || maxFreq * freq . get ( maxFreq ) == i || ( maxFreq - 1 ) * ( freq . get ( maxFreq - 1 ) + 1 ) == i ) ans = i + 1 ; } return ans ; } } 1225. Report Contiguous Dates $\\star\\star\\star$ \ud83d\udd12 1226. The Dining Philosophers $\\star\\star$ 1227. Airplane Seat Assignment Probability $\\star\\star$ class Solution { public double nthPersonGetsNthSeat ( int n ) { return n == 1 ? 1 : 0.5 ; } } 1228. Missing Number In Arithmetic Progression $\\star$ \ud83d\udd12 1229. Meeting Scheduler $\\star\\star$ \ud83d\udd12 1230. Toss Strange Coins $\\star\\star$ \ud83d\udd12","title":"1221-1230"},{"location":"java/1201-1300/1221-1230/#1221-split-a-string-in-balanced-strings-star","text":"","title":"1221. Split a String in Balanced Strings $\\star$"},{"location":"java/1201-1300/1221-1230/#1222-queens-that-can-attack-the-king-starstar","text":"class Solution { public List < List < Integer >> queensAttacktheKing ( int [][] queens , int [] king ) { List < List < Integer >> ans = new ArrayList <> (); Set < Integer > queensSet = new HashSet <> (); for ( int [] queen : queens ) queensSet . add ( hash ( queen [ 0 ] , queen [ 1 ] )); int [][] directions = new int [][] { { - 1 , - 1 }, { - 1 , 0 }, { - 1 , 1 }, { 0 , - 1 }, { 0 , 1 }, { 1 , - 1 }, { 1 , 0 }, { 1 , 1 } }; for ( int [] d : directions ) for ( int i = king [ 0 ] + d [ 0 ] , j = king [ 1 ] + d [ 1 ] ; 0 <= i && i < 8 && 0 <= j && j < 8 ; i += d [ 0 ] , j += d [ 1 ] ) if ( queensSet . contains ( hash ( i , j ))) { ans . add ( Arrays . asList ( i , j )); break ; } return ans ; } private int hash ( int i , int j ) { return i * 8 + j ; } }","title":"1222. Queens That Can Attack the King $\\star\\star$"},{"location":"java/1201-1300/1221-1230/#1223-dice-roll-simulation-starstar","text":"","title":"1223. Dice Roll Simulation $\\star\\star$"},{"location":"java/1201-1300/1221-1230/#1224-maximum-equal-frequency-starstarstar","text":"class Solution { public int maxEqualFreq ( int [] nums ) { int ans = 0 ; int maxFreq = 0 ; Map < Integer , Integer > count = new HashMap <> (); Map < Integer , Integer > freq = new HashMap <> (); for ( int i = 0 ; i < nums . length ; ++ i ) { int currentFreq = count . getOrDefault ( nums [ i ] , 0 ); freq . put ( currentFreq , freq . getOrDefault ( currentFreq , 0 ) - 1 ); int updatedFreq = currentFreq + 1 ; count . put ( nums [ i ] , updatedFreq ); freq . put ( updatedFreq , freq . getOrDefault ( updatedFreq , 0 ) + 1 ); maxFreq = Math . max ( maxFreq , updatedFreq ); if ( maxFreq == 1 || maxFreq * freq . get ( maxFreq ) == i || ( maxFreq - 1 ) * ( freq . get ( maxFreq - 1 ) + 1 ) == i ) ans = i + 1 ; } return ans ; } }","title":"1224. Maximum Equal Frequency $\\star\\star\\star$"},{"location":"java/1201-1300/1221-1230/#1225-report-contiguous-dates-starstarstar","text":"","title":"1225. Report Contiguous Dates $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/1201-1300/1221-1230/#1226-the-dining-philosophers-starstar","text":"","title":"1226. The Dining Philosophers $\\star\\star$"},{"location":"java/1201-1300/1221-1230/#1227-airplane-seat-assignment-probability-starstar","text":"class Solution { public double nthPersonGetsNthSeat ( int n ) { return n == 1 ? 1 : 0.5 ; } }","title":"1227. Airplane Seat Assignment Probability $\\star\\star$"},{"location":"java/1201-1300/1221-1230/#1228-missing-number-in-arithmetic-progression-star","text":"","title":"1228. Missing Number In Arithmetic Progression $\\star$ \ud83d\udd12"},{"location":"java/1201-1300/1221-1230/#1229-meeting-scheduler-starstar","text":"","title":"1229. Meeting Scheduler $\\star\\star$ \ud83d\udd12"},{"location":"java/1201-1300/1221-1230/#1230-toss-strange-coins-starstar","text":"","title":"1230. Toss Strange Coins $\\star\\star$ \ud83d\udd12"},{"location":"java/1201-1300/1231-1240/","text":"1231. Divide Chocolate $\\star\\star\\star$ \ud83d\udd12 1232. Check If It Is a Straight Line $\\star$ class Solution { public boolean checkStraightLine ( int [][] coordinates ) { int x0 = coordinates [ 0 ][ 0 ] ; int y0 = coordinates [ 0 ][ 1 ] ; int x1 = coordinates [ 1 ][ 0 ] ; int y1 = coordinates [ 1 ][ 1 ] ; int dx = x1 - x0 ; int dy = y1 - y0 ; for ( int i = 2 ; i < coordinates . length ; ++ i ) { int x = coordinates [ i ][ 0 ] ; int y = coordinates [ i ][ 1 ] ; if (( x - x0 ) * dy != ( y - y0 ) * dx ) return false ; } return true ; } } 1233. Remove Sub-Folders from the Filesystem $\\star\\star$ class Solution { public List < String > removeSubfolders ( String [] folder ) { List < String > ans = new ArrayList <> (); String prev = \"\" ; Arrays . sort ( folder ); for ( String f : folder ) { if ( prev . length () > 0 && f . startsWith ( prev ) && f . charAt ( prev . length ()) == '/' ) continue ; ans . add ( f ); prev = f ; } return ans ; } } 1234. Replace the Substring for Balanced String $\\star\\star$ class Solution { public int balancedString ( String s ) { final int n = s . length (); final int k = n / 4 ; int ans = n ; int [] count = new int [ 128 ] ; for ( char c : s . toCharArray ()) ++ count [ c ] ; for ( int i = 0 , j = 0 ; i < n ; ++ i ) { -- count [ s . charAt ( i ) ] ; while ( j < n && count [ 'Q' ] <= k && count [ 'W' ] <= k && count [ 'E' ] <= k && count [ 'R' ] <= k ) { ans = Math . min ( ans , i - j + 1 ); ++ count [ s . charAt ( j ) ] ; ++ j ; } } return ans ; } } 1235. Maximum Profit in Job Scheduling $\\star\\star\\star$ 1236. Web Crawler $\\star\\star$ \ud83d\udd12 1237. Find Positive Integer Solution for a Given Equation $\\star$ class Solution { public List < List < Integer >> findSolution ( CustomFunction customfunction , int z ) { List < List < Integer >> ans = new LinkedList <> (); int x = 1 ; int y = 1000 ; while ( x <= 1000 && y >= 1 ) { int f = customfunction . f ( x , y ); if ( f < z ) ++ x ; else if ( f > z ) -- y ; else ans . add ( Arrays . asList ( x ++ , y -- )); } return ans ; } } 1238. Circular Permutation in Binary Representation $\\star\\star$ class Solution { public List < Integer > circularPermutation ( int n , int start ) { List < Integer > ans = new ArrayList <> (); for ( int i = 0 ; i < 1 << n ; ++ i ) ans . add ( start ^ i ^ i >> 1 ); return ans ; } } 1239. Maximum Length of a Concatenated String with Unique Characters $\\star\\star$ 1240. Tiling a Rectangle with the Fewest Squares $\\star\\star\\star$","title":"1231-1240"},{"location":"java/1201-1300/1231-1240/#1231-divide-chocolate-starstarstar","text":"","title":"1231. Divide Chocolate $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/1201-1300/1231-1240/#1232-check-if-it-is-a-straight-line-star","text":"class Solution { public boolean checkStraightLine ( int [][] coordinates ) { int x0 = coordinates [ 0 ][ 0 ] ; int y0 = coordinates [ 0 ][ 1 ] ; int x1 = coordinates [ 1 ][ 0 ] ; int y1 = coordinates [ 1 ][ 1 ] ; int dx = x1 - x0 ; int dy = y1 - y0 ; for ( int i = 2 ; i < coordinates . length ; ++ i ) { int x = coordinates [ i ][ 0 ] ; int y = coordinates [ i ][ 1 ] ; if (( x - x0 ) * dy != ( y - y0 ) * dx ) return false ; } return true ; } }","title":"1232. Check If It Is a Straight Line $\\star$"},{"location":"java/1201-1300/1231-1240/#1233-remove-sub-folders-from-the-filesystem-starstar","text":"class Solution { public List < String > removeSubfolders ( String [] folder ) { List < String > ans = new ArrayList <> (); String prev = \"\" ; Arrays . sort ( folder ); for ( String f : folder ) { if ( prev . length () > 0 && f . startsWith ( prev ) && f . charAt ( prev . length ()) == '/' ) continue ; ans . add ( f ); prev = f ; } return ans ; } }","title":"1233. Remove Sub-Folders from the Filesystem $\\star\\star$"},{"location":"java/1201-1300/1231-1240/#1234-replace-the-substring-for-balanced-string-starstar","text":"class Solution { public int balancedString ( String s ) { final int n = s . length (); final int k = n / 4 ; int ans = n ; int [] count = new int [ 128 ] ; for ( char c : s . toCharArray ()) ++ count [ c ] ; for ( int i = 0 , j = 0 ; i < n ; ++ i ) { -- count [ s . charAt ( i ) ] ; while ( j < n && count [ 'Q' ] <= k && count [ 'W' ] <= k && count [ 'E' ] <= k && count [ 'R' ] <= k ) { ans = Math . min ( ans , i - j + 1 ); ++ count [ s . charAt ( j ) ] ; ++ j ; } } return ans ; } }","title":"1234. Replace the Substring for Balanced String $\\star\\star$"},{"location":"java/1201-1300/1231-1240/#1235-maximum-profit-in-job-scheduling-starstarstar","text":"","title":"1235. Maximum Profit in Job Scheduling $\\star\\star\\star$"},{"location":"java/1201-1300/1231-1240/#1236-web-crawler-starstar","text":"","title":"1236. Web Crawler $\\star\\star$ \ud83d\udd12"},{"location":"java/1201-1300/1231-1240/#1237-find-positive-integer-solution-for-a-given-equation-star","text":"class Solution { public List < List < Integer >> findSolution ( CustomFunction customfunction , int z ) { List < List < Integer >> ans = new LinkedList <> (); int x = 1 ; int y = 1000 ; while ( x <= 1000 && y >= 1 ) { int f = customfunction . f ( x , y ); if ( f < z ) ++ x ; else if ( f > z ) -- y ; else ans . add ( Arrays . asList ( x ++ , y -- )); } return ans ; } }","title":"1237. Find Positive Integer Solution for a Given Equation $\\star$"},{"location":"java/1201-1300/1231-1240/#1238-circular-permutation-in-binary-representation-starstar","text":"class Solution { public List < Integer > circularPermutation ( int n , int start ) { List < Integer > ans = new ArrayList <> (); for ( int i = 0 ; i < 1 << n ; ++ i ) ans . add ( start ^ i ^ i >> 1 ); return ans ; } }","title":"1238. Circular Permutation in Binary Representation $\\star\\star$"},{"location":"java/1201-1300/1231-1240/#1239-maximum-length-of-a-concatenated-string-with-unique-characters-starstar","text":"","title":"1239. Maximum Length of a Concatenated String with Unique Characters $\\star\\star$"},{"location":"java/1201-1300/1231-1240/#1240-tiling-a-rectangle-with-the-fewest-squares-starstarstar","text":"","title":"1240. Tiling a Rectangle with the Fewest Squares $\\star\\star\\star$"},{"location":"java/1201-1300/1241-1250/","text":"1241. Number of Comments per Post $\\star$ \ud83d\udd12 1242. Web Crawler Multithreaded $\\star\\star$ \ud83d\udd12 1243. Array Transformation $\\star$ \ud83d\udd12 1244. Design A Leaderboard $\\star\\star$ \ud83d\udd12 1245. Tree Diameter $\\star\\star$ \ud83d\udd12 1246. Palindrome Removal $\\star\\star\\star$ \ud83d\udd12 1247. Minimum Swaps to Make Strings Equal $\\star\\star$ 1248. Count Number of Nice Subarrays $\\star\\star$ class Solution { public int numberOfSubarrays ( int [] nums , int k ) { return numberOfSubarraysAtMost ( nums , k ) - numberOfSubarraysAtMost ( nums , k - 1 ); } private int numberOfSubarraysAtMost ( int [] nums , int k ) { int ans = 0 ; for ( int l = 0 , r = 0 ; r <= nums . length ;) if ( k >= 0 ) { ans += r - l ; if ( r == nums . length ) break ; if ( nums [ r ] % 2 == 1 ) -- k ; ++ r ; } else { if ( nums [ l ] % 2 == 1 ) ++ k ; ++ l ; } return ans ; } } 1249. Minimum Remove to Make Valid Parentheses $\\star\\star$ 1250. Check If It Is a Good Array $\\star\\star\\star$","title":"1241-1250"},{"location":"java/1201-1300/1241-1250/#1241-number-of-comments-per-post-star","text":"","title":"1241. Number of Comments per Post $\\star$ \ud83d\udd12"},{"location":"java/1201-1300/1241-1250/#1242-web-crawler-multithreaded-starstar","text":"","title":"1242. Web Crawler Multithreaded $\\star\\star$ \ud83d\udd12"},{"location":"java/1201-1300/1241-1250/#1243-array-transformation-star","text":"","title":"1243. Array Transformation $\\star$ \ud83d\udd12"},{"location":"java/1201-1300/1241-1250/#1244-design-a-leaderboard-starstar","text":"","title":"1244. Design A Leaderboard $\\star\\star$ \ud83d\udd12"},{"location":"java/1201-1300/1241-1250/#1245-tree-diameter-starstar","text":"","title":"1245. Tree Diameter $\\star\\star$ \ud83d\udd12"},{"location":"java/1201-1300/1241-1250/#1246-palindrome-removal-starstarstar","text":"","title":"1246. Palindrome Removal $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/1201-1300/1241-1250/#1247-minimum-swaps-to-make-strings-equal-starstar","text":"","title":"1247. Minimum Swaps to Make Strings Equal $\\star\\star$"},{"location":"java/1201-1300/1241-1250/#1248-count-number-of-nice-subarrays-starstar","text":"class Solution { public int numberOfSubarrays ( int [] nums , int k ) { return numberOfSubarraysAtMost ( nums , k ) - numberOfSubarraysAtMost ( nums , k - 1 ); } private int numberOfSubarraysAtMost ( int [] nums , int k ) { int ans = 0 ; for ( int l = 0 , r = 0 ; r <= nums . length ;) if ( k >= 0 ) { ans += r - l ; if ( r == nums . length ) break ; if ( nums [ r ] % 2 == 1 ) -- k ; ++ r ; } else { if ( nums [ l ] % 2 == 1 ) ++ k ; ++ l ; } return ans ; } }","title":"1248. Count Number of Nice Subarrays $\\star\\star$"},{"location":"java/1201-1300/1241-1250/#1249-minimum-remove-to-make-valid-parentheses-starstar","text":"","title":"1249. Minimum Remove to Make Valid Parentheses $\\star\\star$"},{"location":"java/1201-1300/1241-1250/#1250-check-if-it-is-a-good-array-starstarstar","text":"","title":"1250. Check If It Is a Good Array $\\star\\star\\star$"},{"location":"java/1201-1300/1251-1260/","text":"1251. Average Selling Price $\\star$ \ud83d\udd12 1252. Cells with Odd Values in a Matrix $\\star$ 1253. Reconstruct a 2-Row Binary Matrix $\\star\\star$ class Solution { public List < List < Integer >> reconstructMatrix ( int upper , int lower , int [] colsum ) { if ( upper + lower != Arrays . stream ( colsum ). sum ()) return new ArrayList <> (); int count = 0 ; for ( int c : colsum ) if ( c == 2 ) ++ count ; if ( Math . min ( upper , lower ) < count ) return new ArrayList <> (); int [][] ans = new int [ 2 ][ colsum . length ] ; for ( int j = 0 ; j < colsum . length ; ++ j ) if ( colsum [ j ] == 2 ) { ans [ 0 ][ j ] = 1 ; ans [ 1 ][ j ] = 1 ; -- upper ; -- lower ; } for ( int j = 0 ; j < colsum . length ; ++ j ) { if ( colsum [ j ] == 1 && upper > 0 ) { ans [ 0 ][ j ] = 1 ; -- colsum [ j ] ; -- upper ; } if ( colsum [ j ] == 1 && lower > 0 ) { ans [ 1 ][ j ] = 1 ; -- lower ; } } return new ArrayList ( Arrays . asList ( ans [ 0 ] , ans [ 1 ] )); } } 1254. Number of Closed Islands $\\star\\star$ 1255. Maximum Score Words Formed by Letters $\\star\\star\\star$ 1256. Encode Number $\\star\\star$ \ud83d\udd12 1257. Smallest Common Region $\\star\\star$ \ud83d\udd12 1258. Synonymous Sentences $\\star\\star$ \ud83d\udd12 1259. Handshakes That Don't Cross $\\star\\star\\star$ \ud83d\udd12 1260. Shift 2D Grid $\\star$ class Solution { public List < List < Integer >> shiftGrid ( int [][] grid , int k ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; List < List < Integer >> ans = new ArrayList <> (); int [][] arr = new int [ m ][ n ] ; k %= m * n ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int index = ( i * n + j + k ) % ( m * n ); int x = index / n ; int y = index % n ; arr [ x ][ y ] = grid [ i ][ j ] ; } for ( int [] row : arr ) ans . add ( Arrays . stream ( row ). boxed (). collect ( Collectors . toList ())); return ans ; } }","title":"1251-1260"},{"location":"java/1201-1300/1251-1260/#1251-average-selling-price-star","text":"","title":"1251. Average Selling Price $\\star$ \ud83d\udd12"},{"location":"java/1201-1300/1251-1260/#1252-cells-with-odd-values-in-a-matrix-star","text":"","title":"1252. Cells with Odd Values in a Matrix $\\star$"},{"location":"java/1201-1300/1251-1260/#1253-reconstruct-a-2-row-binary-matrix-starstar","text":"class Solution { public List < List < Integer >> reconstructMatrix ( int upper , int lower , int [] colsum ) { if ( upper + lower != Arrays . stream ( colsum ). sum ()) return new ArrayList <> (); int count = 0 ; for ( int c : colsum ) if ( c == 2 ) ++ count ; if ( Math . min ( upper , lower ) < count ) return new ArrayList <> (); int [][] ans = new int [ 2 ][ colsum . length ] ; for ( int j = 0 ; j < colsum . length ; ++ j ) if ( colsum [ j ] == 2 ) { ans [ 0 ][ j ] = 1 ; ans [ 1 ][ j ] = 1 ; -- upper ; -- lower ; } for ( int j = 0 ; j < colsum . length ; ++ j ) { if ( colsum [ j ] == 1 && upper > 0 ) { ans [ 0 ][ j ] = 1 ; -- colsum [ j ] ; -- upper ; } if ( colsum [ j ] == 1 && lower > 0 ) { ans [ 1 ][ j ] = 1 ; -- lower ; } } return new ArrayList ( Arrays . asList ( ans [ 0 ] , ans [ 1 ] )); } }","title":"1253. Reconstruct a 2-Row Binary Matrix $\\star\\star$"},{"location":"java/1201-1300/1251-1260/#1254-number-of-closed-islands-starstar","text":"","title":"1254. Number of Closed Islands $\\star\\star$"},{"location":"java/1201-1300/1251-1260/#1255-maximum-score-words-formed-by-letters-starstarstar","text":"","title":"1255. Maximum Score Words Formed by Letters $\\star\\star\\star$"},{"location":"java/1201-1300/1251-1260/#1256-encode-number-starstar","text":"","title":"1256. Encode Number $\\star\\star$ \ud83d\udd12"},{"location":"java/1201-1300/1251-1260/#1257-smallest-common-region-starstar","text":"","title":"1257. Smallest Common Region $\\star\\star$ \ud83d\udd12"},{"location":"java/1201-1300/1251-1260/#1258-synonymous-sentences-starstar","text":"","title":"1258. Synonymous Sentences $\\star\\star$ \ud83d\udd12"},{"location":"java/1201-1300/1251-1260/#1259-handshakes-that-dont-cross-starstarstar","text":"","title":"1259. Handshakes That Don't Cross $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/1201-1300/1251-1260/#1260-shift-2d-grid-star","text":"class Solution { public List < List < Integer >> shiftGrid ( int [][] grid , int k ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; List < List < Integer >> ans = new ArrayList <> (); int [][] arr = new int [ m ][ n ] ; k %= m * n ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int index = ( i * n + j + k ) % ( m * n ); int x = index / n ; int y = index % n ; arr [ x ][ y ] = grid [ i ][ j ] ; } for ( int [] row : arr ) ans . add ( Arrays . stream ( row ). boxed (). collect ( Collectors . toList ())); return ans ; } }","title":"1260. Shift 2D Grid $\\star$"},{"location":"java/1201-1300/1261-1270/","text":"1261. Find Elements in a Contaminated Binary Tree $\\star\\star$ class FindElements { public FindElements ( TreeNode root ) { dfs ( root , 0 ); } public boolean find ( int target ) { return vals . contains ( target ); } private Set < Integer > vals = new HashSet <> (); private void dfs ( TreeNode root , int val ) { if ( root == null ) return ; root . val = val ; vals . add ( val ); dfs ( root . left , val * 2 + 1 ); dfs ( root . right , val * 2 + 2 ); } } 1262. Greatest Sum Divisible by Three $\\star\\star$ 1263. Minimum Moves to Move a Box to Their Target Location $\\star\\star\\star$ 1264. Page Recommendations $\\star\\star$ \ud83d\udd12 1265. Print Immutable Linked List in Reverse $\\star\\star$ \ud83d\udd12 1266. Minimum Time Visiting All Points $\\star$ class Solution { public int minTimeToVisitAllPoints ( int [][] points ) { int ans = 0 ; for ( int i = 1 ; i < points . length ; ++ i ) ans += Math . max ( Math . abs ( points [ i ][ 0 ] - points [ i - 1 ][ 0 ] ), Math . abs ( points [ i ][ 1 ] - points [ i - 1 ][ 1 ] )); return ans ; } } 1267. Count Servers that Communicate $\\star\\star$ class Solution { public int countServers ( int [][] grid ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; int ans = 0 ; int [] rows = new int [ m ] ; int [] cols = new int [ n ] ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ][ j ] == 1 ) { ++ rows [ i ] ; ++ cols [ j ] ; } for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ][ j ] == 1 && ( rows [ i ] > 1 || cols [ j ] > 1 )) ++ ans ; return ans ; } } 1268. Search Suggestions System $\\star\\star$ 1269. Number of Ways to Stay in the Same Place After Some Steps $\\star\\star\\star$ 1270. All People Report to the Given Manager $\\star\\star$ \ud83d\udd12","title":"1261-1270"},{"location":"java/1201-1300/1261-1270/#1261-find-elements-in-a-contaminated-binary-tree-starstar","text":"class FindElements { public FindElements ( TreeNode root ) { dfs ( root , 0 ); } public boolean find ( int target ) { return vals . contains ( target ); } private Set < Integer > vals = new HashSet <> (); private void dfs ( TreeNode root , int val ) { if ( root == null ) return ; root . val = val ; vals . add ( val ); dfs ( root . left , val * 2 + 1 ); dfs ( root . right , val * 2 + 2 ); } }","title":"1261. Find Elements in a Contaminated Binary Tree $\\star\\star$"},{"location":"java/1201-1300/1261-1270/#1262-greatest-sum-divisible-by-three-starstar","text":"","title":"1262. Greatest Sum Divisible by Three $\\star\\star$"},{"location":"java/1201-1300/1261-1270/#1263-minimum-moves-to-move-a-box-to-their-target-location-starstarstar","text":"","title":"1263. Minimum Moves to Move a Box to Their Target Location $\\star\\star\\star$"},{"location":"java/1201-1300/1261-1270/#1264-page-recommendations-starstar","text":"","title":"1264. Page Recommendations $\\star\\star$ \ud83d\udd12"},{"location":"java/1201-1300/1261-1270/#1265-print-immutable-linked-list-in-reverse-starstar","text":"","title":"1265. Print Immutable Linked List in Reverse $\\star\\star$ \ud83d\udd12"},{"location":"java/1201-1300/1261-1270/#1266-minimum-time-visiting-all-points-star","text":"class Solution { public int minTimeToVisitAllPoints ( int [][] points ) { int ans = 0 ; for ( int i = 1 ; i < points . length ; ++ i ) ans += Math . max ( Math . abs ( points [ i ][ 0 ] - points [ i - 1 ][ 0 ] ), Math . abs ( points [ i ][ 1 ] - points [ i - 1 ][ 1 ] )); return ans ; } }","title":"1266. Minimum Time Visiting All Points $\\star$"},{"location":"java/1201-1300/1261-1270/#1267-count-servers-that-communicate-starstar","text":"class Solution { public int countServers ( int [][] grid ) { final int m = grid . length ; final int n = grid [ 0 ] . length ; int ans = 0 ; int [] rows = new int [ m ] ; int [] cols = new int [ n ] ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ][ j ] == 1 ) { ++ rows [ i ] ; ++ cols [ j ] ; } for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( grid [ i ][ j ] == 1 && ( rows [ i ] > 1 || cols [ j ] > 1 )) ++ ans ; return ans ; } }","title":"1267. Count Servers that Communicate $\\star\\star$"},{"location":"java/1201-1300/1261-1270/#1268-search-suggestions-system-starstar","text":"","title":"1268. Search Suggestions System $\\star\\star$"},{"location":"java/1201-1300/1261-1270/#1269-number-of-ways-to-stay-in-the-same-place-after-some-steps-starstarstar","text":"","title":"1269. Number of Ways to Stay in the Same Place After Some Steps $\\star\\star\\star$"},{"location":"java/1201-1300/1261-1270/#1270-all-people-report-to-the-given-manager-starstar","text":"","title":"1270. All People Report to the Given Manager $\\star\\star$ \ud83d\udd12"},{"location":"java/1201-1300/1271-1280/","text":"1271. Hexspeak $\\star$ \ud83d\udd12 1272. Remove Interval $\\star\\star$ \ud83d\udd12 1273. Delete Tree Nodes $\\star\\star$ \ud83d\udd12 1274. Number of Ships in a Rectangle $\\star\\star\\star$ \ud83d\udd12 1275. Find Winner on a Tic Tac Toe Game $\\star$ class Solution { public String tictactoe ( int [][] moves ) { int [][] row = new int [ 2 ][ 3 ] ; int [][] col = new int [ 2 ][ 3 ] ; int [] diag1 = new int [ 2 ] ; int [] diag2 = new int [ 2 ] ; for ( int i = 0 ; i < moves . length ; ++ i ) { int r = moves [ i ][ 0 ] ; int c = moves [ i ][ 1 ] ; int j = i % 2 ; if ( ++ row [ j ][ r ] == 3 || ++ col [ j ][ c ] == 3 || r == c && ++ diag1 [ j ] == 3 || r + c == 2 && ++ diag2 [ j ] == 3 ) return j == 0 ? \"A\" : \"B\" ; } return moves . length == 9 ? \"Draw\" : \"Pending\" ; } } 1276. Number of Burgers with No Waste of Ingredients $\\star\\star$ class Solution { public List < Integer > numOfBurgers ( int tomatoSlices , int cheeseSlices ) { if ( tomatoSlices % 2 == 1 || tomatoSlices < 2 * cheeseSlices || tomatoSlices > cheeseSlices * 4 ) return new ArrayList <> (); int jumboBurgers = ( tomatoSlices - 2 * cheeseSlices ) / 2 ; return new ArrayList <> ( Arrays . asList ( jumboBurgers , cheeseSlices - jumboBurgers )); } } 1277. Count Square Submatrices with All Ones $\\star\\star$ class Solution { public int countSquares ( int [][] matrix ) { int ans = 0 ; for ( int i = 0 ; i < matrix . length ; ++ i ) for ( int j = 0 ; j < matrix [ 0 ] . length ; ++ j ) { if ( matrix [ i ][ j ] == 1 && i > 0 && j > 0 ) matrix [ i ][ j ] += Math . min ( matrix [ i - 1 ][ j - 1 ] , Math . min ( matrix [ i - 1 ][ j ] , matrix [ i ][ j - 1 ] )); ans += matrix [ i ][ j ] ; } return ans ; } } 1278. Palindrome Partitioning III $\\star\\star\\star$ 1279. Traffic Light Controlled Intersection $\\star$ \ud83d\udd12 1280. Students and Examinations $\\star$ \ud83d\udd12","title":"1271-1280"},{"location":"java/1201-1300/1271-1280/#1271-hexspeak-star","text":"","title":"1271. Hexspeak $\\star$ \ud83d\udd12"},{"location":"java/1201-1300/1271-1280/#1272-remove-interval-starstar","text":"","title":"1272. Remove Interval $\\star\\star$ \ud83d\udd12"},{"location":"java/1201-1300/1271-1280/#1273-delete-tree-nodes-starstar","text":"","title":"1273. Delete Tree Nodes $\\star\\star$ \ud83d\udd12"},{"location":"java/1201-1300/1271-1280/#1274-number-of-ships-in-a-rectangle-starstarstar","text":"","title":"1274. Number of Ships in a Rectangle $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/1201-1300/1271-1280/#1275-find-winner-on-a-tic-tac-toe-game-star","text":"class Solution { public String tictactoe ( int [][] moves ) { int [][] row = new int [ 2 ][ 3 ] ; int [][] col = new int [ 2 ][ 3 ] ; int [] diag1 = new int [ 2 ] ; int [] diag2 = new int [ 2 ] ; for ( int i = 0 ; i < moves . length ; ++ i ) { int r = moves [ i ][ 0 ] ; int c = moves [ i ][ 1 ] ; int j = i % 2 ; if ( ++ row [ j ][ r ] == 3 || ++ col [ j ][ c ] == 3 || r == c && ++ diag1 [ j ] == 3 || r + c == 2 && ++ diag2 [ j ] == 3 ) return j == 0 ? \"A\" : \"B\" ; } return moves . length == 9 ? \"Draw\" : \"Pending\" ; } }","title":"1275. Find Winner on a Tic Tac Toe Game $\\star$"},{"location":"java/1201-1300/1271-1280/#1276-number-of-burgers-with-no-waste-of-ingredients-starstar","text":"class Solution { public List < Integer > numOfBurgers ( int tomatoSlices , int cheeseSlices ) { if ( tomatoSlices % 2 == 1 || tomatoSlices < 2 * cheeseSlices || tomatoSlices > cheeseSlices * 4 ) return new ArrayList <> (); int jumboBurgers = ( tomatoSlices - 2 * cheeseSlices ) / 2 ; return new ArrayList <> ( Arrays . asList ( jumboBurgers , cheeseSlices - jumboBurgers )); } }","title":"1276. Number of Burgers with No Waste of Ingredients $\\star\\star$"},{"location":"java/1201-1300/1271-1280/#1277-count-square-submatrices-with-all-ones-starstar","text":"class Solution { public int countSquares ( int [][] matrix ) { int ans = 0 ; for ( int i = 0 ; i < matrix . length ; ++ i ) for ( int j = 0 ; j < matrix [ 0 ] . length ; ++ j ) { if ( matrix [ i ][ j ] == 1 && i > 0 && j > 0 ) matrix [ i ][ j ] += Math . min ( matrix [ i - 1 ][ j - 1 ] , Math . min ( matrix [ i - 1 ][ j ] , matrix [ i ][ j - 1 ] )); ans += matrix [ i ][ j ] ; } return ans ; } }","title":"1277. Count Square Submatrices with All Ones $\\star\\star$"},{"location":"java/1201-1300/1271-1280/#1278-palindrome-partitioning-iii-starstarstar","text":"","title":"1278. Palindrome Partitioning III $\\star\\star\\star$"},{"location":"java/1201-1300/1271-1280/#1279-traffic-light-controlled-intersection-star","text":"","title":"1279. Traffic Light Controlled Intersection $\\star$ \ud83d\udd12"},{"location":"java/1201-1300/1271-1280/#1280-students-and-examinations-star","text":"","title":"1280. Students and Examinations $\\star$ \ud83d\udd12"},{"location":"java/1201-1300/1281-1290/","text":"1281. Subtract the Product and Sum of Digits of an Integer $\\star$ class Solution { public int subtractProductAndSum ( int n ) { int prod = 1 ; int summ = 0 ; for (; n > 0 ; n /= 10 ) { prod *= n % 10 ; summ += n % 10 ; } return prod - summ ; } } 1282. Group the People Given the Group Size They Belong To $\\star\\star$ 1283. Find the Smallest Divisor Given a Threshold $\\star\\star$ 1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix $\\star\\star\\star$ 1285. Find the Start and End Number of Continuous Ranges $\\star\\star$ \ud83d\udd12 1286. Iterator for Combination $\\star\\star$ 1287. Element Appearing More Than 25% In Sorted Array $\\star$ class Solution { public int findSpecialInteger ( int [] arr ) { final int n = arr . length ; final int quarter = n / 4 ; for ( int i = 0 ; i < n - quarter ; ++ i ) if ( arr [ i ] == arr [ i + quarter ] ) return arr [ i ] ; throw new IllegalArgumentException (); } } 1288. Remove Covered Intervals $\\star\\star$ 1289. Minimum Falling Path Sum II $\\star\\star\\star$ 1290. Convert Binary Number in a Linked List to Integer $\\star$ class Solution { public int getDecimalValue ( ListNode head ) { int ans = 0 ; for (; head != null ; head = head . next ) ans = ans * 2 + head . val ; return ans ; } }","title":"1281-1290"},{"location":"java/1201-1300/1281-1290/#1281-subtract-the-product-and-sum-of-digits-of-an-integer-star","text":"class Solution { public int subtractProductAndSum ( int n ) { int prod = 1 ; int summ = 0 ; for (; n > 0 ; n /= 10 ) { prod *= n % 10 ; summ += n % 10 ; } return prod - summ ; } }","title":"1281. Subtract the Product and Sum of Digits of an Integer $\\star$"},{"location":"java/1201-1300/1281-1290/#1282-group-the-people-given-the-group-size-they-belong-to-starstar","text":"","title":"1282. Group the People Given the Group Size They Belong To $\\star\\star$"},{"location":"java/1201-1300/1281-1290/#1283-find-the-smallest-divisor-given-a-threshold-starstar","text":"","title":"1283. Find the Smallest Divisor Given a Threshold $\\star\\star$"},{"location":"java/1201-1300/1281-1290/#1284-minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix-starstarstar","text":"","title":"1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix $\\star\\star\\star$"},{"location":"java/1201-1300/1281-1290/#1285-find-the-start-and-end-number-of-continuous-ranges-starstar","text":"","title":"1285. Find the Start and End Number of Continuous Ranges $\\star\\star$ \ud83d\udd12"},{"location":"java/1201-1300/1281-1290/#1286-iterator-for-combination-starstar","text":"","title":"1286. Iterator for Combination $\\star\\star$"},{"location":"java/1201-1300/1281-1290/#1287-element-appearing-more-than-25-in-sorted-array-star","text":"class Solution { public int findSpecialInteger ( int [] arr ) { final int n = arr . length ; final int quarter = n / 4 ; for ( int i = 0 ; i < n - quarter ; ++ i ) if ( arr [ i ] == arr [ i + quarter ] ) return arr [ i ] ; throw new IllegalArgumentException (); } }","title":"1287. Element Appearing More Than 25% In Sorted Array $\\star$"},{"location":"java/1201-1300/1281-1290/#1288-remove-covered-intervals-starstar","text":"","title":"1288. Remove Covered Intervals $\\star\\star$"},{"location":"java/1201-1300/1281-1290/#1289-minimum-falling-path-sum-ii-starstarstar","text":"","title":"1289. Minimum Falling Path Sum II $\\star\\star\\star$"},{"location":"java/1201-1300/1281-1290/#1290-convert-binary-number-in-a-linked-list-to-integer-star","text":"class Solution { public int getDecimalValue ( ListNode head ) { int ans = 0 ; for (; head != null ; head = head . next ) ans = ans * 2 + head . val ; return ans ; } }","title":"1290. Convert Binary Number in a Linked List to Integer $\\star$"},{"location":"java/1201-1300/1291-1300/","text":"1291. Sequential Digits $\\star\\star$ 1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold $\\star\\star$ class Solution { public int maxSideLength ( int [][] mat , int threshold ) { final int m = mat . length ; final int n = mat [ 0 ] . length ; int ans = 0 ; int [][] prefixSum = new int [ m + 1 ][ n + 1 ] ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) prefixSum [ i ][ j ] = mat [ i - 1 ][ j - 1 ] + prefixSum [ i ][ j - 1 ] + prefixSum [ i - 1 ][ j ] - prefixSum [ i - 1 ][ j - 1 ] ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) for ( int length = ans ; length < Math . min ( m - i , n - j ); ++ length ) { if ( squareSum ( prefixSum , i , j , i + length , j + length ) > threshold ) break ; ans = Math . max ( ans , length + 1 ); } return ans ; } private int squareSum ( int [][] prefixSum , int r1 , int c1 , int r2 , int c2 ) { return prefixSum [ r2 + 1 ][ c2 + 1 ] - prefixSum [ r1 ][ c2 + 1 ] - prefixSum [ r2 + 1 ][ c1 ] + prefixSum [ r1 ][ c1 ] ; } } 1293. Shortest Path in a Grid with Obstacles Elimination $\\star\\star\\star$ 1294. Weather Type in Each Country $\\star$ \ud83d\udd12 1295. Find Numbers with Even Number of Digits $\\star$ class Solution { public int findNumbers ( int [] nums ) { int ans = 0 ; for ( int num : nums ) if ( 9 < num && num < 100 || 999 < num && num < 10000 || num == 100000 ) ++ ans ; return ans ; } } 1296. Divide Array in Sets of K Consecutive Numbers $\\star\\star$ class Solution { public boolean isPossibleDivide ( int [] nums , int k ) { TreeMap < Integer , Integer > count = new TreeMap <> (); for ( int num : nums ) count . put ( num , count . getOrDefault ( num , 0 ) + 1 ); for ( int key : count . keySet ()) { int value = count . getOrDefault ( key , 0 ); if ( value > 0 ) for ( int i = key ; i < key + k ; ++ i ) { count . put ( i , count . getOrDefault ( i , 0 ) - value ); if ( count . get ( i ) < 0 ) return false ; } } return true ; } } 1297. Maximum Number of Occurrences of a Substring $\\star\\star$ 1298. Maximum Candies You Can Get from Boxes $\\star\\star\\star$ 1299. Replace Elements with Greatest Element on Right Side $\\star$ class Solution { public int [] replaceElements ( int [] arr ) { int maxOfRight = - 1 ; for ( int i = arr . length - 1 ; i >= 0 ; -- i ) { int a = arr [ i ] ; arr [ i ] = maxOfRight ; maxOfRight = Math . max ( maxOfRight , a ); } return arr ; } } 1300. Sum of Mutated Array Closest to Target $\\star\\star$ class Solution { public int findBestValue ( int [] arr , int target ) { final int n = arr . length ; final double err = 1e-9 ; int prefixSum = 0 ; Arrays . sort ( arr ); for ( int i = 0 ; i < n ; ++ i ) { int ans = ( int ) Math . round ((( float ) target - prefixSum - err ) / ( n - i )); if ( ans <= arr [ i ] ) return ans ; prefixSum += arr [ i ] ; } return arr [ n - 1 ] ; } }","title":"1291-1300"},{"location":"java/1201-1300/1291-1300/#1291-sequential-digits-starstar","text":"","title":"1291. Sequential Digits $\\star\\star$"},{"location":"java/1201-1300/1291-1300/#1292-maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold-starstar","text":"class Solution { public int maxSideLength ( int [][] mat , int threshold ) { final int m = mat . length ; final int n = mat [ 0 ] . length ; int ans = 0 ; int [][] prefixSum = new int [ m + 1 ][ n + 1 ] ; for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) prefixSum [ i ][ j ] = mat [ i - 1 ][ j - 1 ] + prefixSum [ i ][ j - 1 ] + prefixSum [ i - 1 ][ j ] - prefixSum [ i - 1 ][ j - 1 ] ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) for ( int length = ans ; length < Math . min ( m - i , n - j ); ++ length ) { if ( squareSum ( prefixSum , i , j , i + length , j + length ) > threshold ) break ; ans = Math . max ( ans , length + 1 ); } return ans ; } private int squareSum ( int [][] prefixSum , int r1 , int c1 , int r2 , int c2 ) { return prefixSum [ r2 + 1 ][ c2 + 1 ] - prefixSum [ r1 ][ c2 + 1 ] - prefixSum [ r2 + 1 ][ c1 ] + prefixSum [ r1 ][ c1 ] ; } }","title":"1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold $\\star\\star$"},{"location":"java/1201-1300/1291-1300/#1293-shortest-path-in-a-grid-with-obstacles-elimination-starstarstar","text":"","title":"1293. Shortest Path in a Grid with Obstacles Elimination $\\star\\star\\star$"},{"location":"java/1201-1300/1291-1300/#1294-weather-type-in-each-country-star","text":"","title":"1294. Weather Type in Each Country $\\star$ \ud83d\udd12"},{"location":"java/1201-1300/1291-1300/#1295-find-numbers-with-even-number-of-digits-star","text":"class Solution { public int findNumbers ( int [] nums ) { int ans = 0 ; for ( int num : nums ) if ( 9 < num && num < 100 || 999 < num && num < 10000 || num == 100000 ) ++ ans ; return ans ; } }","title":"1295. Find Numbers with Even Number of Digits $\\star$"},{"location":"java/1201-1300/1291-1300/#1296-divide-array-in-sets-of-k-consecutive-numbers-starstar","text":"class Solution { public boolean isPossibleDivide ( int [] nums , int k ) { TreeMap < Integer , Integer > count = new TreeMap <> (); for ( int num : nums ) count . put ( num , count . getOrDefault ( num , 0 ) + 1 ); for ( int key : count . keySet ()) { int value = count . getOrDefault ( key , 0 ); if ( value > 0 ) for ( int i = key ; i < key + k ; ++ i ) { count . put ( i , count . getOrDefault ( i , 0 ) - value ); if ( count . get ( i ) < 0 ) return false ; } } return true ; } }","title":"1296. Divide Array in Sets of K Consecutive Numbers $\\star\\star$"},{"location":"java/1201-1300/1291-1300/#1297-maximum-number-of-occurrences-of-a-substring-starstar","text":"","title":"1297. Maximum Number of Occurrences of a Substring $\\star\\star$"},{"location":"java/1201-1300/1291-1300/#1298-maximum-candies-you-can-get-from-boxes-starstarstar","text":"","title":"1298. Maximum Candies You Can Get from Boxes $\\star\\star\\star$"},{"location":"java/1201-1300/1291-1300/#1299-replace-elements-with-greatest-element-on-right-side-star","text":"class Solution { public int [] replaceElements ( int [] arr ) { int maxOfRight = - 1 ; for ( int i = arr . length - 1 ; i >= 0 ; -- i ) { int a = arr [ i ] ; arr [ i ] = maxOfRight ; maxOfRight = Math . max ( maxOfRight , a ); } return arr ; } }","title":"1299. Replace Elements with Greatest Element on Right Side $\\star$"},{"location":"java/1201-1300/1291-1300/#1300-sum-of-mutated-array-closest-to-target-starstar","text":"class Solution { public int findBestValue ( int [] arr , int target ) { final int n = arr . length ; final double err = 1e-9 ; int prefixSum = 0 ; Arrays . sort ( arr ); for ( int i = 0 ; i < n ; ++ i ) { int ans = ( int ) Math . round ((( float ) target - prefixSum - err ) / ( n - i )); if ( ans <= arr [ i ] ) return ans ; prefixSum += arr [ i ] ; } return arr [ n - 1 ] ; } }","title":"1300. Sum of Mutated Array Closest to Target $\\star\\star$"},{"location":"java/1301-1400/1301-1310/","text":"1301. Number of Paths with Max Score $\\star\\star\\star$ 1302. Deepest Leaves Sum $\\star\\star$ 1303. Find the Team Size $\\star$ \ud83d\udd12 1304. Find N Unique Integers Sum up to Zero $\\star$ class Solution { public int [] sumZero ( int n ) { int [] ans = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) ans [ i ] = i * 2 - n + 1 ; return ans ; } } 1305. All Elements in Two Binary Search Trees $\\star\\star$ 1306. Jump Game III $\\star\\star$ 1307. Verbal Arithmetic Puzzle $\\star\\star\\star$ class Solution { public boolean isSolvable ( String [] words , String result ) { rows = words . length + 1 ; for ( final String word : words ) cols = Math . max ( cols , word . length ()); cols = Math . max ( cols , result . length ()); return dfs ( words , result , 0 , 0 , 0 ); } private Map < Character , Integer > letterToDigit = new HashMap <> (); private boolean [] usedDigit = new boolean [ 10 ] ; private int rows = 0 ; private int cols = 0 ; private boolean dfs ( String [] words , String result , int row , int col , int sum ) { if ( col == cols ) return sum == 0 ; if ( row == rows ) return sum % 10 == 0 && dfs ( words , result , 0 , col + 1 , sum / 10 ); String word = row == rows - 1 ? result : words [ row ] ; if ( col >= word . length ()) return dfs ( words , result , row + 1 , col , sum ); char letter = word . charAt ( word . length () - col - 1 ); int sign = row == rows - 1 ? - 1 : 1 ; if ( letterToDigit . containsKey ( letter ) && ( letterToDigit . get ( letter ) > 0 || col < word . length () - 1 )) return dfs ( words , result , row + 1 , col , sum + sign * letterToDigit . get ( letter )); for ( int digit = 0 ; digit < 10 ; ++ digit ) if ( ! usedDigit [ digit ] && ( digit > 0 || col < word . length () - 1 )) { letterToDigit . put ( letter , digit ); usedDigit [ digit ] = true ; if ( dfs ( words , result , row + 1 , col , sum + sign * letterToDigit . get ( letter ))) return true ; usedDigit [ digit ] = false ; letterToDigit . remove ( letter ); } return false ; } } 1308. Running Total for Different Genders $\\star\\star$ \ud83d\udd12 1309. Decrypt String from Alphabet to Integer Mapping $\\star$ class Solution { public String freqAlphabets ( String s ) { String ans = \"\" ; for ( int i = 0 ; i < s . length ();) { if ( i + 2 < s . length () && s . charAt ( i + 2 ) == '#' ) { ans += ( char ) ( Integer . valueOf ( s . substring ( i , i + 2 )) + 'a' - 1 ); i += 3 ; } else { ans += ( char ) (( s . charAt ( i ) - '0' ) + 'a' - 1 ); i += 1 ; } } return ans ; } } 1310. XOR Queries of a Subarray $\\star\\star$ class Solution { public int [] xorQueries ( int [] arr , int [][] queries ) { int [] ans = new int [ queries . length ] ; int [] xors = new int [ arr . length + 1 ] ; for ( int i = 0 ; i < arr . length ; ++ i ) xors [ i + 1 ] ^= xors [ i ] ^ arr [ i ] ; int i = 0 ; for ( int [] query : queries ) ans [ i ++] = xors [ query [ 0 ]] ^ xors [ query [ 1 ] + 1 ] ; return ans ; } }","title":"1301-1310"},{"location":"java/1301-1400/1301-1310/#1301-number-of-paths-with-max-score-starstarstar","text":"","title":"1301. Number of Paths with Max Score $\\star\\star\\star$"},{"location":"java/1301-1400/1301-1310/#1302-deepest-leaves-sum-starstar","text":"","title":"1302. Deepest Leaves Sum $\\star\\star$"},{"location":"java/1301-1400/1301-1310/#1303-find-the-team-size-star","text":"","title":"1303. Find the Team Size $\\star$ \ud83d\udd12"},{"location":"java/1301-1400/1301-1310/#1304-find-n-unique-integers-sum-up-to-zero-star","text":"class Solution { public int [] sumZero ( int n ) { int [] ans = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) ans [ i ] = i * 2 - n + 1 ; return ans ; } }","title":"1304. Find N Unique Integers Sum up to Zero $\\star$"},{"location":"java/1301-1400/1301-1310/#1305-all-elements-in-two-binary-search-trees-starstar","text":"","title":"1305. All Elements in Two Binary Search Trees $\\star\\star$"},{"location":"java/1301-1400/1301-1310/#1306-jump-game-iii-starstar","text":"","title":"1306. Jump Game III $\\star\\star$"},{"location":"java/1301-1400/1301-1310/#1307-verbal-arithmetic-puzzle-starstarstar","text":"class Solution { public boolean isSolvable ( String [] words , String result ) { rows = words . length + 1 ; for ( final String word : words ) cols = Math . max ( cols , word . length ()); cols = Math . max ( cols , result . length ()); return dfs ( words , result , 0 , 0 , 0 ); } private Map < Character , Integer > letterToDigit = new HashMap <> (); private boolean [] usedDigit = new boolean [ 10 ] ; private int rows = 0 ; private int cols = 0 ; private boolean dfs ( String [] words , String result , int row , int col , int sum ) { if ( col == cols ) return sum == 0 ; if ( row == rows ) return sum % 10 == 0 && dfs ( words , result , 0 , col + 1 , sum / 10 ); String word = row == rows - 1 ? result : words [ row ] ; if ( col >= word . length ()) return dfs ( words , result , row + 1 , col , sum ); char letter = word . charAt ( word . length () - col - 1 ); int sign = row == rows - 1 ? - 1 : 1 ; if ( letterToDigit . containsKey ( letter ) && ( letterToDigit . get ( letter ) > 0 || col < word . length () - 1 )) return dfs ( words , result , row + 1 , col , sum + sign * letterToDigit . get ( letter )); for ( int digit = 0 ; digit < 10 ; ++ digit ) if ( ! usedDigit [ digit ] && ( digit > 0 || col < word . length () - 1 )) { letterToDigit . put ( letter , digit ); usedDigit [ digit ] = true ; if ( dfs ( words , result , row + 1 , col , sum + sign * letterToDigit . get ( letter ))) return true ; usedDigit [ digit ] = false ; letterToDigit . remove ( letter ); } return false ; } }","title":"1307. Verbal Arithmetic Puzzle $\\star\\star\\star$"},{"location":"java/1301-1400/1301-1310/#1308-running-total-for-different-genders-starstar","text":"","title":"1308. Running Total for Different Genders $\\star\\star$ \ud83d\udd12"},{"location":"java/1301-1400/1301-1310/#1309-decrypt-string-from-alphabet-to-integer-mapping-star","text":"class Solution { public String freqAlphabets ( String s ) { String ans = \"\" ; for ( int i = 0 ; i < s . length ();) { if ( i + 2 < s . length () && s . charAt ( i + 2 ) == '#' ) { ans += ( char ) ( Integer . valueOf ( s . substring ( i , i + 2 )) + 'a' - 1 ); i += 3 ; } else { ans += ( char ) (( s . charAt ( i ) - '0' ) + 'a' - 1 ); i += 1 ; } } return ans ; } }","title":"1309. Decrypt String from Alphabet to Integer Mapping $\\star$"},{"location":"java/1301-1400/1301-1310/#1310-xor-queries-of-a-subarray-starstar","text":"class Solution { public int [] xorQueries ( int [] arr , int [][] queries ) { int [] ans = new int [ queries . length ] ; int [] xors = new int [ arr . length + 1 ] ; for ( int i = 0 ; i < arr . length ; ++ i ) xors [ i + 1 ] ^= xors [ i ] ^ arr [ i ] ; int i = 0 ; for ( int [] query : queries ) ans [ i ++] = xors [ query [ 0 ]] ^ xors [ query [ 1 ] + 1 ] ; return ans ; } }","title":"1310. XOR Queries of a Subarray $\\star\\star$"},{"location":"java/1301-1400/1311-1320/","text":"1311. Get Watched Videos by Your Friends $\\star\\star$ class Solution { public List < String > watchedVideosByFriends ( List < List < String >> watchedVideos , int [][] friends , int id , int level ) { boolean [] visited = new boolean [ friends . length ] ; visited [ id ] = true ; Queue < Integer > queue = new LinkedList <> (); queue . add ( id ); Map < String , Integer > count = new HashMap <> (); for ( int i = 0 ; i < level ; ++ i ) for ( int j = queue . size (); j > 0 ; -- j ) { for ( int friend : friends [ queue . peek () ] ) if ( visited [ friend ] == false ) { visited [ friend ] = true ; queue . add ( friend ); } queue . poll (); } for ( int friend : queue ) for ( final String video : watchedVideos . get ( friend )) count . put ( video , count . getOrDefault ( video , 0 ) + 1 ); List < String > ans = new ArrayList <> ( count . keySet ()); ans . sort (( a , b ) -> count . get ( a ) == count . get ( b ) ? a . compareTo ( b ) : count . get ( a ) - count . get ( b )); return ans ; } } 1312. Minimum Insertion Steps to Make a String Palindrome $\\star\\star\\star$ 1313. Decompress Run-Length Encoded List $\\star$ class Solution { public int [] decompressRLElist ( int [] nums ) { List < Integer > ans = new ArrayList <> (); for ( int i = 0 ; i < nums . length ; i += 2 ) for ( int freq = 0 ; freq < nums [ i ] ; ++ freq ) ans . add ( nums [ i + 1 ] ); return ans . stream (). mapToInt ( i -> i ). toArray (); } } 1314. Matrix Block Sum $\\star\\star$ 1315. Sum of Nodes with Even-Valued Grandparent $\\star\\star$ 1316. Distinct Echo Substrings $\\star\\star\\star$ 1317. Convert Integer to the Sum of Two No-Zero Integers $\\star$ class Solution { public int [] getNoZeroIntegers ( int n ) { for ( int A = 1 ; A < n ; ++ A ) { int B = n - A ; if ( ! String . valueOf ( A ). contains ( \"0\" ) && ! String . valueOf ( B ). contains ( \"0\" )) return new int [] { A , B }; } throw new IllegalArgumentException (); } } 1318. Minimum Flips to Make a OR b Equal to c $\\star\\star$ 1319. Number of Operations to Make Network Connected $\\star\\star$ 1320. Minimum Distance to Type a Word Using Two Fingers $\\star\\star\\star$","title":"1311-1320"},{"location":"java/1301-1400/1311-1320/#1311-get-watched-videos-by-your-friends-starstar","text":"class Solution { public List < String > watchedVideosByFriends ( List < List < String >> watchedVideos , int [][] friends , int id , int level ) { boolean [] visited = new boolean [ friends . length ] ; visited [ id ] = true ; Queue < Integer > queue = new LinkedList <> (); queue . add ( id ); Map < String , Integer > count = new HashMap <> (); for ( int i = 0 ; i < level ; ++ i ) for ( int j = queue . size (); j > 0 ; -- j ) { for ( int friend : friends [ queue . peek () ] ) if ( visited [ friend ] == false ) { visited [ friend ] = true ; queue . add ( friend ); } queue . poll (); } for ( int friend : queue ) for ( final String video : watchedVideos . get ( friend )) count . put ( video , count . getOrDefault ( video , 0 ) + 1 ); List < String > ans = new ArrayList <> ( count . keySet ()); ans . sort (( a , b ) -> count . get ( a ) == count . get ( b ) ? a . compareTo ( b ) : count . get ( a ) - count . get ( b )); return ans ; } }","title":"1311. Get Watched Videos by Your Friends $\\star\\star$"},{"location":"java/1301-1400/1311-1320/#1312-minimum-insertion-steps-to-make-a-string-palindrome-starstarstar","text":"","title":"1312. Minimum Insertion Steps to Make a String Palindrome $\\star\\star\\star$"},{"location":"java/1301-1400/1311-1320/#1313-decompress-run-length-encoded-list-star","text":"class Solution { public int [] decompressRLElist ( int [] nums ) { List < Integer > ans = new ArrayList <> (); for ( int i = 0 ; i < nums . length ; i += 2 ) for ( int freq = 0 ; freq < nums [ i ] ; ++ freq ) ans . add ( nums [ i + 1 ] ); return ans . stream (). mapToInt ( i -> i ). toArray (); } }","title":"1313. Decompress Run-Length Encoded List $\\star$"},{"location":"java/1301-1400/1311-1320/#1314-matrix-block-sum-starstar","text":"","title":"1314. Matrix Block Sum $\\star\\star$"},{"location":"java/1301-1400/1311-1320/#1315-sum-of-nodes-with-even-valued-grandparent-starstar","text":"","title":"1315. Sum of Nodes with Even-Valued Grandparent $\\star\\star$"},{"location":"java/1301-1400/1311-1320/#1316-distinct-echo-substrings-starstarstar","text":"","title":"1316. Distinct Echo Substrings $\\star\\star\\star$"},{"location":"java/1301-1400/1311-1320/#1317-convert-integer-to-the-sum-of-two-no-zero-integers-star","text":"class Solution { public int [] getNoZeroIntegers ( int n ) { for ( int A = 1 ; A < n ; ++ A ) { int B = n - A ; if ( ! String . valueOf ( A ). contains ( \"0\" ) && ! String . valueOf ( B ). contains ( \"0\" )) return new int [] { A , B }; } throw new IllegalArgumentException (); } }","title":"1317. Convert Integer to the Sum of Two No-Zero Integers $\\star$"},{"location":"java/1301-1400/1311-1320/#1318-minimum-flips-to-make-a-or-b-equal-to-c-starstar","text":"","title":"1318. Minimum Flips to Make a OR b Equal to c $\\star\\star$"},{"location":"java/1301-1400/1311-1320/#1319-number-of-operations-to-make-network-connected-starstar","text":"","title":"1319. Number of Operations to Make Network Connected $\\star\\star$"},{"location":"java/1301-1400/1311-1320/#1320-minimum-distance-to-type-a-word-using-two-fingers-starstarstar","text":"","title":"1320. Minimum Distance to Type a Word Using Two Fingers $\\star\\star\\star$"},{"location":"java/1301-1400/1321-1330/","text":"1321. Restaurant Growth $\\star\\star$ \ud83d\udd12 1322. Ads Performance $\\star$ \ud83d\udd12 1323. Maximum 69 Number $\\star$ class Solution { public int maximum69Number ( int num ) { char [] ans = String . valueOf ( num ). toCharArray (); for ( int i = 0 ; i < ans . length ; ++ i ) if ( ans [ i ] == '6' ) { ans [ i ] = '9' ; break ; } return Integer . valueOf ( String . valueOf ( ans )); } } 1324. Print Words Vertically $\\star\\star$ 1325. Delete Leaves With a Given Value $\\star\\star$ 1326. Minimum Number of Taps to Open to Water a Garden $\\star\\star\\star$ class Solution { public int minTaps ( int n , int [] ranges ) { int [] nums = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; ++ i ) { int l = Math . max ( 0 , i - ranges [ i ] ); int r = Math . min ( n , i + ranges [ i ] ); nums [ l ] = Math . max ( nums [ l ] , r - l ); } int ans = 0 ; int end = 0 ; int farthest = 0 ; for ( int i = 0 ; i < n ; i ++ ) { farthest = Math . max ( farthest , i + nums [ i ] ); if ( i == end ) { ++ ans ; end = farthest ; } } return end == n ? ans : - 1 ; } } 1327. List the Products Ordered in a Period $\\star$ \ud83d\udd12 1328. Break a Palindrome $\\star\\star$ 1329. Sort the Matrix Diagonally $\\star\\star$ class Solution { public int [][] diagonalSort ( int [][] mat ) { final int m = mat . length ; final int n = mat [ 0 ] . length ; Map < Integer , PriorityQueue < Integer >> count = new HashMap <> (); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) count . computeIfAbsent ( i - j , k -> new PriorityQueue <> ()). add ( mat [ i ][ j ] ); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) mat [ i ][ j ] = count . get ( i - j ). poll (); return mat ; } } 1330. Reverse Subarray To Maximize Array Value $\\star\\star\\star$ class Solution { public int maxValueAfterReverse ( int [] nums ) { int total = 0 ; int min = Integer . MAX_VALUE ; int max = Integer . MIN_VALUE ; for ( int i = 0 ; i + 1 < nums . length ; ++ i ) { int a = nums [ i ] ; int b = nums [ i + 1 ] ; total += Math . abs ( a - b ); min = Math . min ( min , Math . max ( a , b )); max = Math . max ( max , Math . min ( a , b )); } int diff = Math . max ( 0 , ( max - min ) * 2 ); for ( int i = 0 ; i + 1 < nums . length ; ++ i ) { int a = nums [ i ] ; int b = nums [ i + 1 ] ; int headDiff = - Math . abs ( a - b ) + Math . abs ( nums [ 0 ] - b ); int tailDiff = - Math . abs ( a - b ) + Math . abs ( nums [ nums . length - 1 ] - a ); diff = Math . max ( diff , Math . max ( headDiff , tailDiff )); } return total + diff ; } }","title":"1321-1330"},{"location":"java/1301-1400/1321-1330/#1321-restaurant-growth-starstar","text":"","title":"1321. Restaurant Growth $\\star\\star$ \ud83d\udd12"},{"location":"java/1301-1400/1321-1330/#1322-ads-performance-star","text":"","title":"1322. Ads Performance $\\star$ \ud83d\udd12"},{"location":"java/1301-1400/1321-1330/#1323-maximum-69-number-star","text":"class Solution { public int maximum69Number ( int num ) { char [] ans = String . valueOf ( num ). toCharArray (); for ( int i = 0 ; i < ans . length ; ++ i ) if ( ans [ i ] == '6' ) { ans [ i ] = '9' ; break ; } return Integer . valueOf ( String . valueOf ( ans )); } }","title":"1323. Maximum 69 Number $\\star$"},{"location":"java/1301-1400/1321-1330/#1324-print-words-vertically-starstar","text":"","title":"1324. Print Words Vertically $\\star\\star$"},{"location":"java/1301-1400/1321-1330/#1325-delete-leaves-with-a-given-value-starstar","text":"","title":"1325. Delete Leaves With a Given Value $\\star\\star$"},{"location":"java/1301-1400/1321-1330/#1326-minimum-number-of-taps-to-open-to-water-a-garden-starstarstar","text":"class Solution { public int minTaps ( int n , int [] ranges ) { int [] nums = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; ++ i ) { int l = Math . max ( 0 , i - ranges [ i ] ); int r = Math . min ( n , i + ranges [ i ] ); nums [ l ] = Math . max ( nums [ l ] , r - l ); } int ans = 0 ; int end = 0 ; int farthest = 0 ; for ( int i = 0 ; i < n ; i ++ ) { farthest = Math . max ( farthest , i + nums [ i ] ); if ( i == end ) { ++ ans ; end = farthest ; } } return end == n ? ans : - 1 ; } }","title":"1326. Minimum Number of Taps to Open to Water a Garden $\\star\\star\\star$"},{"location":"java/1301-1400/1321-1330/#1327-list-the-products-ordered-in-a-period-star","text":"","title":"1327. List the Products Ordered in a Period $\\star$ \ud83d\udd12"},{"location":"java/1301-1400/1321-1330/#1328-break-a-palindrome-starstar","text":"","title":"1328. Break a Palindrome $\\star\\star$"},{"location":"java/1301-1400/1321-1330/#1329-sort-the-matrix-diagonally-starstar","text":"class Solution { public int [][] diagonalSort ( int [][] mat ) { final int m = mat . length ; final int n = mat [ 0 ] . length ; Map < Integer , PriorityQueue < Integer >> count = new HashMap <> (); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) count . computeIfAbsent ( i - j , k -> new PriorityQueue <> ()). add ( mat [ i ][ j ] ); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) mat [ i ][ j ] = count . get ( i - j ). poll (); return mat ; } }","title":"1329. Sort the Matrix Diagonally $\\star\\star$"},{"location":"java/1301-1400/1321-1330/#1330-reverse-subarray-to-maximize-array-value-starstarstar","text":"class Solution { public int maxValueAfterReverse ( int [] nums ) { int total = 0 ; int min = Integer . MAX_VALUE ; int max = Integer . MIN_VALUE ; for ( int i = 0 ; i + 1 < nums . length ; ++ i ) { int a = nums [ i ] ; int b = nums [ i + 1 ] ; total += Math . abs ( a - b ); min = Math . min ( min , Math . max ( a , b )); max = Math . max ( max , Math . min ( a , b )); } int diff = Math . max ( 0 , ( max - min ) * 2 ); for ( int i = 0 ; i + 1 < nums . length ; ++ i ) { int a = nums [ i ] ; int b = nums [ i + 1 ] ; int headDiff = - Math . abs ( a - b ) + Math . abs ( nums [ 0 ] - b ); int tailDiff = - Math . abs ( a - b ) + Math . abs ( nums [ nums . length - 1 ] - a ); diff = Math . max ( diff , Math . max ( headDiff , tailDiff )); } return total + diff ; } }","title":"1330. Reverse Subarray To Maximize Array Value $\\star\\star\\star$"},{"location":"java/1301-1400/1331-1340/","text":"1331. Rank Transform of an Array $\\star$ class Solution { public int [] arrayRankTransform ( int [] arr ) { int [] sortedArr = Arrays . copyOf ( arr , arr . length ); Map < Integer , Integer > rank = new HashMap <> (); Arrays . sort ( sortedArr ); for ( int a : sortedArr ) rank . putIfAbsent ( a , rank . size () + 1 ); for ( int i = 0 ; i < arr . length ; ++ i ) arr [ i ] = rank . get ( arr [ i ] ); return arr ; } } 1332. Remove Palindromic Subsequences $\\star$ 1333. Filter Restaurants by Vegan-Friendly, Price and Distance $\\star\\star$ class Solution { public List < Integer > filterRestaurants ( int [][] restaurants , int veganFriendly , int maxPrice , int maxDistance ) { return Arrays . stream ( restaurants ). filter ( r -> r [ 2 ] >= veganFriendly && r [ 3 ] <= maxPrice && r [ 4 ] <= maxDistance ) . sorted (( a , b ) -> a [ 1 ] == b [ 1 ] ? b [ 0 ] - a [ 0 ] : b [ 1 ] - a [ 1 ] ). map ( i -> i [ 0 ] ). collect ( Collectors . toList ()); } } 1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance $\\star\\star$ 1335. Minimum Difficulty of a Job Schedule $\\star\\star\\star$ class Solution { public int minDifficulty ( int [] jobDifficulty , int d ) { final int n = jobDifficulty . length ; if ( n < d ) return - 1 ; int [][] dp = new int [ n + 1 ][ d + 1 ] ; for ( int [] row : dp ) Arrays . fill ( row , Integer . MAX_VALUE / 2 ); dp [ 0 ][ 0 ] = 0 ; for ( int i = 1 ; i <= n ; ++ i ) for ( int k = 1 ; k <= d ; ++ k ) { int maxDifficulty = 0 ; for ( int j = i ; j >= k ; -- j ) { maxDifficulty = Math . max ( maxDifficulty , jobDifficulty [ j - 1 ] ); dp [ i ][ k ] = Math . min ( dp [ i ][ k ] , dp [ j - 1 ][ k - 1 ] + maxDifficulty ); } } return dp [ n ][ d ] ; } } 1336. Number of Transactions per Visit $\\star\\star\\star$ \ud83d\udd12 1337. The K Weakest Rows in a Matrix $\\star$ class Solution { public int [] kWeakestRows ( int [][] mat , int k ) { int [] ans = new int [ k ] ; int [][] candidates = new int [ mat . length ][ 2 ] ; for ( int i = 0 ; i < mat . length ; ++ i ) { candidates [ i ][ 0 ] = IntStream . of ( mat [ i ] ). sum (); candidates [ i ][ 1 ] = i ; } Arrays . sort ( candidates , ( a , b ) -> a [ 0 ] == b [ 0 ] ? a [ 1 ] - b [ 1 ] : a [ 0 ] - b [ 0 ] ); for ( int i = 0 ; i < k ; ++ i ) ans [ i ] = candidates [ i ][ 1 ] ; return ans ; } } 1338. Reduce Array Size to The Half $\\star\\star$ class Solution { public int minSetSize ( int [] arr ) { final int n = arr . length ; int sum = 0 ; Map < Integer , Integer > map = new HashMap <> (); for ( int a : arr ) map . put ( a , map . getOrDefault ( a , 0 ) + 1 ); int [][] count = new int [ map . size () ][ 2 ] ; int i = 0 ; for ( int key : map . keySet ()) { count [ i ][ 0 ] = key ; count [ i ++][ 1 ] = map . get ( key ); } Arrays . sort ( count , ( c1 , c2 ) -> c2 [ 1 ] - c1 [ 1 ] ); for ( i = 0 ; i < count . length ; ++ i ) { sum += count [ i ][ 1 ] ; if ( sum >= n / 2 ) return i + 1 ; } throw new IllegalArgumentException (); } } 1339. Maximum Product of Splitted Binary Tree $\\star\\star$ 1340. Jump Game V $\\star\\star\\star$","title":"1331-1340"},{"location":"java/1301-1400/1331-1340/#1331-rank-transform-of-an-array-star","text":"class Solution { public int [] arrayRankTransform ( int [] arr ) { int [] sortedArr = Arrays . copyOf ( arr , arr . length ); Map < Integer , Integer > rank = new HashMap <> (); Arrays . sort ( sortedArr ); for ( int a : sortedArr ) rank . putIfAbsent ( a , rank . size () + 1 ); for ( int i = 0 ; i < arr . length ; ++ i ) arr [ i ] = rank . get ( arr [ i ] ); return arr ; } }","title":"1331. Rank Transform of an Array $\\star$"},{"location":"java/1301-1400/1331-1340/#1332-remove-palindromic-subsequences-star","text":"","title":"1332. Remove Palindromic Subsequences $\\star$"},{"location":"java/1301-1400/1331-1340/#1333-filter-restaurants-by-vegan-friendly-price-and-distance-starstar","text":"class Solution { public List < Integer > filterRestaurants ( int [][] restaurants , int veganFriendly , int maxPrice , int maxDistance ) { return Arrays . stream ( restaurants ). filter ( r -> r [ 2 ] >= veganFriendly && r [ 3 ] <= maxPrice && r [ 4 ] <= maxDistance ) . sorted (( a , b ) -> a [ 1 ] == b [ 1 ] ? b [ 0 ] - a [ 0 ] : b [ 1 ] - a [ 1 ] ). map ( i -> i [ 0 ] ). collect ( Collectors . toList ()); } }","title":"1333. Filter Restaurants by Vegan-Friendly, Price and Distance $\\star\\star$"},{"location":"java/1301-1400/1331-1340/#1334-find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance-starstar","text":"","title":"1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance $\\star\\star$"},{"location":"java/1301-1400/1331-1340/#1335-minimum-difficulty-of-a-job-schedule-starstarstar","text":"class Solution { public int minDifficulty ( int [] jobDifficulty , int d ) { final int n = jobDifficulty . length ; if ( n < d ) return - 1 ; int [][] dp = new int [ n + 1 ][ d + 1 ] ; for ( int [] row : dp ) Arrays . fill ( row , Integer . MAX_VALUE / 2 ); dp [ 0 ][ 0 ] = 0 ; for ( int i = 1 ; i <= n ; ++ i ) for ( int k = 1 ; k <= d ; ++ k ) { int maxDifficulty = 0 ; for ( int j = i ; j >= k ; -- j ) { maxDifficulty = Math . max ( maxDifficulty , jobDifficulty [ j - 1 ] ); dp [ i ][ k ] = Math . min ( dp [ i ][ k ] , dp [ j - 1 ][ k - 1 ] + maxDifficulty ); } } return dp [ n ][ d ] ; } }","title":"1335. Minimum Difficulty of a Job Schedule $\\star\\star\\star$"},{"location":"java/1301-1400/1331-1340/#1336-number-of-transactions-per-visit-starstarstar","text":"","title":"1336. Number of Transactions per Visit $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/1301-1400/1331-1340/#1337-the-k-weakest-rows-in-a-matrix-star","text":"class Solution { public int [] kWeakestRows ( int [][] mat , int k ) { int [] ans = new int [ k ] ; int [][] candidates = new int [ mat . length ][ 2 ] ; for ( int i = 0 ; i < mat . length ; ++ i ) { candidates [ i ][ 0 ] = IntStream . of ( mat [ i ] ). sum (); candidates [ i ][ 1 ] = i ; } Arrays . sort ( candidates , ( a , b ) -> a [ 0 ] == b [ 0 ] ? a [ 1 ] - b [ 1 ] : a [ 0 ] - b [ 0 ] ); for ( int i = 0 ; i < k ; ++ i ) ans [ i ] = candidates [ i ][ 1 ] ; return ans ; } }","title":"1337. The K Weakest Rows in a Matrix $\\star$"},{"location":"java/1301-1400/1331-1340/#1338-reduce-array-size-to-the-half-starstar","text":"class Solution { public int minSetSize ( int [] arr ) { final int n = arr . length ; int sum = 0 ; Map < Integer , Integer > map = new HashMap <> (); for ( int a : arr ) map . put ( a , map . getOrDefault ( a , 0 ) + 1 ); int [][] count = new int [ map . size () ][ 2 ] ; int i = 0 ; for ( int key : map . keySet ()) { count [ i ][ 0 ] = key ; count [ i ++][ 1 ] = map . get ( key ); } Arrays . sort ( count , ( c1 , c2 ) -> c2 [ 1 ] - c1 [ 1 ] ); for ( i = 0 ; i < count . length ; ++ i ) { sum += count [ i ][ 1 ] ; if ( sum >= n / 2 ) return i + 1 ; } throw new IllegalArgumentException (); } }","title":"1338. Reduce Array Size to The Half $\\star\\star$"},{"location":"java/1301-1400/1331-1340/#1339-maximum-product-of-splitted-binary-tree-starstar","text":"","title":"1339. Maximum Product of Splitted Binary Tree $\\star\\star$"},{"location":"java/1301-1400/1331-1340/#1340-jump-game-v-starstarstar","text":"","title":"1340. Jump Game V $\\star\\star\\star$"},{"location":"java/1301-1400/1341-1350/","text":"1341. Movie Rating $\\star\\star$ \ud83d\udd12 1342. Number of Steps to Reduce a Number to Zero $\\star$ 1343. Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold $\\star\\star$ 1344. Angle Between Hands of a Clock $\\star\\star$ class Solution { public double angleClock ( int hour , int minutes ) { double hourAngle = ( hour % 12 ) * 30 + minutes * 0.5 ; double minuteAngle = minutes * 6 ; double ans = Math . abs ( hourAngle - minuteAngle ); return Math . min ( ans , 360 - ans ); } } 1345. Jump Game IV $\\star\\star\\star$ 1346. Check If N and Its Double Exist $\\star$ 1347. Minimum Number of Steps to Make Two Strings Anagram $\\star\\star$ 1348. Tweet Counts Per Frequency $\\star\\star$ 1349. Maximum Students Taking Exam $\\star\\star\\star$ 1350. Students With Invalid Departments $\\star$ \ud83d\udd12","title":"1341-1350"},{"location":"java/1301-1400/1341-1350/#1341-movie-rating-starstar","text":"","title":"1341. Movie Rating $\\star\\star$ \ud83d\udd12"},{"location":"java/1301-1400/1341-1350/#1342-number-of-steps-to-reduce-a-number-to-zero-star","text":"","title":"1342. Number of Steps to Reduce a Number to Zero $\\star$"},{"location":"java/1301-1400/1341-1350/#1343-number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold-starstar","text":"","title":"1343. Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold $\\star\\star$"},{"location":"java/1301-1400/1341-1350/#1344-angle-between-hands-of-a-clock-starstar","text":"class Solution { public double angleClock ( int hour , int minutes ) { double hourAngle = ( hour % 12 ) * 30 + minutes * 0.5 ; double minuteAngle = minutes * 6 ; double ans = Math . abs ( hourAngle - minuteAngle ); return Math . min ( ans , 360 - ans ); } }","title":"1344. Angle Between Hands of a Clock $\\star\\star$"},{"location":"java/1301-1400/1341-1350/#1345-jump-game-iv-starstarstar","text":"","title":"1345. Jump Game IV $\\star\\star\\star$"},{"location":"java/1301-1400/1341-1350/#1346-check-if-n-and-its-double-exist-star","text":"","title":"1346. Check If N and Its Double Exist $\\star$"},{"location":"java/1301-1400/1341-1350/#1347-minimum-number-of-steps-to-make-two-strings-anagram-starstar","text":"","title":"1347. Minimum Number of Steps to Make Two Strings Anagram $\\star\\star$"},{"location":"java/1301-1400/1341-1350/#1348-tweet-counts-per-frequency-starstar","text":"","title":"1348. Tweet Counts Per Frequency $\\star\\star$"},{"location":"java/1301-1400/1341-1350/#1349-maximum-students-taking-exam-starstarstar","text":"","title":"1349. Maximum Students Taking Exam $\\star\\star\\star$"},{"location":"java/1301-1400/1341-1350/#1350-students-with-invalid-departments-star","text":"","title":"1350. Students With Invalid Departments $\\star$ \ud83d\udd12"},{"location":"java/1301-1400/1351-1360/","text":"1351. Count Negative Numbers in a Sorted Matrix $\\star$ 1352. Product of the Last K Numbers $\\star\\star$ 1353. Maximum Number of Events That Can Be Attended $\\star\\star$ 1354. Construct Target Array With Multiple Sums $\\star\\star\\star$ 1355. Activity Participants $\\star\\star$ \ud83d\udd12 1356. Sort Integers by The Number of 1 Bits $\\star$ 1357. Apply Discount Every n Orders $\\star\\star$ 1358. Number of Substrings Containing All Three Characters $\\star\\star$ 1359. Count All Valid Pickup and Delivery Options $\\star\\star\\star$ class Solution { public int countOrders ( int n ) { final int kMod = ( int ) 1e9 + 7 ; long ans = 1 ; for ( int i = 1 ; i <= n ; ++ i ) ans = ans * i * ( i * 2 - 1 ) % kMod ; return ( int ) ans ; } } 1360. Number of Days Between Two Dates $\\star$","title":"1351-1360"},{"location":"java/1301-1400/1351-1360/#1351-count-negative-numbers-in-a-sorted-matrix-star","text":"","title":"1351. Count Negative Numbers in a Sorted Matrix $\\star$"},{"location":"java/1301-1400/1351-1360/#1352-product-of-the-last-k-numbers-starstar","text":"","title":"1352. Product of the Last K Numbers $\\star\\star$"},{"location":"java/1301-1400/1351-1360/#1353-maximum-number-of-events-that-can-be-attended-starstar","text":"","title":"1353. Maximum Number of Events That Can Be Attended $\\star\\star$"},{"location":"java/1301-1400/1351-1360/#1354-construct-target-array-with-multiple-sums-starstarstar","text":"","title":"1354. Construct Target Array With Multiple Sums $\\star\\star\\star$"},{"location":"java/1301-1400/1351-1360/#1355-activity-participants-starstar","text":"","title":"1355. Activity Participants $\\star\\star$ \ud83d\udd12"},{"location":"java/1301-1400/1351-1360/#1356-sort-integers-by-the-number-of-1-bits-star","text":"","title":"1356. Sort Integers by The Number of 1 Bits $\\star$"},{"location":"java/1301-1400/1351-1360/#1357-apply-discount-every-n-orders-starstar","text":"","title":"1357. Apply Discount Every n Orders $\\star\\star$"},{"location":"java/1301-1400/1351-1360/#1358-number-of-substrings-containing-all-three-characters-starstar","text":"","title":"1358. Number of Substrings Containing All Three Characters $\\star\\star$"},{"location":"java/1301-1400/1351-1360/#1359-count-all-valid-pickup-and-delivery-options-starstarstar","text":"class Solution { public int countOrders ( int n ) { final int kMod = ( int ) 1e9 + 7 ; long ans = 1 ; for ( int i = 1 ; i <= n ; ++ i ) ans = ans * i * ( i * 2 - 1 ) % kMod ; return ( int ) ans ; } }","title":"1359. Count All Valid Pickup and Delivery Options $\\star\\star\\star$"},{"location":"java/1301-1400/1351-1360/#1360-number-of-days-between-two-dates-star","text":"","title":"1360. Number of Days Between Two Dates $\\star$"},{"location":"java/1301-1400/1361-1370/","text":"1361. Validate Binary Tree Nodes $\\star\\star$ 1362. Closest Divisors $\\star\\star$ class Solution { public int [] closestDivisors ( int num ) { for ( int root = ( int ) Math . sqrt ( num + 2 ); root > 0 ; -- root ) for ( int cand : new int [] { num + 1 , num + 2 }) if ( cand % root == 0 ) return new int [] { root , cand / root }; throw new IllegalArgumentException (); } } 1363. Largest Multiple of Three $\\star\\star\\star$ class Solution { public String largestMultipleOfThree ( int [] digits ) { StringBuilder ans = new StringBuilder (); int [] mod1 = new int [] { 1 , 4 , 7 , 2 , 5 , 8 }; int [] mod2 = new int [] { 2 , 5 , 8 , 1 , 4 , 7 }; int [] count = new int [ 10 ] ; int sum = 0 ; for ( int digit : digits ) { ++ count [ digit ] ; sum += digit ; } while ( sum % 3 != 0 ) for ( int i : sum % 3 == 1 ? mod1 : mod2 ) if ( count [ i ] > 0 ) { -- count [ i ] ; sum -= i ; break ; } for ( int digit = 9 ; digit >= 0 ; -- digit ) ans . append ( Character . toString ( '0' + digit ). repeat ( count [ digit ] )); return ans . length () > 0 && ans . charAt ( 0 ) == '0' ? \"0\" : ans . toString (); } } 1364. Number of Trusted Contacts of a Customer $\\star\\star$ \ud83d\udd12 1365. How Many Numbers Are Smaller Than the Current Number $\\star$ 1366. Rank Teams by Votes $\\star\\star$ 1367. Linked List in Binary Tree $\\star\\star$ 1368. Minimum Cost to Make at Least One Valid Path in a Grid $\\star\\star\\star$ 1369. Get the Second Most Recent Activity $\\star\\star\\star$ \ud83d\udd12 1370. Increasing Decreasing String $\\star$","title":"1361-1370"},{"location":"java/1301-1400/1361-1370/#1361-validate-binary-tree-nodes-starstar","text":"","title":"1361. Validate Binary Tree Nodes $\\star\\star$"},{"location":"java/1301-1400/1361-1370/#1362-closest-divisors-starstar","text":"class Solution { public int [] closestDivisors ( int num ) { for ( int root = ( int ) Math . sqrt ( num + 2 ); root > 0 ; -- root ) for ( int cand : new int [] { num + 1 , num + 2 }) if ( cand % root == 0 ) return new int [] { root , cand / root }; throw new IllegalArgumentException (); } }","title":"1362. Closest Divisors $\\star\\star$"},{"location":"java/1301-1400/1361-1370/#1363-largest-multiple-of-three-starstarstar","text":"class Solution { public String largestMultipleOfThree ( int [] digits ) { StringBuilder ans = new StringBuilder (); int [] mod1 = new int [] { 1 , 4 , 7 , 2 , 5 , 8 }; int [] mod2 = new int [] { 2 , 5 , 8 , 1 , 4 , 7 }; int [] count = new int [ 10 ] ; int sum = 0 ; for ( int digit : digits ) { ++ count [ digit ] ; sum += digit ; } while ( sum % 3 != 0 ) for ( int i : sum % 3 == 1 ? mod1 : mod2 ) if ( count [ i ] > 0 ) { -- count [ i ] ; sum -= i ; break ; } for ( int digit = 9 ; digit >= 0 ; -- digit ) ans . append ( Character . toString ( '0' + digit ). repeat ( count [ digit ] )); return ans . length () > 0 && ans . charAt ( 0 ) == '0' ? \"0\" : ans . toString (); } }","title":"1363. Largest Multiple of Three $\\star\\star\\star$"},{"location":"java/1301-1400/1361-1370/#1364-number-of-trusted-contacts-of-a-customer-starstar","text":"","title":"1364. Number of Trusted Contacts of a Customer $\\star\\star$ \ud83d\udd12"},{"location":"java/1301-1400/1361-1370/#1365-how-many-numbers-are-smaller-than-the-current-number-star","text":"","title":"1365. How Many Numbers Are Smaller Than the Current Number $\\star$"},{"location":"java/1301-1400/1361-1370/#1366-rank-teams-by-votes-starstar","text":"","title":"1366. Rank Teams by Votes $\\star\\star$"},{"location":"java/1301-1400/1361-1370/#1367-linked-list-in-binary-tree-starstar","text":"","title":"1367. Linked List in Binary Tree $\\star\\star$"},{"location":"java/1301-1400/1361-1370/#1368-minimum-cost-to-make-at-least-one-valid-path-in-a-grid-starstarstar","text":"","title":"1368. Minimum Cost to Make at Least One Valid Path in a Grid $\\star\\star\\star$"},{"location":"java/1301-1400/1361-1370/#1369-get-the-second-most-recent-activity-starstarstar","text":"","title":"1369. Get the Second Most Recent Activity $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/1301-1400/1361-1370/#1370-increasing-decreasing-string-star","text":"","title":"1370. Increasing Decreasing String $\\star$"},{"location":"java/1301-1400/1371-1380/","text":"1371. Find the Longest Substring Containing Vowels in Even Counts $\\star\\star$ 1372. Longest ZigZag Path in a Binary Tree $\\star\\star$ 1373. Maximum Sum BST in Binary Tree $\\star\\star\\star$ class Solution { public int maxSumBST ( TreeNode root ) { dfs ( root ); return ans ; } private int ans = 0 ; private Info dfs ( TreeNode root ) { if ( root == null ) return new Info ( Integer . MAX_VALUE , Integer . MIN_VALUE , 0 , true ); Info left = dfs ( root . left ); Info right = dfs ( root . right ); boolean valid = left . valid && right . valid && root . val > left . max && root . val < right . min ; int sum = valid ? root . val + left . sum + right . sum : - 1 ; ans = Math . max ( ans , sum ); return new Info ( Math . min ( root . val , left . min ), Math . max ( root . val , right . max ), sum , valid ); } private class Info { int min ; int max ; int sum ; boolean valid ; public Info ( int min , int max , int sum , boolean valid ) { this . min = min ; this . max = max ; this . sum = sum ; this . valid = valid ; } } } 1374. Generate a String With Characters That Have Odd Counts $\\star$ 1375. Bulb Switcher III $\\star\\star$ 1376. Time Needed to Inform All Employees $\\star\\star$ 1377. Frog Position After T Seconds $\\star\\star\\star$ class Solution { public double frogPosition ( int n , int [][] edges , int t , int target ) { double [] prob = new double [ n + 1 ] ; boolean [] visited = new boolean [ n + 1 ] ; Queue < Integer > queue = new LinkedList <> (); List < Integer >[] graph = new List [ n + 1 ] ; prob [ 1 ] = 1.0 ; visited [ 1 ] = true ; queue . add ( 1 ); for ( int i = 1 ; i <= n ; ++ i ) graph [ i ] = new ArrayList <> (); for ( final int [] edge : edges ) { graph [ edge [ 0 ]] . add ( edge [ 1 ] ); graph [ edge [ 1 ]] . add ( edge [ 0 ] ); } for ( int i = 0 ; i < t ; ++ i ) { for ( int j = queue . size (); j > 0 ; -- j ) { int curr = queue . poll (); int children = 0 ; for ( int child : graph [ curr ] ) if ( ! visited [ child ] ) ++ children ; for ( int child : graph [ curr ] ) if ( ! visited [ child ] ) { visited [ child ] = true ; prob [ child ] = prob [ curr ] / children ; queue . add ( child ); } if ( children > 0 ) prob [ curr ] = 0.0 ; } } return prob [ target ] ; } } 1378. Replace Employee ID With The Unique Identifier $\\star$ \ud83d\udd12 1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree $\\star\\star$ 1380. Lucky Numbers in a Matrix $\\star$","title":"1371-1380"},{"location":"java/1301-1400/1371-1380/#1371-find-the-longest-substring-containing-vowels-in-even-counts-starstar","text":"","title":"1371. Find the Longest Substring Containing Vowels in Even Counts $\\star\\star$"},{"location":"java/1301-1400/1371-1380/#1372-longest-zigzag-path-in-a-binary-tree-starstar","text":"","title":"1372. Longest ZigZag Path in a Binary Tree $\\star\\star$"},{"location":"java/1301-1400/1371-1380/#1373-maximum-sum-bst-in-binary-tree-starstarstar","text":"class Solution { public int maxSumBST ( TreeNode root ) { dfs ( root ); return ans ; } private int ans = 0 ; private Info dfs ( TreeNode root ) { if ( root == null ) return new Info ( Integer . MAX_VALUE , Integer . MIN_VALUE , 0 , true ); Info left = dfs ( root . left ); Info right = dfs ( root . right ); boolean valid = left . valid && right . valid && root . val > left . max && root . val < right . min ; int sum = valid ? root . val + left . sum + right . sum : - 1 ; ans = Math . max ( ans , sum ); return new Info ( Math . min ( root . val , left . min ), Math . max ( root . val , right . max ), sum , valid ); } private class Info { int min ; int max ; int sum ; boolean valid ; public Info ( int min , int max , int sum , boolean valid ) { this . min = min ; this . max = max ; this . sum = sum ; this . valid = valid ; } } }","title":"1373. Maximum Sum BST in Binary Tree $\\star\\star\\star$"},{"location":"java/1301-1400/1371-1380/#1374-generate-a-string-with-characters-that-have-odd-counts-star","text":"","title":"1374. Generate a String With Characters That Have Odd Counts $\\star$"},{"location":"java/1301-1400/1371-1380/#1375-bulb-switcher-iii-starstar","text":"","title":"1375. Bulb Switcher III $\\star\\star$"},{"location":"java/1301-1400/1371-1380/#1376-time-needed-to-inform-all-employees-starstar","text":"","title":"1376. Time Needed to Inform All Employees $\\star\\star$"},{"location":"java/1301-1400/1371-1380/#1377-frog-position-after-t-seconds-starstarstar","text":"class Solution { public double frogPosition ( int n , int [][] edges , int t , int target ) { double [] prob = new double [ n + 1 ] ; boolean [] visited = new boolean [ n + 1 ] ; Queue < Integer > queue = new LinkedList <> (); List < Integer >[] graph = new List [ n + 1 ] ; prob [ 1 ] = 1.0 ; visited [ 1 ] = true ; queue . add ( 1 ); for ( int i = 1 ; i <= n ; ++ i ) graph [ i ] = new ArrayList <> (); for ( final int [] edge : edges ) { graph [ edge [ 0 ]] . add ( edge [ 1 ] ); graph [ edge [ 1 ]] . add ( edge [ 0 ] ); } for ( int i = 0 ; i < t ; ++ i ) { for ( int j = queue . size (); j > 0 ; -- j ) { int curr = queue . poll (); int children = 0 ; for ( int child : graph [ curr ] ) if ( ! visited [ child ] ) ++ children ; for ( int child : graph [ curr ] ) if ( ! visited [ child ] ) { visited [ child ] = true ; prob [ child ] = prob [ curr ] / children ; queue . add ( child ); } if ( children > 0 ) prob [ curr ] = 0.0 ; } } return prob [ target ] ; } }","title":"1377. Frog Position After T Seconds $\\star\\star\\star$"},{"location":"java/1301-1400/1371-1380/#1378-replace-employee-id-with-the-unique-identifier-star","text":"","title":"1378. Replace Employee ID With The Unique Identifier $\\star$ \ud83d\udd12"},{"location":"java/1301-1400/1371-1380/#1379-find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree-starstar","text":"","title":"1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree $\\star\\star$"},{"location":"java/1301-1400/1371-1380/#1380-lucky-numbers-in-a-matrix-star","text":"","title":"1380. Lucky Numbers in a Matrix $\\star$"},{"location":"java/1301-1400/1381-1390/","text":"1381. Design a Stack With Increment Operation $\\star\\star$ 1382. Balance a Binary Search Tree $\\star\\star$ 1383. Maximum Performance of a Team $\\star\\star\\star$ 1384. Total Sales Amount by Year $\\star\\star\\star$ \ud83d\udd12 1385. Find the Distance Value Between Two Arrays $\\star$ 1386. Cinema Seat Allocation $\\star\\star$ 1387. Sort Integers by The Power Value $\\star\\star$ 1388. Pizza With 3n Slices $\\star\\star\\star$ 1389. Create Target Array in the Given Order $\\star$ 1390. Four Divisors $\\star\\star$ class Solution { public int sumFourDivisors ( int [] nums ) { int ans = 0 ; for ( int num : nums ) { int divisor = 0 ; for ( int i = 2 ; i * i <= num ; ++ i ) if ( num % i == 0 ) { if ( divisor == 0 ) divisor = i ; else { divisor = 0 ; break ; } } if ( divisor > 0 && divisor * divisor < num ) ans += 1 + num + divisor + num / divisor ; } return ans ; } }","title":"1381-1390"},{"location":"java/1301-1400/1381-1390/#1381-design-a-stack-with-increment-operation-starstar","text":"","title":"1381. Design a Stack With Increment Operation $\\star\\star$"},{"location":"java/1301-1400/1381-1390/#1382-balance-a-binary-search-tree-starstar","text":"","title":"1382. Balance a Binary Search Tree $\\star\\star$"},{"location":"java/1301-1400/1381-1390/#1383-maximum-performance-of-a-team-starstarstar","text":"","title":"1383. Maximum Performance of a Team $\\star\\star\\star$"},{"location":"java/1301-1400/1381-1390/#1384-total-sales-amount-by-year-starstarstar","text":"","title":"1384. Total Sales Amount by Year $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/1301-1400/1381-1390/#1385-find-the-distance-value-between-two-arrays-star","text":"","title":"1385. Find the Distance Value Between Two Arrays $\\star$"},{"location":"java/1301-1400/1381-1390/#1386-cinema-seat-allocation-starstar","text":"","title":"1386. Cinema Seat Allocation $\\star\\star$"},{"location":"java/1301-1400/1381-1390/#1387-sort-integers-by-the-power-value-starstar","text":"","title":"1387. Sort Integers by The Power Value $\\star\\star$"},{"location":"java/1301-1400/1381-1390/#1388-pizza-with-3n-slices-starstarstar","text":"","title":"1388. Pizza With 3n Slices $\\star\\star\\star$"},{"location":"java/1301-1400/1381-1390/#1389-create-target-array-in-the-given-order-star","text":"","title":"1389. Create Target Array in the Given Order $\\star$"},{"location":"java/1301-1400/1381-1390/#1390-four-divisors-starstar","text":"class Solution { public int sumFourDivisors ( int [] nums ) { int ans = 0 ; for ( int num : nums ) { int divisor = 0 ; for ( int i = 2 ; i * i <= num ; ++ i ) if ( num % i == 0 ) { if ( divisor == 0 ) divisor = i ; else { divisor = 0 ; break ; } } if ( divisor > 0 && divisor * divisor < num ) ans += 1 + num + divisor + num / divisor ; } return ans ; } }","title":"1390. Four Divisors $\\star\\star$"},{"location":"java/1301-1400/1391-1400/","text":"1391. Check if There is a Valid Path in a Grid $\\star\\star$ 1392. Longest Happy Prefix $\\star\\star\\star$ 1393. Capital Gain/Loss $\\star\\star$ \ud83d\udd12 1394. Find Lucky Integer in an Array $\\star$ 1395. Count Number of Teams $\\star\\star$ 1396. Design Underground System $\\star\\star$ 1397. Find All Good Strings $\\star\\star\\star$ 1398. Customers Who Bought Products A and B but Not C $\\star\\star$ \ud83d\udd12 1399. Count Largest Group $\\star$ 1400. Construct K Palindrome Strings $\\star\\star$","title":"1391-1400"},{"location":"java/1301-1400/1391-1400/#1391-check-if-there-is-a-valid-path-in-a-grid-starstar","text":"","title":"1391. Check if There is a Valid Path in a Grid $\\star\\star$"},{"location":"java/1301-1400/1391-1400/#1392-longest-happy-prefix-starstarstar","text":"","title":"1392. Longest Happy Prefix $\\star\\star\\star$"},{"location":"java/1301-1400/1391-1400/#1393-capital-gainloss-starstar","text":"","title":"1393. Capital Gain/Loss $\\star\\star$ \ud83d\udd12"},{"location":"java/1301-1400/1391-1400/#1394-find-lucky-integer-in-an-array-star","text":"","title":"1394. Find Lucky Integer in an Array $\\star$"},{"location":"java/1301-1400/1391-1400/#1395-count-number-of-teams-starstar","text":"","title":"1395. Count Number of Teams $\\star\\star$"},{"location":"java/1301-1400/1391-1400/#1396-design-underground-system-starstar","text":"","title":"1396. Design Underground System $\\star\\star$"},{"location":"java/1301-1400/1391-1400/#1397-find-all-good-strings-starstarstar","text":"","title":"1397. Find All Good Strings $\\star\\star\\star$"},{"location":"java/1301-1400/1391-1400/#1398-customers-who-bought-products-a-and-b-but-not-c-starstar","text":"","title":"1398. Customers Who Bought Products A and B but Not C $\\star\\star$ \ud83d\udd12"},{"location":"java/1301-1400/1391-1400/#1399-count-largest-group-star","text":"","title":"1399. Count Largest Group $\\star$"},{"location":"java/1301-1400/1391-1400/#1400-construct-k-palindrome-strings-starstar","text":"","title":"1400. Construct K Palindrome Strings $\\star\\star$"},{"location":"java/1401-1500/1401-1410/","text":"1401. Circle and Rectangle Overlapping $\\star\\star$ 1402. Reducing Dishes $\\star\\star\\star$ 1403. Minimum Subsequence in Non-Increasing Order $\\star$ 1404. Number of Steps to Reduce a Number in Binary Representation to One $\\star\\star$ 1405. Longest Happy String $\\star\\star$ 1406. Stone Game III $\\star\\star\\star$ 1407. Top Travellers $\\star$ \ud83d\udd12 1408. String Matching in an Array $\\star$ 1409. Queries on a Permutation With Key $\\star\\star$ 1410. HTML Entity Parser $\\star\\star$","title":"1401-1410"},{"location":"java/1401-1500/1401-1410/#1401-circle-and-rectangle-overlapping-starstar","text":"","title":"1401. Circle and Rectangle Overlapping $\\star\\star$"},{"location":"java/1401-1500/1401-1410/#1402-reducing-dishes-starstarstar","text":"","title":"1402. Reducing Dishes $\\star\\star\\star$"},{"location":"java/1401-1500/1401-1410/#1403-minimum-subsequence-in-non-increasing-order-star","text":"","title":"1403. Minimum Subsequence in Non-Increasing Order $\\star$"},{"location":"java/1401-1500/1401-1410/#1404-number-of-steps-to-reduce-a-number-in-binary-representation-to-one-starstar","text":"","title":"1404. Number of Steps to Reduce a Number in Binary Representation to One $\\star\\star$"},{"location":"java/1401-1500/1401-1410/#1405-longest-happy-string-starstar","text":"","title":"1405. Longest Happy String $\\star\\star$"},{"location":"java/1401-1500/1401-1410/#1406-stone-game-iii-starstarstar","text":"","title":"1406. Stone Game III $\\star\\star\\star$"},{"location":"java/1401-1500/1401-1410/#1407-top-travellers-star","text":"","title":"1407. Top Travellers $\\star$ \ud83d\udd12"},{"location":"java/1401-1500/1401-1410/#1408-string-matching-in-an-array-star","text":"","title":"1408. String Matching in an Array $\\star$"},{"location":"java/1401-1500/1401-1410/#1409-queries-on-a-permutation-with-key-starstar","text":"","title":"1409. Queries on a Permutation With Key $\\star\\star$"},{"location":"java/1401-1500/1401-1410/#1410-html-entity-parser-starstar","text":"","title":"1410. HTML Entity Parser $\\star\\star$"},{"location":"java/1401-1500/1411-1420/","text":"1411. Number of Ways to Paint N \u00d7 3 Grid $\\star\\star\\star$ 1412. Find the Quiet Students in All Exams $\\star\\star\\star$ \ud83d\udd12 1413. Minimum Value to Get Positive Step by Step Sum $\\star$ 1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K $\\star\\star$ 1415. The k-th Lexicographical String of All Happy Strings of Length n $\\star\\star$ 1416. Restore The Array $\\star\\star\\star$ 1417. Reformat The String $\\star$ 1418. Display Table of Food Orders in a Restaurant $\\star\\star$ 1419. Minimum Number of Frogs Croaking $\\star\\star$ 1420. Build Array Where You Can Find The Maximum Exactly K Comparisons $\\star\\star\\star$","title":"1411-1420"},{"location":"java/1401-1500/1411-1420/#1411-number-of-ways-to-paint-n-3-grid-starstarstar","text":"","title":"1411. Number of Ways to Paint N \u00d7 3 Grid $\\star\\star\\star$"},{"location":"java/1401-1500/1411-1420/#1412-find-the-quiet-students-in-all-exams-starstarstar","text":"","title":"1412. Find the Quiet Students in All Exams $\\star\\star\\star$ \ud83d\udd12"},{"location":"java/1401-1500/1411-1420/#1413-minimum-value-to-get-positive-step-by-step-sum-star","text":"","title":"1413. Minimum Value to Get Positive Step by Step Sum $\\star$"},{"location":"java/1401-1500/1411-1420/#1414-find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k-starstar","text":"","title":"1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K $\\star\\star$"},{"location":"java/1401-1500/1411-1420/#1415-the-k-th-lexicographical-string-of-all-happy-strings-of-length-n-starstar","text":"","title":"1415. The k-th Lexicographical String of All Happy Strings of Length n $\\star\\star$"},{"location":"java/1401-1500/1411-1420/#1416-restore-the-array-starstarstar","text":"","title":"1416. Restore The Array $\\star\\star\\star$"},{"location":"java/1401-1500/1411-1420/#1417-reformat-the-string-star","text":"","title":"1417. Reformat The String $\\star$"},{"location":"java/1401-1500/1411-1420/#1418-display-table-of-food-orders-in-a-restaurant-starstar","text":"","title":"1418. Display Table of Food Orders in a Restaurant $\\star\\star$"},{"location":"java/1401-1500/1411-1420/#1419-minimum-number-of-frogs-croaking-starstar","text":"","title":"1419. Minimum Number of Frogs Croaking $\\star\\star$"},{"location":"java/1401-1500/1411-1420/#1420-build-array-where-you-can-find-the-maximum-exactly-k-comparisons-starstarstar","text":"","title":"1420. Build Array Where You Can Find The Maximum Exactly K Comparisons $\\star\\star\\star$"},{"location":"java/1401-1500/1421-1430/","text":"1421. NPV Queries $\\star\\star$ \ud83d\udd12 1422. Maximum Score After Splitting a String $\\star$ 1423. Maximum Points You Can Obtain from Cards $\\star\\star$ 1424. Diagonal Traverse II $\\star\\star$ 1425. Constrained Subsequence Sum $\\star\\star\\star$ class Solution { public int constrainedSubsetSum ( int [] nums , int k ) { int ans = Integer . MIN_VALUE ; int [] dp = new int [ nums . length ] ; Deque < Integer > q = new ArrayDeque <> (); for ( int i = 0 ; i < nums . length ; ++ i ) { if ( q . isEmpty ()) dp [ i ] = nums [ i ] ; else dp [ i ] = Math . max ( q . peekFirst (), 0 ) + nums [ i ] ; ans = Math . max ( ans , dp [ i ] ); while ( ! q . isEmpty () && q . peekLast () < dp [ i ] ) q . pollLast (); q . offerLast ( dp [ i ] ); if ( i >= k && dp [ i - k ] == q . peekFirst ()) q . pollFirst (); } return ans ; } } 1426. Counting Elements $\\star$ \ud83d\udd12 1427. Perform String Shifts $\\star$ \ud83d\udd12 1428. Leftmost Column with at Least a One $\\star\\star$ \ud83d\udd12 1429. First Unique Number $\\star\\star$ \ud83d\udd12 1430. Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree $\\star\\star$ \ud83d\udd12","title":"1421-1430"},{"location":"java/1401-1500/1421-1430/#1421-npv-queries-starstar","text":"","title":"1421. NPV Queries $\\star\\star$ \ud83d\udd12"},{"location":"java/1401-1500/1421-1430/#1422-maximum-score-after-splitting-a-string-star","text":"","title":"1422. Maximum Score After Splitting a String $\\star$"},{"location":"java/1401-1500/1421-1430/#1423-maximum-points-you-can-obtain-from-cards-starstar","text":"","title":"1423. Maximum Points You Can Obtain from Cards $\\star\\star$"},{"location":"java/1401-1500/1421-1430/#1424-diagonal-traverse-ii-starstar","text":"","title":"1424. Diagonal Traverse II $\\star\\star$"},{"location":"java/1401-1500/1421-1430/#1425-constrained-subsequence-sum-starstarstar","text":"class Solution { public int constrainedSubsetSum ( int [] nums , int k ) { int ans = Integer . MIN_VALUE ; int [] dp = new int [ nums . length ] ; Deque < Integer > q = new ArrayDeque <> (); for ( int i = 0 ; i < nums . length ; ++ i ) { if ( q . isEmpty ()) dp [ i ] = nums [ i ] ; else dp [ i ] = Math . max ( q . peekFirst (), 0 ) + nums [ i ] ; ans = Math . max ( ans , dp [ i ] ); while ( ! q . isEmpty () && q . peekLast () < dp [ i ] ) q . pollLast (); q . offerLast ( dp [ i ] ); if ( i >= k && dp [ i - k ] == q . peekFirst ()) q . pollFirst (); } return ans ; } }","title":"1425. Constrained Subsequence Sum $\\star\\star\\star$"},{"location":"java/1401-1500/1421-1430/#1426-counting-elements-star","text":"","title":"1426. Counting Elements $\\star$ \ud83d\udd12"},{"location":"java/1401-1500/1421-1430/#1427-perform-string-shifts-star","text":"","title":"1427. Perform String Shifts $\\star$ \ud83d\udd12"},{"location":"java/1401-1500/1421-1430/#1428-leftmost-column-with-at-least-a-one-starstar","text":"","title":"1428. Leftmost Column with at Least a One $\\star\\star$ \ud83d\udd12"},{"location":"java/1401-1500/1421-1430/#1429-first-unique-number-starstar","text":"","title":"1429. First Unique Number $\\star\\star$ \ud83d\udd12"},{"location":"java/1401-1500/1421-1430/#1430-check-if-a-string-is-a-valid-sequence-from-root-to-leaves-path-in-a-binary-tree-starstar","text":"","title":"1430. Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree $\\star\\star$ \ud83d\udd12"},{"location":"java/1401-1500/1431-1440/","text":"1431. Kids With the Greatest Number of Candies $\\star$ 1432. Max Difference You Can Get From Changing an Integer $\\star\\star$ 1433. Check If a String Can Break Another String $\\star\\star$ 1434. Number of Ways to Wear Different Hats to Each Other $\\star\\star\\star$ 1435. Create a Session Bar Chart $\\star$ \ud83d\udd12 1436. Destination City $\\star$ 1437. Check If All 1's Are at Least Length K Places Away $\\star\\star$ 1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit $\\star\\star$ 1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows $\\star\\star\\star$ 1440. Evaluate Boolean Expression $\\star\\star$ \ud83d\udd12","title":"1431-1440"},{"location":"java/1401-1500/1431-1440/#1431-kids-with-the-greatest-number-of-candies-star","text":"","title":"1431. Kids With the Greatest Number of Candies $\\star$"},{"location":"java/1401-1500/1431-1440/#1432-max-difference-you-can-get-from-changing-an-integer-starstar","text":"","title":"1432. Max Difference You Can Get From Changing an Integer $\\star\\star$"},{"location":"java/1401-1500/1431-1440/#1433-check-if-a-string-can-break-another-string-starstar","text":"","title":"1433. Check If a String Can Break Another String $\\star\\star$"},{"location":"java/1401-1500/1431-1440/#1434-number-of-ways-to-wear-different-hats-to-each-other-starstarstar","text":"","title":"1434. Number of Ways to Wear Different Hats to Each Other $\\star\\star\\star$"},{"location":"java/1401-1500/1431-1440/#1435-create-a-session-bar-chart-star","text":"","title":"1435. Create a Session Bar Chart $\\star$ \ud83d\udd12"},{"location":"java/1401-1500/1431-1440/#1436-destination-city-star","text":"","title":"1436. Destination City $\\star$"},{"location":"java/1401-1500/1431-1440/#1437-check-if-all-1s-are-at-least-length-k-places-away-starstar","text":"","title":"1437. Check If All 1's Are at Least Length K Places Away $\\star\\star$"},{"location":"java/1401-1500/1431-1440/#1438-longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit-starstar","text":"","title":"1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit $\\star\\star$"},{"location":"java/1401-1500/1431-1440/#1439-find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows-starstarstar","text":"","title":"1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows $\\star\\star\\star$"},{"location":"java/1401-1500/1431-1440/#1440-evaluate-boolean-expression-starstar","text":"","title":"1440. Evaluate Boolean Expression $\\star\\star$ \ud83d\udd12"},{"location":"java/1401-1500/1441-1450/","text":"1441. Build an Array With Stack Operations $\\star$ 1442. Count Triplets That Can Form Two Arrays of Equal XOR $\\star\\star$ 1443. Minimum Time to Collect All Apples in a Tree $\\star\\star$ 1444. Number of Ways of Cutting a Pizza $\\star\\star\\star$ 1445. Apples & Oranges $\\star\\star$ \ud83d\udd12 1446. Consecutive Characters $\\star$ 1447. Simplified Fractions $\\star\\star$ 1448. Count Good Nodes in Binary Tree $\\star\\star$ 1449. Form Largest Integer With Digits That Add up to Target $\\star\\star\\star$ 1450. Number of Students Doing Homework at a Given Time $\\star$","title":"1441-1450"},{"location":"java/1401-1500/1441-1450/#1441-build-an-array-with-stack-operations-star","text":"","title":"1441. Build an Array With Stack Operations $\\star$"},{"location":"java/1401-1500/1441-1450/#1442-count-triplets-that-can-form-two-arrays-of-equal-xor-starstar","text":"","title":"1442. Count Triplets That Can Form Two Arrays of Equal XOR $\\star\\star$"},{"location":"java/1401-1500/1441-1450/#1443-minimum-time-to-collect-all-apples-in-a-tree-starstar","text":"","title":"1443. Minimum Time to Collect All Apples in a Tree $\\star\\star$"},{"location":"java/1401-1500/1441-1450/#1444-number-of-ways-of-cutting-a-pizza-starstarstar","text":"","title":"1444. Number of Ways of Cutting a Pizza $\\star\\star\\star$"},{"location":"java/1401-1500/1441-1450/#1445-apples-oranges-starstar","text":"","title":"1445. Apples &amp; Oranges $\\star\\star$ \ud83d\udd12"},{"location":"java/1401-1500/1441-1450/#1446-consecutive-characters-star","text":"","title":"1446. Consecutive Characters $\\star$"},{"location":"java/1401-1500/1441-1450/#1447-simplified-fractions-starstar","text":"","title":"1447. Simplified Fractions $\\star\\star$"},{"location":"java/1401-1500/1441-1450/#1448-count-good-nodes-in-binary-tree-starstar","text":"","title":"1448. Count Good Nodes in Binary Tree $\\star\\star$"},{"location":"java/1401-1500/1441-1450/#1449-form-largest-integer-with-digits-that-add-up-to-target-starstarstar","text":"","title":"1449. Form Largest Integer With Digits That Add up to Target $\\star\\star\\star$"},{"location":"java/1401-1500/1441-1450/#1450-number-of-students-doing-homework-at-a-given-time-star","text":"","title":"1450. Number of Students Doing Homework at a Given Time $\\star$"},{"location":"java/1401-1500/1451-1460/","text":"1451. Rearrange Words in a Sentence $\\star\\star$ 1452. People Whose List of Favorite Companies Is Not a Subset of Another List $\\star\\star$ 1453. Maximum Number of Darts Inside of a Circular Dartboard $\\star\\star\\star$ 1454. Active Users $\\star\\star$ \ud83d\udd12 1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence $\\star$ 1456. Maximum Number of Vowels in a Substring of Given Length $\\star\\star$ 1457. Pseudo-Palindromic Paths in a Binary Tree $\\star\\star$ 1458. Max Dot Product of Two Subsequences $\\star\\star\\star$","title":"1451-1460"},{"location":"java/1401-1500/1451-1460/#1451-rearrange-words-in-a-sentence-starstar","text":"","title":"1451. Rearrange Words in a Sentence $\\star\\star$"},{"location":"java/1401-1500/1451-1460/#1452-people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list-starstar","text":"","title":"1452. People Whose List of Favorite Companies Is Not a Subset of Another List $\\star\\star$"},{"location":"java/1401-1500/1451-1460/#1453-maximum-number-of-darts-inside-of-a-circular-dartboard-starstarstar","text":"","title":"1453. Maximum Number of Darts Inside of a Circular Dartboard $\\star\\star\\star$"},{"location":"java/1401-1500/1451-1460/#1454-active-users-starstar","text":"","title":"1454. Active Users $\\star\\star$ \ud83d\udd12"},{"location":"java/1401-1500/1451-1460/#1455-check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence-star","text":"","title":"1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence $\\star$"},{"location":"java/1401-1500/1451-1460/#1456-maximum-number-of-vowels-in-a-substring-of-given-length-starstar","text":"","title":"1456. Maximum Number of Vowels in a Substring of Given Length $\\star\\star$"},{"location":"java/1401-1500/1451-1460/#1457-pseudo-palindromic-paths-in-a-binary-tree-starstar","text":"","title":"1457. Pseudo-Palindromic Paths in a Binary Tree $\\star\\star$"},{"location":"java/1401-1500/1451-1460/#1458-max-dot-product-of-two-subsequences-starstarstar","text":"","title":"1458. Max Dot Product of Two Subsequences $\\star\\star\\star$"},{"location":"python3/","text":"LeetCode in Python Python code is formatted by PEP 8 -- Style Guide for Python Code . Try to write pythonic code as possible as I can, but sometimes it's hard. Not a fan of 1-liner, but I have to admit that sometimes 1-liner is savvy.","title":"Preface"},{"location":"python3/#leetcode-in-python","text":"Python code is formatted by PEP 8 -- Style Guide for Python Code . Try to write pythonic code as possible as I can, but sometimes it's hard. Not a fan of 1-liner, but I have to admit that sometimes 1-liner is savvy.","title":"LeetCode in Python"},{"location":"python3/0001-0100/0001-0010/","text":"1. Two Sum $\\star$ Time: $O(n)$ Space: $O(n)$ class Solution : def twoSum ( self , nums : List [ int ], target : int ) -> List [ int ]: numToIndex = {} for i , num in enumerate ( nums ): if target - num in numToIndex : return numToIndex [ target - num ], i numToIndex [ num ] = i 2. Add Two Numbers $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def addTwoNumbers ( self , l1 : ListNode , l2 : ListNode ) -> ListNode : dummy = ListNode ( 0 ) curr = dummy carry = 0 while carry or l1 or l2 : carry += ( l1 . val if l1 else 0 ) + ( l2 . val if l2 else 0 ) curr . next = ListNode ( carry % 10 ) curr = curr . next carry //= 10 if l1 : l1 = l1 . next if l2 : l2 = l2 . next return dummy . next 3. Longest Substring Without Repeating Characters $\\star\\star$ Time: $O(n)$ Space: $O(128)$ class Solution : def lengthOfLongestSubstring ( self , s : str ) -> int : ans = 0 count = collections . Counter () l = 0 for r , c in enumerate ( s ): count [ c ] += 1 while count [ c ] > 1 : count [ s [ l ]] -= 1 l += 1 ans = max ( ans , r - l + 1 ) return ans 4. Median of Two Sorted Arrays $\\star\\star\\star$ Time: $O(\\log\\min(m, n))$ Space: $O(1)$ class Solution : def findMedianSortedArrays ( self , nums1 : List [ int ], nums2 : List [ int ]) -> float : n1 = len ( nums1 ) n2 = len ( nums2 ) if n1 > n2 : return self . findMedianSortedArrays ( nums2 , nums1 ) l = 0 r = n1 while l <= r : partition1 = l + ( r - l ) // 2 partition2 = ( n1 + n2 + 1 ) // 2 - partition1 maxLeft1 = - 2 ** 31 if partition1 == 0 else nums1 [ partition1 - 1 ] maxLeft2 = - 2 ** 31 if partition2 == 0 else nums2 [ partition2 - 1 ] minRight1 = 2 ** 31 - 1 if partition1 == n1 else nums1 [ partition1 ] minRight2 = 2 ** 31 - 1 if partition2 == n2 else nums2 [ partition2 ] if maxLeft1 <= minRight2 and maxLeft2 <= minRight1 : return ( max ( maxLeft1 , maxLeft2 ) + min ( minRight1 , minRight2 )) * 0.5 if ( n1 + n2 ) % 2 == 0 else max ( maxLeft1 , maxLeft2 ) elif maxLeft1 > minRight2 : r = partition1 - 1 else : l = partition1 + 1 5. Longest Palindromic Substring $\\star\\star$ Time: $O(n^2)$ Space: $O(1)$ class Solution : def longestPalindrome ( self , s : str ) -> str : T = '$#' + '#' . join ( s ) + '#@' center = 1 right = 1 P = [ 0 ] * len ( T ) for i in range ( 1 , len ( T ) - 1 ): mirr = 2 * center - i if i < right : P [ i ] = min ( P [ mirr ], right - i ) while T [ i + P [ i ] + 1 ] == T [ i - P [ i ] - 1 ]: P [ i ] += 1 if i + P [ i ] > right : center = i right = i + P [ i ] max = 0 c = 0 for i in range ( len ( T )): if P [ i ] > max : max = P [ i ] c = i return T [ c - max + 1 : c + max ] . replace ( '#' , '' ) 6. ZigZag Conversion $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution : def convert ( self , s : str , numRows : int ) -> str : rows = [ '' ] * numRows k = 0 direction = ( numRows == 1 ) - 1 for c in s : rows [ k ] += c if k == 0 or k == numRows - 1 : direction *= - 1 k += direction return '' . join ( rows ) 7. Reverse Integer $\\star$ Time: $O(\\log x)$ Space: $O(1)$ class Solution : def reverse ( self , x : int ) -> int : ans = 0 sign = - 1 if x < 0 else 1 x *= sign while x : ans = ans * 10 + x % 10 x //= 10 return 0 if ans < - 2 ** 31 or ans > 2 ** 31 - 1 else sign * ans 8. String to Integer (atoi) $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def myAtoi ( self , str : str ) -> int : ans = 0 str = str . strip () if not str : return 0 sign = - 1 if str [ 0 ] == '-' else 1 if str [ 0 ] in { '-' , '+' }: str = str [ 1 :] for c in str : if not c . isdigit (): break ans = ans * 10 + ord ( c ) - ord ( '0' ) return max ( - 2 ** 31 , min ( 2 ** 31 - 1 , sign * ans )) 9. Palindrome Number $\\star$ Time: $O\\log x)$ Space: $O(1)$ class Solution : def isPalindrome ( self , x : int ) -> bool : if x < 0 : return False ans = 0 y = x while y : ans = ans * 10 + y % 10 y //= 10 return ans == x 10. Regular Expression Matching $\\star\\star\\star$ Time: $O(mn)$ Space: $O(n^2) \\to O(n)$ class Solution : def isMatch ( self , s : str , p : str ) -> bool : if not p : return not s firstMatch = bool ( s ) and p [ 0 ] in { s [ 0 ], '.' } if len ( p ) >= 2 and p [ 1 ] == '*' : return ( self . isMatch ( s , p [ 2 :]) or firstMatch and self . isMatch ( s [ 1 :], p )) return firstMatch and self . isMatch ( s [ 1 :], p [ 1 :])","title":"0001-0010"},{"location":"python3/0001-0100/0001-0010/#1-two-sum-star","text":"Time: $O(n)$ Space: $O(n)$ class Solution : def twoSum ( self , nums : List [ int ], target : int ) -> List [ int ]: numToIndex = {} for i , num in enumerate ( nums ): if target - num in numToIndex : return numToIndex [ target - num ], i numToIndex [ num ] = i","title":"1. Two Sum $\\star$"},{"location":"python3/0001-0100/0001-0010/#2-add-two-numbers-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def addTwoNumbers ( self , l1 : ListNode , l2 : ListNode ) -> ListNode : dummy = ListNode ( 0 ) curr = dummy carry = 0 while carry or l1 or l2 : carry += ( l1 . val if l1 else 0 ) + ( l2 . val if l2 else 0 ) curr . next = ListNode ( carry % 10 ) curr = curr . next carry //= 10 if l1 : l1 = l1 . next if l2 : l2 = l2 . next return dummy . next","title":"2. Add Two Numbers $\\star\\star$"},{"location":"python3/0001-0100/0001-0010/#3-longest-substring-without-repeating-characters-starstar","text":"Time: $O(n)$ Space: $O(128)$ class Solution : def lengthOfLongestSubstring ( self , s : str ) -> int : ans = 0 count = collections . Counter () l = 0 for r , c in enumerate ( s ): count [ c ] += 1 while count [ c ] > 1 : count [ s [ l ]] -= 1 l += 1 ans = max ( ans , r - l + 1 ) return ans","title":"3. Longest Substring Without Repeating Characters $\\star\\star$"},{"location":"python3/0001-0100/0001-0010/#4-median-of-two-sorted-arrays-starstarstar","text":"Time: $O(\\log\\min(m, n))$ Space: $O(1)$ class Solution : def findMedianSortedArrays ( self , nums1 : List [ int ], nums2 : List [ int ]) -> float : n1 = len ( nums1 ) n2 = len ( nums2 ) if n1 > n2 : return self . findMedianSortedArrays ( nums2 , nums1 ) l = 0 r = n1 while l <= r : partition1 = l + ( r - l ) // 2 partition2 = ( n1 + n2 + 1 ) // 2 - partition1 maxLeft1 = - 2 ** 31 if partition1 == 0 else nums1 [ partition1 - 1 ] maxLeft2 = - 2 ** 31 if partition2 == 0 else nums2 [ partition2 - 1 ] minRight1 = 2 ** 31 - 1 if partition1 == n1 else nums1 [ partition1 ] minRight2 = 2 ** 31 - 1 if partition2 == n2 else nums2 [ partition2 ] if maxLeft1 <= minRight2 and maxLeft2 <= minRight1 : return ( max ( maxLeft1 , maxLeft2 ) + min ( minRight1 , minRight2 )) * 0.5 if ( n1 + n2 ) % 2 == 0 else max ( maxLeft1 , maxLeft2 ) elif maxLeft1 > minRight2 : r = partition1 - 1 else : l = partition1 + 1","title":"4. Median of Two Sorted Arrays $\\star\\star\\star$"},{"location":"python3/0001-0100/0001-0010/#5-longest-palindromic-substring-starstar","text":"Time: $O(n^2)$ Space: $O(1)$ class Solution : def longestPalindrome ( self , s : str ) -> str : T = '$#' + '#' . join ( s ) + '#@' center = 1 right = 1 P = [ 0 ] * len ( T ) for i in range ( 1 , len ( T ) - 1 ): mirr = 2 * center - i if i < right : P [ i ] = min ( P [ mirr ], right - i ) while T [ i + P [ i ] + 1 ] == T [ i - P [ i ] - 1 ]: P [ i ] += 1 if i + P [ i ] > right : center = i right = i + P [ i ] max = 0 c = 0 for i in range ( len ( T )): if P [ i ] > max : max = P [ i ] c = i return T [ c - max + 1 : c + max ] . replace ( '#' , '' )","title":"5. Longest Palindromic Substring $\\star\\star$"},{"location":"python3/0001-0100/0001-0010/#6-zigzag-conversion-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution : def convert ( self , s : str , numRows : int ) -> str : rows = [ '' ] * numRows k = 0 direction = ( numRows == 1 ) - 1 for c in s : rows [ k ] += c if k == 0 or k == numRows - 1 : direction *= - 1 k += direction return '' . join ( rows )","title":"6. ZigZag Conversion $\\star\\star$"},{"location":"python3/0001-0100/0001-0010/#7-reverse-integer-star","text":"Time: $O(\\log x)$ Space: $O(1)$ class Solution : def reverse ( self , x : int ) -> int : ans = 0 sign = - 1 if x < 0 else 1 x *= sign while x : ans = ans * 10 + x % 10 x //= 10 return 0 if ans < - 2 ** 31 or ans > 2 ** 31 - 1 else sign * ans","title":"7. Reverse Integer $\\star$"},{"location":"python3/0001-0100/0001-0010/#8-string-to-integer-atoi-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def myAtoi ( self , str : str ) -> int : ans = 0 str = str . strip () if not str : return 0 sign = - 1 if str [ 0 ] == '-' else 1 if str [ 0 ] in { '-' , '+' }: str = str [ 1 :] for c in str : if not c . isdigit (): break ans = ans * 10 + ord ( c ) - ord ( '0' ) return max ( - 2 ** 31 , min ( 2 ** 31 - 1 , sign * ans ))","title":"8. String to Integer (atoi) $\\star\\star$"},{"location":"python3/0001-0100/0001-0010/#9-palindrome-number-star","text":"Time: $O\\log x)$ Space: $O(1)$ class Solution : def isPalindrome ( self , x : int ) -> bool : if x < 0 : return False ans = 0 y = x while y : ans = ans * 10 + y % 10 y //= 10 return ans == x","title":"9. Palindrome Number $\\star$"},{"location":"python3/0001-0100/0001-0010/#10-regular-expression-matching-starstarstar","text":"Time: $O(mn)$ Space: $O(n^2) \\to O(n)$ class Solution : def isMatch ( self , s : str , p : str ) -> bool : if not p : return not s firstMatch = bool ( s ) and p [ 0 ] in { s [ 0 ], '.' } if len ( p ) >= 2 and p [ 1 ] == '*' : return ( self . isMatch ( s , p [ 2 :]) or firstMatch and self . isMatch ( s [ 1 :], p )) return firstMatch and self . isMatch ( s [ 1 :], p [ 1 :])","title":"10. Regular Expression Matching $\\star\\star\\star$"},{"location":"python3/0001-0100/0011-0020/","text":"11. Container With Most Water $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def maxArea ( self , height : List [ int ]) -> int : ans = 0 l = 0 r = len ( height ) - 1 while l < r : h = min ( height [ l ], height [ r ]) ans = max ( ans , ( r - l ) * h ) while height [ l ] <= h and l < r : l += 1 while height [ r ] <= h and l < r : r -= 1 return ans 12. Integer to Roman $\\star\\star$ Time: $O(1)$ Space: $O(k)$ class Solution : def intToRoman ( self , num : int ) -> str : M = [ \"\" , \"M\" , \"MM\" , \"MMM\" ] C = [ \"\" , \"C\" , \"CC\" , \"CCC\" , \"CD\" , \"D\" , \"DC\" , \"DCC\" , \"DCCC\" , \"CM\" ] X = [ \"\" , \"X\" , \"XX\" , \"XXX\" , \"XL\" , \"L\" , \"LX\" , \"LXX\" , \"LXXX\" , \"XC\" ] I = [ \"\" , \"I\" , \"II\" , \"III\" , \"IV\" , \"V\" , \"VI\" , \"VII\" , \"VIII\" , \"IX\" ] return M [ num // 1000 ] + C [ num % 1000 // 100 ] + X [ num % 100 // 10 ] + I [ num % 10 ] 13. Roman to Integer $\\star$ Time: $O(n)$ Space: $O(24)$ class Solution : def romanToInt ( self , s : str ) -> int : ans = 0 roman = { 'I' : 1 , 'V' : 5 , 'X' : 10 , 'L' : 50 , 'C' : 100 , 'D' : 500 , 'M' : 1000 } for a , b in zip ( s , s [ 1 :]): if roman [ a ] < roman [ b ]: ans -= roman [ a ] else : ans += roman [ a ] return ans + roman [ s [ - 1 ]] 14. Longest Common Prefix $\\star$ Time: $O(nm)$, where n = len(strs) and m = len(strs[i]) Space: $O(1)$ class Solution : def longestCommonPrefix ( self , strs : List [ str ]) -> str : if len ( strs ) == 0 : return \"\" if len ( strs ) == 1 : return strs [ 0 ] ans = \"\" mini = len ( strs [ 0 ]) isMatch = True for i in range ( 1 , len ( strs )): mini = min ( mini , len ( strs [ i ])) for i in range ( mini ): c = strs [ 0 ][ i ] for j in range ( 1 , len ( strs )): if c != strs [ j ][ i ]: isMatch = False break if not isMatch : break ans += c return ans 15. 3Sum $\\star\\star$ Time: $O(n^2)$ Space: $O(1)$ class Solution : def threeSum ( self , nums : List [ int ]) -> List [ List [ int ]]: ans = [] nums . sort () for i in range ( len ( nums ) - 2 ): if i > 0 and nums [ i ] == nums [ i - 1 ]: continue l = i + 1 r = len ( nums ) - 1 while l < r : sum = nums [ i ] + nums [ l ] + nums [ r ] if sum == 0 : ans . append (( nums [ i ], nums [ l ], nums [ r ])) l += 1 r -= 1 while nums [ l ] == nums [ l - 1 ] and l < r : l += 1 while nums [ r ] == nums [ r + 1 ] and l < r : r -= 1 elif sum < 0 : l += 1 else : r -= 1 return ans 16. 3Sum Closest $\\star\\star$ Time: $O(n^2)$ Space: $O(1)$ class Solution : def threeSumClosest ( self , nums : List [ int ], target : int ) -> int : ans = nums [ 0 ] + nums [ 1 ] + nums [ 2 ] nums . sort () for i in range ( len ( nums ) - 2 ): l = i + 1 r = len ( nums ) - 1 while l < r : sum = nums [ i ] + nums [ l ] + nums [ r ] if sum == target : return sum if abs ( sum - target ) < abs ( ans - target ): ans = sum if sum < target : l += 1 else : r -= 1 return ans 17. Letter Combinations of a Phone Number $\\star\\star$ Time: $O(n4^n)$ Space: $O(4^n)$ class Solution : def letterCombinations ( self , digits : str ) -> List [ str ]: if not digits : return [] ans = [ '' ] dict = { '2' : 'abc' , '3' : 'def' , '4' : 'ghi' , '5' : 'jkl' , '6' : 'mno' , '7' : 'pqrs' , '8' : 'tuv' , '9' : 'wxyz' } for i in digits : tmp = [] for j in ans : for k in dict [ i ]: tmp . append ( j + k ) ans = tmp return ans 18. 4Sum $\\star\\star$ Time: $O(n^3)$ Space: $O(1)$ class Solution : def fourSum ( self , nums : List [ int ], target : int ): def nSum ( l : int , r : int , target : int , n : int , path : List [ int ], ans : List [ List [ int ]]): if r - l + 1 < n or n < 2 or target < nums [ l ] * n or target > nums [ r ] * n : return if n == 2 : while l < r : sum = nums [ l ] + nums [ r ] if sum == target : ans . append ( path + [ nums [ l ], nums [ r ]]) l += 1 while nums [ l ] == nums [ l - 1 ] and l < r : l += 1 elif sum < target : l += 1 else : r -= 1 return for i in range ( l , r + 1 ): if i > l and nums [ i ] == nums [ i - 1 ]: continue nSum ( i + 1 , r , target - nums [ i ], n - 1 , path + [ nums [ i ]], ans ) ans = [] nums . sort () nSum ( 0 , len ( nums ) - 1 , target , 4 , [], ans ) return ans 19. Remove Nth Node From End of List $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def removeNthFromEnd ( self , head : ListNode , n : int ) -> ListNode : slow = head fast = head for _ in range ( n ): fast = fast . next if not fast : return head . next while fast . next : slow = slow . next fast = fast . next slow . next = slow . next . next return head 20. Valid Parentheses $\\star$ Time: $O(n)$ Space: $O(n)$ class Solution : def isValid ( self , s : str ) -> bool : stack = [] for c in s : if c == '(' or c == '{' or c == '[' : stack . append ( c ) else : if not stack or \\ c == ')' and stack [ - 1 ] != '(' or \\ c == '}' and stack [ - 1 ] != '{' or \\ c == ']' and stack [ - 1 ] != '[' : return False stack . pop () return not stack","title":"0011-0020"},{"location":"python3/0001-0100/0011-0020/#11-container-with-most-water-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def maxArea ( self , height : List [ int ]) -> int : ans = 0 l = 0 r = len ( height ) - 1 while l < r : h = min ( height [ l ], height [ r ]) ans = max ( ans , ( r - l ) * h ) while height [ l ] <= h and l < r : l += 1 while height [ r ] <= h and l < r : r -= 1 return ans","title":"11. Container With Most Water $\\star\\star$"},{"location":"python3/0001-0100/0011-0020/#12-integer-to-roman-starstar","text":"Time: $O(1)$ Space: $O(k)$ class Solution : def intToRoman ( self , num : int ) -> str : M = [ \"\" , \"M\" , \"MM\" , \"MMM\" ] C = [ \"\" , \"C\" , \"CC\" , \"CCC\" , \"CD\" , \"D\" , \"DC\" , \"DCC\" , \"DCCC\" , \"CM\" ] X = [ \"\" , \"X\" , \"XX\" , \"XXX\" , \"XL\" , \"L\" , \"LX\" , \"LXX\" , \"LXXX\" , \"XC\" ] I = [ \"\" , \"I\" , \"II\" , \"III\" , \"IV\" , \"V\" , \"VI\" , \"VII\" , \"VIII\" , \"IX\" ] return M [ num // 1000 ] + C [ num % 1000 // 100 ] + X [ num % 100 // 10 ] + I [ num % 10 ]","title":"12. Integer to Roman $\\star\\star$"},{"location":"python3/0001-0100/0011-0020/#13-roman-to-integer-star","text":"Time: $O(n)$ Space: $O(24)$ class Solution : def romanToInt ( self , s : str ) -> int : ans = 0 roman = { 'I' : 1 , 'V' : 5 , 'X' : 10 , 'L' : 50 , 'C' : 100 , 'D' : 500 , 'M' : 1000 } for a , b in zip ( s , s [ 1 :]): if roman [ a ] < roman [ b ]: ans -= roman [ a ] else : ans += roman [ a ] return ans + roman [ s [ - 1 ]]","title":"13. Roman to Integer $\\star$"},{"location":"python3/0001-0100/0011-0020/#14-longest-common-prefix-star","text":"Time: $O(nm)$, where n = len(strs) and m = len(strs[i]) Space: $O(1)$ class Solution : def longestCommonPrefix ( self , strs : List [ str ]) -> str : if len ( strs ) == 0 : return \"\" if len ( strs ) == 1 : return strs [ 0 ] ans = \"\" mini = len ( strs [ 0 ]) isMatch = True for i in range ( 1 , len ( strs )): mini = min ( mini , len ( strs [ i ])) for i in range ( mini ): c = strs [ 0 ][ i ] for j in range ( 1 , len ( strs )): if c != strs [ j ][ i ]: isMatch = False break if not isMatch : break ans += c return ans","title":"14. Longest Common Prefix $\\star$"},{"location":"python3/0001-0100/0011-0020/#15-3sum-starstar","text":"Time: $O(n^2)$ Space: $O(1)$ class Solution : def threeSum ( self , nums : List [ int ]) -> List [ List [ int ]]: ans = [] nums . sort () for i in range ( len ( nums ) - 2 ): if i > 0 and nums [ i ] == nums [ i - 1 ]: continue l = i + 1 r = len ( nums ) - 1 while l < r : sum = nums [ i ] + nums [ l ] + nums [ r ] if sum == 0 : ans . append (( nums [ i ], nums [ l ], nums [ r ])) l += 1 r -= 1 while nums [ l ] == nums [ l - 1 ] and l < r : l += 1 while nums [ r ] == nums [ r + 1 ] and l < r : r -= 1 elif sum < 0 : l += 1 else : r -= 1 return ans","title":"15. 3Sum $\\star\\star$"},{"location":"python3/0001-0100/0011-0020/#16-3sum-closest-starstar","text":"Time: $O(n^2)$ Space: $O(1)$ class Solution : def threeSumClosest ( self , nums : List [ int ], target : int ) -> int : ans = nums [ 0 ] + nums [ 1 ] + nums [ 2 ] nums . sort () for i in range ( len ( nums ) - 2 ): l = i + 1 r = len ( nums ) - 1 while l < r : sum = nums [ i ] + nums [ l ] + nums [ r ] if sum == target : return sum if abs ( sum - target ) < abs ( ans - target ): ans = sum if sum < target : l += 1 else : r -= 1 return ans","title":"16. 3Sum Closest $\\star\\star$"},{"location":"python3/0001-0100/0011-0020/#17-letter-combinations-of-a-phone-number-starstar","text":"Time: $O(n4^n)$ Space: $O(4^n)$ class Solution : def letterCombinations ( self , digits : str ) -> List [ str ]: if not digits : return [] ans = [ '' ] dict = { '2' : 'abc' , '3' : 'def' , '4' : 'ghi' , '5' : 'jkl' , '6' : 'mno' , '7' : 'pqrs' , '8' : 'tuv' , '9' : 'wxyz' } for i in digits : tmp = [] for j in ans : for k in dict [ i ]: tmp . append ( j + k ) ans = tmp return ans","title":"17. Letter Combinations of a Phone Number $\\star\\star$"},{"location":"python3/0001-0100/0011-0020/#18-4sum-starstar","text":"Time: $O(n^3)$ Space: $O(1)$ class Solution : def fourSum ( self , nums : List [ int ], target : int ): def nSum ( l : int , r : int , target : int , n : int , path : List [ int ], ans : List [ List [ int ]]): if r - l + 1 < n or n < 2 or target < nums [ l ] * n or target > nums [ r ] * n : return if n == 2 : while l < r : sum = nums [ l ] + nums [ r ] if sum == target : ans . append ( path + [ nums [ l ], nums [ r ]]) l += 1 while nums [ l ] == nums [ l - 1 ] and l < r : l += 1 elif sum < target : l += 1 else : r -= 1 return for i in range ( l , r + 1 ): if i > l and nums [ i ] == nums [ i - 1 ]: continue nSum ( i + 1 , r , target - nums [ i ], n - 1 , path + [ nums [ i ]], ans ) ans = [] nums . sort () nSum ( 0 , len ( nums ) - 1 , target , 4 , [], ans ) return ans","title":"18. 4Sum $\\star\\star$"},{"location":"python3/0001-0100/0011-0020/#19-remove-nth-node-from-end-of-list-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def removeNthFromEnd ( self , head : ListNode , n : int ) -> ListNode : slow = head fast = head for _ in range ( n ): fast = fast . next if not fast : return head . next while fast . next : slow = slow . next fast = fast . next slow . next = slow . next . next return head","title":"19. Remove Nth Node From End of List $\\star\\star$"},{"location":"python3/0001-0100/0011-0020/#20-valid-parentheses-star","text":"Time: $O(n)$ Space: $O(n)$ class Solution : def isValid ( self , s : str ) -> bool : stack = [] for c in s : if c == '(' or c == '{' or c == '[' : stack . append ( c ) else : if not stack or \\ c == ')' and stack [ - 1 ] != '(' or \\ c == '}' and stack [ - 1 ] != '{' or \\ c == ']' and stack [ - 1 ] != '[' : return False stack . pop () return not stack","title":"20. Valid Parentheses $\\star$"},{"location":"python3/0001-0100/0021-0030/","text":"21. Merge Two Sorted Lists $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def mergeTwoLists ( self , l1 : ListNode , l2 : ListNode ) -> ListNode : if not l1 or not l2 : return l1 if l1 else l2 if l1 . val > l2 . val : l1 , l2 = l2 , l1 l1 . next = self . mergeTwoLists ( l1 . next , l2 ) return l1 22. Generate Parentheses $\\star\\star$ Time: $O(2^{2n})$ Space: $O(n)$ class Solution : def generateParenthesis ( self , n ): ans = [] self . helper ( '' , n , n , ans ) return ans def helper ( self , str , l , r , ans ): if l == 0 and r == 0 : ans . append ( str ) if l > 0 : self . helper ( str + '(' , l - 1 , r , ans ) if l < r : self . helper ( str + ')' , l , r - 1 , ans ) 23. Merge k Sorted Lists $\\star\\star\\star$ Time: $O(n\\log k)$, where $n$ is # of nodes Space: $O(n)$ class Solution : def mergeKLists ( self , lists : List [ ListNode ]) -> ListNode : dummy = ListNode ( 0 ) curr = dummy pq = [] for i , lst in enumerate ( lists ): if lst : heapq . heappush ( pq , ( lst . val , i , lst )) while pq : node = heapq . heappop ( pq ) curr . next = node [ 2 ] curr = curr . next if curr . next : heapq . heappush ( pq , ( curr . next . val , node [ 1 ], curr . next )) return dummy . next 24. Swap Nodes in Pairs $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def swapPairs ( self , head : ListNode ) -> ListNode : dummy = ListNode ( 0 ) dummy . next = head length = 0 curr = head while curr : length += 1 curr = curr . next prev = dummy curr = head for i in range ( length // 2 ): next = curr . next curr . next = next . next next . next = prev . next prev . next = next prev = curr curr = curr . next return dummy . next 25. Reverse Nodes in k-Group $\\star\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def reverseKGroup ( self , head : ListNode , k : int ) -> ListNode : if not head or k == 1 : return head dummy = ListNode ( 0 ) dummy . next = head length = 0 curr = head while curr : length += 1 curr = curr . next prev = dummy curr = head for i in range ( length // k ): for j in range ( k - 1 ): next = curr . next curr . next = next . next next . next = prev . next prev . next = next prev = curr curr = curr . next return dummy . next 26. Remove Duplicates from Sorted Array $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def removeDuplicates ( self , nums : List [ int ]) -> int : if len ( nums ) == 0 : return 0 j = 0 for i in range ( len ( nums )): if nums [ i ] != nums [ j ]: j += 1 nums [ j ] = nums [ i ] return j + 1 27. Remove Element $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def removeElement ( self , nums : List [ int ], val : int ) -> int : i = 0 for num in nums : if num != val : nums [ i ] = num i += 1 return i 28. Implement strStr() $\\star$ Time: $O((m - n)n)$, where m = len(haystack) and n = len(needle) Space: $O(1)$ class Solution : def strStr ( self , haystack : str , needle : str ) -> int : m = len ( haystack ) n = len ( needle ) for i in range ( m - n + 1 ): if haystack [ i : i + n ] == needle : return i return - 1 29. Divide Two Integers $\\star\\star$ Time: $O(\\log^2 n)$ Space: $O(1)$ class Solution : def divide ( self , dividend : int , divisor : int ) -> int : if dividend == - 2 ** 31 and divisor == - 1 : return 2 ** 31 - 1 ans = 0 sign = - 1 if ( dividend > 0 ) ^ ( divisor > 0 ) else 1 dividend = abs ( dividend ) divisor = abs ( divisor ) while dividend >= divisor : m = 1 temp = divisor while temp << 1 <= dividend : m <<= 1 temp <<= 1 dividend -= temp ans += m return sign * ans 30. Substring with Concatenation of All Words $\\star\\star\\star$ Time: $O(nk)$, where n = len(word) and k = len(s) Space: $O(n)$ class Solution : def findSubstring ( self , s : str , words : List [ str ]) -> List [ int ]: if len ( s ) == 0 or words == []: return [] n = len ( words [ 0 ]) ans = [] count = collections . Counter ( words ) for i in range ( len ( s ) - len ( words ) * n + 1 ): seen = collections . defaultdict ( int ) j = 0 while j < len ( words ): word = s [ i + j * n : i + j * n + n ] seen [ word ] += 1 if seen [ word ] > count [ word ]: break j += 1 if j == len ( words ): ans . append ( i ) return ans","title":"0021-0030"},{"location":"python3/0001-0100/0021-0030/#21-merge-two-sorted-lists-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def mergeTwoLists ( self , l1 : ListNode , l2 : ListNode ) -> ListNode : if not l1 or not l2 : return l1 if l1 else l2 if l1 . val > l2 . val : l1 , l2 = l2 , l1 l1 . next = self . mergeTwoLists ( l1 . next , l2 ) return l1","title":"21. Merge Two Sorted Lists $\\star$"},{"location":"python3/0001-0100/0021-0030/#22-generate-parentheses-starstar","text":"Time: $O(2^{2n})$ Space: $O(n)$ class Solution : def generateParenthesis ( self , n ): ans = [] self . helper ( '' , n , n , ans ) return ans def helper ( self , str , l , r , ans ): if l == 0 and r == 0 : ans . append ( str ) if l > 0 : self . helper ( str + '(' , l - 1 , r , ans ) if l < r : self . helper ( str + ')' , l , r - 1 , ans )","title":"22. Generate Parentheses $\\star\\star$"},{"location":"python3/0001-0100/0021-0030/#23-merge-k-sorted-lists-starstarstar","text":"Time: $O(n\\log k)$, where $n$ is # of nodes Space: $O(n)$ class Solution : def mergeKLists ( self , lists : List [ ListNode ]) -> ListNode : dummy = ListNode ( 0 ) curr = dummy pq = [] for i , lst in enumerate ( lists ): if lst : heapq . heappush ( pq , ( lst . val , i , lst )) while pq : node = heapq . heappop ( pq ) curr . next = node [ 2 ] curr = curr . next if curr . next : heapq . heappush ( pq , ( curr . next . val , node [ 1 ], curr . next )) return dummy . next","title":"23. Merge k Sorted Lists $\\star\\star\\star$"},{"location":"python3/0001-0100/0021-0030/#24-swap-nodes-in-pairs-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def swapPairs ( self , head : ListNode ) -> ListNode : dummy = ListNode ( 0 ) dummy . next = head length = 0 curr = head while curr : length += 1 curr = curr . next prev = dummy curr = head for i in range ( length // 2 ): next = curr . next curr . next = next . next next . next = prev . next prev . next = next prev = curr curr = curr . next return dummy . next","title":"24. Swap Nodes in Pairs $\\star\\star$"},{"location":"python3/0001-0100/0021-0030/#25-reverse-nodes-in-k-group-starstarstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def reverseKGroup ( self , head : ListNode , k : int ) -> ListNode : if not head or k == 1 : return head dummy = ListNode ( 0 ) dummy . next = head length = 0 curr = head while curr : length += 1 curr = curr . next prev = dummy curr = head for i in range ( length // k ): for j in range ( k - 1 ): next = curr . next curr . next = next . next next . next = prev . next prev . next = next prev = curr curr = curr . next return dummy . next","title":"25. Reverse Nodes in k-Group $\\star\\star\\star$"},{"location":"python3/0001-0100/0021-0030/#26-remove-duplicates-from-sorted-array-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def removeDuplicates ( self , nums : List [ int ]) -> int : if len ( nums ) == 0 : return 0 j = 0 for i in range ( len ( nums )): if nums [ i ] != nums [ j ]: j += 1 nums [ j ] = nums [ i ] return j + 1","title":"26. Remove Duplicates from Sorted Array $\\star$"},{"location":"python3/0001-0100/0021-0030/#27-remove-element-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def removeElement ( self , nums : List [ int ], val : int ) -> int : i = 0 for num in nums : if num != val : nums [ i ] = num i += 1 return i","title":"27. Remove Element $\\star$"},{"location":"python3/0001-0100/0021-0030/#28-implement-strstr-star","text":"Time: $O((m - n)n)$, where m = len(haystack) and n = len(needle) Space: $O(1)$ class Solution : def strStr ( self , haystack : str , needle : str ) -> int : m = len ( haystack ) n = len ( needle ) for i in range ( m - n + 1 ): if haystack [ i : i + n ] == needle : return i return - 1","title":"28. Implement strStr() $\\star$"},{"location":"python3/0001-0100/0021-0030/#29-divide-two-integers-starstar","text":"Time: $O(\\log^2 n)$ Space: $O(1)$ class Solution : def divide ( self , dividend : int , divisor : int ) -> int : if dividend == - 2 ** 31 and divisor == - 1 : return 2 ** 31 - 1 ans = 0 sign = - 1 if ( dividend > 0 ) ^ ( divisor > 0 ) else 1 dividend = abs ( dividend ) divisor = abs ( divisor ) while dividend >= divisor : m = 1 temp = divisor while temp << 1 <= dividend : m <<= 1 temp <<= 1 dividend -= temp ans += m return sign * ans","title":"29. Divide Two Integers $\\star\\star$"},{"location":"python3/0001-0100/0021-0030/#30-substring-with-concatenation-of-all-words-starstarstar","text":"Time: $O(nk)$, where n = len(word) and k = len(s) Space: $O(n)$ class Solution : def findSubstring ( self , s : str , words : List [ str ]) -> List [ int ]: if len ( s ) == 0 or words == []: return [] n = len ( words [ 0 ]) ans = [] count = collections . Counter ( words ) for i in range ( len ( s ) - len ( words ) * n + 1 ): seen = collections . defaultdict ( int ) j = 0 while j < len ( words ): word = s [ i + j * n : i + j * n + n ] seen [ word ] += 1 if seen [ word ] > count [ word ]: break j += 1 if j == len ( words ): ans . append ( i ) return ans","title":"30. Substring with Concatenation of All Words $\\star\\star\\star$"},{"location":"python3/0001-0100/0031-0040/","text":"31. Next Permutation $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def nextPermutation ( self , nums : List [ int ]) -> None : def reverse ( nums : List [ int ], l : int , r : int ): while l < r : nums [ l ], nums [ r ] = nums [ r ], nums [ l ] l += 1 r -= 1 i = len ( nums ) - 2 while i >= 0 : if nums [ i ] < nums [ i + 1 ]: break i -= 1 if i >= 0 : for j in range ( len ( nums ) - 1 , i , - 1 ): if nums [ j ] > nums [ i ]: break nums [ i ], nums [ j ] = nums [ j ], nums [ i ] reverse ( nums , i + 1 , len ( nums ) - 1 ) 32. Longest Valid Parentheses $\\star\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution : def longestValidParentheses ( self , s : str ) -> int : ans = 0 l = 0 r = 0 for i in range ( len ( s )): if s [ i ] == '(' : l += 1 else : r += 1 if l == r : ans = max ( ans , 2 * r ) elif r > l : l = 0 r = 0 l = 0 r = 0 for i in range ( len ( s ) - 1 , - 1 , - 1 ): if s [ i ] == '(' : l += 1 else : r += 1 if l == r : ans = max ( ans , 2 * l ) elif l > r : l = 0 r = 0 return ans 33. Search in Rotated Sorted Array $\\star\\star$ Time: $O(\\log n)$ Space: $O(1)$ class Solution : def search ( self , nums : List [ int ], target : int ) -> int : l = 0 r = len ( nums ) - 1 while l <= r : m = ( l + r ) // 2 if nums [ m ] == target : return m if nums [ l ] <= nums [ m ]: if nums [ l ] <= target < nums [ m ]: r = m - 1 else : l = m + 1 else : if nums [ m ] < target <= nums [ r ]: l = m + 1 else : r = m - 1 return - 1 34. Find First and Last Position of Element in Sorted Array $\\star\\star$ Time: $O(\\log n)$ Space: $O(1)$ class Solution : def searchRange ( self , nums : List [ int ], target : int ) -> List [ int ]: leftIndex = self . find ( nums , target , True ) if leftIndex == len ( nums ) or nums [ leftIndex ] != target : return - 1 , - 1 return leftIndex , self . find ( nums , target , False ) - 1 def find ( self , nums : List [ int ], target : int , isLeft : bool ) -> int : l = 0 r = len ( nums ) while l < r : m = ( l + r ) // 2 if nums [ m ] > target or ( isLeft and nums [ m ] == target ): r = m else : l = m + 1 return l 35. Search Insert Position $\\star$ Time: $O(\\log n)$ Space: $O(1)$ class Solution : def searchInsert ( self , nums : List [ int ], target : int ) -> int : l = 0 r = len ( nums ) while l < r : m = ( l + r ) // 2 if nums [ m ] == target : return m if nums [ m ] < target : l = m + 1 else : r = m return l 36. Valid Sudoku $\\star\\star$ Time: $O(1)$ Space: $O(1)$ class Solution : def isValidSudoku ( self , board : List [ List [ str ]]) -> bool : seen = set () for i in range ( 9 ): for j in range ( 9 ): c = board [ i ][ j ] if c == '.' : continue if c + ' in row ' + str ( i ) in seen or \\ c + ' in col ' + str ( j ) in seen or \\ c + ' in box ' + str ( i // 3 ) + str ( j // 3 ) in seen : return False seen . add ( c + ' in row ' + str ( i )) seen . add ( c + ' in col ' + str ( j )) seen . add ( c + ' in box ' + str ( i // 3 ) + str ( j // 3 )) return True 37. Sudoku Solver $\\star\\star\\star$ Time: NP-Complete Space: $O(1)$ class Solution : def solveSudoku ( self , board : List [ List [ str ]]) -> None : def isValid ( row : int , col : int , c : str ) -> bool : for i in range ( 9 ): if board [ i ][ col ] == c or \\ board [ row ][ i ] == c or \\ board [ 3 * ( row // 3 ) + i // 3 ][ 3 * ( col // 3 ) + i % 3 ] == c : return False return True def dfs ( s : int ) -> bool : if s == 81 : return True i = s // 9 j = s % 9 if board [ i ][ j ] != '.' : return dfs ( s + 1 ) for c in range ( 1 , 10 ): if isValid ( i , j , str ( c )): board [ i ][ j ] = str ( c ) if dfs ( s + 1 ): return True board [ i ][ j ] = '.' return False dfs ( 0 ) 38. Count and Say $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def countAndSay ( self , n : int ) -> str : dict = { 1 : '1' , 2 : '11' , 3 : '21' , 4 : '1211' , 5 : '111221' } if n <= 5 : return dict [ n ] for i in range ( 6 , n + 1 ): s = '' j = 0 while j <= len ( dict [ i - 1 ]) - 2 : count = 1 while j <= len ( dict [ i - 1 ]) - 2 and dict [ i - 1 ][ j ] == dict [ i - 1 ][ j + 1 ]: count += 1 j += 1 s += str ( count ) + dict [ i - 1 ][ j ] j += 1 if j == len ( dict [ i - 1 ]) - 1 : s += str ( 1 ) + dict [ i - 1 ][ j ] dict [ i ] = s return dict [ n ] 39. Combination Sum $\\star\\star$ Time: $O(n^{target})$, where n = len(candidates) Space: $O(target)$ class Solution : def combinationSum ( self , candidates : List [ int ], target : int ) -> List [ List [ int ]]: def dfs ( target : int , s : int , path : List [ int ]) -> None : if target < 0 : return if target == 0 : ans . append ( path ) return for i in range ( s , len ( candidates )): dfs ( target - candidates [ i ], i , path + [ candidates [ i ]]) ans = [] candidates . sort () dfs ( target , 0 , []) return ans 40. Combination Sum II $\\star\\star$ Time: $O(2^n)$ Space: $O(n)$ class Solution : def combinationSum2 ( self , candidates : List [ int ], target : int ) -> List [ List [ int ]]: def dfs ( target : int , s : int , path : List [ int ]) -> None : if target < 0 : return if target == 0 : ans . append ( path ) return for i in range ( s , len ( candidates )): if i > s and candidates [ i ] == candidates [ i - 1 ]: continue dfs ( target - candidates [ i ], i + 1 , path + [ candidates [ i ]]) ans = [] candidates . sort () dfs ( target , 0 , []) return ans","title":"0031-0040"},{"location":"python3/0001-0100/0031-0040/#31-next-permutation-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def nextPermutation ( self , nums : List [ int ]) -> None : def reverse ( nums : List [ int ], l : int , r : int ): while l < r : nums [ l ], nums [ r ] = nums [ r ], nums [ l ] l += 1 r -= 1 i = len ( nums ) - 2 while i >= 0 : if nums [ i ] < nums [ i + 1 ]: break i -= 1 if i >= 0 : for j in range ( len ( nums ) - 1 , i , - 1 ): if nums [ j ] > nums [ i ]: break nums [ i ], nums [ j ] = nums [ j ], nums [ i ] reverse ( nums , i + 1 , len ( nums ) - 1 )","title":"31. Next Permutation $\\star\\star$"},{"location":"python3/0001-0100/0031-0040/#32-longest-valid-parentheses-starstarstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution : def longestValidParentheses ( self , s : str ) -> int : ans = 0 l = 0 r = 0 for i in range ( len ( s )): if s [ i ] == '(' : l += 1 else : r += 1 if l == r : ans = max ( ans , 2 * r ) elif r > l : l = 0 r = 0 l = 0 r = 0 for i in range ( len ( s ) - 1 , - 1 , - 1 ): if s [ i ] == '(' : l += 1 else : r += 1 if l == r : ans = max ( ans , 2 * l ) elif l > r : l = 0 r = 0 return ans","title":"32. Longest Valid Parentheses $\\star\\star\\star$"},{"location":"python3/0001-0100/0031-0040/#33-search-in-rotated-sorted-array-starstar","text":"Time: $O(\\log n)$ Space: $O(1)$ class Solution : def search ( self , nums : List [ int ], target : int ) -> int : l = 0 r = len ( nums ) - 1 while l <= r : m = ( l + r ) // 2 if nums [ m ] == target : return m if nums [ l ] <= nums [ m ]: if nums [ l ] <= target < nums [ m ]: r = m - 1 else : l = m + 1 else : if nums [ m ] < target <= nums [ r ]: l = m + 1 else : r = m - 1 return - 1","title":"33. Search in Rotated Sorted Array $\\star\\star$"},{"location":"python3/0001-0100/0031-0040/#34-find-first-and-last-position-of-element-in-sorted-array-starstar","text":"Time: $O(\\log n)$ Space: $O(1)$ class Solution : def searchRange ( self , nums : List [ int ], target : int ) -> List [ int ]: leftIndex = self . find ( nums , target , True ) if leftIndex == len ( nums ) or nums [ leftIndex ] != target : return - 1 , - 1 return leftIndex , self . find ( nums , target , False ) - 1 def find ( self , nums : List [ int ], target : int , isLeft : bool ) -> int : l = 0 r = len ( nums ) while l < r : m = ( l + r ) // 2 if nums [ m ] > target or ( isLeft and nums [ m ] == target ): r = m else : l = m + 1 return l","title":"34. Find First and Last Position of Element in Sorted Array $\\star\\star$"},{"location":"python3/0001-0100/0031-0040/#35-search-insert-position-star","text":"Time: $O(\\log n)$ Space: $O(1)$ class Solution : def searchInsert ( self , nums : List [ int ], target : int ) -> int : l = 0 r = len ( nums ) while l < r : m = ( l + r ) // 2 if nums [ m ] == target : return m if nums [ m ] < target : l = m + 1 else : r = m return l","title":"35. Search Insert Position $\\star$"},{"location":"python3/0001-0100/0031-0040/#36-valid-sudoku-starstar","text":"Time: $O(1)$ Space: $O(1)$ class Solution : def isValidSudoku ( self , board : List [ List [ str ]]) -> bool : seen = set () for i in range ( 9 ): for j in range ( 9 ): c = board [ i ][ j ] if c == '.' : continue if c + ' in row ' + str ( i ) in seen or \\ c + ' in col ' + str ( j ) in seen or \\ c + ' in box ' + str ( i // 3 ) + str ( j // 3 ) in seen : return False seen . add ( c + ' in row ' + str ( i )) seen . add ( c + ' in col ' + str ( j )) seen . add ( c + ' in box ' + str ( i // 3 ) + str ( j // 3 )) return True","title":"36. Valid Sudoku $\\star\\star$"},{"location":"python3/0001-0100/0031-0040/#37-sudoku-solver-starstarstar","text":"Time: NP-Complete Space: $O(1)$ class Solution : def solveSudoku ( self , board : List [ List [ str ]]) -> None : def isValid ( row : int , col : int , c : str ) -> bool : for i in range ( 9 ): if board [ i ][ col ] == c or \\ board [ row ][ i ] == c or \\ board [ 3 * ( row // 3 ) + i // 3 ][ 3 * ( col // 3 ) + i % 3 ] == c : return False return True def dfs ( s : int ) -> bool : if s == 81 : return True i = s // 9 j = s % 9 if board [ i ][ j ] != '.' : return dfs ( s + 1 ) for c in range ( 1 , 10 ): if isValid ( i , j , str ( c )): board [ i ][ j ] = str ( c ) if dfs ( s + 1 ): return True board [ i ][ j ] = '.' return False dfs ( 0 )","title":"37. Sudoku Solver $\\star\\star\\star$"},{"location":"python3/0001-0100/0031-0040/#38-count-and-say-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def countAndSay ( self , n : int ) -> str : dict = { 1 : '1' , 2 : '11' , 3 : '21' , 4 : '1211' , 5 : '111221' } if n <= 5 : return dict [ n ] for i in range ( 6 , n + 1 ): s = '' j = 0 while j <= len ( dict [ i - 1 ]) - 2 : count = 1 while j <= len ( dict [ i - 1 ]) - 2 and dict [ i - 1 ][ j ] == dict [ i - 1 ][ j + 1 ]: count += 1 j += 1 s += str ( count ) + dict [ i - 1 ][ j ] j += 1 if j == len ( dict [ i - 1 ]) - 1 : s += str ( 1 ) + dict [ i - 1 ][ j ] dict [ i ] = s return dict [ n ]","title":"38. Count and Say $\\star$"},{"location":"python3/0001-0100/0031-0040/#39-combination-sum-starstar","text":"Time: $O(n^{target})$, where n = len(candidates) Space: $O(target)$ class Solution : def combinationSum ( self , candidates : List [ int ], target : int ) -> List [ List [ int ]]: def dfs ( target : int , s : int , path : List [ int ]) -> None : if target < 0 : return if target == 0 : ans . append ( path ) return for i in range ( s , len ( candidates )): dfs ( target - candidates [ i ], i , path + [ candidates [ i ]]) ans = [] candidates . sort () dfs ( target , 0 , []) return ans","title":"39. Combination Sum $\\star\\star$"},{"location":"python3/0001-0100/0031-0040/#40-combination-sum-ii-starstar","text":"Time: $O(2^n)$ Space: $O(n)$ class Solution : def combinationSum2 ( self , candidates : List [ int ], target : int ) -> List [ List [ int ]]: def dfs ( target : int , s : int , path : List [ int ]) -> None : if target < 0 : return if target == 0 : ans . append ( path ) return for i in range ( s , len ( candidates )): if i > s and candidates [ i ] == candidates [ i - 1 ]: continue dfs ( target - candidates [ i ], i + 1 , path + [ candidates [ i ]]) ans = [] candidates . sort () dfs ( target , 0 , []) return ans","title":"40. Combination Sum II $\\star\\star$"},{"location":"python3/0001-0100/0041-0050/","text":"41. First Missing Positive $\\star\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def firstMissingPositive ( self , nums : List [ int ]) -> int : if not nums : return 1 n = len ( nums ) for i in range ( n ): while nums [ i ] > 0 and nums [ i ] <= n and nums [ nums [ i ] - 1 ] != nums [ i ]: nums [ nums [ i ] - 1 ], nums [ i ] = nums [ i ], nums [ nums [ i ] - 1 ] for i in range ( n ): if nums [ i ] != i + 1 : return i + 1 return n + 1 42. Trapping Rain Water $\\star\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def trap ( self , height : List [ int ]) -> int : ans = 0 l = 0 r = len ( height ) - 1 maxLeft = 0 maxRight = 0 while l < r : if height [ l ] < height [ r ]: maxLeft = max ( maxLeft , height [ l ]) ans += maxLeft - height [ l ] l += 1 else : maxRight = max ( maxRight , height [ r ]) ans += maxRight - height [ r ] r -= 1 return ans 43. Multiply Strings $\\star\\star$ Time: $O(mn)$, where m = len(num1) and n = len(num2) Space: $O(m + n)$ class Solution : def multiply ( self , num1 : str , num2 : str ) -> str : m = len ( num1 ) n = len ( num2 ) ans = '' pos = [ 0 ] * ( m + n ) for i in range ( m )[:: - 1 ]: for j in range ( n )[:: - 1 ]: multiply = ( ord ( num1 [ i ]) - ord ( '0' )) * \\ ( ord ( num2 [ j ]) - ord ( '0' )) sum = multiply + pos [ i + j + 1 ] pos [ i + j ] += sum // 10 pos [ i + j + 1 ] = ( sum ) % 10 for p in pos : if not ( not ans and p == 0 ): ans += str ( p ) return '0' if not ans else ans 44. Wildcard Matching $\\star\\star\\star$ Time: $O(mn)$, where m = len(s) and n = len(p) Space: $O(mn)$ class Solution : def isMatch ( self , s : str , p : str ) -> bool : m = len ( s ) n = len ( p ) dp = [[ False ] * ( n + 1 ) for _ in range ( m + 1 )] for i in range ( m + 1 ): for j in range ( n + 1 ): if i == 0 and j == 0 : dp [ i ][ j ] = True elif i == 0 : dp [ i ][ j ] = dp [ i ][ j - 1 ] and p [ j - 1 ] == '*' elif j == 0 : dp [ i ][ j ] = dp [ i - 1 ][ j ] and s [ i - 1 ] == '*' else : dp [ i ][ j ] = \\ ( dp [ i - 1 ][ j ] or dp [ i ][ j - 1 ] or dp [ i - 1 ][ j - 1 ]) and \\ ( s [ i - 1 ] == '*' or p [ j - 1 ] == '*' ) or \\ ( dp [ i - 1 ][ j - 1 ]) and \\ ( s [ i - 1 ] == '?' or p [ j - 1 ] == '?' or s [ i - 1 ] == p [ j - 1 ]) return dp [ m ][ n ] 45. Jump Game II $\\star\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def jump ( self , nums : List [ int ]) -> int : ans = 0 end = 0 farthest = 0 for i in range ( len ( nums ) - 1 ): farthest = max ( farthest , i + nums [ i ]) if i == end : ans += 1 end = farthest return ans 46. Permutations $\\star\\star$ Time: $O(n!)$ Space: $O(n)$ class Solution : def permute ( self , nums : List [ int ]) -> List [ List [ int ]]: def dfs ( path : List [ int ]) -> None : if len ( path ) == len ( nums ): ans . append ( path ) return for i in range ( len ( nums )): if used [ i ]: continue used [ i ] = True dfs ( path + [ nums [ i ]]) used [ i ] = False ans = [] used = [ False ] * len ( nums ) dfs ([]) return ans 47. Permutations II $\\star\\star$ Time: $O(n!)$ Space: $O(n)$ class Solution : def permuteUnique ( self , nums : List [ int ]) -> List [ List [ int ]]: def dfs ( path : List [ int ]) -> None : if len ( path ) == len ( nums ): ans . append ( path ) return for i , num in enumerate ( nums ): if used [ i ]: continue if i > 0 and nums [ i ] == nums [ i - 1 ] and not used [ i - 1 ]: continue used [ i ] = True dfs ( path + [ num ]) used [ i ] = False ans = [] used = [ False ] * len ( nums ) nums . sort () dfs ([]) return ans 48. Rotate Image $\\star\\star$ Time: $O(n^2)$ Space: $O(1)$ class Solution : def rotate ( self , matrix : List [ List [ int ]]) -> None : for min in range ( len ( matrix ) // 2 ): max = len ( matrix ) - min - 1 for i in range ( min , max ): offset = i - min top = matrix [ min ][ i ] matrix [ min ][ i ] = matrix [ max - offset ][ min ] matrix [ max - offset ][ min ] = matrix [ max ][ max - offset ] matrix [ max ][ max - offset ] = matrix [ i ][ max ] matrix [ i ][ max ] = top 49. Group Anagrams $\\star\\star$ Time: $O(n\\log k)$, where n = len(strs) and k = len(strs[i]) Space: $O(n)$ class Solution : def groupAnagrams ( self , strs : List [ str ]) -> List [ List [ str ]]: ans = [] dict = collections . defaultdict ( list ) for str in strs : s = '' . join ( sorted ( str )) dict [ s ] . append ( str ) return dict . values () 50. Pow(x, n) $\\star\\star$ Time: $O(\\log n)$ Space: $O(1)$ class Solution : def myPow ( self , x : float , n : int ) -> float : if n == 0 : return 1 if n < 0 : return 1 / self . myPow ( x , - n ) if n % 2 : return x * self . myPow ( x , n - 1 ) return self . myPow ( x * x , n / 2 )","title":"0041-0050"},{"location":"python3/0001-0100/0041-0050/#41-first-missing-positive-starstarstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def firstMissingPositive ( self , nums : List [ int ]) -> int : if not nums : return 1 n = len ( nums ) for i in range ( n ): while nums [ i ] > 0 and nums [ i ] <= n and nums [ nums [ i ] - 1 ] != nums [ i ]: nums [ nums [ i ] - 1 ], nums [ i ] = nums [ i ], nums [ nums [ i ] - 1 ] for i in range ( n ): if nums [ i ] != i + 1 : return i + 1 return n + 1","title":"41. First Missing Positive $\\star\\star\\star$"},{"location":"python3/0001-0100/0041-0050/#42-trapping-rain-water-starstarstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def trap ( self , height : List [ int ]) -> int : ans = 0 l = 0 r = len ( height ) - 1 maxLeft = 0 maxRight = 0 while l < r : if height [ l ] < height [ r ]: maxLeft = max ( maxLeft , height [ l ]) ans += maxLeft - height [ l ] l += 1 else : maxRight = max ( maxRight , height [ r ]) ans += maxRight - height [ r ] r -= 1 return ans","title":"42. Trapping Rain Water $\\star\\star\\star$"},{"location":"python3/0001-0100/0041-0050/#43-multiply-strings-starstar","text":"Time: $O(mn)$, where m = len(num1) and n = len(num2) Space: $O(m + n)$ class Solution : def multiply ( self , num1 : str , num2 : str ) -> str : m = len ( num1 ) n = len ( num2 ) ans = '' pos = [ 0 ] * ( m + n ) for i in range ( m )[:: - 1 ]: for j in range ( n )[:: - 1 ]: multiply = ( ord ( num1 [ i ]) - ord ( '0' )) * \\ ( ord ( num2 [ j ]) - ord ( '0' )) sum = multiply + pos [ i + j + 1 ] pos [ i + j ] += sum // 10 pos [ i + j + 1 ] = ( sum ) % 10 for p in pos : if not ( not ans and p == 0 ): ans += str ( p ) return '0' if not ans else ans","title":"43. Multiply Strings $\\star\\star$"},{"location":"python3/0001-0100/0041-0050/#44-wildcard-matching-starstarstar","text":"Time: $O(mn)$, where m = len(s) and n = len(p) Space: $O(mn)$ class Solution : def isMatch ( self , s : str , p : str ) -> bool : m = len ( s ) n = len ( p ) dp = [[ False ] * ( n + 1 ) for _ in range ( m + 1 )] for i in range ( m + 1 ): for j in range ( n + 1 ): if i == 0 and j == 0 : dp [ i ][ j ] = True elif i == 0 : dp [ i ][ j ] = dp [ i ][ j - 1 ] and p [ j - 1 ] == '*' elif j == 0 : dp [ i ][ j ] = dp [ i - 1 ][ j ] and s [ i - 1 ] == '*' else : dp [ i ][ j ] = \\ ( dp [ i - 1 ][ j ] or dp [ i ][ j - 1 ] or dp [ i - 1 ][ j - 1 ]) and \\ ( s [ i - 1 ] == '*' or p [ j - 1 ] == '*' ) or \\ ( dp [ i - 1 ][ j - 1 ]) and \\ ( s [ i - 1 ] == '?' or p [ j - 1 ] == '?' or s [ i - 1 ] == p [ j - 1 ]) return dp [ m ][ n ]","title":"44. Wildcard Matching $\\star\\star\\star$"},{"location":"python3/0001-0100/0041-0050/#45-jump-game-ii-starstarstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def jump ( self , nums : List [ int ]) -> int : ans = 0 end = 0 farthest = 0 for i in range ( len ( nums ) - 1 ): farthest = max ( farthest , i + nums [ i ]) if i == end : ans += 1 end = farthest return ans","title":"45. Jump Game II $\\star\\star\\star$"},{"location":"python3/0001-0100/0041-0050/#46-permutations-starstar","text":"Time: $O(n!)$ Space: $O(n)$ class Solution : def permute ( self , nums : List [ int ]) -> List [ List [ int ]]: def dfs ( path : List [ int ]) -> None : if len ( path ) == len ( nums ): ans . append ( path ) return for i in range ( len ( nums )): if used [ i ]: continue used [ i ] = True dfs ( path + [ nums [ i ]]) used [ i ] = False ans = [] used = [ False ] * len ( nums ) dfs ([]) return ans","title":"46. Permutations $\\star\\star$"},{"location":"python3/0001-0100/0041-0050/#47-permutations-ii-starstar","text":"Time: $O(n!)$ Space: $O(n)$ class Solution : def permuteUnique ( self , nums : List [ int ]) -> List [ List [ int ]]: def dfs ( path : List [ int ]) -> None : if len ( path ) == len ( nums ): ans . append ( path ) return for i , num in enumerate ( nums ): if used [ i ]: continue if i > 0 and nums [ i ] == nums [ i - 1 ] and not used [ i - 1 ]: continue used [ i ] = True dfs ( path + [ num ]) used [ i ] = False ans = [] used = [ False ] * len ( nums ) nums . sort () dfs ([]) return ans","title":"47. Permutations II $\\star\\star$"},{"location":"python3/0001-0100/0041-0050/#48-rotate-image-starstar","text":"Time: $O(n^2)$ Space: $O(1)$ class Solution : def rotate ( self , matrix : List [ List [ int ]]) -> None : for min in range ( len ( matrix ) // 2 ): max = len ( matrix ) - min - 1 for i in range ( min , max ): offset = i - min top = matrix [ min ][ i ] matrix [ min ][ i ] = matrix [ max - offset ][ min ] matrix [ max - offset ][ min ] = matrix [ max ][ max - offset ] matrix [ max ][ max - offset ] = matrix [ i ][ max ] matrix [ i ][ max ] = top","title":"48. Rotate Image $\\star\\star$"},{"location":"python3/0001-0100/0041-0050/#49-group-anagrams-starstar","text":"Time: $O(n\\log k)$, where n = len(strs) and k = len(strs[i]) Space: $O(n)$ class Solution : def groupAnagrams ( self , strs : List [ str ]) -> List [ List [ str ]]: ans = [] dict = collections . defaultdict ( list ) for str in strs : s = '' . join ( sorted ( str )) dict [ s ] . append ( str ) return dict . values ()","title":"49. Group Anagrams $\\star\\star$"},{"location":"python3/0001-0100/0041-0050/#50-powx-n-starstar","text":"Time: $O(\\log n)$ Space: $O(1)$ class Solution : def myPow ( self , x : float , n : int ) -> float : if n == 0 : return 1 if n < 0 : return 1 / self . myPow ( x , - n ) if n % 2 : return x * self . myPow ( x , n - 1 ) return self . myPow ( x * x , n / 2 )","title":"50. Pow(x, n) $\\star\\star$"},{"location":"python3/0001-0100/0051-0060/","text":"51. N-Queens $\\star\\star\\star$ Time: $O(n^n)$ Space: $O(n)$ class Solution : def solveNQueens ( self , n : int ) -> List [ List [ str ]]: def dfs ( i : int , board : List [ str ]) -> None : if i == n : ans . append ( board ) return for j in range ( n ): if cols [ j ] or diag1 [ i + j ] or diag2 [ j - i + n - 1 ]: continue cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + n - 1 ] = True dfs ( i + 1 , board + [ '.' * j + 'Q' + '.' * ( n - j - 1 )]) cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + n - 1 ] = False ans = [] cols = [ False ] * n diag1 = [ False ] * ( 2 * n - 1 ) diag2 = [ False ] * ( 2 * n - 1 ) dfs ( 0 , []) return ans 52. N-Queens II $\\star\\star\\star$ Time: $O(n^n)$ Space: $O(n)$ class Solution : def totalNQueens ( self , n : int ) -> int : self . ans = 0 self . dfs ( 0 , [ False ] * n , [ False ] * ( 2 * n - 1 ), [ False ] * ( 2 * n - 1 )) return self . ans def dfs ( self , y : int , cols : List [ bool ], diag1 : List [ bool ], diag2 : List [ bool ]) -> None : if y == len ( cols ): self . ans += 1 return for x in range ( len ( cols )): if not cols [ x ] and not diag1 [ x + y ] and not diag2 [ x - y + len ( cols ) - 1 ]: cols [ x ] = diag1 [ x + y ] = diag2 [ x - y + len ( cols ) - 1 ] = True self . dfs ( y + 1 , cols , diag1 , diag2 ) cols [ x ] = diag1 [ x + y ] = diag2 [ x - y + len ( cols ) - 1 ] = False 53. Maximum Subarray $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def maxSubArray ( self , nums : List [ int ]) -> int : ans = float ( '-inf' ) sum = 0 for num in nums : sum += num ans = max ( ans , sum ) sum = max ( sum , 0 ) return ans 54. Spiral Matrix $\\star\\star$ Time: $O(mn)$ Space: $O(1)$ class Solution : def spiralOrder ( self , matrix : List [ List [ int ]]) -> List [ int ]: if not matrix : return [] ans = [] r1 = 0 c1 = 0 r2 = len ( matrix ) - 1 c2 = len ( matrix [ 0 ]) - 1 while r1 <= r2 and c1 <= c2 : for c in range ( c1 , c2 + 1 ): ans . append ( matrix [ r1 ][ c ]) for r in range ( r1 + 1 , r2 + 1 ): ans . append ( matrix [ r ][ c2 ]) if r1 < r2 and c1 < c2 : for c in range ( c2 - 1 , c1 , - 1 ): ans . append ( matrix [ r2 ][ c ]) for r in range ( r2 , r1 , - 1 ): ans . append ( matrix [ r ][ c1 ]) r1 += 1 c1 += 1 r2 -= 1 c2 -= 1 return ans 55. Jump Game $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def canJump ( self , nums : List [ int ]) -> bool : goal = len ( nums ) - 1 for i in range ( goal , - 1 , - 1 ): if i + nums [ i ] >= goal : goal = i return goal == 0 56. Merge Intervals $\\star\\star$ Time: $O(n\\log n)$ Space: $O(1)$ class Solution : def merge ( self , intervals : List [ List [ int ]]) -> List [ List [ int ]]: ans = [] for interval in sorted ( intervals ): if not ans or ans [ - 1 ][ 1 ] < interval [ 0 ]: ans . append ( interval ) else : ans [ - 1 ][ 1 ] = max ( ans [ - 1 ][ 1 ], interval [ 1 ]) return ans 57. Insert Interval $\\star\\star\\star$ Time: $O(n\\log n)$ Space: $O(1)$ class Solution : def insert ( self , intervals : List [ List [ int ]], newInterval : List [ int ]) -> List [ List [ int ]]: ans = [] index = len ( intervals ) for i in range ( len ( intervals )): if intervals [ i ][ 0 ] >= newInterval [ 0 ]: index = i break intervals . insert ( index , newInterval ) for interval in intervals : if not ans or ans [ - 1 ][ 1 ] < interval [ 0 ]: ans . append ( interval ) else : ans [ - 1 ][ 1 ] = max ( ans [ - 1 ][ 1 ], interval [ 1 ]) return ans 58. Length of Last Word $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def lengthOfLastWord ( self , s : str ) -> int : ans = 0 i = len ( s ) - 1 while i >= 0 and s [ i ] == ' ' : i -= 1 while i >= 0 and s [ i ] != ' ' : i -= 1 ans += 1 return ans 59. Spiral Matrix II $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def generateMatrix ( self , n : int ) -> List [ List [ int ]]: ans = [[ 0 for j in range ( n )] for i in range ( n )] count = 1 for min in range ( n // 2 ): max = n - min - 1 for i in range ( min , max ): ans [ min ][ i ] = count count += 1 for i in range ( min , max ): ans [ i ][ max ] = count count += 1 for i in range ( max , min , - 1 ): ans [ max ][ i ] = count count += 1 for i in range ( max , min , - 1 ): ans [ i ][ min ] = count count += 1 if n & 1 : ans [ n // 2 ][ n // 2 ] = count return ans 60. Permutation Sequence $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution : def getPermutation ( self , n : int , k : int ) -> str : ans = '' nums = [ i + 1 for i in range ( n )] factorial = [ 1 ] * n for i in range ( 1 , n ): factorial [ i ] = factorial [ i - 1 ] * i k -= 1 for i in range ( n , 0 , - 1 ): j = k // factorial [ i - 1 ] k %= factorial [ i - 1 ] ans += str ( nums [ j ]) nums . pop ( j ) return ans","title":"0051-0060"},{"location":"python3/0001-0100/0051-0060/#51-n-queens-starstarstar","text":"Time: $O(n^n)$ Space: $O(n)$ class Solution : def solveNQueens ( self , n : int ) -> List [ List [ str ]]: def dfs ( i : int , board : List [ str ]) -> None : if i == n : ans . append ( board ) return for j in range ( n ): if cols [ j ] or diag1 [ i + j ] or diag2 [ j - i + n - 1 ]: continue cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + n - 1 ] = True dfs ( i + 1 , board + [ '.' * j + 'Q' + '.' * ( n - j - 1 )]) cols [ j ] = diag1 [ i + j ] = diag2 [ j - i + n - 1 ] = False ans = [] cols = [ False ] * n diag1 = [ False ] * ( 2 * n - 1 ) diag2 = [ False ] * ( 2 * n - 1 ) dfs ( 0 , []) return ans","title":"51. N-Queens $\\star\\star\\star$"},{"location":"python3/0001-0100/0051-0060/#52-n-queens-ii-starstarstar","text":"Time: $O(n^n)$ Space: $O(n)$ class Solution : def totalNQueens ( self , n : int ) -> int : self . ans = 0 self . dfs ( 0 , [ False ] * n , [ False ] * ( 2 * n - 1 ), [ False ] * ( 2 * n - 1 )) return self . ans def dfs ( self , y : int , cols : List [ bool ], diag1 : List [ bool ], diag2 : List [ bool ]) -> None : if y == len ( cols ): self . ans += 1 return for x in range ( len ( cols )): if not cols [ x ] and not diag1 [ x + y ] and not diag2 [ x - y + len ( cols ) - 1 ]: cols [ x ] = diag1 [ x + y ] = diag2 [ x - y + len ( cols ) - 1 ] = True self . dfs ( y + 1 , cols , diag1 , diag2 ) cols [ x ] = diag1 [ x + y ] = diag2 [ x - y + len ( cols ) - 1 ] = False","title":"52. N-Queens II $\\star\\star\\star$"},{"location":"python3/0001-0100/0051-0060/#53-maximum-subarray-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def maxSubArray ( self , nums : List [ int ]) -> int : ans = float ( '-inf' ) sum = 0 for num in nums : sum += num ans = max ( ans , sum ) sum = max ( sum , 0 ) return ans","title":"53. Maximum Subarray $\\star$"},{"location":"python3/0001-0100/0051-0060/#54-spiral-matrix-starstar","text":"Time: $O(mn)$ Space: $O(1)$ class Solution : def spiralOrder ( self , matrix : List [ List [ int ]]) -> List [ int ]: if not matrix : return [] ans = [] r1 = 0 c1 = 0 r2 = len ( matrix ) - 1 c2 = len ( matrix [ 0 ]) - 1 while r1 <= r2 and c1 <= c2 : for c in range ( c1 , c2 + 1 ): ans . append ( matrix [ r1 ][ c ]) for r in range ( r1 + 1 , r2 + 1 ): ans . append ( matrix [ r ][ c2 ]) if r1 < r2 and c1 < c2 : for c in range ( c2 - 1 , c1 , - 1 ): ans . append ( matrix [ r2 ][ c ]) for r in range ( r2 , r1 , - 1 ): ans . append ( matrix [ r ][ c1 ]) r1 += 1 c1 += 1 r2 -= 1 c2 -= 1 return ans","title":"54. Spiral Matrix $\\star\\star$"},{"location":"python3/0001-0100/0051-0060/#55-jump-game-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def canJump ( self , nums : List [ int ]) -> bool : goal = len ( nums ) - 1 for i in range ( goal , - 1 , - 1 ): if i + nums [ i ] >= goal : goal = i return goal == 0","title":"55. Jump Game $\\star\\star$"},{"location":"python3/0001-0100/0051-0060/#56-merge-intervals-starstar","text":"Time: $O(n\\log n)$ Space: $O(1)$ class Solution : def merge ( self , intervals : List [ List [ int ]]) -> List [ List [ int ]]: ans = [] for interval in sorted ( intervals ): if not ans or ans [ - 1 ][ 1 ] < interval [ 0 ]: ans . append ( interval ) else : ans [ - 1 ][ 1 ] = max ( ans [ - 1 ][ 1 ], interval [ 1 ]) return ans","title":"56. Merge Intervals $\\star\\star$"},{"location":"python3/0001-0100/0051-0060/#57-insert-interval-starstarstar","text":"Time: $O(n\\log n)$ Space: $O(1)$ class Solution : def insert ( self , intervals : List [ List [ int ]], newInterval : List [ int ]) -> List [ List [ int ]]: ans = [] index = len ( intervals ) for i in range ( len ( intervals )): if intervals [ i ][ 0 ] >= newInterval [ 0 ]: index = i break intervals . insert ( index , newInterval ) for interval in intervals : if not ans or ans [ - 1 ][ 1 ] < interval [ 0 ]: ans . append ( interval ) else : ans [ - 1 ][ 1 ] = max ( ans [ - 1 ][ 1 ], interval [ 1 ]) return ans","title":"57. Insert Interval $\\star\\star\\star$"},{"location":"python3/0001-0100/0051-0060/#58-length-of-last-word-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def lengthOfLastWord ( self , s : str ) -> int : ans = 0 i = len ( s ) - 1 while i >= 0 and s [ i ] == ' ' : i -= 1 while i >= 0 and s [ i ] != ' ' : i -= 1 ans += 1 return ans","title":"58. Length of Last Word $\\star$"},{"location":"python3/0001-0100/0051-0060/#59-spiral-matrix-ii-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def generateMatrix ( self , n : int ) -> List [ List [ int ]]: ans = [[ 0 for j in range ( n )] for i in range ( n )] count = 1 for min in range ( n // 2 ): max = n - min - 1 for i in range ( min , max ): ans [ min ][ i ] = count count += 1 for i in range ( min , max ): ans [ i ][ max ] = count count += 1 for i in range ( max , min , - 1 ): ans [ max ][ i ] = count count += 1 for i in range ( max , min , - 1 ): ans [ i ][ min ] = count count += 1 if n & 1 : ans [ n // 2 ][ n // 2 ] = count return ans","title":"59. Spiral Matrix II $\\star\\star$"},{"location":"python3/0001-0100/0051-0060/#60-permutation-sequence-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution : def getPermutation ( self , n : int , k : int ) -> str : ans = '' nums = [ i + 1 for i in range ( n )] factorial = [ 1 ] * n for i in range ( 1 , n ): factorial [ i ] = factorial [ i - 1 ] * i k -= 1 for i in range ( n , 0 , - 1 ): j = k // factorial [ i - 1 ] k %= factorial [ i - 1 ] ans += str ( nums [ j ]) nums . pop ( j ) return ans","title":"60. Permutation Sequence $\\star\\star$"},{"location":"python3/0001-0100/0061-0070/","text":"61. Rotate List $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def rotateRight ( self , head : ListNode , k : int ) -> ListNode : if not head or not head . next or k == 0 : return head length = 0 curr = head while curr : length += 1 curr = curr . next k %= length if k == 0 : return head slow = head fast = head for _ in range ( k ): fast = fast . next while fast and fast . next : slow = slow . next fast = fast . next ans = slow . next slow . next = None fast . next = head return ans 62. Unique Paths $\\star\\star$ Time: $O(mn)$ Space: $O(mn) \\to O(n)$ class Solution : def uniquePaths ( self , m : int , n : int ) -> int : dp = [ 1 ] * n for i in range ( 1 , m ): for j in range ( 1 , n ): dp [ j ] += dp [ j - 1 ] return dp [ n - 1 ] 63. Unique Paths II $\\star\\star$ Time: $O(mn)$ Space: $O(mn) \\to O(n)$ class Solution : def uniquePathsWithObstacles ( self , obstacleGrid : List [ List [ int ]]) -> int : m = len ( obstacleGrid ) n = len ( obstacleGrid [ 0 ]) dp = [ 0 ] * n dp [ 0 ] = 1 for i in range ( m ): for j in range ( n ): if obstacleGrid [ i ][ j ]: dp [ j ] = 0 elif j > 0 : dp [ j ] += dp [ j - 1 ] return dp [ n - 1 ] 64. Minimum Path Sum $\\star\\star$ Time: $O(mn)$ Space: $O(1)$ class Solution : def minPathSum ( self , grid : List [ List [ int ]]) -> int : m = len ( grid ) n = len ( grid [ 0 ]) for i in range ( 1 , m ): grid [ i ][ 0 ] += grid [ i - 1 ][ 0 ] for j in range ( 1 , n ): grid [ 0 ][ j ] += grid [ 0 ][ j - 1 ] for i in range ( 1 , m ): for j in range ( 1 , n ): grid [ i ][ j ] += min ( grid [ i - 1 ][ j ], grid [ i ][ j - 1 ]) return grid [ m - 1 ][ n - 1 ] 65. Valid Number $\\star\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def isNumber ( self , s : str ) -> bool : s = s . strip () if not s : return False seenNum = False seenDot = False seenE = False for i , c in enumerate ( s ): if c == '.' : if seenDot or seenE : return False seenDot = True elif c == 'e' : if seenE or not seenNum : return False seenE = True seenNum = False elif c in '+-' : if i > 0 and s [ i - 1 ] != 'e' : return False seenNum = False else : if not c . isdigit (): return False seenNum = True return seenNum 66. Plus One $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def plusOne ( self , digits : List [ int ]) -> List [ int ]: n = len ( digits ) for i in range ( n - 1 , - 1 , - 1 ): if digits [ i ] < 9 : digits [ i ] += 1 return digits digits [ i ] = 0 return [ 1 ] + [ 0 ] * n 67. Add Binary $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def addBinary ( self , a : str , b : str ) -> str : ans = '' carry = 0 i = len ( a ) - 1 j = len ( b ) - 1 while carry == 1 or i >= 0 or j >= 0 : if i >= 0 : carry += ord ( a [ i ]) - ord ( '0' ) i -= 1 if j >= 0 : carry += ord ( b [ j ]) - ord ( '0' ) j -= 1 ans = chr ( carry % 2 + ord ( '0' )) + ans carry >>= 1 return ans 68. Text Justification $\\star\\star\\star$ Time: $O( sum(len(words[i]) )$ Space: $O(1)$ class Solution : def fullJustify ( self , words : List [ str ], maxWidth : int ) -> List [ str ]: ans = [] curr = [] numOfLetters = 0 for word in words : if numOfLetters + len ( word ) + len ( curr ) > maxWidth : for i in range ( maxWidth - numOfLetters ): curr [ i % ( len ( curr ) - 1 or 1 )] += ' ' ans . append ( '' . join ( curr )) curr = [] numOfLetters = 0 curr . append ( word ) numOfLetters += len ( word ) return ans + [ ' ' . join ( curr ) . ljust ( maxWidth )] 69. Sqrt(x) $\\star$ Time: $O(\\log x)$ Space: $O(1)$ class Solution : def mySqrt ( self , x : int ) -> int : l = 1 r = x + 1 while l < r : m = ( l + r ) // 2 if m * m > x : r = m else : l = m + 1 return l - 1 70. Climbing Stairs $\\star$ Time: $O(n)$ Space: $O(n) \\to O(1)$ class Solution : def climbStairs ( self , n : int ) -> int : if n == 1 : return 1 dp = [ 0 ] * ( n + 1 ) dp [ 1 ] = 1 dp [ 2 ] = 2 for i in range ( 3 , n + 1 ): dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] return dp [ n ]","title":"0061-0070"},{"location":"python3/0001-0100/0061-0070/#61-rotate-list-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def rotateRight ( self , head : ListNode , k : int ) -> ListNode : if not head or not head . next or k == 0 : return head length = 0 curr = head while curr : length += 1 curr = curr . next k %= length if k == 0 : return head slow = head fast = head for _ in range ( k ): fast = fast . next while fast and fast . next : slow = slow . next fast = fast . next ans = slow . next slow . next = None fast . next = head return ans","title":"61. Rotate List $\\star\\star$"},{"location":"python3/0001-0100/0061-0070/#62-unique-paths-starstar","text":"Time: $O(mn)$ Space: $O(mn) \\to O(n)$ class Solution : def uniquePaths ( self , m : int , n : int ) -> int : dp = [ 1 ] * n for i in range ( 1 , m ): for j in range ( 1 , n ): dp [ j ] += dp [ j - 1 ] return dp [ n - 1 ]","title":"62. Unique Paths $\\star\\star$"},{"location":"python3/0001-0100/0061-0070/#63-unique-paths-ii-starstar","text":"Time: $O(mn)$ Space: $O(mn) \\to O(n)$ class Solution : def uniquePathsWithObstacles ( self , obstacleGrid : List [ List [ int ]]) -> int : m = len ( obstacleGrid ) n = len ( obstacleGrid [ 0 ]) dp = [ 0 ] * n dp [ 0 ] = 1 for i in range ( m ): for j in range ( n ): if obstacleGrid [ i ][ j ]: dp [ j ] = 0 elif j > 0 : dp [ j ] += dp [ j - 1 ] return dp [ n - 1 ]","title":"63. Unique Paths II $\\star\\star$"},{"location":"python3/0001-0100/0061-0070/#64-minimum-path-sum-starstar","text":"Time: $O(mn)$ Space: $O(1)$ class Solution : def minPathSum ( self , grid : List [ List [ int ]]) -> int : m = len ( grid ) n = len ( grid [ 0 ]) for i in range ( 1 , m ): grid [ i ][ 0 ] += grid [ i - 1 ][ 0 ] for j in range ( 1 , n ): grid [ 0 ][ j ] += grid [ 0 ][ j - 1 ] for i in range ( 1 , m ): for j in range ( 1 , n ): grid [ i ][ j ] += min ( grid [ i - 1 ][ j ], grid [ i ][ j - 1 ]) return grid [ m - 1 ][ n - 1 ]","title":"64. Minimum Path Sum $\\star\\star$"},{"location":"python3/0001-0100/0061-0070/#65-valid-number-starstarstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def isNumber ( self , s : str ) -> bool : s = s . strip () if not s : return False seenNum = False seenDot = False seenE = False for i , c in enumerate ( s ): if c == '.' : if seenDot or seenE : return False seenDot = True elif c == 'e' : if seenE or not seenNum : return False seenE = True seenNum = False elif c in '+-' : if i > 0 and s [ i - 1 ] != 'e' : return False seenNum = False else : if not c . isdigit (): return False seenNum = True return seenNum","title":"65. Valid Number $\\star\\star\\star$"},{"location":"python3/0001-0100/0061-0070/#66-plus-one-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def plusOne ( self , digits : List [ int ]) -> List [ int ]: n = len ( digits ) for i in range ( n - 1 , - 1 , - 1 ): if digits [ i ] < 9 : digits [ i ] += 1 return digits digits [ i ] = 0 return [ 1 ] + [ 0 ] * n","title":"66. Plus One $\\star$"},{"location":"python3/0001-0100/0061-0070/#67-add-binary-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def addBinary ( self , a : str , b : str ) -> str : ans = '' carry = 0 i = len ( a ) - 1 j = len ( b ) - 1 while carry == 1 or i >= 0 or j >= 0 : if i >= 0 : carry += ord ( a [ i ]) - ord ( '0' ) i -= 1 if j >= 0 : carry += ord ( b [ j ]) - ord ( '0' ) j -= 1 ans = chr ( carry % 2 + ord ( '0' )) + ans carry >>= 1 return ans","title":"67. Add Binary $\\star$"},{"location":"python3/0001-0100/0061-0070/#68-text-justification-starstarstar","text":"Time: $O( sum(len(words[i]) )$ Space: $O(1)$ class Solution : def fullJustify ( self , words : List [ str ], maxWidth : int ) -> List [ str ]: ans = [] curr = [] numOfLetters = 0 for word in words : if numOfLetters + len ( word ) + len ( curr ) > maxWidth : for i in range ( maxWidth - numOfLetters ): curr [ i % ( len ( curr ) - 1 or 1 )] += ' ' ans . append ( '' . join ( curr )) curr = [] numOfLetters = 0 curr . append ( word ) numOfLetters += len ( word ) return ans + [ ' ' . join ( curr ) . ljust ( maxWidth )]","title":"68. Text Justification $\\star\\star\\star$"},{"location":"python3/0001-0100/0061-0070/#69-sqrtx-star","text":"Time: $O(\\log x)$ Space: $O(1)$ class Solution : def mySqrt ( self , x : int ) -> int : l = 1 r = x + 1 while l < r : m = ( l + r ) // 2 if m * m > x : r = m else : l = m + 1 return l - 1","title":"69. Sqrt(x) $\\star$"},{"location":"python3/0001-0100/0061-0070/#70-climbing-stairs-star","text":"Time: $O(n)$ Space: $O(n) \\to O(1)$ class Solution : def climbStairs ( self , n : int ) -> int : if n == 1 : return 1 dp = [ 0 ] * ( n + 1 ) dp [ 1 ] = 1 dp [ 2 ] = 2 for i in range ( 3 , n + 1 ): dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] return dp [ n ]","title":"70. Climbing Stairs $\\star$"},{"location":"python3/0001-0100/0071-0080/","text":"71. Simplify Path $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution : def simplifyPath ( self , path : str ) -> str : stack = [] for str in path . split ( '/' ): if str in ( '' , '.' ): continue if str == '..' : if stack : stack . pop () else : stack . append ( str ) return '/' + '/' . join ( stack ) 72. Edit Distance $\\star\\star\\star$ Time: $O(mn)$ Space: $O(mn) \\to O(n)$ class Solution : def minDistance ( self , word1 : str , word2 : str ) -> int : m = len ( word1 ) n = len ( word2 ) dp = [[ 0 ] * ( n + 1 ) for _ in range ( m + 1 )] for i in range ( m + 1 ): for j in range ( n + 1 ): if i == 0 : dp [ i ][ j ] = j elif j == 0 : dp [ i ][ j ] = i else : dp [ i ][ j ] = min ( dp [ i - 1 ][ j - 1 ] + ( 0 if word1 [ i - 1 ] == word2 [ j - 1 ] else 1 ), dp [ i - 1 ][ j ] + 1 , dp [ i ][ j - 1 ] + 1 ) return dp [ m ][ n ] 73. Set Matrix Zeroes $\\star\\star$ Time: $O(mn)$ Space: $O(1)$ class Solution : def setZeroes ( self , matrix : List [ List [ int ]]) -> None : m = len ( matrix ) n = len ( matrix [ 0 ]) isFirstRow = 0 in matrix [ 0 ] isFirstCol = 0 in list ( zip ( * matrix ))[ 0 ] for i in range ( 1 , m ): for j in range ( 1 , n ): if matrix [ i ][ j ] == 0 : matrix [ i ][ 0 ] = 0 matrix [ 0 ][ j ] = 0 for i in range ( 1 , m ): for j in range ( 1 , n ): if matrix [ i ][ 0 ] == 0 or matrix [ 0 ][ j ] == 0 : matrix [ i ][ j ] = 0 if isFirstRow : matrix [ 0 ] = [ 0 ] * n if isFirstCol : for row in matrix : row [ 0 ] = 0 74. Search a 2D Matrix $\\star\\star$ Time: $O(mn\\log mn)$ Space: $O(1)$ class Solution : def searchMatrix ( self , matrix : List [ List [ int ]], target : int ) -> bool : if not matrix : return False m = len ( matrix ) n = len ( matrix [ 0 ]) l = 0 r = m * n while l < r : mid = l + ( r - l ) // 2 i = mid // n j = mid % n if matrix [ i ][ j ] == target : return True if matrix [ i ][ j ] < target : l = mid + 1 else : r = mid return False 75. Sort Colors $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def sortColors ( self , nums : List [ int ]) -> None : zero = - 1 one = - 1 two = - 1 for num in nums : if num == 0 : two += 1 one += 1 zero += 1 nums [ two ] = 2 nums [ one ] = 1 nums [ zero ] = 0 elif num == 1 : two += 1 one += 1 nums [ two ] = 2 nums [ one ] = 1 else : two += 1 nums [ two ] = 2 76. Minimum Window Substring $\\star\\star\\star$ Time: $O(n)$ Space: $O(128)$ class Solution : def minWindow ( self , s : str , t : str ) -> str : count = collections . Counter ( t ) required = len ( t ) bestLeft = 0 minLength = float ( 'inf' ) l = 0 for r , c in enumerate ( s ): count [ c ] -= 1 if count [ c ] >= 0 : required -= 1 while required == 0 : if r - l + 1 < minLength : bestLeft = l minLength = r - l + 1 count [ s [ l ]] += 1 if count [ s [ l ]] > 0 : required += 1 l += 1 return \"\" if minLength == float ( 'inf' ) else s [ bestLeft : bestLeft + minLength ] 77. Combinations $\\star\\star$ Time: $O(C(n, k))$ Space: $O(k)$ class Solution : def combine ( self , n : int , k : int ) -> List [ List [ int ]]: ans = [] self . dfs ( n , k , 1 , [], ans ) return ans def dfs ( self , n : int , k : int , s : int , path : List [ int ], ans : List [ List [ int ]]) -> None : if k == 0 : ans . append ( path ) return for i in range ( s , n + 1 ): self . dfs ( n , k - 1 , i + 1 , path + [ i ], ans ) 78. Subsets $\\star\\star$ Time: $O(2^n)$ Space: $O(n)$ class Solution : def subsets ( self , nums : List [ int ]) -> List [ List [ int ]]: def dfs ( s : int , path : List [ int ]) -> None : ans . append ( path ) for i in range ( s , len ( nums )): dfs ( i + 1 , path + [ nums [ i ]]) ans = [] dfs ( 0 , []) return ans 79. Word Search $\\star\\star$ Time: $O(4^l)$, where l = len(word) Space: $O(1)$ class Solution : def exist ( self , board : List [ List [ str ]], word : str ) -> bool : def dfs ( i : int , j : int , pos : int ) -> bool : if not 0 <= i < len ( board ) or not 0 <= j < len ( board [ 0 ]) or board [ i ][ j ] != word [ pos ] or board [ i ][ j ] == '*' : return False if pos == len ( word ) - 1 : return True c = board [ i ][ j ] board [ i ][ j ] = '*' flag = \\ dfs ( i + 1 , j , pos + 1 ) or \\ dfs ( i - 1 , j , pos + 1 ) or \\ dfs ( i , j + 1 , pos + 1 ) or \\ dfs ( i , j - 1 , pos + 1 ) board [ i ][ j ] = c return flag if not board : return False for i in range ( len ( board )): for j in range ( len ( board [ 0 ])): if dfs ( i , j , 0 ): return True return False 80. Remove Duplicates from Sorted Array II $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def removeDuplicates ( self , nums : List [ int ]) -> int : i = 0 for num in nums : if i < 2 or num != nums [ i - 2 ]: nums [ i ] = num i += 1 return i","title":"0071-0080"},{"location":"python3/0001-0100/0071-0080/#71-simplify-path-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution : def simplifyPath ( self , path : str ) -> str : stack = [] for str in path . split ( '/' ): if str in ( '' , '.' ): continue if str == '..' : if stack : stack . pop () else : stack . append ( str ) return '/' + '/' . join ( stack )","title":"71. Simplify Path $\\star\\star$"},{"location":"python3/0001-0100/0071-0080/#72-edit-distance-starstarstar","text":"Time: $O(mn)$ Space: $O(mn) \\to O(n)$ class Solution : def minDistance ( self , word1 : str , word2 : str ) -> int : m = len ( word1 ) n = len ( word2 ) dp = [[ 0 ] * ( n + 1 ) for _ in range ( m + 1 )] for i in range ( m + 1 ): for j in range ( n + 1 ): if i == 0 : dp [ i ][ j ] = j elif j == 0 : dp [ i ][ j ] = i else : dp [ i ][ j ] = min ( dp [ i - 1 ][ j - 1 ] + ( 0 if word1 [ i - 1 ] == word2 [ j - 1 ] else 1 ), dp [ i - 1 ][ j ] + 1 , dp [ i ][ j - 1 ] + 1 ) return dp [ m ][ n ]","title":"72. Edit Distance $\\star\\star\\star$"},{"location":"python3/0001-0100/0071-0080/#73-set-matrix-zeroes-starstar","text":"Time: $O(mn)$ Space: $O(1)$ class Solution : def setZeroes ( self , matrix : List [ List [ int ]]) -> None : m = len ( matrix ) n = len ( matrix [ 0 ]) isFirstRow = 0 in matrix [ 0 ] isFirstCol = 0 in list ( zip ( * matrix ))[ 0 ] for i in range ( 1 , m ): for j in range ( 1 , n ): if matrix [ i ][ j ] == 0 : matrix [ i ][ 0 ] = 0 matrix [ 0 ][ j ] = 0 for i in range ( 1 , m ): for j in range ( 1 , n ): if matrix [ i ][ 0 ] == 0 or matrix [ 0 ][ j ] == 0 : matrix [ i ][ j ] = 0 if isFirstRow : matrix [ 0 ] = [ 0 ] * n if isFirstCol : for row in matrix : row [ 0 ] = 0","title":"73. Set Matrix Zeroes $\\star\\star$"},{"location":"python3/0001-0100/0071-0080/#74-search-a-2d-matrix-starstar","text":"Time: $O(mn\\log mn)$ Space: $O(1)$ class Solution : def searchMatrix ( self , matrix : List [ List [ int ]], target : int ) -> bool : if not matrix : return False m = len ( matrix ) n = len ( matrix [ 0 ]) l = 0 r = m * n while l < r : mid = l + ( r - l ) // 2 i = mid // n j = mid % n if matrix [ i ][ j ] == target : return True if matrix [ i ][ j ] < target : l = mid + 1 else : r = mid return False","title":"74. Search a 2D Matrix $\\star\\star$"},{"location":"python3/0001-0100/0071-0080/#75-sort-colors-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def sortColors ( self , nums : List [ int ]) -> None : zero = - 1 one = - 1 two = - 1 for num in nums : if num == 0 : two += 1 one += 1 zero += 1 nums [ two ] = 2 nums [ one ] = 1 nums [ zero ] = 0 elif num == 1 : two += 1 one += 1 nums [ two ] = 2 nums [ one ] = 1 else : two += 1 nums [ two ] = 2","title":"75. Sort Colors $\\star\\star$"},{"location":"python3/0001-0100/0071-0080/#76-minimum-window-substring-starstarstar","text":"Time: $O(n)$ Space: $O(128)$ class Solution : def minWindow ( self , s : str , t : str ) -> str : count = collections . Counter ( t ) required = len ( t ) bestLeft = 0 minLength = float ( 'inf' ) l = 0 for r , c in enumerate ( s ): count [ c ] -= 1 if count [ c ] >= 0 : required -= 1 while required == 0 : if r - l + 1 < minLength : bestLeft = l minLength = r - l + 1 count [ s [ l ]] += 1 if count [ s [ l ]] > 0 : required += 1 l += 1 return \"\" if minLength == float ( 'inf' ) else s [ bestLeft : bestLeft + minLength ]","title":"76. Minimum Window Substring $\\star\\star\\star$"},{"location":"python3/0001-0100/0071-0080/#77-combinations-starstar","text":"Time: $O(C(n, k))$ Space: $O(k)$ class Solution : def combine ( self , n : int , k : int ) -> List [ List [ int ]]: ans = [] self . dfs ( n , k , 1 , [], ans ) return ans def dfs ( self , n : int , k : int , s : int , path : List [ int ], ans : List [ List [ int ]]) -> None : if k == 0 : ans . append ( path ) return for i in range ( s , n + 1 ): self . dfs ( n , k - 1 , i + 1 , path + [ i ], ans )","title":"77. Combinations $\\star\\star$"},{"location":"python3/0001-0100/0071-0080/#78-subsets-starstar","text":"Time: $O(2^n)$ Space: $O(n)$ class Solution : def subsets ( self , nums : List [ int ]) -> List [ List [ int ]]: def dfs ( s : int , path : List [ int ]) -> None : ans . append ( path ) for i in range ( s , len ( nums )): dfs ( i + 1 , path + [ nums [ i ]]) ans = [] dfs ( 0 , []) return ans","title":"78. Subsets $\\star\\star$"},{"location":"python3/0001-0100/0071-0080/#79-word-search-starstar","text":"Time: $O(4^l)$, where l = len(word) Space: $O(1)$ class Solution : def exist ( self , board : List [ List [ str ]], word : str ) -> bool : def dfs ( i : int , j : int , pos : int ) -> bool : if not 0 <= i < len ( board ) or not 0 <= j < len ( board [ 0 ]) or board [ i ][ j ] != word [ pos ] or board [ i ][ j ] == '*' : return False if pos == len ( word ) - 1 : return True c = board [ i ][ j ] board [ i ][ j ] = '*' flag = \\ dfs ( i + 1 , j , pos + 1 ) or \\ dfs ( i - 1 , j , pos + 1 ) or \\ dfs ( i , j + 1 , pos + 1 ) or \\ dfs ( i , j - 1 , pos + 1 ) board [ i ][ j ] = c return flag if not board : return False for i in range ( len ( board )): for j in range ( len ( board [ 0 ])): if dfs ( i , j , 0 ): return True return False","title":"79. Word Search $\\star\\star$"},{"location":"python3/0001-0100/0071-0080/#80-remove-duplicates-from-sorted-array-ii-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def removeDuplicates ( self , nums : List [ int ]) -> int : i = 0 for num in nums : if i < 2 or num != nums [ i - 2 ]: nums [ i ] = num i += 1 return i","title":"80. Remove Duplicates from Sorted Array II $\\star\\star$"},{"location":"python3/0001-0100/0081-0090/","text":"81. Search in Rotated Sorted Array II $\\star\\star$ Time: $O(\\log n) \\to O(n)$ Space: $O(1)$ class Solution : def search ( self , nums : List [ int ], target : int ) -> bool : l = 0 r = len ( nums ) - 1 while l <= r : m = l + ( r - l ) // 2 if nums [ m ] == target : return True if nums [ l ] == nums [ m ] == nums [ r ]: l += 1 r -= 1 elif nums [ l ] <= nums [ m ]: if nums [ l ] <= target < nums [ m ]: r = m - 1 else : l = m + 1 else : if nums [ m ] < target <= nums [ r ]: l = m + 1 else : r = m - 1 return False 82. Remove Duplicates from Sorted List II $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def deleteDuplicates ( self , head : ListNode ) -> ListNode : dummy = ListNode ( 0 ) dummy . next = head prev = dummy while head : while head . next and head . val == head . next . val : head = head . next if prev . next == head : prev = prev . next else : prev . next = head . next head = head . next return dummy . next 83. Remove Duplicates from Sorted List $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def deleteDuplicates ( self , head : ListNode ) -> ListNode : curr = head while curr : while curr . next and curr . val == curr . next . val : curr . next = curr . next . next curr = curr . next return head 84. Largest Rectangle in Histogram $\\star\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution : def largestRectangleArea ( self , heights : List [ int ]) -> int : ans = 0 stack = [] for i in range ( len ( heights ) + 1 ): while stack != [] and ( i == len ( heights ) or heights [ i ] < heights [ stack [ - 1 ]]): h = heights [ stack . pop ()] w = i if stack == [] else i - stack [ - 1 ] - 1 ans = max ( ans , h * w ) stack . append ( i ) return ans 85. Maximal Rectangle $\\star\\star\\star$ Time: $O(mn)$, where $m = len(matrix)$ and n = len(matrix[i]) Space: $O(n)$ class Solution : def maximalRectangle ( self , matrix : List [ List [ str ]]) -> int : def largestRectangleArea ( heights : List [ int ]) -> int : ans = 0 stack = [] for i in range ( len ( heights ) + 1 ): while stack != [] and ( i == len ( heights ) or heights [ i ] < heights [ stack [ - 1 ]]): h = heights [ stack . pop ()] w = i if stack == [] else i - stack [ - 1 ] - 1 ans = max ( ans , h * w ) stack . append ( i ) return ans if matrix == []: return 0 ans = 0 temp = [ 0 ] * len ( matrix [ 0 ]) for row in matrix : for i , num in enumerate ( row ): temp [ i ] = 0 if num == '0' else temp [ i ] + 1 ans = max ( ans , largestRectangleArea ( temp )) return ans 86. Partition List $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def partition ( self , head : ListNode , x : int ) -> ListNode : beforeHead = ListNode ( 0 ) afterHead = ListNode ( 0 ) before = beforeHead after = afterHead while head : if head . val < x : before . next = head before = head else : after . next = head after = head head = head . next after . next = None before . next = afterHead . next return beforeHead . next 87. Scramble String $\\star\\star\\star$ class Solution : def isScramble ( self , s1 : str , s2 : str ) -> bool : if s1 == s2 : return True if len ( s1 ) != len ( s2 ): return False if collections . Counter ( s1 ) != collections . Counter ( s2 ): return False for i in range ( 1 , len ( s1 )): if self . isScramble ( s1 [: i ], s2 [: i ]) and self . isScramble ( s1 [ i :], s2 [ i :]): return True if self . isScramble ( s1 [: i ], s2 [ len ( s2 ) - i :]) and self . isScramble ( s1 [ i :], s2 [: len ( s2 ) - i ]): return True return False 88. Merge Sorted Array $\\star$ Time: $O(m + n)$ Space: $O(1)$ class Solution : def merge ( self , nums1 : List [ int ], m : int , nums2 : List [ int ], n : int ) -> None : k = m + n while n > 0 : k -= 1 if m > 0 and nums1 [ m - 1 ] > nums2 [ n - 1 ]: m -= 1 nums1 [ k ] = nums1 [ m ] else : n -= 1 nums1 [ k ] = nums2 [ n ] 89. Gray Code $\\star\\star$ Time: $O(2^n)$ Space: $O(2^n)$ class Solution : def grayCode ( self , n : int ) -> List [ int ]: ans = [ 0 ] for i in range ( n ): for j in range ( len ( ans ) - 1 , - 1 , - 1 ): ans . append ( ans [ j ] | 1 << i ) return ans 90. Subsets II $\\star\\star$ Time: $O(n2^n)$ Space: $O(n)$ class Solution : def subsetsWithDup ( self , nums : List [ int ]) -> List [ List [ int ]]: def dfs ( s : int , path : List [ int ]) -> None : ans . append ( path ) if s == len ( nums ): return for i in range ( s , len ( nums )): if i > s and nums [ i ] == nums [ i - 1 ]: continue dfs ( i + 1 , path + [ nums [ i ]]) ans = [] nums . sort () dfs ( 0 , []) return ans","title":"0081-0090"},{"location":"python3/0001-0100/0081-0090/#81-search-in-rotated-sorted-array-ii-starstar","text":"Time: $O(\\log n) \\to O(n)$ Space: $O(1)$ class Solution : def search ( self , nums : List [ int ], target : int ) -> bool : l = 0 r = len ( nums ) - 1 while l <= r : m = l + ( r - l ) // 2 if nums [ m ] == target : return True if nums [ l ] == nums [ m ] == nums [ r ]: l += 1 r -= 1 elif nums [ l ] <= nums [ m ]: if nums [ l ] <= target < nums [ m ]: r = m - 1 else : l = m + 1 else : if nums [ m ] < target <= nums [ r ]: l = m + 1 else : r = m - 1 return False","title":"81. Search in Rotated Sorted Array II $\\star\\star$"},{"location":"python3/0001-0100/0081-0090/#82-remove-duplicates-from-sorted-list-ii-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def deleteDuplicates ( self , head : ListNode ) -> ListNode : dummy = ListNode ( 0 ) dummy . next = head prev = dummy while head : while head . next and head . val == head . next . val : head = head . next if prev . next == head : prev = prev . next else : prev . next = head . next head = head . next return dummy . next","title":"82. Remove Duplicates from Sorted List II $\\star\\star$"},{"location":"python3/0001-0100/0081-0090/#83-remove-duplicates-from-sorted-list-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def deleteDuplicates ( self , head : ListNode ) -> ListNode : curr = head while curr : while curr . next and curr . val == curr . next . val : curr . next = curr . next . next curr = curr . next return head","title":"83. Remove Duplicates from Sorted List $\\star$"},{"location":"python3/0001-0100/0081-0090/#84-largest-rectangle-in-histogram-starstarstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution : def largestRectangleArea ( self , heights : List [ int ]) -> int : ans = 0 stack = [] for i in range ( len ( heights ) + 1 ): while stack != [] and ( i == len ( heights ) or heights [ i ] < heights [ stack [ - 1 ]]): h = heights [ stack . pop ()] w = i if stack == [] else i - stack [ - 1 ] - 1 ans = max ( ans , h * w ) stack . append ( i ) return ans","title":"84. Largest Rectangle in Histogram $\\star\\star\\star$"},{"location":"python3/0001-0100/0081-0090/#85-maximal-rectangle-starstarstar","text":"Time: $O(mn)$, where $m = len(matrix)$ and n = len(matrix[i]) Space: $O(n)$ class Solution : def maximalRectangle ( self , matrix : List [ List [ str ]]) -> int : def largestRectangleArea ( heights : List [ int ]) -> int : ans = 0 stack = [] for i in range ( len ( heights ) + 1 ): while stack != [] and ( i == len ( heights ) or heights [ i ] < heights [ stack [ - 1 ]]): h = heights [ stack . pop ()] w = i if stack == [] else i - stack [ - 1 ] - 1 ans = max ( ans , h * w ) stack . append ( i ) return ans if matrix == []: return 0 ans = 0 temp = [ 0 ] * len ( matrix [ 0 ]) for row in matrix : for i , num in enumerate ( row ): temp [ i ] = 0 if num == '0' else temp [ i ] + 1 ans = max ( ans , largestRectangleArea ( temp )) return ans","title":"85. Maximal Rectangle $\\star\\star\\star$"},{"location":"python3/0001-0100/0081-0090/#86-partition-list-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def partition ( self , head : ListNode , x : int ) -> ListNode : beforeHead = ListNode ( 0 ) afterHead = ListNode ( 0 ) before = beforeHead after = afterHead while head : if head . val < x : before . next = head before = head else : after . next = head after = head head = head . next after . next = None before . next = afterHead . next return beforeHead . next","title":"86. Partition List $\\star\\star$"},{"location":"python3/0001-0100/0081-0090/#87-scramble-string-starstarstar","text":"class Solution : def isScramble ( self , s1 : str , s2 : str ) -> bool : if s1 == s2 : return True if len ( s1 ) != len ( s2 ): return False if collections . Counter ( s1 ) != collections . Counter ( s2 ): return False for i in range ( 1 , len ( s1 )): if self . isScramble ( s1 [: i ], s2 [: i ]) and self . isScramble ( s1 [ i :], s2 [ i :]): return True if self . isScramble ( s1 [: i ], s2 [ len ( s2 ) - i :]) and self . isScramble ( s1 [ i :], s2 [: len ( s2 ) - i ]): return True return False","title":"87. Scramble String $\\star\\star\\star$"},{"location":"python3/0001-0100/0081-0090/#88-merge-sorted-array-star","text":"Time: $O(m + n)$ Space: $O(1)$ class Solution : def merge ( self , nums1 : List [ int ], m : int , nums2 : List [ int ], n : int ) -> None : k = m + n while n > 0 : k -= 1 if m > 0 and nums1 [ m - 1 ] > nums2 [ n - 1 ]: m -= 1 nums1 [ k ] = nums1 [ m ] else : n -= 1 nums1 [ k ] = nums2 [ n ]","title":"88. Merge Sorted Array $\\star$"},{"location":"python3/0001-0100/0081-0090/#89-gray-code-starstar","text":"Time: $O(2^n)$ Space: $O(2^n)$ class Solution : def grayCode ( self , n : int ) -> List [ int ]: ans = [ 0 ] for i in range ( n ): for j in range ( len ( ans ) - 1 , - 1 , - 1 ): ans . append ( ans [ j ] | 1 << i ) return ans","title":"89. Gray Code $\\star\\star$"},{"location":"python3/0001-0100/0081-0090/#90-subsets-ii-starstar","text":"Time: $O(n2^n)$ Space: $O(n)$ class Solution : def subsetsWithDup ( self , nums : List [ int ]) -> List [ List [ int ]]: def dfs ( s : int , path : List [ int ]) -> None : ans . append ( path ) if s == len ( nums ): return for i in range ( s , len ( nums )): if i > s and nums [ i ] == nums [ i - 1 ]: continue dfs ( i + 1 , path + [ nums [ i ]]) ans = [] nums . sort () dfs ( 0 , []) return ans","title":"90. Subsets II $\\star\\star$"},{"location":"python3/0001-0100/0091-0100/","text":"91. Decode Ways $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution : def numDecodings ( self , s : str ) -> int : if not s or s [ 0 ] == '0' : return 0 if len ( s ) == 1 : return 1 dp1 = 1 dp2 = 1 for i in range ( 1 , len ( s )): dp = 0 if not self . isValid ( s [ i ]) and not self . isValid ( s [ i - 1 ], s [ i ]): return 0 if self . isValid ( s [ i ]): dp += dp1 if self . isValid ( s [ i - 1 ], s [ i ]): dp += dp2 dp2 = dp1 dp1 = dp return dp1 def isValid ( self , a : chr , b = None ) -> bool : if b : return a == '1' or ( a == '2' and b <= '6' ) return a != '0' 92. Reverse Linked List II $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def reverseBetween ( self , head : ListNode , m : int , n : int ) -> ListNode : if not head : return None prev = None curr = head for _ in range ( m - 1 ): prev = curr curr = curr . next conn = prev tail = curr for _ in range ( n - m + 1 ): next = curr . next curr . next = prev prev = curr curr = next if conn : conn . next = prev else : head = prev tail . next = curr return head 93. Restore IP Addresses $\\star\\star$ Time: $O(3^4)$ Space: $O(1)$ class Solution : def restoreIpAddresses ( self , s : str ) -> List [ str ]: def dfs ( index : int , path : List [ str ]): if len ( path ) == 4 and index == len ( s ): ans . append ( path [ 0 ] + '.' + path [ 1 ] + '.' + path [ 2 ] + '.' + path [ 3 ]) return if len ( path ) == 4 or index == len ( s ): return for i in range ( 1 , 4 ): if index + i > len ( s ): return if i > 1 and s [ index ] == '0' : return num = s [ index : index + i ] if int ( num ) > 255 : return dfs ( index + i , path + [ num ]) ans = [] dfs ( 0 , []) return ans 94. Binary Tree Inorder Traversal $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution : def inorderTraversal ( self , root : TreeNode ) -> List [ int ]: ans = [] stack = [] curr = root while curr or stack : while curr : stack . append ( curr ) curr = curr . left curr = stack . pop () ans . append ( curr . val ) curr = curr . right return ans 95. Unique Binary Search Trees II $\\star\\star$ Time: $O(3^n)$ Space: $O(3^n)$ class Solution : def generateTrees ( self , n : int ) -> List [ TreeNode ]: if n == 0 : return [] return self . helper ( 1 , n ) def helper ( self , min : int , max : int ) -> List [ TreeNode ]: ans = [] if min > max : ans . append ( None ) return ans for i in range ( min , max + 1 ): leftTree = self . helper ( min , i - 1 ) rightTree = self . helper ( i + 1 , max ) for left in leftTree : for right in rightTree : root = TreeNode ( i ) root . left = left root . right = right ans . append ( root ) return ans 96. Unique Binary Search Trees $\\star\\star$ Time: $O(n^2)$ Space: $O(n)$ class Solution : def numTrees ( self , n : int ) -> int : G = [ 0 ] * ( n + 1 ) G [ 0 ] = 1 G [ 1 ] = 1 for i in range ( 2 , n + 1 ): for j in range ( i ): G [ i ] += G [ j ] * G [ i - j - 1 ] return G [ n ] 97. Interleaving String $\\star\\star\\star$ Time: $O(mn)$, where m = len(s1) and n = len(s2) Space: $O(mn) \\to O(n)$, where m = len(s1) and n = len(s2) class Solution : def isInterleave ( self , s1 : str , s2 : str , s3 : str ) -> bool : if len ( s1 ) + len ( s2 ) != len ( s3 ): return False dp = [ False ] * ( len ( s2 ) + 1 ) for i in range ( len ( s1 ) + 1 ): for j in range ( len ( s2 ) + 1 ): if i == 0 and j == 0 : dp [ j ] = True elif i == 0 : dp [ j ] = dp [ j - 1 ] and s2 [ j - 1 ] == s3 [ i + j - 1 ] elif j == 0 : dp [ j ] = dp [ j ] and s1 [ i - 1 ] == s3 [ i + j - 1 ] else : dp [ j ] = ( dp [ j ] and s1 [ i - 1 ] == s3 [ i + j - 1 ]) or ( dp [ j - 1 ] and s2 [ j - 1 ] == s3 [ i + j - 1 ]) return dp [ len ( s2 )] 98. Validate Binary Search Tree $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def isValidBST ( self , root : TreeNode ) -> bool : def dfs ( root : TreeNode , minNode : TreeNode , maxNode : TreeNode ): if not root : return True if minNode and minNode . val >= root . val or \\ maxNode and maxNode . val <= root . val : return False return dfs ( root . left , minNode , root ) and \\ dfs ( root . right , root , maxNode ) return dfs ( root , None , None ) 99. Recover Binary Search Tree $\\star\\star\\star$ 100. Same Tree $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def isSameTree ( self , p : TreeNode , q : TreeNode ) -> bool : if not p or not q : return p == q return p . val == q . val and \\ self . isSameTree ( p . left , q . left ) and \\ self . isSameTree ( p . right , q . right )","title":"0091-0100"},{"location":"python3/0001-0100/0091-0100/#91-decode-ways-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution : def numDecodings ( self , s : str ) -> int : if not s or s [ 0 ] == '0' : return 0 if len ( s ) == 1 : return 1 dp1 = 1 dp2 = 1 for i in range ( 1 , len ( s )): dp = 0 if not self . isValid ( s [ i ]) and not self . isValid ( s [ i - 1 ], s [ i ]): return 0 if self . isValid ( s [ i ]): dp += dp1 if self . isValid ( s [ i - 1 ], s [ i ]): dp += dp2 dp2 = dp1 dp1 = dp return dp1 def isValid ( self , a : chr , b = None ) -> bool : if b : return a == '1' or ( a == '2' and b <= '6' ) return a != '0'","title":"91. Decode Ways $\\star\\star$"},{"location":"python3/0001-0100/0091-0100/#92-reverse-linked-list-ii-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def reverseBetween ( self , head : ListNode , m : int , n : int ) -> ListNode : if not head : return None prev = None curr = head for _ in range ( m - 1 ): prev = curr curr = curr . next conn = prev tail = curr for _ in range ( n - m + 1 ): next = curr . next curr . next = prev prev = curr curr = next if conn : conn . next = prev else : head = prev tail . next = curr return head","title":"92. Reverse Linked List II $\\star\\star$"},{"location":"python3/0001-0100/0091-0100/#93-restore-ip-addresses-starstar","text":"Time: $O(3^4)$ Space: $O(1)$ class Solution : def restoreIpAddresses ( self , s : str ) -> List [ str ]: def dfs ( index : int , path : List [ str ]): if len ( path ) == 4 and index == len ( s ): ans . append ( path [ 0 ] + '.' + path [ 1 ] + '.' + path [ 2 ] + '.' + path [ 3 ]) return if len ( path ) == 4 or index == len ( s ): return for i in range ( 1 , 4 ): if index + i > len ( s ): return if i > 1 and s [ index ] == '0' : return num = s [ index : index + i ] if int ( num ) > 255 : return dfs ( index + i , path + [ num ]) ans = [] dfs ( 0 , []) return ans","title":"93. Restore IP Addresses $\\star\\star$"},{"location":"python3/0001-0100/0091-0100/#94-binary-tree-inorder-traversal-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution : def inorderTraversal ( self , root : TreeNode ) -> List [ int ]: ans = [] stack = [] curr = root while curr or stack : while curr : stack . append ( curr ) curr = curr . left curr = stack . pop () ans . append ( curr . val ) curr = curr . right return ans","title":"94. Binary Tree Inorder Traversal $\\star\\star$"},{"location":"python3/0001-0100/0091-0100/#95-unique-binary-search-trees-ii-starstar","text":"Time: $O(3^n)$ Space: $O(3^n)$ class Solution : def generateTrees ( self , n : int ) -> List [ TreeNode ]: if n == 0 : return [] return self . helper ( 1 , n ) def helper ( self , min : int , max : int ) -> List [ TreeNode ]: ans = [] if min > max : ans . append ( None ) return ans for i in range ( min , max + 1 ): leftTree = self . helper ( min , i - 1 ) rightTree = self . helper ( i + 1 , max ) for left in leftTree : for right in rightTree : root = TreeNode ( i ) root . left = left root . right = right ans . append ( root ) return ans","title":"95. Unique Binary Search Trees II $\\star\\star$"},{"location":"python3/0001-0100/0091-0100/#96-unique-binary-search-trees-starstar","text":"Time: $O(n^2)$ Space: $O(n)$ class Solution : def numTrees ( self , n : int ) -> int : G = [ 0 ] * ( n + 1 ) G [ 0 ] = 1 G [ 1 ] = 1 for i in range ( 2 , n + 1 ): for j in range ( i ): G [ i ] += G [ j ] * G [ i - j - 1 ] return G [ n ]","title":"96. Unique Binary Search Trees $\\star\\star$"},{"location":"python3/0001-0100/0091-0100/#97-interleaving-string-starstarstar","text":"Time: $O(mn)$, where m = len(s1) and n = len(s2) Space: $O(mn) \\to O(n)$, where m = len(s1) and n = len(s2) class Solution : def isInterleave ( self , s1 : str , s2 : str , s3 : str ) -> bool : if len ( s1 ) + len ( s2 ) != len ( s3 ): return False dp = [ False ] * ( len ( s2 ) + 1 ) for i in range ( len ( s1 ) + 1 ): for j in range ( len ( s2 ) + 1 ): if i == 0 and j == 0 : dp [ j ] = True elif i == 0 : dp [ j ] = dp [ j - 1 ] and s2 [ j - 1 ] == s3 [ i + j - 1 ] elif j == 0 : dp [ j ] = dp [ j ] and s1 [ i - 1 ] == s3 [ i + j - 1 ] else : dp [ j ] = ( dp [ j ] and s1 [ i - 1 ] == s3 [ i + j - 1 ]) or ( dp [ j - 1 ] and s2 [ j - 1 ] == s3 [ i + j - 1 ]) return dp [ len ( s2 )]","title":"97. Interleaving String $\\star\\star\\star$"},{"location":"python3/0001-0100/0091-0100/#98-validate-binary-search-tree-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def isValidBST ( self , root : TreeNode ) -> bool : def dfs ( root : TreeNode , minNode : TreeNode , maxNode : TreeNode ): if not root : return True if minNode and minNode . val >= root . val or \\ maxNode and maxNode . val <= root . val : return False return dfs ( root . left , minNode , root ) and \\ dfs ( root . right , root , maxNode ) return dfs ( root , None , None )","title":"98. Validate Binary Search Tree $\\star\\star$"},{"location":"python3/0001-0100/0091-0100/#99-recover-binary-search-tree-starstarstar","text":"","title":"99. Recover Binary Search Tree $\\star\\star\\star$"},{"location":"python3/0001-0100/0091-0100/#100-same-tree-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def isSameTree ( self , p : TreeNode , q : TreeNode ) -> bool : if not p or not q : return p == q return p . val == q . val and \\ self . isSameTree ( p . left , q . left ) and \\ self . isSameTree ( p . right , q . right )","title":"100. Same Tree $\\star$"},{"location":"python3/0101-0200/0101-0110/","text":"101. Symmetric Tree $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def isSymmetric ( self , root : TreeNode ) -> bool : def helper ( p : TreeNode , q : TreeNode ) -> bool : if not p or not q : return p == q return p . val == q . val and \\ helper ( p . left , q . right ) and \\ helper ( p . right , q . left ) return helper ( root , root ) 102. Binary Tree Level Order Traversal $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution : def levelOrder ( self , root : TreeNode ) -> List [ List [ int ]]: if not root : return [] ans = [] queue = collections . deque ([ root ]) while queue : currLevel = [] for _ in range ( len ( queue )): node = queue . popleft () currLevel . append ( node . val ) if node . left : queue . append ( node . left ) if node . right : queue . append ( node . right ) ans . append ( currLevel ) return ans 103. Binary Tree Zigzag Level Order Traversal $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution : def zigzagLevelOrder ( self , root : TreeNode ) -> List [ List [ int ]]: if not root : return [] ans = [] deque = collections . deque ([ root ]) isLeftToRight = True while deque : currLevel = [] for i in range ( len ( deque )): if isLeftToRight : node = deque . popleft () currLevel . append ( node . val ) if node . left : deque . append ( node . left ) if node . right : deque . append ( node . right ) else : node = deque . pop () currLevel . append ( node . val ) if node . right : deque . appendleft ( node . right ) if node . left : deque . appendleft ( node . left ) ans . append ( currLevel ) isLeftToRight = not isLeftToRight return ans 104. Maximum Depth of Binary Tree $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def maxDepth ( self , root : TreeNode ) -> int : if not root : return 0 return 1 + max ( self . maxDepth ( root . left ), self . maxDepth ( root . right )) 105. Construct Binary Tree from Preorder and Inorder Traversal $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution : def buildTree ( self , preorder : List [ int ], inorder : List [ int ]) -> TreeNode : def helper ( pL : int , pR : int , iL : int , iR : int ) -> TreeNode : if pL > pR : return None i = inorderToIndex [ preorder [ pL ]] curr = TreeNode ( preorder [ pL ]) curr . left = helper ( pL + 1 , pL + i - iL , iL , i - 1 ) curr . right = helper ( pL + i - iL + 1 , pR , i + 1 , iR ) return curr inorderToIndex = { num : i for i , num in enumerate ( inorder )} return helper ( 0 , len ( preorder ) - 1 , 0 , len ( inorder ) - 1 ) 106. Construct Binary Tree from Inorder and Postorder Traversal $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution : def buildTree ( self , inorder : List [ int ], postorder : List [ int ]) -> TreeNode : def helper ( iL : int , iR : int , pL : int , pR : int ) -> TreeNode : if iL > iR : return None i = inorderToIndex [ postorder [ pR ]] curr = TreeNode ( postorder [ pR ]) curr . left = helper ( iL , i - 1 , pL , pL + i - iL - 1 ) curr . right = helper ( i + 1 , iR , pL + i - iL , pR - 1 ) return curr inorderToIndex = { num : i for i , num in enumerate ( inorder )} return helper ( 0 , len ( inorder ) - 1 , 0 , len ( postorder ) - 1 ) 107. Binary Tree Level Order Traversal II $\\star$ Time: $O(n)$ Space: $O(n)$ class Solution : def levelOrderBottom ( self , root : TreeNode ) -> List [ List [ int ]]: if not root : return [] ans = [] queue = collections . deque ([ root ]) while queue : currLevel = [] for _ in range ( len ( queue )): node = queue . popleft () currLevel . append ( node . val ) if node . left : queue . append ( node . left ) if node . right : queue . append ( node . right ) ans . insert ( 0 , currLevel ) return ans 108. Convert Sorted Array to Binary Search Tree $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def sortedArrayToBST ( self , nums : List [ int ]) -> TreeNode : def helper ( l : int , r : int ) -> TreeNode : if l > r : return None m = ( l + r ) // 2 root = TreeNode ( nums [ m ]) root . left = helper ( l , m - 1 ) root . right = helper ( m + 1 , r ) return root return helper ( 0 , len ( nums ) - 1 ) 109. Convert Sorted List to Binary Search Tree $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def sortedListToBST ( self , head : ListNode ) -> TreeNode : def findMid ( head : ListNode ) -> ListNode : prev = None slow = head fast = head while fast and fast . next : prev = slow slow = slow . next fast = fast . next . next prev . next = None return slow if not head : return None if not head . next : return TreeNode ( head . val ) mid = findMid ( head ) root = TreeNode ( mid . val ) root . left = self . sortedListToBST ( head ) root . right = self . sortedListToBST ( mid . next ) return root 110. Balanced Binary Tree $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def isBalanced ( self , root : TreeNode ) -> bool : def maxDepth ( root : TreeNode ) -> int : if not root : return 0 return 1 + max ( maxDepth ( root . left ), maxDepth ( root . right )) if not root : return True return abs ( maxDepth ( root . left ) - maxDepth ( root . right )) <= 1 and \\ self . isBalanced ( root . left ) and self . isBalanced ( root . right )","title":"0101-0110"},{"location":"python3/0101-0200/0101-0110/#101-symmetric-tree-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def isSymmetric ( self , root : TreeNode ) -> bool : def helper ( p : TreeNode , q : TreeNode ) -> bool : if not p or not q : return p == q return p . val == q . val and \\ helper ( p . left , q . right ) and \\ helper ( p . right , q . left ) return helper ( root , root )","title":"101. Symmetric Tree $\\star$"},{"location":"python3/0101-0200/0101-0110/#102-binary-tree-level-order-traversal-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution : def levelOrder ( self , root : TreeNode ) -> List [ List [ int ]]: if not root : return [] ans = [] queue = collections . deque ([ root ]) while queue : currLevel = [] for _ in range ( len ( queue )): node = queue . popleft () currLevel . append ( node . val ) if node . left : queue . append ( node . left ) if node . right : queue . append ( node . right ) ans . append ( currLevel ) return ans","title":"102. Binary Tree Level Order Traversal $\\star\\star$"},{"location":"python3/0101-0200/0101-0110/#103-binary-tree-zigzag-level-order-traversal-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution : def zigzagLevelOrder ( self , root : TreeNode ) -> List [ List [ int ]]: if not root : return [] ans = [] deque = collections . deque ([ root ]) isLeftToRight = True while deque : currLevel = [] for i in range ( len ( deque )): if isLeftToRight : node = deque . popleft () currLevel . append ( node . val ) if node . left : deque . append ( node . left ) if node . right : deque . append ( node . right ) else : node = deque . pop () currLevel . append ( node . val ) if node . right : deque . appendleft ( node . right ) if node . left : deque . appendleft ( node . left ) ans . append ( currLevel ) isLeftToRight = not isLeftToRight return ans","title":"103. Binary Tree Zigzag Level Order Traversal $\\star\\star$"},{"location":"python3/0101-0200/0101-0110/#104-maximum-depth-of-binary-tree-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def maxDepth ( self , root : TreeNode ) -> int : if not root : return 0 return 1 + max ( self . maxDepth ( root . left ), self . maxDepth ( root . right ))","title":"104. Maximum Depth of Binary Tree $\\star$"},{"location":"python3/0101-0200/0101-0110/#105-construct-binary-tree-from-preorder-and-inorder-traversal-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution : def buildTree ( self , preorder : List [ int ], inorder : List [ int ]) -> TreeNode : def helper ( pL : int , pR : int , iL : int , iR : int ) -> TreeNode : if pL > pR : return None i = inorderToIndex [ preorder [ pL ]] curr = TreeNode ( preorder [ pL ]) curr . left = helper ( pL + 1 , pL + i - iL , iL , i - 1 ) curr . right = helper ( pL + i - iL + 1 , pR , i + 1 , iR ) return curr inorderToIndex = { num : i for i , num in enumerate ( inorder )} return helper ( 0 , len ( preorder ) - 1 , 0 , len ( inorder ) - 1 )","title":"105. Construct Binary Tree from Preorder and Inorder Traversal $\\star\\star$"},{"location":"python3/0101-0200/0101-0110/#106-construct-binary-tree-from-inorder-and-postorder-traversal-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution : def buildTree ( self , inorder : List [ int ], postorder : List [ int ]) -> TreeNode : def helper ( iL : int , iR : int , pL : int , pR : int ) -> TreeNode : if iL > iR : return None i = inorderToIndex [ postorder [ pR ]] curr = TreeNode ( postorder [ pR ]) curr . left = helper ( iL , i - 1 , pL , pL + i - iL - 1 ) curr . right = helper ( i + 1 , iR , pL + i - iL , pR - 1 ) return curr inorderToIndex = { num : i for i , num in enumerate ( inorder )} return helper ( 0 , len ( inorder ) - 1 , 0 , len ( postorder ) - 1 )","title":"106. Construct Binary Tree from Inorder and Postorder Traversal $\\star\\star$"},{"location":"python3/0101-0200/0101-0110/#107-binary-tree-level-order-traversal-ii-star","text":"Time: $O(n)$ Space: $O(n)$ class Solution : def levelOrderBottom ( self , root : TreeNode ) -> List [ List [ int ]]: if not root : return [] ans = [] queue = collections . deque ([ root ]) while queue : currLevel = [] for _ in range ( len ( queue )): node = queue . popleft () currLevel . append ( node . val ) if node . left : queue . append ( node . left ) if node . right : queue . append ( node . right ) ans . insert ( 0 , currLevel ) return ans","title":"107. Binary Tree Level Order Traversal II $\\star$"},{"location":"python3/0101-0200/0101-0110/#108-convert-sorted-array-to-binary-search-tree-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def sortedArrayToBST ( self , nums : List [ int ]) -> TreeNode : def helper ( l : int , r : int ) -> TreeNode : if l > r : return None m = ( l + r ) // 2 root = TreeNode ( nums [ m ]) root . left = helper ( l , m - 1 ) root . right = helper ( m + 1 , r ) return root return helper ( 0 , len ( nums ) - 1 )","title":"108. Convert Sorted Array to Binary Search Tree $\\star$"},{"location":"python3/0101-0200/0101-0110/#109-convert-sorted-list-to-binary-search-tree-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def sortedListToBST ( self , head : ListNode ) -> TreeNode : def findMid ( head : ListNode ) -> ListNode : prev = None slow = head fast = head while fast and fast . next : prev = slow slow = slow . next fast = fast . next . next prev . next = None return slow if not head : return None if not head . next : return TreeNode ( head . val ) mid = findMid ( head ) root = TreeNode ( mid . val ) root . left = self . sortedListToBST ( head ) root . right = self . sortedListToBST ( mid . next ) return root","title":"109. Convert Sorted List to Binary Search Tree $\\star\\star$"},{"location":"python3/0101-0200/0101-0110/#110-balanced-binary-tree-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def isBalanced ( self , root : TreeNode ) -> bool : def maxDepth ( root : TreeNode ) -> int : if not root : return 0 return 1 + max ( maxDepth ( root . left ), maxDepth ( root . right )) if not root : return True return abs ( maxDepth ( root . left ) - maxDepth ( root . right )) <= 1 and \\ self . isBalanced ( root . left ) and self . isBalanced ( root . right )","title":"110. Balanced Binary Tree $\\star$"},{"location":"python3/0101-0200/0111-0120/","text":"111. Minimum Depth of Binary Tree $\\star$ Time: $O(n)$ Space: $O(n)$ class Solution : def minDepth ( self , root : TreeNode ) -> int : if not root : return 0 ans = 0 queue = collections . deque ([ root ]) while queue : ans += 1 for i in range ( len ( queue )): node = queue . popleft () if not node . left and not node . right : return ans if node . left : queue . append ( node . left ) if node . right : queue . append ( node . right ) 112. Path Sum $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def hasPathSum ( self , root : TreeNode , sum : int ) -> bool : if not root : return False if root . val == sum and not root . left and not root . right : return True return self . hasPathSum ( root . left , sum - root . val ) or \\ self . hasPathSum ( root . right , sum - root . val ) 113. Path Sum II $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def pathSum ( self , root : TreeNode , sum : int ) -> List [ List [ int ]]: def dfs ( root : TreeNode , sum : int , path : List [ int ]) -> None : if root is None : return if root . val == sum and root . left is None and root . right is None : ans . append ( path + [ root . val ]) return dfs ( root . left , sum - root . val , path + [ root . val ]) dfs ( root . right , sum - root . val , path + [ root . val ]) ans = [] dfs ( root , sum , []) return ans 114. Flatten Binary Tree to Linked List $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def flatten ( self , root : TreeNode ) -> None : if not root : return self . flatten ( root . right ) self . flatten ( root . left ) root . right = self . next root . left = None self . next = root next = None 115. Distinct Subsequences $\\star\\star\\star$ Time: $O(mn)$ Space: $O(mn) \\to O(n)$ class Solution : def numDistinct ( self , s : str , t : str ) -> int : m = len ( s ) n = len ( t ) dp = [[ 0 ] * ( n + 1 ) for _ in range ( m + 1 )] for i in range ( m + 1 ): for j in range ( n + 1 ): if j == 0 : dp [ i ][ j ] = 1 elif i == 0 : dp [ i ][ j ] = 0 else : dp [ i ][ j ] = dp [ i - 1 ][ j ] + \\ ( dp [ i - 1 ][ j - 1 ] if s [ i - 1 ] == t [ j - 1 ] else 0 ) return dp [ m ][ n ] 116. Populating Next Right Pointers in Each Node $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def connect ( self , root : 'Node' ) -> 'Node' : node = root while node and node . left : cached = node . left while node : node . left . next = node . right node . right . next = node . next . left if node . next else None node = node . next node = cached return root 117. Populating Next Right Pointers in Each Node II $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def connect ( self , root : 'Node' ) -> 'Node' : node = root cached = Node ( 0 ) while node : curr = cached while node : if node . left : curr . next = node . left curr = curr . next if node . right : curr . next = node . right curr = curr . next node = node . next node = cached . next cached . next = None return root 118. Pascal's Triangle $\\star$ Time: $O(n^2)$ Space: $O(n^2)$ class Solution : def generate ( self , numRows : int ) -> List [ List [ int ]]: ans = [] for i in range ( numRows ): ans . append ([ 1 ] * ( i + 1 )) for i in range ( 2 , numRows ): for j in range ( 1 , len ( ans [ i ]) - 1 ): ans [ i ][ j ] = ans [ i - 1 ][ j - 1 ] + ans [ i - 1 ][ j ] return ans 119. Pascal's Triangle II $\\star$ Time: $O(k^2)$ Space: $O(k)$ class Solution : def getRow ( self , rowIndex : int ) -> List [ int ]: ans = [ 1 ] * ( rowIndex + 1 ) for i in range ( 2 , rowIndex + 1 ): for j in range ( 1 , i ): ans [ i - j ] += ans [ i - j - 1 ] return ans 120. Triangle $\\star\\star$ Time: $O(n^2)$ Space: $O(1)$ class Solution : def minimumTotal ( self , triangle : List [ List [ int ]]) -> int : for i in range ( len ( triangle ) - 2 , - 1 , - 1 ): for j in range ( i + 1 ): triangle [ i ][ j ] += min ( triangle [ i + 1 ][ j ], triangle [ i + 1 ][ j + 1 ]) return triangle [ 0 ][ 0 ]","title":"0111-0120"},{"location":"python3/0101-0200/0111-0120/#111-minimum-depth-of-binary-tree-star","text":"Time: $O(n)$ Space: $O(n)$ class Solution : def minDepth ( self , root : TreeNode ) -> int : if not root : return 0 ans = 0 queue = collections . deque ([ root ]) while queue : ans += 1 for i in range ( len ( queue )): node = queue . popleft () if not node . left and not node . right : return ans if node . left : queue . append ( node . left ) if node . right : queue . append ( node . right )","title":"111. Minimum Depth of Binary Tree $\\star$"},{"location":"python3/0101-0200/0111-0120/#112-path-sum-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def hasPathSum ( self , root : TreeNode , sum : int ) -> bool : if not root : return False if root . val == sum and not root . left and not root . right : return True return self . hasPathSum ( root . left , sum - root . val ) or \\ self . hasPathSum ( root . right , sum - root . val )","title":"112. Path Sum $\\star$"},{"location":"python3/0101-0200/0111-0120/#113-path-sum-ii-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def pathSum ( self , root : TreeNode , sum : int ) -> List [ List [ int ]]: def dfs ( root : TreeNode , sum : int , path : List [ int ]) -> None : if root is None : return if root . val == sum and root . left is None and root . right is None : ans . append ( path + [ root . val ]) return dfs ( root . left , sum - root . val , path + [ root . val ]) dfs ( root . right , sum - root . val , path + [ root . val ]) ans = [] dfs ( root , sum , []) return ans","title":"113. Path Sum II $\\star\\star$"},{"location":"python3/0101-0200/0111-0120/#114-flatten-binary-tree-to-linked-list-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def flatten ( self , root : TreeNode ) -> None : if not root : return self . flatten ( root . right ) self . flatten ( root . left ) root . right = self . next root . left = None self . next = root next = None","title":"114. Flatten Binary Tree to Linked List $\\star\\star$"},{"location":"python3/0101-0200/0111-0120/#115-distinct-subsequences-starstarstar","text":"Time: $O(mn)$ Space: $O(mn) \\to O(n)$ class Solution : def numDistinct ( self , s : str , t : str ) -> int : m = len ( s ) n = len ( t ) dp = [[ 0 ] * ( n + 1 ) for _ in range ( m + 1 )] for i in range ( m + 1 ): for j in range ( n + 1 ): if j == 0 : dp [ i ][ j ] = 1 elif i == 0 : dp [ i ][ j ] = 0 else : dp [ i ][ j ] = dp [ i - 1 ][ j ] + \\ ( dp [ i - 1 ][ j - 1 ] if s [ i - 1 ] == t [ j - 1 ] else 0 ) return dp [ m ][ n ]","title":"115. Distinct Subsequences $\\star\\star\\star$"},{"location":"python3/0101-0200/0111-0120/#116-populating-next-right-pointers-in-each-node-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def connect ( self , root : 'Node' ) -> 'Node' : node = root while node and node . left : cached = node . left while node : node . left . next = node . right node . right . next = node . next . left if node . next else None node = node . next node = cached return root","title":"116. Populating Next Right Pointers in Each Node $\\star\\star$"},{"location":"python3/0101-0200/0111-0120/#117-populating-next-right-pointers-in-each-node-ii-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def connect ( self , root : 'Node' ) -> 'Node' : node = root cached = Node ( 0 ) while node : curr = cached while node : if node . left : curr . next = node . left curr = curr . next if node . right : curr . next = node . right curr = curr . next node = node . next node = cached . next cached . next = None return root","title":"117. Populating Next Right Pointers in Each Node II $\\star\\star$"},{"location":"python3/0101-0200/0111-0120/#118-pascals-triangle-star","text":"Time: $O(n^2)$ Space: $O(n^2)$ class Solution : def generate ( self , numRows : int ) -> List [ List [ int ]]: ans = [] for i in range ( numRows ): ans . append ([ 1 ] * ( i + 1 )) for i in range ( 2 , numRows ): for j in range ( 1 , len ( ans [ i ]) - 1 ): ans [ i ][ j ] = ans [ i - 1 ][ j - 1 ] + ans [ i - 1 ][ j ] return ans","title":"118. Pascal's Triangle $\\star$"},{"location":"python3/0101-0200/0111-0120/#119-pascals-triangle-ii-star","text":"Time: $O(k^2)$ Space: $O(k)$ class Solution : def getRow ( self , rowIndex : int ) -> List [ int ]: ans = [ 1 ] * ( rowIndex + 1 ) for i in range ( 2 , rowIndex + 1 ): for j in range ( 1 , i ): ans [ i - j ] += ans [ i - j - 1 ] return ans","title":"119. Pascal's Triangle II $\\star$"},{"location":"python3/0101-0200/0111-0120/#120-triangle-starstar","text":"Time: $O(n^2)$ Space: $O(1)$ class Solution : def minimumTotal ( self , triangle : List [ List [ int ]]) -> int : for i in range ( len ( triangle ) - 2 , - 1 , - 1 ): for j in range ( i + 1 ): triangle [ i ][ j ] += min ( triangle [ i + 1 ][ j ], triangle [ i + 1 ][ j + 1 ]) return triangle [ 0 ][ 0 ]","title":"120. Triangle $\\star\\star$"},{"location":"python3/0101-0200/0121-0130/","text":"121. Best Time to Buy and Sell Stock $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def maxProfit ( self , prices : List [ int ]) -> int : sellOne = 0 holdOne = float ( '-inf' ) for price in prices : sellOne = max ( sellOne , holdOne + price ) holdOne = max ( holdOne , - price ) return sellOne 122. Best Time to Buy and Sell Stock II $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def maxProfit ( self , prices : List [ int ]) -> int : sell = 0 hold = float ( '-inf' ) for price in prices : sell = max ( sell , hold + price ) hold = max ( hold , sell - price ) return sell 123. Best Time to Buy and Sell Stock III $\\star\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def maxProfit ( self , prices : List [ int ]) -> int : sellTwo = 0 holdTwo = float ( '-inf' ) sellOne = 0 holdOne = float ( '-inf' ) for price in prices : sellTwo = max ( sellTwo , holdTwo + price ) holdTwo = max ( holdTwo , sellOne - price ) sellOne = max ( sellOne , holdOne + price ) holdOne = max ( holdOne , - price ) return sellTwo 124. Binary Tree Maximum Path Sum $\\star\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def maxPathSum ( self , root : TreeNode ) -> int : def maxPathSumDownFrom ( root : TreeNode ) -> int : if not root : return 0 left = max ( maxPathSumDownFrom ( root . left ), 0 ) right = max ( maxPathSumDownFrom ( root . right ), 0 ) self . ans = max ( self . ans , root . val + left + right ) return root . val + max ( left , right ) self . ans = float ( '-inf' ) maxPathSumDownFrom ( root ) return self . ans 125. Valid Palindrome $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def isPalindrome ( self , s : str ) -> bool : l = 0 r = len ( s ) - 1 while l < r : while l < r and not s [ l ] . isalnum (): l += 1 while l < r and not s [ r ] . isalnum (): r -= 1 if s [ l ] . lower () != s [ r ] . lower (): return False l += 1 r -= 1 return True 126. Word Ladder II $\\star\\star\\star$ Time: $O(n26^l)$, where n = len(wordList) and l = len(word) Space: $O(n + kl)$, where k = #paths class Solution : def findLadders ( self , beginWord : str , endWord : str , wordList : List [ str ]) -> List [ List [ str ]]: def dfs ( word : str , path : List [ str ]) -> None : if word == endWord : ans . append ( path ) return if word not in dict : return for child in dict [ word ]: dfs ( child , path + [ child ]) ans = [] wordList = set ( wordList ) if endWord not in wordList : return ans set1 = set ([ beginWord ]) dict = collections . defaultdict ( list ) isFound = False while set1 and not isFound : for word in set1 : wordList . discard ( word ) tempSet = set () for parent in set1 : for i in range ( len ( parent )): for j in string . ascii_lowercase : newWord = parent [: i ] + j + parent [ i + 1 :] if newWord == endWord : dict [ parent ] . append ( newWord ) isFound = True elif newWord in wordList and not isFound : tempSet . add ( newWord ) dict [ parent ] . append ( newWord ) set1 = tempSet if isFound : dfs ( beginWord , [ beginWord ]) return ans 127. Word Ladder $\\star\\star$ Time: $O(n26^l)$, where n = len(wordList) and l = len(word) Space: $O(n)$ class Solution : def ladderLength ( self , beginWord : str , endWord : str , wordList : List [ str ]) -> int : wordList = set ( wordList ) if endWord not in wordList : return 0 ans = 0 set1 = set ([ beginWord ]) set2 = set ([ endWord ]) while set1 and set2 : ans += 1 if len ( set1 ) > len ( set2 ): set1 , set2 = set2 , set1 tempSet = set () for word in set1 : for i in range ( len ( word )): for j in string . ascii_lowercase : newWord = word [: i ] + j + word [ i + 1 :] if newWord in set2 : return ans + 1 if newWord not in wordList : continue wordList . remove ( newWord ) tempSet . add ( newWord ) set1 = tempSet return 0 128. Longest Consecutive Sequence $\\star\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution : def longestConsecutive ( self , nums : List [ int ]) -> int : ans = 0 numsSet = set ( nums ) for num in nums : if num - 1 not in numsSet : length = 0 while num in numsSet : num += 1 length += 1 ans = max ( ans , length ) return ans 129. Sum Root to Leaf Numbers $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def sumNumbers ( self , root : TreeNode ) -> int : def dfs ( root : TreeNode , path : int ) -> None : if not root : return if not root . left and not root . right : self . ans += path * 10 + root . val return dfs ( root . left , path * 10 + root . val ) dfs ( root . right , path * 10 + root . val ) self . ans = 0 dfs ( root , 0 ) return self . ans 130. Surrounded Regions $\\star\\star$ Time: $O(mn)$ Space: $O(1)$ class Solution : def solve ( self , board : List [ List [ str ]]) -> None : def dfs ( i : int , j : int ) -> None : if not 0 <= i < len ( board ) or not 0 <= j < len ( board [ 0 ]) or board [ i ][ j ] != 'O' : return board [ i ][ j ] = '.' dfs ( i + 1 , j ) dfs ( i - 1 , j ) dfs ( i , j + 1 ) dfs ( i , j - 1 ) if not board : return for i in range ( len ( board )): dfs ( i , 0 ) dfs ( i , len ( board [ 0 ]) - 1 ) for j in range ( 1 , len ( board [ 0 ]) - 1 ): dfs ( 0 , j ) dfs ( len ( board ) - 1 , j ) for row in board : for i , c in enumerate ( row ): row [ i ] = 'O' if c == '.' else 'X'","title":"0121-0130"},{"location":"python3/0101-0200/0121-0130/#121-best-time-to-buy-and-sell-stock-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def maxProfit ( self , prices : List [ int ]) -> int : sellOne = 0 holdOne = float ( '-inf' ) for price in prices : sellOne = max ( sellOne , holdOne + price ) holdOne = max ( holdOne , - price ) return sellOne","title":"121. Best Time to Buy and Sell Stock $\\star$"},{"location":"python3/0101-0200/0121-0130/#122-best-time-to-buy-and-sell-stock-ii-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def maxProfit ( self , prices : List [ int ]) -> int : sell = 0 hold = float ( '-inf' ) for price in prices : sell = max ( sell , hold + price ) hold = max ( hold , sell - price ) return sell","title":"122. Best Time to Buy and Sell Stock II $\\star$"},{"location":"python3/0101-0200/0121-0130/#123-best-time-to-buy-and-sell-stock-iii-starstarstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def maxProfit ( self , prices : List [ int ]) -> int : sellTwo = 0 holdTwo = float ( '-inf' ) sellOne = 0 holdOne = float ( '-inf' ) for price in prices : sellTwo = max ( sellTwo , holdTwo + price ) holdTwo = max ( holdTwo , sellOne - price ) sellOne = max ( sellOne , holdOne + price ) holdOne = max ( holdOne , - price ) return sellTwo","title":"123. Best Time to Buy and Sell Stock III $\\star\\star\\star$"},{"location":"python3/0101-0200/0121-0130/#124-binary-tree-maximum-path-sum-starstarstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def maxPathSum ( self , root : TreeNode ) -> int : def maxPathSumDownFrom ( root : TreeNode ) -> int : if not root : return 0 left = max ( maxPathSumDownFrom ( root . left ), 0 ) right = max ( maxPathSumDownFrom ( root . right ), 0 ) self . ans = max ( self . ans , root . val + left + right ) return root . val + max ( left , right ) self . ans = float ( '-inf' ) maxPathSumDownFrom ( root ) return self . ans","title":"124. Binary Tree Maximum Path Sum $\\star\\star\\star$"},{"location":"python3/0101-0200/0121-0130/#125-valid-palindrome-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def isPalindrome ( self , s : str ) -> bool : l = 0 r = len ( s ) - 1 while l < r : while l < r and not s [ l ] . isalnum (): l += 1 while l < r and not s [ r ] . isalnum (): r -= 1 if s [ l ] . lower () != s [ r ] . lower (): return False l += 1 r -= 1 return True","title":"125. Valid Palindrome $\\star$"},{"location":"python3/0101-0200/0121-0130/#126-word-ladder-ii-starstarstar","text":"Time: $O(n26^l)$, where n = len(wordList) and l = len(word) Space: $O(n + kl)$, where k = #paths class Solution : def findLadders ( self , beginWord : str , endWord : str , wordList : List [ str ]) -> List [ List [ str ]]: def dfs ( word : str , path : List [ str ]) -> None : if word == endWord : ans . append ( path ) return if word not in dict : return for child in dict [ word ]: dfs ( child , path + [ child ]) ans = [] wordList = set ( wordList ) if endWord not in wordList : return ans set1 = set ([ beginWord ]) dict = collections . defaultdict ( list ) isFound = False while set1 and not isFound : for word in set1 : wordList . discard ( word ) tempSet = set () for parent in set1 : for i in range ( len ( parent )): for j in string . ascii_lowercase : newWord = parent [: i ] + j + parent [ i + 1 :] if newWord == endWord : dict [ parent ] . append ( newWord ) isFound = True elif newWord in wordList and not isFound : tempSet . add ( newWord ) dict [ parent ] . append ( newWord ) set1 = tempSet if isFound : dfs ( beginWord , [ beginWord ]) return ans","title":"126. Word Ladder II $\\star\\star\\star$"},{"location":"python3/0101-0200/0121-0130/#127-word-ladder-starstar","text":"Time: $O(n26^l)$, where n = len(wordList) and l = len(word) Space: $O(n)$ class Solution : def ladderLength ( self , beginWord : str , endWord : str , wordList : List [ str ]) -> int : wordList = set ( wordList ) if endWord not in wordList : return 0 ans = 0 set1 = set ([ beginWord ]) set2 = set ([ endWord ]) while set1 and set2 : ans += 1 if len ( set1 ) > len ( set2 ): set1 , set2 = set2 , set1 tempSet = set () for word in set1 : for i in range ( len ( word )): for j in string . ascii_lowercase : newWord = word [: i ] + j + word [ i + 1 :] if newWord in set2 : return ans + 1 if newWord not in wordList : continue wordList . remove ( newWord ) tempSet . add ( newWord ) set1 = tempSet return 0","title":"127. Word Ladder $\\star\\star$"},{"location":"python3/0101-0200/0121-0130/#128-longest-consecutive-sequence-starstarstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution : def longestConsecutive ( self , nums : List [ int ]) -> int : ans = 0 numsSet = set ( nums ) for num in nums : if num - 1 not in numsSet : length = 0 while num in numsSet : num += 1 length += 1 ans = max ( ans , length ) return ans","title":"128. Longest Consecutive Sequence $\\star\\star\\star$"},{"location":"python3/0101-0200/0121-0130/#129-sum-root-to-leaf-numbers-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def sumNumbers ( self , root : TreeNode ) -> int : def dfs ( root : TreeNode , path : int ) -> None : if not root : return if not root . left and not root . right : self . ans += path * 10 + root . val return dfs ( root . left , path * 10 + root . val ) dfs ( root . right , path * 10 + root . val ) self . ans = 0 dfs ( root , 0 ) return self . ans","title":"129. Sum Root to Leaf Numbers $\\star\\star$"},{"location":"python3/0101-0200/0121-0130/#130-surrounded-regions-starstar","text":"Time: $O(mn)$ Space: $O(1)$ class Solution : def solve ( self , board : List [ List [ str ]]) -> None : def dfs ( i : int , j : int ) -> None : if not 0 <= i < len ( board ) or not 0 <= j < len ( board [ 0 ]) or board [ i ][ j ] != 'O' : return board [ i ][ j ] = '.' dfs ( i + 1 , j ) dfs ( i - 1 , j ) dfs ( i , j + 1 ) dfs ( i , j - 1 ) if not board : return for i in range ( len ( board )): dfs ( i , 0 ) dfs ( i , len ( board [ 0 ]) - 1 ) for j in range ( 1 , len ( board [ 0 ]) - 1 ): dfs ( 0 , j ) dfs ( len ( board ) - 1 , j ) for row in board : for i , c in enumerate ( row ): row [ i ] = 'O' if c == '.' else 'X'","title":"130. Surrounded Regions $\\star\\star$"},{"location":"python3/0101-0200/0131-0140/","text":"131. Palindrome Partitioning $\\star\\star$ Time: $O(n2^n)$ Space: $O(n2^n)$ class Solution : def partition ( self , s : str ) -> List [ List [ str ]]: ans = [] self . dfs ( s , 0 , [], ans ) return ans def dfs ( self , s : str , j : int , path : List [ str ], ans : List [ List [ str ]]) -> None : if j == len ( s ): ans . append ( path ) return for i in range ( j , len ( s )): if self . isPalindrome ( s [ j : i + 1 ]): self . dfs ( s , i + 1 , path + [ s [ j : i + 1 ]], ans ) def isPalindrome ( self , s : str ) -> bool : return s == s [:: - 1 ] 132. Palindrome Partitioning II $\\star\\star\\star$ Time: $O(mn)$ Space: $O(mn)$ class Solution : def minCut ( self , s : str ) -> int : n = len ( s ) cut = [ 0 ] * n dp = [[ False ] * n for _ in range ( n )] for i in range ( n ): mini = i for j in range ( i + 1 ): if s [ j ] == s [ i ] and ( j + 1 > i - 1 or dp [ j + 1 ][ i - 1 ]): dp [ j ][ i ] = True mini = 0 if j == 0 else min ( mini , cut [ j - 1 ] + 1 ) cut [ i ] = mini return cut [ n - 1 ] 133. Clone Graph $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution : def cloneGraph ( self , node : 'Node' ) -> 'Node' : if not node : return None if node in self . lookup : return self . lookup [ node ] self . lookup [ node ] = Node ( node . val , []) for neighbor in node . neighbors : self . lookup [ node ] . neighbors . append ( self . cloneGraph ( neighbor )) return self . lookup [ node ] lookup = {} 134. Gas Station $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def canCompleteCircuit ( self , gas : List [ int ], cost : List [ int ]) -> int : ans = 0 net = 0 sum = 0 for i in range ( len ( gas )): net += gas [ i ] - cost [ i ] sum += gas [ i ] - cost [ i ] if sum < 0 : sum = 0 ans = i + 1 return - 1 if net < 0 else ans 135. Candy $\\star\\star\\star$ 136. Single Number $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def singleNumber ( self , nums : List [ int ]) -> int : ans = 0 for num in nums : ans ^= num return ans 137. Single Number II $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def singleNumber ( self , nums : List [ int ]) -> int : ones = 0 twos = 0 for num in nums : ones ^= ( num & ~ twos ) twos ^= ( num & ~ ones ) return ones 138. Copy List with Random Pointer $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution : def copyRandomList ( self , head : 'Node' ) -> 'Node' : if head is None : return None if head in self . dict : return self . dict [ head ] self . dict [ head ] = Node ( head . val ) self . dict [ head ] . next = self . copyRandomList ( head . next ) self . dict [ head ] . random = self . copyRandomList ( head . random ) return self . dict [ head ] dict = {} 139. Word Break $\\star\\star$ Time: $O(n^2)$ Space: $O(n)$ class Solution : def wordBreak ( self , s : str , wordDict : List [ str ]) -> bool : def wordBreak ( s : str ) -> bool : if s in memo : return memo [ s ] if s in wordDict : memo [ s ] = True return True for i in range ( 1 , len ( s )): if s [: i ] in wordDict and wordBreak ( s [ i :]): memo [ s ] = True return True memo [ s ] = False return False memo = {} wordDict = set ( wordDict ) return wordBreak ( s ) 140. Word Break II $\\star\\star\\star$","title":"0131-0140"},{"location":"python3/0101-0200/0131-0140/#131-palindrome-partitioning-starstar","text":"Time: $O(n2^n)$ Space: $O(n2^n)$ class Solution : def partition ( self , s : str ) -> List [ List [ str ]]: ans = [] self . dfs ( s , 0 , [], ans ) return ans def dfs ( self , s : str , j : int , path : List [ str ], ans : List [ List [ str ]]) -> None : if j == len ( s ): ans . append ( path ) return for i in range ( j , len ( s )): if self . isPalindrome ( s [ j : i + 1 ]): self . dfs ( s , i + 1 , path + [ s [ j : i + 1 ]], ans ) def isPalindrome ( self , s : str ) -> bool : return s == s [:: - 1 ]","title":"131. Palindrome Partitioning $\\star\\star$"},{"location":"python3/0101-0200/0131-0140/#132-palindrome-partitioning-ii-starstarstar","text":"Time: $O(mn)$ Space: $O(mn)$ class Solution : def minCut ( self , s : str ) -> int : n = len ( s ) cut = [ 0 ] * n dp = [[ False ] * n for _ in range ( n )] for i in range ( n ): mini = i for j in range ( i + 1 ): if s [ j ] == s [ i ] and ( j + 1 > i - 1 or dp [ j + 1 ][ i - 1 ]): dp [ j ][ i ] = True mini = 0 if j == 0 else min ( mini , cut [ j - 1 ] + 1 ) cut [ i ] = mini return cut [ n - 1 ]","title":"132. Palindrome Partitioning II $\\star\\star\\star$"},{"location":"python3/0101-0200/0131-0140/#133-clone-graph-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution : def cloneGraph ( self , node : 'Node' ) -> 'Node' : if not node : return None if node in self . lookup : return self . lookup [ node ] self . lookup [ node ] = Node ( node . val , []) for neighbor in node . neighbors : self . lookup [ node ] . neighbors . append ( self . cloneGraph ( neighbor )) return self . lookup [ node ] lookup = {}","title":"133. Clone Graph $\\star\\star$"},{"location":"python3/0101-0200/0131-0140/#134-gas-station-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def canCompleteCircuit ( self , gas : List [ int ], cost : List [ int ]) -> int : ans = 0 net = 0 sum = 0 for i in range ( len ( gas )): net += gas [ i ] - cost [ i ] sum += gas [ i ] - cost [ i ] if sum < 0 : sum = 0 ans = i + 1 return - 1 if net < 0 else ans","title":"134. Gas Station $\\star\\star$"},{"location":"python3/0101-0200/0131-0140/#135-candy-starstarstar","text":"","title":"135. Candy $\\star\\star\\star$"},{"location":"python3/0101-0200/0131-0140/#136-single-number-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def singleNumber ( self , nums : List [ int ]) -> int : ans = 0 for num in nums : ans ^= num return ans","title":"136. Single Number $\\star$"},{"location":"python3/0101-0200/0131-0140/#137-single-number-ii-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def singleNumber ( self , nums : List [ int ]) -> int : ones = 0 twos = 0 for num in nums : ones ^= ( num & ~ twos ) twos ^= ( num & ~ ones ) return ones","title":"137. Single Number II $\\star\\star$"},{"location":"python3/0101-0200/0131-0140/#138-copy-list-with-random-pointer-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution : def copyRandomList ( self , head : 'Node' ) -> 'Node' : if head is None : return None if head in self . dict : return self . dict [ head ] self . dict [ head ] = Node ( head . val ) self . dict [ head ] . next = self . copyRandomList ( head . next ) self . dict [ head ] . random = self . copyRandomList ( head . random ) return self . dict [ head ] dict = {}","title":"138. Copy List with Random Pointer $\\star\\star$"},{"location":"python3/0101-0200/0131-0140/#139-word-break-starstar","text":"Time: $O(n^2)$ Space: $O(n)$ class Solution : def wordBreak ( self , s : str , wordDict : List [ str ]) -> bool : def wordBreak ( s : str ) -> bool : if s in memo : return memo [ s ] if s in wordDict : memo [ s ] = True return True for i in range ( 1 , len ( s )): if s [: i ] in wordDict and wordBreak ( s [ i :]): memo [ s ] = True return True memo [ s ] = False return False memo = {} wordDict = set ( wordDict ) return wordBreak ( s )","title":"139. Word Break $\\star\\star$"},{"location":"python3/0101-0200/0131-0140/#140-word-break-ii-starstarstar","text":"","title":"140. Word Break II $\\star\\star\\star$"},{"location":"python3/0101-0200/0141-0150/","text":"141. Linked List Cycle $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def hasCycle ( self , head : ListNode ) -> bool : slow = head fast = head while fast and fast . next : slow = slow . next fast = fast . next . next if slow == fast : return True return False 142. Linked List Cycle II $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def detectCycle ( self , head : ListNode ) -> ListNode : slow = head fast = head while fast and fast . next : slow = slow . next fast = fast . next . next if slow == fast : slow = head while slow != fast : slow = slow . next fast = fast . next return slow return None 143. Reorder List $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def reorderList ( self , head : ListNode ) -> None : def findMid ( head : ListNode ): prev = None slow = head fast = head while fast and fast . next : prev = slow slow = slow . next fast = fast . next . next prev . next = None return slow def reverse ( head : ListNode ) -> ListNode : prev = None curr = head while curr : next = curr . next curr . next = prev prev = curr curr = next return prev def merge ( l1 : ListNode , l2 : ListNode ) -> None : while l2 : next = l1 . next l1 . next = l2 l1 = l2 l2 = next if not head or not head . next : return mid = findMid ( head ) reversed = reverse ( mid ) merge ( head , reversed ) 144. Binary Tree Preorder Traversal $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution : def preorderTraversal ( self , root : TreeNode ) -> List [ int ]: if not root : return [] ans = [] stack = [ root ] while stack : node = stack . pop () ans . append ( node . val ) if node . right : stack . append ( node . right ) if node . left : stack . append ( node . left ) return ans 145. Binary Tree Postorder Traversal $\\star\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution : def postorderTraversal ( self , root : TreeNode ) -> List [ int ]: if not root : return [] ans = [] stack = [ root ] while stack : node = stack . pop () ans . append ( node . val ) if node . left : stack . append ( node . left ) if node . right : stack . append ( node . right ) return ans [:: - 1 ] 146. LRU Cache $\\star\\star$ Time: $O(1)$ Space: $O(capacity)$ class Node : def __init__ ( self , key : int , value : int ): self . key = key self . value = value self . prev = None self . next = None class LRUCache : def __init__ ( self , capacity : int ): self . capacity = capacity self . dict = {} self . head = Node ( - 1 , - 1 ) self . tail = Node ( - 1 , - 1 ) self . join ( self . head , self . tail ) def get ( self , key : int ) -> int : if key not in self . dict : return - 1 node = self . dict [ key ] self . remove ( node ) self . moveToHead ( node ) return node . value def put ( self , key : int , value : int ) -> None : if key in self . dict : node = self . dict [ key ] node . value = value self . remove ( node ) self . moveToHead ( node ) return if len ( self . dict ) == self . capacity : lastNode = self . tail . prev del self . dict [ lastNode . key ] self . remove ( lastNode ) self . moveToHead ( Node ( key , value )) self . dict [ key ] = self . head . next def join ( self , node1 : Node , node2 : Node ): node1 . next = node2 node2 . prev = node1 def moveToHead ( self , node : Node ): self . join ( node , self . head . next ) self . join ( self . head , node ) def remove ( self , node : Node ): self . join ( node . prev , node . next ) 147. Insertion Sort List $\\star\\star$ Time: $O(n^2)$ Space: $O(1)$ class Solution : def insertionSortList ( self , head : ListNode ) -> ListNode : dummy = ListNode ( 0 ) curr = head while curr : prev = dummy while prev . next and prev . next . val < curr . val : prev = prev . next next = curr . next curr . next = prev . next prev . next = curr curr = next return dummy . next 148. Sort List $\\star\\star$ Time: $O(n\\log n)$ Space: $O(1)$ class Solution : def sortList ( self , head : ListNode ) -> ListNode : def split ( head : ListNode , k : int ) -> ListNode : while k > 1 and head : head = head . next k -= 1 rest = head . next if head else None if head : head . next = None return rest def merge ( l1 : ListNode , l2 : ListNode ) -> tuple : dummy = ListNode ( 0 ) tail = dummy while l1 and l2 : if l1 . val > l2 . val : l1 , l2 = l2 , l1 tail . next = l1 l1 = l1 . next tail = tail . next tail . next = l1 if l1 else l2 while tail . next : tail = tail . next return dummy . next , tail length = 0 curr = head while curr : length += 1 curr = curr . next dummy = ListNode ( 0 ) dummy . next = head k = 1 while k < length : curr = dummy . next tail = dummy while curr : l = curr r = split ( l , k ) curr = split ( r , k ) mergedHead , mergedTail = merge ( l , r ) tail . next = mergedHead tail = mergedTail k *= 2 return dummy . next 149. Max Points on a Line $\\star\\star\\star$ Time: $O(n^2)$ Space: $O(n)$ from fractions import gcd class Solution : def maxPoints ( self , points : List [ List [ int ]]) -> int : ans = 0 for i , p1 in enumerate ( points ): count = collections . defaultdict ( int ) samePoints = 1 maxPoints = 0 for j in range ( i + 1 , len ( points )): p2 = points [ j ] if p1 == p2 : samePoints += 1 else : slope = self . getSlope ( p1 , p2 ) count [ slope ] += 1 maxPoints = max ( maxPoints , count [ slope ]) ans = max ( ans , samePoints + maxPoints ) return ans def getSlope ( self , p1 : List [ int ], p2 : List [ int ]) -> tuple : dx = p2 [ 0 ] - p1 [ 0 ] dy = p2 [ 1 ] - p1 [ 1 ] if dx == 0 : return ( 0 , p1 [ 0 ]) if dy == 0 : return ( p1 [ 1 ], 0 ) d = gcd ( dx , dy ) return ( dx // d , dy // d ) 150. Evaluate Reverse Polish Notation $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution : def evalRPN ( self , tokens : List [ str ]) -> int : stack = [] operators = { \"+\" : lambda a , b : a + b , \"-\" : lambda a , b : a - b , \"*\" : lambda a , b : a * b , \"/\" : lambda a , b : int ( a / b ), } for token in tokens : if token in operators : b = stack . pop () a = stack . pop () stack . append ( operators [ token ]( a , b )) else : stack . append ( int ( token )) return stack [ 0 ]","title":"0141-0150"},{"location":"python3/0101-0200/0141-0150/#141-linked-list-cycle-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def hasCycle ( self , head : ListNode ) -> bool : slow = head fast = head while fast and fast . next : slow = slow . next fast = fast . next . next if slow == fast : return True return False","title":"141. Linked List Cycle $\\star$"},{"location":"python3/0101-0200/0141-0150/#142-linked-list-cycle-ii-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def detectCycle ( self , head : ListNode ) -> ListNode : slow = head fast = head while fast and fast . next : slow = slow . next fast = fast . next . next if slow == fast : slow = head while slow != fast : slow = slow . next fast = fast . next return slow return None","title":"142. Linked List Cycle II $\\star\\star$"},{"location":"python3/0101-0200/0141-0150/#143-reorder-list-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def reorderList ( self , head : ListNode ) -> None : def findMid ( head : ListNode ): prev = None slow = head fast = head while fast and fast . next : prev = slow slow = slow . next fast = fast . next . next prev . next = None return slow def reverse ( head : ListNode ) -> ListNode : prev = None curr = head while curr : next = curr . next curr . next = prev prev = curr curr = next return prev def merge ( l1 : ListNode , l2 : ListNode ) -> None : while l2 : next = l1 . next l1 . next = l2 l1 = l2 l2 = next if not head or not head . next : return mid = findMid ( head ) reversed = reverse ( mid ) merge ( head , reversed )","title":"143. Reorder List $\\star\\star$"},{"location":"python3/0101-0200/0141-0150/#144-binary-tree-preorder-traversal-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution : def preorderTraversal ( self , root : TreeNode ) -> List [ int ]: if not root : return [] ans = [] stack = [ root ] while stack : node = stack . pop () ans . append ( node . val ) if node . right : stack . append ( node . right ) if node . left : stack . append ( node . left ) return ans","title":"144. Binary Tree Preorder Traversal $\\star\\star$"},{"location":"python3/0101-0200/0141-0150/#145-binary-tree-postorder-traversal-starstarstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution : def postorderTraversal ( self , root : TreeNode ) -> List [ int ]: if not root : return [] ans = [] stack = [ root ] while stack : node = stack . pop () ans . append ( node . val ) if node . left : stack . append ( node . left ) if node . right : stack . append ( node . right ) return ans [:: - 1 ]","title":"145. Binary Tree Postorder Traversal $\\star\\star\\star$"},{"location":"python3/0101-0200/0141-0150/#146-lru-cache-starstar","text":"Time: $O(1)$ Space: $O(capacity)$ class Node : def __init__ ( self , key : int , value : int ): self . key = key self . value = value self . prev = None self . next = None class LRUCache : def __init__ ( self , capacity : int ): self . capacity = capacity self . dict = {} self . head = Node ( - 1 , - 1 ) self . tail = Node ( - 1 , - 1 ) self . join ( self . head , self . tail ) def get ( self , key : int ) -> int : if key not in self . dict : return - 1 node = self . dict [ key ] self . remove ( node ) self . moveToHead ( node ) return node . value def put ( self , key : int , value : int ) -> None : if key in self . dict : node = self . dict [ key ] node . value = value self . remove ( node ) self . moveToHead ( node ) return if len ( self . dict ) == self . capacity : lastNode = self . tail . prev del self . dict [ lastNode . key ] self . remove ( lastNode ) self . moveToHead ( Node ( key , value )) self . dict [ key ] = self . head . next def join ( self , node1 : Node , node2 : Node ): node1 . next = node2 node2 . prev = node1 def moveToHead ( self , node : Node ): self . join ( node , self . head . next ) self . join ( self . head , node ) def remove ( self , node : Node ): self . join ( node . prev , node . next )","title":"146. LRU Cache $\\star\\star$"},{"location":"python3/0101-0200/0141-0150/#147-insertion-sort-list-starstar","text":"Time: $O(n^2)$ Space: $O(1)$ class Solution : def insertionSortList ( self , head : ListNode ) -> ListNode : dummy = ListNode ( 0 ) curr = head while curr : prev = dummy while prev . next and prev . next . val < curr . val : prev = prev . next next = curr . next curr . next = prev . next prev . next = curr curr = next return dummy . next","title":"147. Insertion Sort List $\\star\\star$"},{"location":"python3/0101-0200/0141-0150/#148-sort-list-starstar","text":"Time: $O(n\\log n)$ Space: $O(1)$ class Solution : def sortList ( self , head : ListNode ) -> ListNode : def split ( head : ListNode , k : int ) -> ListNode : while k > 1 and head : head = head . next k -= 1 rest = head . next if head else None if head : head . next = None return rest def merge ( l1 : ListNode , l2 : ListNode ) -> tuple : dummy = ListNode ( 0 ) tail = dummy while l1 and l2 : if l1 . val > l2 . val : l1 , l2 = l2 , l1 tail . next = l1 l1 = l1 . next tail = tail . next tail . next = l1 if l1 else l2 while tail . next : tail = tail . next return dummy . next , tail length = 0 curr = head while curr : length += 1 curr = curr . next dummy = ListNode ( 0 ) dummy . next = head k = 1 while k < length : curr = dummy . next tail = dummy while curr : l = curr r = split ( l , k ) curr = split ( r , k ) mergedHead , mergedTail = merge ( l , r ) tail . next = mergedHead tail = mergedTail k *= 2 return dummy . next","title":"148. Sort List $\\star\\star$"},{"location":"python3/0101-0200/0141-0150/#149-max-points-on-a-line-starstarstar","text":"Time: $O(n^2)$ Space: $O(n)$ from fractions import gcd class Solution : def maxPoints ( self , points : List [ List [ int ]]) -> int : ans = 0 for i , p1 in enumerate ( points ): count = collections . defaultdict ( int ) samePoints = 1 maxPoints = 0 for j in range ( i + 1 , len ( points )): p2 = points [ j ] if p1 == p2 : samePoints += 1 else : slope = self . getSlope ( p1 , p2 ) count [ slope ] += 1 maxPoints = max ( maxPoints , count [ slope ]) ans = max ( ans , samePoints + maxPoints ) return ans def getSlope ( self , p1 : List [ int ], p2 : List [ int ]) -> tuple : dx = p2 [ 0 ] - p1 [ 0 ] dy = p2 [ 1 ] - p1 [ 1 ] if dx == 0 : return ( 0 , p1 [ 0 ]) if dy == 0 : return ( p1 [ 1 ], 0 ) d = gcd ( dx , dy ) return ( dx // d , dy // d )","title":"149. Max Points on a Line $\\star\\star\\star$"},{"location":"python3/0101-0200/0141-0150/#150-evaluate-reverse-polish-notation-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution : def evalRPN ( self , tokens : List [ str ]) -> int : stack = [] operators = { \"+\" : lambda a , b : a + b , \"-\" : lambda a , b : a - b , \"*\" : lambda a , b : a * b , \"/\" : lambda a , b : int ( a / b ), } for token in tokens : if token in operators : b = stack . pop () a = stack . pop () stack . append ( operators [ token ]( a , b )) else : stack . append ( int ( token )) return stack [ 0 ]","title":"150. Evaluate Reverse Polish Notation $\\star\\star$"},{"location":"python3/0101-0200/0151-0160/","text":"151. Reverse Words in a String $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution : def reverseWords ( self , s : str ) -> str : return ' ' . join ( reversed ( s . split ())) 152. Maximum Product Subarray $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def maxProduct ( self , nums : List [ int ]) -> int : ans = nums [ 0 ] prevMin = nums [ 0 ] prevMax = nums [ 0 ] for i in range ( 1 , len ( nums )): mini = prevMin * nums [ i ] maxi = prevMax * nums [ i ] prevMin = min ( nums [ i ], mini , maxi ) prevMax = max ( nums [ i ], mini , maxi ) ans = max ( ans , prevMax ) return ans 153. Find Minimum in Rotated Sorted Array $\\star\\star$ Time: $O(\\log n)$ Space: $O(1)$ class Solution : def findMin ( self , nums : List [ int ]) -> int : l = 0 r = len ( nums ) - 1 while l < r : m = ( l + r ) // 2 if nums [ m ] < nums [ r ]: r = m else : l = m + 1 return nums [ l ] 154. Find Minimum in Rotated Sorted Array II $\\star\\star\\star$ Time: $O(\\log n) \\to O(n)$ Space: $O(1)$ class Solution : def findMin ( self , nums : List [ int ]) -> int : l = 0 r = len ( nums ) - 1 while l < r : m = ( l + r ) // 2 if nums [ m ] == nums [ r ]: r -= 1 elif nums [ m ] < nums [ r ]: r = m else : l = m + 1 return nums [ l ] 155. Min Stack $\\star$ Time: $O(1)$ Space: $O(n)$ class MinStack : def __init__ ( self ): self . stack = [] def push ( self , x : int ) -> None : mini = x if not self . stack else min ( self . stack [ - 1 ][ 1 ], x ) self . stack . append ([ x , mini ]) def pop ( self ) -> None : self . stack . pop () def top ( self ) -> int : return self . stack [ - 1 ][ 0 ] def getMin ( self ) -> int : return self . stack [ - 1 ][ 1 ] 156. Binary Tree Upside Down $\\star\\star$ \ud83d\udd12 157. Read N Characters Given Read4 $\\star$ \ud83d\udd12 158. Read N Characters Given Read4 II - Call multiple times $\\star\\star\\star$ \ud83d\udd12 159. Longest Substring with At Most Two Distinct Characters $\\star\\star$ \ud83d\udd12 160. Intersection of Two Linked Lists $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def getIntersectionNode ( self , headA : ListNode , headB : ListNode ) -> ListNode : a = headA b = headB while a != b : a = a . next if a else headB b = b . next if b else headA return a","title":"0151-0160"},{"location":"python3/0101-0200/0151-0160/#151-reverse-words-in-a-string-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution : def reverseWords ( self , s : str ) -> str : return ' ' . join ( reversed ( s . split ()))","title":"151. Reverse Words in a String $\\star\\star$"},{"location":"python3/0101-0200/0151-0160/#152-maximum-product-subarray-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def maxProduct ( self , nums : List [ int ]) -> int : ans = nums [ 0 ] prevMin = nums [ 0 ] prevMax = nums [ 0 ] for i in range ( 1 , len ( nums )): mini = prevMin * nums [ i ] maxi = prevMax * nums [ i ] prevMin = min ( nums [ i ], mini , maxi ) prevMax = max ( nums [ i ], mini , maxi ) ans = max ( ans , prevMax ) return ans","title":"152. Maximum Product Subarray $\\star\\star$"},{"location":"python3/0101-0200/0151-0160/#153-find-minimum-in-rotated-sorted-array-starstar","text":"Time: $O(\\log n)$ Space: $O(1)$ class Solution : def findMin ( self , nums : List [ int ]) -> int : l = 0 r = len ( nums ) - 1 while l < r : m = ( l + r ) // 2 if nums [ m ] < nums [ r ]: r = m else : l = m + 1 return nums [ l ]","title":"153. Find Minimum in Rotated Sorted Array $\\star\\star$"},{"location":"python3/0101-0200/0151-0160/#154-find-minimum-in-rotated-sorted-array-ii-starstarstar","text":"Time: $O(\\log n) \\to O(n)$ Space: $O(1)$ class Solution : def findMin ( self , nums : List [ int ]) -> int : l = 0 r = len ( nums ) - 1 while l < r : m = ( l + r ) // 2 if nums [ m ] == nums [ r ]: r -= 1 elif nums [ m ] < nums [ r ]: r = m else : l = m + 1 return nums [ l ]","title":"154. Find Minimum in Rotated Sorted Array II $\\star\\star\\star$"},{"location":"python3/0101-0200/0151-0160/#155-min-stack-star","text":"Time: $O(1)$ Space: $O(n)$ class MinStack : def __init__ ( self ): self . stack = [] def push ( self , x : int ) -> None : mini = x if not self . stack else min ( self . stack [ - 1 ][ 1 ], x ) self . stack . append ([ x , mini ]) def pop ( self ) -> None : self . stack . pop () def top ( self ) -> int : return self . stack [ - 1 ][ 0 ] def getMin ( self ) -> int : return self . stack [ - 1 ][ 1 ]","title":"155. Min Stack $\\star$"},{"location":"python3/0101-0200/0151-0160/#156-binary-tree-upside-down-starstar","text":"","title":"156. Binary Tree Upside Down $\\star\\star$ \ud83d\udd12"},{"location":"python3/0101-0200/0151-0160/#157-read-n-characters-given-read4-star","text":"","title":"157. Read N Characters Given Read4 $\\star$ \ud83d\udd12"},{"location":"python3/0101-0200/0151-0160/#158-read-n-characters-given-read4-ii-call-multiple-times-starstarstar","text":"","title":"158. Read N Characters Given Read4 II - Call multiple times $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/0101-0200/0151-0160/#159-longest-substring-with-at-most-two-distinct-characters-starstar","text":"","title":"159. Longest Substring with At Most Two Distinct Characters $\\star\\star$ \ud83d\udd12"},{"location":"python3/0101-0200/0151-0160/#160-intersection-of-two-linked-lists-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def getIntersectionNode ( self , headA : ListNode , headB : ListNode ) -> ListNode : a = headA b = headB while a != b : a = a . next if a else headB b = b . next if b else headA return a","title":"160. Intersection of Two Linked Lists $\\star$"},{"location":"python3/0101-0200/0161-0170/","text":"161. One Edit Distance $\\star\\star$ \ud83d\udd12 162. Find Peak Element $\\star\\star$ Time: $O(n\\log n)$ Space: $O(1)$ class Solution : def findPeakElement ( self , nums : List [ int ]) -> int : l = 0 r = len ( nums ) - 1 while l < r : m = ( l + r ) // 2 if nums [ m ] > nums [ m + 1 ]: r = m else : l = m + 1 return l 163. Missing Ranges $\\star\\star$ \ud83d\udd12 164. Maximum Gap $\\star\\star\\star$ 165. Compare Version Numbers $\\star\\star$ 166. Fraction to Recurring Decimal $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def fractionToDecimal ( self , numerator : int , denominator : int ) -> str : if numerator == 0 : return \"0\" ans = \"\" if ( numerator < 0 ) ^ ( denominator < 0 ): ans += \"-\" numerator = abs ( numerator ) denominator = abs ( denominator ) ans += str ( numerator // denominator ) if numerator % denominator == 0 : return ans ans += \".\" dict = {} remainder = numerator % denominator while remainder : if remainder in dict : ans = ans [: dict [ remainder ]] + '(' + ans [ dict [ remainder ]:] + ')' break dict [ remainder ] = len ( ans ) remainder *= 10 ans += str ( remainder // denominator ) remainder %= denominator return ans 167. Two Sum II - Input array is sorted $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def twoSum ( self , numbers : List [ int ], target : int ) -> List [ int ]: l = 0 r = len ( numbers ) - 1 while l < r : sum = numbers [ l ] + numbers [ r ] if sum == target : return [ l + 1 , r + 1 ] if sum < target : l += 1 else : r -= 1 168. Excel Sheet Column Title $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def convertToTitle ( self , n : int ) -> str : return self . convertToTitle (( n - 1 ) // 26 ) + chr ( ord ( 'A' ) + ( n - 1 ) % 26 ) if n else \"\" 169. Majority Element $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def majorityElement ( self , nums : List [ int ]) -> int : ans = None count = 0 for num in nums : if count == 0 : ans = num count += ( 1 if num == ans else - 1 ) return ans 170. Two Sum III - Data structure design $\\star$ \ud83d\udd12","title":"0161-0170"},{"location":"python3/0101-0200/0161-0170/#161-one-edit-distance-starstar","text":"","title":"161. One Edit Distance $\\star\\star$ \ud83d\udd12"},{"location":"python3/0101-0200/0161-0170/#162-find-peak-element-starstar","text":"Time: $O(n\\log n)$ Space: $O(1)$ class Solution : def findPeakElement ( self , nums : List [ int ]) -> int : l = 0 r = len ( nums ) - 1 while l < r : m = ( l + r ) // 2 if nums [ m ] > nums [ m + 1 ]: r = m else : l = m + 1 return l","title":"162. Find Peak Element $\\star\\star$"},{"location":"python3/0101-0200/0161-0170/#163-missing-ranges-starstar","text":"","title":"163. Missing Ranges $\\star\\star$ \ud83d\udd12"},{"location":"python3/0101-0200/0161-0170/#164-maximum-gap-starstarstar","text":"","title":"164. Maximum Gap $\\star\\star\\star$"},{"location":"python3/0101-0200/0161-0170/#165-compare-version-numbers-starstar","text":"","title":"165. Compare Version Numbers $\\star\\star$"},{"location":"python3/0101-0200/0161-0170/#166-fraction-to-recurring-decimal-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def fractionToDecimal ( self , numerator : int , denominator : int ) -> str : if numerator == 0 : return \"0\" ans = \"\" if ( numerator < 0 ) ^ ( denominator < 0 ): ans += \"-\" numerator = abs ( numerator ) denominator = abs ( denominator ) ans += str ( numerator // denominator ) if numerator % denominator == 0 : return ans ans += \".\" dict = {} remainder = numerator % denominator while remainder : if remainder in dict : ans = ans [: dict [ remainder ]] + '(' + ans [ dict [ remainder ]:] + ')' break dict [ remainder ] = len ( ans ) remainder *= 10 ans += str ( remainder // denominator ) remainder %= denominator return ans","title":"166. Fraction to Recurring Decimal $\\star\\star$"},{"location":"python3/0101-0200/0161-0170/#167-two-sum-ii-input-array-is-sorted-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def twoSum ( self , numbers : List [ int ], target : int ) -> List [ int ]: l = 0 r = len ( numbers ) - 1 while l < r : sum = numbers [ l ] + numbers [ r ] if sum == target : return [ l + 1 , r + 1 ] if sum < target : l += 1 else : r -= 1","title":"167. Two Sum II - Input array is sorted $\\star$"},{"location":"python3/0101-0200/0161-0170/#168-excel-sheet-column-title-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def convertToTitle ( self , n : int ) -> str : return self . convertToTitle (( n - 1 ) // 26 ) + chr ( ord ( 'A' ) + ( n - 1 ) % 26 ) if n else \"\"","title":"168. Excel Sheet Column Title $\\star$"},{"location":"python3/0101-0200/0161-0170/#169-majority-element-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def majorityElement ( self , nums : List [ int ]) -> int : ans = None count = 0 for num in nums : if count == 0 : ans = num count += ( 1 if num == ans else - 1 ) return ans","title":"169. Majority Element $\\star$"},{"location":"python3/0101-0200/0161-0170/#170-two-sum-iii-data-structure-design-star","text":"","title":"170. Two Sum III - Data structure design $\\star$ \ud83d\udd12"},{"location":"python3/0101-0200/0171-0180/","text":"171. Excel Sheet Column Number $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def titleToNumber ( self , s : str ) -> int : ans = 0 for c in s : ans = ans * 26 + ord ( c ) - ord ( '@' ) return ans 172. Factorial Trailing Zeroes $\\star$ Time: $O(\\log_5 n)$ Space: $O(1)$ class Solution : def trailingZeroes ( self , n : int ) -> int : return 0 if n == 0 else n // 5 + self . trailingZeroes ( n // 5 ) 173. Binary Search Tree Iterator $\\star\\star$ Time: $O(n)$ Space: $O(\\log n)$ class BSTIterator : def __init__ ( self , root : TreeNode ): self . helper ( root ) def next ( self ) -> int : node = self . stack . pop () if node . right : self . helper ( node . right ) return node . val def hasNext ( self ) -> bool : return len ( self . stack ) > 0 stack = [] def helper ( self , root : TreeNode ) -> None : while root : self . stack . append ( root ) root = root . left 174. Dungeon Game $\\star\\star\\star$ Time: $O(mn)$ Space: $O(mn) \\to O(n)$ class Solution : def calculateMinimumHP ( self , dungeon : List [ List [ int ]]) -> int : m = len ( dungeon ) n = len ( dungeon [ 0 ]) dp = [ float ( 'inf' )] * ( n + 1 ) dp [ n - 1 ] = 1 for i in range ( m )[:: - 1 ]: for j in range ( n )[:: - 1 ]: dp [ j ] = min ( dp [ j ], dp [ j + 1 ]) - dungeon [ i ][ j ] dp [ j ] = max ( dp [ j ], 1 ) return dp [ 0 ] 175. Combine Two Tables $\\star$ 176. Second Highest Salary $\\star$ 177. Nth Highest Salary $\\star\\star$ 178. Rank Scores $\\star\\star$ 179. Largest Number $\\star\\star$ 180. Consecutive Numbers $\\star\\star$","title":"0171-0180"},{"location":"python3/0101-0200/0171-0180/#171-excel-sheet-column-number-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def titleToNumber ( self , s : str ) -> int : ans = 0 for c in s : ans = ans * 26 + ord ( c ) - ord ( '@' ) return ans","title":"171. Excel Sheet Column Number $\\star$"},{"location":"python3/0101-0200/0171-0180/#172-factorial-trailing-zeroes-star","text":"Time: $O(\\log_5 n)$ Space: $O(1)$ class Solution : def trailingZeroes ( self , n : int ) -> int : return 0 if n == 0 else n // 5 + self . trailingZeroes ( n // 5 )","title":"172. Factorial Trailing Zeroes $\\star$"},{"location":"python3/0101-0200/0171-0180/#173-binary-search-tree-iterator-starstar","text":"Time: $O(n)$ Space: $O(\\log n)$ class BSTIterator : def __init__ ( self , root : TreeNode ): self . helper ( root ) def next ( self ) -> int : node = self . stack . pop () if node . right : self . helper ( node . right ) return node . val def hasNext ( self ) -> bool : return len ( self . stack ) > 0 stack = [] def helper ( self , root : TreeNode ) -> None : while root : self . stack . append ( root ) root = root . left","title":"173. Binary Search Tree Iterator $\\star\\star$"},{"location":"python3/0101-0200/0171-0180/#174-dungeon-game-starstarstar","text":"Time: $O(mn)$ Space: $O(mn) \\to O(n)$ class Solution : def calculateMinimumHP ( self , dungeon : List [ List [ int ]]) -> int : m = len ( dungeon ) n = len ( dungeon [ 0 ]) dp = [ float ( 'inf' )] * ( n + 1 ) dp [ n - 1 ] = 1 for i in range ( m )[:: - 1 ]: for j in range ( n )[:: - 1 ]: dp [ j ] = min ( dp [ j ], dp [ j + 1 ]) - dungeon [ i ][ j ] dp [ j ] = max ( dp [ j ], 1 ) return dp [ 0 ]","title":"174. Dungeon Game $\\star\\star\\star$"},{"location":"python3/0101-0200/0171-0180/#175-combine-two-tables-star","text":"","title":"175. Combine Two Tables $\\star$"},{"location":"python3/0101-0200/0171-0180/#176-second-highest-salary-star","text":"","title":"176. Second Highest Salary $\\star$"},{"location":"python3/0101-0200/0171-0180/#177-nth-highest-salary-starstar","text":"","title":"177. Nth Highest Salary $\\star\\star$"},{"location":"python3/0101-0200/0171-0180/#178-rank-scores-starstar","text":"","title":"178. Rank Scores $\\star\\star$"},{"location":"python3/0101-0200/0171-0180/#179-largest-number-starstar","text":"","title":"179. Largest Number $\\star\\star$"},{"location":"python3/0101-0200/0171-0180/#180-consecutive-numbers-starstar","text":"","title":"180. Consecutive Numbers $\\star\\star$"},{"location":"python3/0101-0200/0181-0190/","text":"181. Employees Earning More Than Their Managers $\\star$ 182. Duplicate Emails $\\star$ 183. Customers Who Never Order $\\star$ 184. Department Highest Salary $\\star\\star$ 185. Department Top Three Salaries $\\star\\star\\star$ 186. Reverse Words in a String II $\\star\\star$ \ud83d\udd12 187. Repeated DNA Sequences $\\star\\star$ Time: $O(10n)$ Space: $O(10n)$ class Solution : def findRepeatedDnaSequences ( self , s : str ) -> List [ str ]: ans = set () seen = set () for i in range ( len ( s ) - 9 ): seq = s [ i : i + 10 ] if seq in seen : ans . add ( seq ) seen . add ( seq ) return list ( ans ) 188. Best Time to Buy and Sell Stock IV $\\star\\star\\star$ Time: $O(nk)$ Space: $O(k)$ class Solution : def maxProfit ( self , k : int , prices : List [ int ]) -> int : if k >= len ( prices ) // 2 : sell = 0 hold = float ( '-inf' ) for price in prices : sell = max ( sell , hold + price ) hold = max ( hold , sell - price ) return sell sell = [ 0 ] * ( k + 1 ) hold = [ float ( '-inf' )] * ( k + 1 ) for price in prices : for i in range ( k , 0 , - 1 ): sell [ i ] = max ( sell [ i ], hold [ i ] + price ) hold [ i ] = max ( hold [ i ], sell [ i - 1 ] - price ) return sell [ k ] 189. Rotate Array $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def rotate ( self , nums : List [ int ], k : int ) -> None : k %= len ( nums ) self . reverse ( nums , 0 , len ( nums ) - 1 ) self . reverse ( nums , 0 , k - 1 ) self . reverse ( nums , k , len ( nums ) - 1 ) def reverse ( self , nums : List [ int ], l : int , r : int ) -> None : while l < r : nums [ l ], nums [ r ] = nums [ r ], nums [ l ] l += 1 r -= 1 190. Reverse Bits $\\star$","title":"0181-0190"},{"location":"python3/0101-0200/0181-0190/#181-employees-earning-more-than-their-managers-star","text":"","title":"181. Employees Earning More Than Their Managers $\\star$"},{"location":"python3/0101-0200/0181-0190/#182-duplicate-emails-star","text":"","title":"182. Duplicate Emails $\\star$"},{"location":"python3/0101-0200/0181-0190/#183-customers-who-never-order-star","text":"","title":"183. Customers Who Never Order $\\star$"},{"location":"python3/0101-0200/0181-0190/#184-department-highest-salary-starstar","text":"","title":"184. Department Highest Salary $\\star\\star$"},{"location":"python3/0101-0200/0181-0190/#185-department-top-three-salaries-starstarstar","text":"","title":"185. Department Top Three Salaries $\\star\\star\\star$"},{"location":"python3/0101-0200/0181-0190/#186-reverse-words-in-a-string-ii-starstar","text":"","title":"186. Reverse Words in a String II $\\star\\star$ \ud83d\udd12"},{"location":"python3/0101-0200/0181-0190/#187-repeated-dna-sequences-starstar","text":"Time: $O(10n)$ Space: $O(10n)$ class Solution : def findRepeatedDnaSequences ( self , s : str ) -> List [ str ]: ans = set () seen = set () for i in range ( len ( s ) - 9 ): seq = s [ i : i + 10 ] if seq in seen : ans . add ( seq ) seen . add ( seq ) return list ( ans )","title":"187. Repeated DNA Sequences $\\star\\star$"},{"location":"python3/0101-0200/0181-0190/#188-best-time-to-buy-and-sell-stock-iv-starstarstar","text":"Time: $O(nk)$ Space: $O(k)$ class Solution : def maxProfit ( self , k : int , prices : List [ int ]) -> int : if k >= len ( prices ) // 2 : sell = 0 hold = float ( '-inf' ) for price in prices : sell = max ( sell , hold + price ) hold = max ( hold , sell - price ) return sell sell = [ 0 ] * ( k + 1 ) hold = [ float ( '-inf' )] * ( k + 1 ) for price in prices : for i in range ( k , 0 , - 1 ): sell [ i ] = max ( sell [ i ], hold [ i ] + price ) hold [ i ] = max ( hold [ i ], sell [ i - 1 ] - price ) return sell [ k ]","title":"188. Best Time to Buy and Sell Stock IV $\\star\\star\\star$"},{"location":"python3/0101-0200/0181-0190/#189-rotate-array-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def rotate ( self , nums : List [ int ], k : int ) -> None : k %= len ( nums ) self . reverse ( nums , 0 , len ( nums ) - 1 ) self . reverse ( nums , 0 , k - 1 ) self . reverse ( nums , k , len ( nums ) - 1 ) def reverse ( self , nums : List [ int ], l : int , r : int ) -> None : while l < r : nums [ l ], nums [ r ] = nums [ r ], nums [ l ] l += 1 r -= 1","title":"189. Rotate Array $\\star$"},{"location":"python3/0101-0200/0181-0190/#190-reverse-bits-star","text":"","title":"190. Reverse Bits $\\star$"},{"location":"python3/0101-0200/0191-0200/","text":"191. Number of 1 Bits $\\star$ 192. Word Frequency $\\star\\star$ 193. Valid Phone Numbers $\\star$ 194. Transpose File $\\star\\star$ 195. Tenth Line $\\star$ 196. Delete Duplicate Emails $\\star$ 197. Rising Temperature $\\star$ 198. House Robber $\\star$ Time: $O(n)$ Space: $O(n) \\to O(1)$ class Solution : def rob ( self , nums : List [ int ]) -> int : dp1 = 0 dp2 = 0 for num in nums : temp = dp1 dp1 = max ( dp1 , dp2 + num ) dp2 = temp return dp1 199. Binary Tree Right Side View $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def rightSideView ( self , root : TreeNode ) -> List [ int ]: def dfs ( root : TreeNode , depth : int ) -> None : if not root : return if depth == len ( ans ): ans . append ( root . val ) dfs ( root . right , depth + 1 ) dfs ( root . left , depth + 1 ) ans = [] dfs ( root , 0 ) return ans 200. Number of Islands $\\star\\star$ Time: $O(mn)$ Space: $O(mn)$ class Solution : def numIslands ( self , grid : List [ List [ str ]]) -> int : def dfs ( i : int , j : int ) -> None : if i < 0 or j < 0 or i >= len ( grid ) or j >= len ( grid [ 0 ]) or visited [ i ][ j ] or grid [ i ][ j ] == '0' : return visited [ i ][ j ] = True dfs ( i + 1 , j ) dfs ( i - 1 , j ) dfs ( i , j + 1 ) dfs ( i , j - 1 ) if not grid : return 0 m = len ( grid ) n = len ( grid [ 0 ]) ans = 0 visited = [[ False ] * n for _ in range ( m )] for i in range ( m ): for j in range ( n ): if not visited [ i ][ j ] and grid [ i ][ j ] == '1' : ans += 1 dfs ( i , j ) return ans","title":"0191-0200"},{"location":"python3/0101-0200/0191-0200/#191-number-of-1-bits-star","text":"","title":"191. Number of 1 Bits $\\star$"},{"location":"python3/0101-0200/0191-0200/#192-word-frequency-starstar","text":"","title":"192. Word Frequency $\\star\\star$"},{"location":"python3/0101-0200/0191-0200/#193-valid-phone-numbers-star","text":"","title":"193. Valid Phone Numbers $\\star$"},{"location":"python3/0101-0200/0191-0200/#194-transpose-file-starstar","text":"","title":"194. Transpose File $\\star\\star$"},{"location":"python3/0101-0200/0191-0200/#195-tenth-line-star","text":"","title":"195. Tenth Line $\\star$"},{"location":"python3/0101-0200/0191-0200/#196-delete-duplicate-emails-star","text":"","title":"196. Delete Duplicate Emails $\\star$"},{"location":"python3/0101-0200/0191-0200/#197-rising-temperature-star","text":"","title":"197. Rising Temperature $\\star$"},{"location":"python3/0101-0200/0191-0200/#198-house-robber-star","text":"Time: $O(n)$ Space: $O(n) \\to O(1)$ class Solution : def rob ( self , nums : List [ int ]) -> int : dp1 = 0 dp2 = 0 for num in nums : temp = dp1 dp1 = max ( dp1 , dp2 + num ) dp2 = temp return dp1","title":"198. House Robber $\\star$"},{"location":"python3/0101-0200/0191-0200/#199-binary-tree-right-side-view-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def rightSideView ( self , root : TreeNode ) -> List [ int ]: def dfs ( root : TreeNode , depth : int ) -> None : if not root : return if depth == len ( ans ): ans . append ( root . val ) dfs ( root . right , depth + 1 ) dfs ( root . left , depth + 1 ) ans = [] dfs ( root , 0 ) return ans","title":"199. Binary Tree Right Side View $\\star\\star$"},{"location":"python3/0101-0200/0191-0200/#200-number-of-islands-starstar","text":"Time: $O(mn)$ Space: $O(mn)$ class Solution : def numIslands ( self , grid : List [ List [ str ]]) -> int : def dfs ( i : int , j : int ) -> None : if i < 0 or j < 0 or i >= len ( grid ) or j >= len ( grid [ 0 ]) or visited [ i ][ j ] or grid [ i ][ j ] == '0' : return visited [ i ][ j ] = True dfs ( i + 1 , j ) dfs ( i - 1 , j ) dfs ( i , j + 1 ) dfs ( i , j - 1 ) if not grid : return 0 m = len ( grid ) n = len ( grid [ 0 ]) ans = 0 visited = [[ False ] * n for _ in range ( m )] for i in range ( m ): for j in range ( n ): if not visited [ i ][ j ] and grid [ i ][ j ] == '1' : ans += 1 dfs ( i , j ) return ans","title":"200. Number of Islands $\\star\\star$"},{"location":"python3/0201-0300/0201-0210/","text":"201. Bitwise AND of Numbers Range $\\star\\star$ Time: $O(32)$ Space: $O(1)$ class Solution : def rangeBitwiseAnd ( self , m : int , n : int ) -> int : return self . rangeBitwiseAnd ( m >> 1 , n >> 1 ) << 1 if m < n else m 202. Happy Number $\\star$ Time: $O(\\log n)$ Space: $O(1)$ class Solution : def isHappy ( self , n : int ) -> bool : def helper ( n : int ) -> bool : sum = 0 while n : sum += pow ( n % 10 , 2 ) n //= 10 return sum slow = helper ( n ) fast = helper ( helper ( n )) while slow != fast : slow = helper ( slow ) fast = helper ( helper ( fast )) return slow == 1 203. Remove Linked List Elements $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def removeElements ( self , head : ListNode , val : int ) -> ListNode : dummy = ListNode ( 0 ) dummy . next = head prev = dummy while head : if head . val != val : prev . next = head prev = prev . next head = head . next prev . next = None return dummy . next 204. Count Primes $\\star$ Time: $O(n\\log\\log n)$ Space: $O(n)$ class Solution : def countPrimes ( self , n : int ) -> int : if n <= 2 : return 0 isPrime = [ False ] * 2 + [ True ] * ( n - 2 ) for i in range ( 2 , int ( n ** 0.5 ) + 1 ): if isPrime [ i ]: for j in range ( i * i , n , i ): isPrime [ j ] = False return sum ( isPrime ) 205. Isomorphic Strings $\\star$ Time: $O(n)$ Space: $O(128)$ class Solution : def isIsomorphic ( self , s : str , t : str ) -> bool : return [ * map ( s . index , s )] == [ * map ( t . index , t )] 206. Reverse Linked List $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def reverseList ( self , head : ListNode ) -> ListNode : prev = None curr = head while curr : next = curr . next curr . next = prev prev = curr curr = next return prev 207. Course Schedule $\\star\\star$ Time: $O(n^2) \\to O(n)$ Space: $O(n)$ class Solution : def canFinish ( self , numCourses : int , prerequisites : List [ List [ int ]]) -> bool : def hasCycle ( course : int ) -> bool : if state [ course ] == 1 : return True if state [ course ] == 2 : return False state [ course ] = 1 for neighbor in graph [ course ]: if hasCycle ( neighbor ): return True state [ course ] = 2 return False graph = [[] for _ in range ( numCourses )] state = [ 0 ] * numCourses for a , b in prerequisites : graph [ b ] . append ( a ) for course in range ( numCourses ): if hasCycle ( course ): return False return True 208. Implement Trie (Prefix Tree) $\\star\\star$ class Trie : def __init__ ( self ): self . root = {} def insert ( self , word : str ) -> None : node = self . root for c in word : if c not in node : node [ c ] = {} node = node [ c ] node [ 'isWord' ] = True def search ( self , word : str ) -> bool : node = self . find ( word ) return node is not None and 'isWord' in node def startsWith ( self , prefix : str ) -> bool : return self . find ( prefix ) is not None def find ( self , prefix : str ) -> dict : node = self . root for c in prefix : if c not in node : return None node = node [ c ] return node 209. Minimum Size Subarray Sum $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def minSubArrayLen ( self , s : int , nums : List [ int ]) -> int : ans = float ( 'inf' ) sum = 0 j = 0 for i , num in enumerate ( nums ): sum += num while sum >= s : ans = min ( ans , i - j + 1 ) sum -= nums [ j ] j += 1 return ans if ans != float ( 'inf' ) else 0 210. Course Schedule II $\\star\\star$ Time: $O(n^2) \\to O(n)$ Space: $O(n)$ class Solution : def findOrder ( self , numCourses : int , prerequisites : List [ List [ int ]]) -> List [ int ]: def hasCycle ( course : int ) -> bool : if state [ course ] == 1 : return True if state [ course ] == 2 : return False state [ course ] = 1 for neighbor in graph [ course ]: if hasCycle ( neighbor ): return True state [ course ] = 2 ans . append ( course ) return False ans = [] graph = [[] for _ in range ( numCourses )] state = [ 0 ] * numCourses for a , b in prerequisites : graph [ b ] . append ( a ) for course in range ( numCourses ): if hasCycle ( course ): return [] return ans [:: - 1 ]","title":"0201-0210"},{"location":"python3/0201-0300/0201-0210/#201-bitwise-and-of-numbers-range-starstar","text":"Time: $O(32)$ Space: $O(1)$ class Solution : def rangeBitwiseAnd ( self , m : int , n : int ) -> int : return self . rangeBitwiseAnd ( m >> 1 , n >> 1 ) << 1 if m < n else m","title":"201. Bitwise AND of Numbers Range $\\star\\star$"},{"location":"python3/0201-0300/0201-0210/#202-happy-number-star","text":"Time: $O(\\log n)$ Space: $O(1)$ class Solution : def isHappy ( self , n : int ) -> bool : def helper ( n : int ) -> bool : sum = 0 while n : sum += pow ( n % 10 , 2 ) n //= 10 return sum slow = helper ( n ) fast = helper ( helper ( n )) while slow != fast : slow = helper ( slow ) fast = helper ( helper ( fast )) return slow == 1","title":"202. Happy Number $\\star$"},{"location":"python3/0201-0300/0201-0210/#203-remove-linked-list-elements-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def removeElements ( self , head : ListNode , val : int ) -> ListNode : dummy = ListNode ( 0 ) dummy . next = head prev = dummy while head : if head . val != val : prev . next = head prev = prev . next head = head . next prev . next = None return dummy . next","title":"203. Remove Linked List Elements $\\star$"},{"location":"python3/0201-0300/0201-0210/#204-count-primes-star","text":"Time: $O(n\\log\\log n)$ Space: $O(n)$ class Solution : def countPrimes ( self , n : int ) -> int : if n <= 2 : return 0 isPrime = [ False ] * 2 + [ True ] * ( n - 2 ) for i in range ( 2 , int ( n ** 0.5 ) + 1 ): if isPrime [ i ]: for j in range ( i * i , n , i ): isPrime [ j ] = False return sum ( isPrime )","title":"204. Count Primes $\\star$"},{"location":"python3/0201-0300/0201-0210/#205-isomorphic-strings-star","text":"Time: $O(n)$ Space: $O(128)$ class Solution : def isIsomorphic ( self , s : str , t : str ) -> bool : return [ * map ( s . index , s )] == [ * map ( t . index , t )]","title":"205. Isomorphic Strings $\\star$"},{"location":"python3/0201-0300/0201-0210/#206-reverse-linked-list-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def reverseList ( self , head : ListNode ) -> ListNode : prev = None curr = head while curr : next = curr . next curr . next = prev prev = curr curr = next return prev","title":"206. Reverse Linked List $\\star$"},{"location":"python3/0201-0300/0201-0210/#207-course-schedule-starstar","text":"Time: $O(n^2) \\to O(n)$ Space: $O(n)$ class Solution : def canFinish ( self , numCourses : int , prerequisites : List [ List [ int ]]) -> bool : def hasCycle ( course : int ) -> bool : if state [ course ] == 1 : return True if state [ course ] == 2 : return False state [ course ] = 1 for neighbor in graph [ course ]: if hasCycle ( neighbor ): return True state [ course ] = 2 return False graph = [[] for _ in range ( numCourses )] state = [ 0 ] * numCourses for a , b in prerequisites : graph [ b ] . append ( a ) for course in range ( numCourses ): if hasCycle ( course ): return False return True","title":"207. Course Schedule $\\star\\star$"},{"location":"python3/0201-0300/0201-0210/#208-implement-trie-prefix-tree-starstar","text":"class Trie : def __init__ ( self ): self . root = {} def insert ( self , word : str ) -> None : node = self . root for c in word : if c not in node : node [ c ] = {} node = node [ c ] node [ 'isWord' ] = True def search ( self , word : str ) -> bool : node = self . find ( word ) return node is not None and 'isWord' in node def startsWith ( self , prefix : str ) -> bool : return self . find ( prefix ) is not None def find ( self , prefix : str ) -> dict : node = self . root for c in prefix : if c not in node : return None node = node [ c ] return node","title":"208. Implement Trie (Prefix Tree) $\\star\\star$"},{"location":"python3/0201-0300/0201-0210/#209-minimum-size-subarray-sum-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def minSubArrayLen ( self , s : int , nums : List [ int ]) -> int : ans = float ( 'inf' ) sum = 0 j = 0 for i , num in enumerate ( nums ): sum += num while sum >= s : ans = min ( ans , i - j + 1 ) sum -= nums [ j ] j += 1 return ans if ans != float ( 'inf' ) else 0","title":"209. Minimum Size Subarray Sum $\\star\\star$"},{"location":"python3/0201-0300/0201-0210/#210-course-schedule-ii-starstar","text":"Time: $O(n^2) \\to O(n)$ Space: $O(n)$ class Solution : def findOrder ( self , numCourses : int , prerequisites : List [ List [ int ]]) -> List [ int ]: def hasCycle ( course : int ) -> bool : if state [ course ] == 1 : return True if state [ course ] == 2 : return False state [ course ] = 1 for neighbor in graph [ course ]: if hasCycle ( neighbor ): return True state [ course ] = 2 ans . append ( course ) return False ans = [] graph = [[] for _ in range ( numCourses )] state = [ 0 ] * numCourses for a , b in prerequisites : graph [ b ] . append ( a ) for course in range ( numCourses ): if hasCycle ( course ): return [] return ans [:: - 1 ]","title":"210. Course Schedule II $\\star\\star$"},{"location":"python3/0201-0300/0211-0220/","text":"211. Add and Search Word - Data structure design $\\star\\star$ class WordDictionary : def __init__ ( self ): self . root = {} def addWord ( self , word : str ) -> None : node = self . root for c in word : if c not in node : node [ c ] = {} node = node [ c ] node [ 'isWord' ] = True def search ( self , word : str ) -> bool : return self . dfs ( word , 0 , self . root ) def dfs ( self , word : str , depth : int , node : dict ) -> bool : if depth == len ( word ): return 'isWord' in node if word [ depth ] != '.' : if word [ depth ] in node : return self . dfs ( word , depth + 1 , node [ word [ depth ]]) return False for c in string . ascii_lowercase : if c in node and self . dfs ( word , depth + 1 , node [ c ]): return True return False 212. Word Search II $\\star\\star\\star$ class Solution : def findWords ( self , board : List [ List [ str ]], words : List [ str ]) -> List [ str ]: def dfs ( i : int , j : int , node : dict ) -> None : if not 0 <= i < len ( board ) or not 0 <= j < len ( board [ 0 ]) or board [ i ][ j ] == '*' : return c = board [ i ][ j ] if c not in node : return next = node [ c ] if 'word' in next : ans . append ( next [ 'word' ]) del next [ 'word' ] board [ i ][ j ] = '*' dfs ( i + 1 , j , next ) dfs ( i - 1 , j , next ) dfs ( i , j + 1 , next ) dfs ( i , j - 1 , next ) board [ i ][ j ] = c self . root = {} for word in words : node = self . root for c in word : if c not in node : node [ c ] = {} node = node [ c ] node [ 'word' ] = word ans = [] for i in range ( len ( board )): for j in range ( len ( board [ 0 ])): dfs ( i , j , self . root ) return ans 213. House Robber II $\\star\\star$ Time: $O(n)$ Space: $O(n) \\to O(1)$ class Solution : def rob ( self , nums : List [ int ]) -> int : def rob ( l : int , r : int ) -> int : dp1 = 0 dp2 = 0 for i in range ( l , r + 1 ): temp = dp1 dp1 = max ( dp1 , dp2 + nums [ i ]) dp2 = temp return dp1 if not nums : return 0 if len ( nums ) < 2 : return nums [ 0 ] return max ( rob ( 0 , len ( nums ) - 2 ), rob ( 1 , len ( nums ) - 1 )) 214. Shortest Palindrome $\\star\\star\\star$ 215. Kth Largest Element in an Array $\\star\\star$ 216. Combination Sum III $\\star\\star$ Time: $O(C(9, k)) = O(9^k)$ Space: $O(n)$ class Solution : def combinationSum3 ( self , k : int , n : int ) -> List [ List [ int ]]: def dfs ( k : int , n : int , s : int , path : List [ int ]) -> None : if k == 0 and n == 0 : ans . append ( path ) return if k == 0 or n < 0 : return for i in range ( s , 10 ): dfs ( k - 1 , n - i , i + 1 , path + [ i ]) ans = [] dfs ( k , n , 1 , []) return ans 217. Contains Duplicate $\\star$ Time: $O(n)$ Space: $O(n)$ class Solution : def containsDuplicate ( self , nums : List [ int ]) -> bool : return len ( nums ) != len ( set ( nums )) 218. The Skyline Problem $\\star\\star\\star$ 219. Contains Duplicate II $\\star$ Time: $O(n)$ Space: $O(n)$ class Solution : def containsNearbyDuplicate ( self , nums : List [ int ], k : int ) -> bool : seen = set () for i , num in enumerate ( nums ): if i > k : seen . remove ( nums [ i - k - 1 ]) if num in seen : return True seen . add ( num ) return False 220. Contains Duplicate III $\\star\\star$","title":"0211-0220"},{"location":"python3/0201-0300/0211-0220/#211-add-and-search-word-data-structure-design-starstar","text":"class WordDictionary : def __init__ ( self ): self . root = {} def addWord ( self , word : str ) -> None : node = self . root for c in word : if c not in node : node [ c ] = {} node = node [ c ] node [ 'isWord' ] = True def search ( self , word : str ) -> bool : return self . dfs ( word , 0 , self . root ) def dfs ( self , word : str , depth : int , node : dict ) -> bool : if depth == len ( word ): return 'isWord' in node if word [ depth ] != '.' : if word [ depth ] in node : return self . dfs ( word , depth + 1 , node [ word [ depth ]]) return False for c in string . ascii_lowercase : if c in node and self . dfs ( word , depth + 1 , node [ c ]): return True return False","title":"211. Add and Search Word - Data structure design $\\star\\star$"},{"location":"python3/0201-0300/0211-0220/#212-word-search-ii-starstarstar","text":"class Solution : def findWords ( self , board : List [ List [ str ]], words : List [ str ]) -> List [ str ]: def dfs ( i : int , j : int , node : dict ) -> None : if not 0 <= i < len ( board ) or not 0 <= j < len ( board [ 0 ]) or board [ i ][ j ] == '*' : return c = board [ i ][ j ] if c not in node : return next = node [ c ] if 'word' in next : ans . append ( next [ 'word' ]) del next [ 'word' ] board [ i ][ j ] = '*' dfs ( i + 1 , j , next ) dfs ( i - 1 , j , next ) dfs ( i , j + 1 , next ) dfs ( i , j - 1 , next ) board [ i ][ j ] = c self . root = {} for word in words : node = self . root for c in word : if c not in node : node [ c ] = {} node = node [ c ] node [ 'word' ] = word ans = [] for i in range ( len ( board )): for j in range ( len ( board [ 0 ])): dfs ( i , j , self . root ) return ans","title":"212. Word Search II $\\star\\star\\star$"},{"location":"python3/0201-0300/0211-0220/#213-house-robber-ii-starstar","text":"Time: $O(n)$ Space: $O(n) \\to O(1)$ class Solution : def rob ( self , nums : List [ int ]) -> int : def rob ( l : int , r : int ) -> int : dp1 = 0 dp2 = 0 for i in range ( l , r + 1 ): temp = dp1 dp1 = max ( dp1 , dp2 + nums [ i ]) dp2 = temp return dp1 if not nums : return 0 if len ( nums ) < 2 : return nums [ 0 ] return max ( rob ( 0 , len ( nums ) - 2 ), rob ( 1 , len ( nums ) - 1 ))","title":"213. House Robber II $\\star\\star$"},{"location":"python3/0201-0300/0211-0220/#214-shortest-palindrome-starstarstar","text":"","title":"214. Shortest Palindrome $\\star\\star\\star$"},{"location":"python3/0201-0300/0211-0220/#215-kth-largest-element-in-an-array-starstar","text":"","title":"215. Kth Largest Element in an Array $\\star\\star$"},{"location":"python3/0201-0300/0211-0220/#216-combination-sum-iii-starstar","text":"Time: $O(C(9, k)) = O(9^k)$ Space: $O(n)$ class Solution : def combinationSum3 ( self , k : int , n : int ) -> List [ List [ int ]]: def dfs ( k : int , n : int , s : int , path : List [ int ]) -> None : if k == 0 and n == 0 : ans . append ( path ) return if k == 0 or n < 0 : return for i in range ( s , 10 ): dfs ( k - 1 , n - i , i + 1 , path + [ i ]) ans = [] dfs ( k , n , 1 , []) return ans","title":"216. Combination Sum III $\\star\\star$"},{"location":"python3/0201-0300/0211-0220/#217-contains-duplicate-star","text":"Time: $O(n)$ Space: $O(n)$ class Solution : def containsDuplicate ( self , nums : List [ int ]) -> bool : return len ( nums ) != len ( set ( nums ))","title":"217. Contains Duplicate $\\star$"},{"location":"python3/0201-0300/0211-0220/#218-the-skyline-problem-starstarstar","text":"","title":"218. The Skyline Problem $\\star\\star\\star$"},{"location":"python3/0201-0300/0211-0220/#219-contains-duplicate-ii-star","text":"Time: $O(n)$ Space: $O(n)$ class Solution : def containsNearbyDuplicate ( self , nums : List [ int ], k : int ) -> bool : seen = set () for i , num in enumerate ( nums ): if i > k : seen . remove ( nums [ i - k - 1 ]) if num in seen : return True seen . add ( num ) return False","title":"219. Contains Duplicate II $\\star$"},{"location":"python3/0201-0300/0211-0220/#220-contains-duplicate-iii-starstar","text":"","title":"220. Contains Duplicate III $\\star\\star$"},{"location":"python3/0201-0300/0221-0230/","text":"221. Maximal Square $\\star\\star$ Time: $O(mn)$ Space: $O(mn) \\to O(n)$ class Solution : def maximalSquare ( self , matrix : List [ List [ str ]]) -> int : if not matrix : return 0 dp = [[ 0 ] * len ( matrix [ 0 ]) for _ in range ( len ( matrix ))] maxLength = 0 for i in range ( len ( matrix )): for j in range ( len ( matrix [ 0 ])): if i == 0 or j == 0 or matrix [ i ][ j ] == '0' : dp [ i ][ j ] = 1 if matrix [ i ][ j ] == '1' else 0 else : dp [ i ][ j ] = min ( dp [ i - 1 ][ j - 1 ], dp [ i - 1 ] [ j ], dp [ i ][ j - 1 ]) + 1 maxLength = max ( maxLength , dp [ i ][ j ]) return maxLength * maxLength 222. Count Complete Tree Nodes $\\star\\star$ Time: $O(\\log^2n)$ Space: $O(1)$ class Solution : def countNodes ( self , root : TreeNode ) -> int : if not root : return 0 ans = 0 queue = collections . deque ([ root ]) while queue : ans += 1 node = queue . popleft () if node . left : queue . append ( node . left ) if node . right : queue . append ( node . right ) return ans 223. Rectangle Area $\\star\\star$ Time: $O(1)$ Space: $O(1)$ class Solution : def computeArea ( self , A : int , B : int , C : int , D : int , E : int , F : int , G : int , H : int ) -> int : x = min ( C , G ) - max ( A , E ) if max ( A , E ) < min ( C , G ) else 0 y = min ( D , H ) - max ( B , F ) if max ( B , F ) < min ( D , H ) else 0 return ( C - A ) * ( D - B ) + ( G - E ) * ( H - F ) - x * y 224. Basic Calculator $\\star\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution : def calculate ( self , s : str ) -> int : ans = 0 num = 0 sign = 1 stack = [ sign ] for i , c in enumerate ( s ): if c . isdigit (): num = num * 10 + ord ( c ) - ord ( '0' ) elif c in '+-' : ans += sign * num sign = stack [ - 1 ] * ( 1 if c == '+' else - 1 ) num = 0 elif c == '(' : stack . append ( sign ) elif c == ')' : stack . pop () return ans + sign * num 225. Implement Stack using Queues $\\star$ 226. Invert Binary Tree $\\star$ 227. Basic Calculator II $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution : def calculate ( self , s : str ) -> int : num = 0 sign = '+' stack = [] for i , c in enumerate ( s ): if c . isdigit (): num = num * 10 + int ( c ) if not c . isdigit () and c != ' ' or i == len ( s ) - 1 : if sign == '+' : stack . append ( num ) elif sign == '-' : stack . append ( - num ) elif sign == '*' : stack . append ( stack . pop () * num ) else : if stack [ - 1 ] < 0 : stack . append ( math . ceil ( stack . pop () / num )) else : stack . append ( stack . pop () // num ) num = 0 sign = c return sum ( stack ) 228. Summary Ranges $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution : def summaryRanges ( self , nums : List [ int ]) -> List [ str ]: ans = [] i = 0 while i < len ( nums ): begin = nums [ i ] while i < len ( nums ) - 1 and nums [ i ] == nums [ i + 1 ] - 1 : i += 1 end = nums [ i ] if begin == end : ans . append ( str ( begin )) else : ans . append ( str ( begin ) + \"->\" + str ( end )) i += 1 return ans 229. Majority Element II $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def majorityElement ( self , nums : List [ int ]) -> List [ int ]: ans1 = 0 ans2 = 1 count1 = 0 count2 = 0 for num in nums : if num == ans1 : count1 += 1 elif num == ans2 : count2 += 1 elif count1 == 0 : ans1 = num count1 = 1 elif count2 == 0 : ans2 = num count2 = 1 else : count1 -= 1 count2 -= 1 return [ ans for ans in ( ans1 , ans2 ) if nums . count ( ans ) > len ( nums ) // 3 ] 230. Kth Smallest Element in a BST $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution : def kthSmallest ( self , root : TreeNode , k : int ) -> int : def inorder ( root : TreeNode ) -> List [ TreeNode ]: if not root : return [] return inorder ( root . left ) + [ root . val ] + inorder ( root . right ) return inorder ( root )[ k - 1 ]","title":"0221-0230"},{"location":"python3/0201-0300/0221-0230/#221-maximal-square-starstar","text":"Time: $O(mn)$ Space: $O(mn) \\to O(n)$ class Solution : def maximalSquare ( self , matrix : List [ List [ str ]]) -> int : if not matrix : return 0 dp = [[ 0 ] * len ( matrix [ 0 ]) for _ in range ( len ( matrix ))] maxLength = 0 for i in range ( len ( matrix )): for j in range ( len ( matrix [ 0 ])): if i == 0 or j == 0 or matrix [ i ][ j ] == '0' : dp [ i ][ j ] = 1 if matrix [ i ][ j ] == '1' else 0 else : dp [ i ][ j ] = min ( dp [ i - 1 ][ j - 1 ], dp [ i - 1 ] [ j ], dp [ i ][ j - 1 ]) + 1 maxLength = max ( maxLength , dp [ i ][ j ]) return maxLength * maxLength","title":"221. Maximal Square $\\star\\star$"},{"location":"python3/0201-0300/0221-0230/#222-count-complete-tree-nodes-starstar","text":"Time: $O(\\log^2n)$ Space: $O(1)$ class Solution : def countNodes ( self , root : TreeNode ) -> int : if not root : return 0 ans = 0 queue = collections . deque ([ root ]) while queue : ans += 1 node = queue . popleft () if node . left : queue . append ( node . left ) if node . right : queue . append ( node . right ) return ans","title":"222. Count Complete Tree Nodes $\\star\\star$"},{"location":"python3/0201-0300/0221-0230/#223-rectangle-area-starstar","text":"Time: $O(1)$ Space: $O(1)$ class Solution : def computeArea ( self , A : int , B : int , C : int , D : int , E : int , F : int , G : int , H : int ) -> int : x = min ( C , G ) - max ( A , E ) if max ( A , E ) < min ( C , G ) else 0 y = min ( D , H ) - max ( B , F ) if max ( B , F ) < min ( D , H ) else 0 return ( C - A ) * ( D - B ) + ( G - E ) * ( H - F ) - x * y","title":"223. Rectangle Area $\\star\\star$"},{"location":"python3/0201-0300/0221-0230/#224-basic-calculator-starstarstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution : def calculate ( self , s : str ) -> int : ans = 0 num = 0 sign = 1 stack = [ sign ] for i , c in enumerate ( s ): if c . isdigit (): num = num * 10 + ord ( c ) - ord ( '0' ) elif c in '+-' : ans += sign * num sign = stack [ - 1 ] * ( 1 if c == '+' else - 1 ) num = 0 elif c == '(' : stack . append ( sign ) elif c == ')' : stack . pop () return ans + sign * num","title":"224. Basic Calculator $\\star\\star\\star$"},{"location":"python3/0201-0300/0221-0230/#225-implement-stack-using-queues-star","text":"","title":"225. Implement Stack using Queues $\\star$"},{"location":"python3/0201-0300/0221-0230/#226-invert-binary-tree-star","text":"","title":"226. Invert Binary Tree $\\star$"},{"location":"python3/0201-0300/0221-0230/#227-basic-calculator-ii-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution : def calculate ( self , s : str ) -> int : num = 0 sign = '+' stack = [] for i , c in enumerate ( s ): if c . isdigit (): num = num * 10 + int ( c ) if not c . isdigit () and c != ' ' or i == len ( s ) - 1 : if sign == '+' : stack . append ( num ) elif sign == '-' : stack . append ( - num ) elif sign == '*' : stack . append ( stack . pop () * num ) else : if stack [ - 1 ] < 0 : stack . append ( math . ceil ( stack . pop () / num )) else : stack . append ( stack . pop () // num ) num = 0 sign = c return sum ( stack )","title":"227. Basic Calculator II $\\star\\star$"},{"location":"python3/0201-0300/0221-0230/#228-summary-ranges-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution : def summaryRanges ( self , nums : List [ int ]) -> List [ str ]: ans = [] i = 0 while i < len ( nums ): begin = nums [ i ] while i < len ( nums ) - 1 and nums [ i ] == nums [ i + 1 ] - 1 : i += 1 end = nums [ i ] if begin == end : ans . append ( str ( begin )) else : ans . append ( str ( begin ) + \"->\" + str ( end )) i += 1 return ans","title":"228. Summary Ranges $\\star\\star$"},{"location":"python3/0201-0300/0221-0230/#229-majority-element-ii-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def majorityElement ( self , nums : List [ int ]) -> List [ int ]: ans1 = 0 ans2 = 1 count1 = 0 count2 = 0 for num in nums : if num == ans1 : count1 += 1 elif num == ans2 : count2 += 1 elif count1 == 0 : ans1 = num count1 = 1 elif count2 == 0 : ans2 = num count2 = 1 else : count1 -= 1 count2 -= 1 return [ ans for ans in ( ans1 , ans2 ) if nums . count ( ans ) > len ( nums ) // 3 ]","title":"229. Majority Element II $\\star\\star$"},{"location":"python3/0201-0300/0221-0230/#230-kth-smallest-element-in-a-bst-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution : def kthSmallest ( self , root : TreeNode , k : int ) -> int : def inorder ( root : TreeNode ) -> List [ TreeNode ]: if not root : return [] return inorder ( root . left ) + [ root . val ] + inorder ( root . right ) return inorder ( root )[ k - 1 ]","title":"230. Kth Smallest Element in a BST $\\star\\star$"},{"location":"python3/0201-0300/0231-0240/","text":"231. Power of Two $\\star$ Time: $O(1)$ Space: $O(1)$ class Solution : def isPowerOfTwo ( self , n : int ) -> bool : return False if n < 0 else bin ( n ) . count ( '1' ) == 1 232. Implement Queue using Stacks $\\star$ 233. Number of Digit One $\\star\\star\\star$ Time: $O(\\log n)$ Space: $O(1)$ class Solution : def countDigitOne ( self , n : int ) -> int : if n < 0 : return 0 ans = 0 i = 1 num = n while i <= n : prefix = n // ( i * 10 ) suffix = n % i currentDigit = num % 10 ans += prefix * i if currentDigit > 1 : ans += i elif currentDigit == 1 : ans += suffix + 1 i *= 10 num //= 10 return ans 234. Palindrome Linked List $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def isPalindrome ( self , head : ListNode ) -> bool : def reverseList ( head : ListNode ) -> ListNode : prev = None curr = head while curr : next = curr . next curr . next = prev prev = curr curr = next return prev slow = head fast = head while fast and fast . next : slow = slow . next fast = fast . next . next if fast : slow = slow . next slow = reverseList ( slow ) while slow : if slow . val != head . val : return False slow = slow . next head = head . next return True 235. Lowest Common Ancestor of a Binary Search Tree $\\star$ 236. Lowest Common Ancestor of a Binary Tree $\\star\\star$ Time: $O(\\log n)$ Space: $O(\\log n)$ class Solution : def lowestCommonAncestor ( self , root : 'TreeNode' , p : 'TreeNode' , q : 'TreeNode' ) -> 'TreeNode' : if not root or root == p or root == q : return root left = self . lowestCommonAncestor ( root . left , p , q ) right = self . lowestCommonAncestor ( root . right , p , q ) if not left : return right if not right : return left return root 237. Delete Node in a Linked List $\\star$ Time: $O(1)$ Space: $O(1)$ class Solution : def deleteNode ( self , node ): node . val = node . next . val node . next = node . next . next 238. Product of Array Except Self $\\star\\star$ Time: $O(n)$ Space: $O(n) \\to O(1)$ class Solution : def productExceptSelf ( self , nums : List [ int ]) -> List [ int ]: ans = [ 0 ] * len ( nums ) ans [ 0 ] = 1 r = 1 for i in range ( 1 , len ( nums )): ans [ i ] = ans [ i - 1 ] * nums [ i - 1 ] for i in range ( len ( nums ) - 1 , - 1 , - 1 ): ans [ i ] *= r r *= nums [ i ] return ans 239. Sliding Window Maximum $\\star\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution : def maxSlidingWindow ( self , nums : List [ int ], k : int ) -> List [ int ]: ans = [] decreasingQueue = collections . deque () for i , num in enumerate ( nums ): while decreasingQueue and num > decreasingQueue [ - 1 ]: decreasingQueue . pop () decreasingQueue . append ( num ) if i >= k - 1 : ans . append ( decreasingQueue [ 0 ]) if nums [ i - k + 1 ] == decreasingQueue [ 0 ]: decreasingQueue . popleft () return ans 240. Search a 2D Matrix II $\\star\\star$ Time: $O(m + n)$ Space: $O(1)$ class Solution : def searchMatrix ( self , matrix : List [ List [ int ]], target : int ) -> bool : if not matrix : return False r = 0 c = len ( matrix [ 0 ]) - 1 while r < len ( matrix ) and c >= 0 : if matrix [ r ][ c ] == target : return True if target < matrix [ r ][ c ]: c -= 1 else : r += 1 return False","title":"0231-0240"},{"location":"python3/0201-0300/0231-0240/#231-power-of-two-star","text":"Time: $O(1)$ Space: $O(1)$ class Solution : def isPowerOfTwo ( self , n : int ) -> bool : return False if n < 0 else bin ( n ) . count ( '1' ) == 1","title":"231. Power of Two $\\star$"},{"location":"python3/0201-0300/0231-0240/#232-implement-queue-using-stacks-star","text":"","title":"232. Implement Queue using Stacks $\\star$"},{"location":"python3/0201-0300/0231-0240/#233-number-of-digit-one-starstarstar","text":"Time: $O(\\log n)$ Space: $O(1)$ class Solution : def countDigitOne ( self , n : int ) -> int : if n < 0 : return 0 ans = 0 i = 1 num = n while i <= n : prefix = n // ( i * 10 ) suffix = n % i currentDigit = num % 10 ans += prefix * i if currentDigit > 1 : ans += i elif currentDigit == 1 : ans += suffix + 1 i *= 10 num //= 10 return ans","title":"233. Number of Digit One $\\star\\star\\star$"},{"location":"python3/0201-0300/0231-0240/#234-palindrome-linked-list-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def isPalindrome ( self , head : ListNode ) -> bool : def reverseList ( head : ListNode ) -> ListNode : prev = None curr = head while curr : next = curr . next curr . next = prev prev = curr curr = next return prev slow = head fast = head while fast and fast . next : slow = slow . next fast = fast . next . next if fast : slow = slow . next slow = reverseList ( slow ) while slow : if slow . val != head . val : return False slow = slow . next head = head . next return True","title":"234. Palindrome Linked List $\\star$"},{"location":"python3/0201-0300/0231-0240/#235-lowest-common-ancestor-of-a-binary-search-tree-star","text":"","title":"235. Lowest Common Ancestor of a Binary Search Tree $\\star$"},{"location":"python3/0201-0300/0231-0240/#236-lowest-common-ancestor-of-a-binary-tree-starstar","text":"Time: $O(\\log n)$ Space: $O(\\log n)$ class Solution : def lowestCommonAncestor ( self , root : 'TreeNode' , p : 'TreeNode' , q : 'TreeNode' ) -> 'TreeNode' : if not root or root == p or root == q : return root left = self . lowestCommonAncestor ( root . left , p , q ) right = self . lowestCommonAncestor ( root . right , p , q ) if not left : return right if not right : return left return root","title":"236. Lowest Common Ancestor of a Binary Tree $\\star\\star$"},{"location":"python3/0201-0300/0231-0240/#237-delete-node-in-a-linked-list-star","text":"Time: $O(1)$ Space: $O(1)$ class Solution : def deleteNode ( self , node ): node . val = node . next . val node . next = node . next . next","title":"237. Delete Node in a Linked List $\\star$"},{"location":"python3/0201-0300/0231-0240/#238-product-of-array-except-self-starstar","text":"Time: $O(n)$ Space: $O(n) \\to O(1)$ class Solution : def productExceptSelf ( self , nums : List [ int ]) -> List [ int ]: ans = [ 0 ] * len ( nums ) ans [ 0 ] = 1 r = 1 for i in range ( 1 , len ( nums )): ans [ i ] = ans [ i - 1 ] * nums [ i - 1 ] for i in range ( len ( nums ) - 1 , - 1 , - 1 ): ans [ i ] *= r r *= nums [ i ] return ans","title":"238. Product of Array Except Self $\\star\\star$"},{"location":"python3/0201-0300/0231-0240/#239-sliding-window-maximum-starstarstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution : def maxSlidingWindow ( self , nums : List [ int ], k : int ) -> List [ int ]: ans = [] decreasingQueue = collections . deque () for i , num in enumerate ( nums ): while decreasingQueue and num > decreasingQueue [ - 1 ]: decreasingQueue . pop () decreasingQueue . append ( num ) if i >= k - 1 : ans . append ( decreasingQueue [ 0 ]) if nums [ i - k + 1 ] == decreasingQueue [ 0 ]: decreasingQueue . popleft () return ans","title":"239. Sliding Window Maximum $\\star\\star\\star$"},{"location":"python3/0201-0300/0231-0240/#240-search-a-2d-matrix-ii-starstar","text":"Time: $O(m + n)$ Space: $O(1)$ class Solution : def searchMatrix ( self , matrix : List [ List [ int ]], target : int ) -> bool : if not matrix : return False r = 0 c = len ( matrix [ 0 ]) - 1 while r < len ( matrix ) and c >= 0 : if matrix [ r ][ c ] == target : return True if target < matrix [ r ][ c ]: c -= 1 else : r += 1 return False","title":"240. Search a 2D Matrix II $\\star\\star$"},{"location":"python3/0201-0300/0241-0250/","text":"241. Different Ways to Add Parentheses $\\star\\star$ Time: $O(2^n \\to n)$ Space: $O(2^n)$ class Solution : def diffWaysToCompute ( self , input : str ) -> List [ int ]: ans = [] for i , c in enumerate ( input ): if c in '+-*' : left = self . diffWaysToCompute ( input [: i ]) right = self . diffWaysToCompute ( input [ i + 1 :]) for a in left : for b in right : ans . append ( eval ( str ( a ) + c + str ( b ))) return ans or [ int ( input )] 242. Valid Anagram $\\star$ Time: $O(26)$ Space: $O(n)$ class Solution : def isAnagram ( self , s : str , t : str ) -> bool : if len ( s ) != len ( t ): return False dict = collections . Counter ( s ) for c in t : dict [ c ] -= 1 if dict [ c ] < 0 : return False return True 243. Shortest Word Distance $\\star$ \ud83d\udd12 244. Shortest Word Distance II $\\star\\star$ \ud83d\udd12 245. Shortest Word Distance III $\\star\\star$ \ud83d\udd12 246. Strobogrammatic Number $\\star$ \ud83d\udd12 247. Strobogrammatic Number II $\\star\\star$ \ud83d\udd12 248. Strobogrammatic Number III $\\star\\star\\star$ \ud83d\udd12 249. Group Shifted Strings $\\star\\star$ \ud83d\udd12 250. Count Univalue Subtrees $\\star\\star$ \ud83d\udd12","title":"0241-0250"},{"location":"python3/0201-0300/0241-0250/#241-different-ways-to-add-parentheses-starstar","text":"Time: $O(2^n \\to n)$ Space: $O(2^n)$ class Solution : def diffWaysToCompute ( self , input : str ) -> List [ int ]: ans = [] for i , c in enumerate ( input ): if c in '+-*' : left = self . diffWaysToCompute ( input [: i ]) right = self . diffWaysToCompute ( input [ i + 1 :]) for a in left : for b in right : ans . append ( eval ( str ( a ) + c + str ( b ))) return ans or [ int ( input )]","title":"241. Different Ways to Add Parentheses $\\star\\star$"},{"location":"python3/0201-0300/0241-0250/#242-valid-anagram-star","text":"Time: $O(26)$ Space: $O(n)$ class Solution : def isAnagram ( self , s : str , t : str ) -> bool : if len ( s ) != len ( t ): return False dict = collections . Counter ( s ) for c in t : dict [ c ] -= 1 if dict [ c ] < 0 : return False return True","title":"242. Valid Anagram $\\star$"},{"location":"python3/0201-0300/0241-0250/#243-shortest-word-distance-star","text":"","title":"243. Shortest Word Distance $\\star$ \ud83d\udd12"},{"location":"python3/0201-0300/0241-0250/#244-shortest-word-distance-ii-starstar","text":"","title":"244. Shortest Word Distance II $\\star\\star$ \ud83d\udd12"},{"location":"python3/0201-0300/0241-0250/#245-shortest-word-distance-iii-starstar","text":"","title":"245. Shortest Word Distance III $\\star\\star$ \ud83d\udd12"},{"location":"python3/0201-0300/0241-0250/#246-strobogrammatic-number-star","text":"","title":"246. Strobogrammatic Number $\\star$ \ud83d\udd12"},{"location":"python3/0201-0300/0241-0250/#247-strobogrammatic-number-ii-starstar","text":"","title":"247. Strobogrammatic Number II $\\star\\star$ \ud83d\udd12"},{"location":"python3/0201-0300/0241-0250/#248-strobogrammatic-number-iii-starstarstar","text":"","title":"248. Strobogrammatic Number III $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/0201-0300/0241-0250/#249-group-shifted-strings-starstar","text":"","title":"249. Group Shifted Strings $\\star\\star$ \ud83d\udd12"},{"location":"python3/0201-0300/0241-0250/#250-count-univalue-subtrees-starstar","text":"","title":"250. Count Univalue Subtrees $\\star\\star$ \ud83d\udd12"},{"location":"python3/0201-0300/0251-0260/","text":"251. Flatten 2D Vector $\\star\\star$ \ud83d\udd12 252. Meeting Rooms $\\star$ \ud83d\udd12 253. Meeting Rooms II $\\star\\star$ \ud83d\udd12 254. Factor Combinations $\\star\\star$ \ud83d\udd12 255. Verify Preorder Sequence in Binary Search Tree $\\star\\star$ \ud83d\udd12 256. Paint House $\\star$ \ud83d\udd12 257. Binary Tree Paths $\\star$ Time: $O(n)$ Space: $O(\\log n)$ class Solution : def binaryTreePaths ( self , root : TreeNode ) -> List [ str ]: def dfs ( root : TreeNode , path : str ) -> None : if not root : return if not root . left and not root . right : ans . append ( path + str ( root . val )) return dfs ( root . left , path + str ( root . val ) + '->' ) dfs ( root . right , path + str ( root . val ) + '->' ) ans = [] dfs ( root , '' ) return ans 258. Add Digits $\\star$ Time: $O(1)$ Space: $O(1)$ class Solution : def addDigits ( self , num : int ) -> int : return 0 if num == 0 else 1 + ( num - 1 ) % 9 259. 3Sum Smaller $\\star\\star$ \ud83d\udd12 260. Single Number III $\\star\\star$ Time: $O(n)$ Space: $O(1)$ import functools class Solution : def singleNumber ( self , nums : List [ int ]) -> List [ int ]: ans = [ 0 , 0 ] xor = functools . reduce ( lambda x , y : x ^ y , nums ) xor &= - xor for num in nums : if num & xor : ans [ 0 ] ^= num else : ans [ 1 ] ^= num return ans","title":"0251-0260"},{"location":"python3/0201-0300/0251-0260/#251-flatten-2d-vector-starstar","text":"","title":"251. Flatten 2D Vector $\\star\\star$ \ud83d\udd12"},{"location":"python3/0201-0300/0251-0260/#252-meeting-rooms-star","text":"","title":"252. Meeting Rooms $\\star$ \ud83d\udd12"},{"location":"python3/0201-0300/0251-0260/#253-meeting-rooms-ii-starstar","text":"","title":"253. Meeting Rooms II $\\star\\star$ \ud83d\udd12"},{"location":"python3/0201-0300/0251-0260/#254-factor-combinations-starstar","text":"","title":"254. Factor Combinations $\\star\\star$ \ud83d\udd12"},{"location":"python3/0201-0300/0251-0260/#255-verify-preorder-sequence-in-binary-search-tree-starstar","text":"","title":"255. Verify Preorder Sequence in Binary Search Tree $\\star\\star$ \ud83d\udd12"},{"location":"python3/0201-0300/0251-0260/#256-paint-house-star","text":"","title":"256. Paint House $\\star$ \ud83d\udd12"},{"location":"python3/0201-0300/0251-0260/#257-binary-tree-paths-star","text":"Time: $O(n)$ Space: $O(\\log n)$ class Solution : def binaryTreePaths ( self , root : TreeNode ) -> List [ str ]: def dfs ( root : TreeNode , path : str ) -> None : if not root : return if not root . left and not root . right : ans . append ( path + str ( root . val )) return dfs ( root . left , path + str ( root . val ) + '->' ) dfs ( root . right , path + str ( root . val ) + '->' ) ans = [] dfs ( root , '' ) return ans","title":"257. Binary Tree Paths $\\star$"},{"location":"python3/0201-0300/0251-0260/#258-add-digits-star","text":"Time: $O(1)$ Space: $O(1)$ class Solution : def addDigits ( self , num : int ) -> int : return 0 if num == 0 else 1 + ( num - 1 ) % 9","title":"258. Add Digits $\\star$"},{"location":"python3/0201-0300/0251-0260/#259-3sum-smaller-starstar","text":"","title":"259. 3Sum Smaller $\\star\\star$ \ud83d\udd12"},{"location":"python3/0201-0300/0251-0260/#260-single-number-iii-starstar","text":"Time: $O(n)$ Space: $O(1)$ import functools class Solution : def singleNumber ( self , nums : List [ int ]) -> List [ int ]: ans = [ 0 , 0 ] xor = functools . reduce ( lambda x , y : x ^ y , nums ) xor &= - xor for num in nums : if num & xor : ans [ 0 ] ^= num else : ans [ 1 ] ^= num return ans","title":"260. Single Number III $\\star\\star$"},{"location":"python3/0201-0300/0261-0270/","text":"261. Graph Valid Tree $\\star\\star$ \ud83d\udd12 262. Trips and Users $\\star\\star\\star$ 263. Ugly Number $\\star$ Time: $O(\\log n)$ Space: $O(1)$ class Solution : def isUgly ( self , num : int ) -> bool : if num == 0 : return False for prime in 2 , 3 , 5 : while num % prime == 0 : num //= prime return num == 1 264. Ugly Number II $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution : def nthUglyNumber ( self , n : int ) -> int : nums = [ 1 ] i2 = 0 i3 = 0 i5 = 0 while len ( nums ) < n : next2 = nums [ i2 ] * 2 next3 = nums [ i3 ] * 3 next5 = nums [ i5 ] * 5 next = min ( next2 , next3 , next5 ) if next == next2 : i2 += 1 if next == next3 : i3 += 1 if next == next5 : i5 += 1 nums . append ( next ) return nums [ - 1 ] 265. Paint House II $\\star\\star\\star$ \ud83d\udd12 266. Palindrome Permutation $\\star$ \ud83d\udd12 267. Palindrome Permutation II $\\star\\star$ \ud83d\udd12 268. Missing Number $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def missingNumber ( self , nums : List [ int ]) -> int : ans = len ( nums ) for i , num in enumerate ( nums ): ans ^= i ^ num return ans 269. Alien Dictionary $\\star\\star\\star$ \ud83d\udd12 270. Closest Binary Search Tree Value $\\star$ \ud83d\udd12","title":"0261-0270"},{"location":"python3/0201-0300/0261-0270/#261-graph-valid-tree-starstar","text":"","title":"261. Graph Valid Tree $\\star\\star$ \ud83d\udd12"},{"location":"python3/0201-0300/0261-0270/#262-trips-and-users-starstarstar","text":"","title":"262. Trips and Users $\\star\\star\\star$"},{"location":"python3/0201-0300/0261-0270/#263-ugly-number-star","text":"Time: $O(\\log n)$ Space: $O(1)$ class Solution : def isUgly ( self , num : int ) -> bool : if num == 0 : return False for prime in 2 , 3 , 5 : while num % prime == 0 : num //= prime return num == 1","title":"263. Ugly Number $\\star$"},{"location":"python3/0201-0300/0261-0270/#264-ugly-number-ii-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution : def nthUglyNumber ( self , n : int ) -> int : nums = [ 1 ] i2 = 0 i3 = 0 i5 = 0 while len ( nums ) < n : next2 = nums [ i2 ] * 2 next3 = nums [ i3 ] * 3 next5 = nums [ i5 ] * 5 next = min ( next2 , next3 , next5 ) if next == next2 : i2 += 1 if next == next3 : i3 += 1 if next == next5 : i5 += 1 nums . append ( next ) return nums [ - 1 ]","title":"264. Ugly Number II $\\star\\star$"},{"location":"python3/0201-0300/0261-0270/#265-paint-house-ii-starstarstar","text":"","title":"265. Paint House II $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/0201-0300/0261-0270/#266-palindrome-permutation-star","text":"","title":"266. Palindrome Permutation $\\star$ \ud83d\udd12"},{"location":"python3/0201-0300/0261-0270/#267-palindrome-permutation-ii-starstar","text":"","title":"267. Palindrome Permutation II $\\star\\star$ \ud83d\udd12"},{"location":"python3/0201-0300/0261-0270/#268-missing-number-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def missingNumber ( self , nums : List [ int ]) -> int : ans = len ( nums ) for i , num in enumerate ( nums ): ans ^= i ^ num return ans","title":"268. Missing Number $\\star$"},{"location":"python3/0201-0300/0261-0270/#269-alien-dictionary-starstarstar","text":"","title":"269. Alien Dictionary $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/0201-0300/0261-0270/#270-closest-binary-search-tree-value-star","text":"","title":"270. Closest Binary Search Tree Value $\\star$ \ud83d\udd12"},{"location":"python3/0201-0300/0271-0280/","text":"271. Encode and Decode Strings $\\star\\star$ \ud83d\udd12 272. Closest Binary Search Tree Value II $\\star\\star\\star$ \ud83d\udd12 273. Integer to English Words $\\star\\star\\star$ class Solution : def numberToWords ( self , num : int ) -> str : def helper ( num : int ) -> str : if num < 20 : s = belowTwenty [ num ] elif num < 100 : s = tens [ num // 10 ] + \" \" + helper ( num % 10 ) elif num < 1000 : s = helper ( num // 100 ) + \" Hundred \" + helper ( num % 100 ) elif num < 1000000 : s = helper ( num // 1000 ) + \" Thousand \" + helper ( num % 1000 ) elif num < 1000000000 : s = helper ( num // 1000000 ) + \" Million \" + \\ helper ( num % 1000000 ) else : s = helper ( num // 1000000000 ) + \" Billion \" + \\ helper ( num % 1000000000 ) return s . strip () belowTwenty = [ \"\" , \"One\" , \"Two\" , \"Three\" , \"Four\" , \"Five\" , \"Six\" , \"Seven\" , \"Eight\" , \"Nine\" , \"Ten\" , \"Eleven\" , \"Twelve\" , \"Thirteen\" , \"Fourteen\" , \"Fifteen\" , \"Sixteen\" , \"Seventeen\" , \"Eighteen\" , \"Nineteen\" ] tens = [ \"\" , \"Ten\" , \"Twenty\" , \"Thirty\" , \"Forty\" , \"Fifty\" , \"Sixty\" , \"Seventy\" , \"Eighty\" , \"Ninety\" ] if num == 0 : return \"Zero\" return helper ( num ) 274. H-Index $\\star\\star$ Time: $O(n\\log n)$ Space: $O(n)$ class Solution : def hIndex ( self , citations : List [ int ]) -> int : n = len ( citations ) citations . sort () for i , citation in enumerate ( citations ): if citation >= n - i : return n - i return 0 275. H-Index II $\\star\\star$ 276. Paint Fence $\\star$ \ud83d\udd12 277. Find the Celebrity $\\star\\star$ \ud83d\udd12 278. First Bad Version $\\star$ Time: $O(\\log n)$ Space: $O(1)$ class Solution : def firstBadVersion ( self , n : int ) -> int : l = 1 r = n while l < r : m = ( l + r ) >> 1 if isBadVersion ( m ): r = m else : l = m + 1 return l 279. Perfect Squares $\\star\\star$ Time: $O(\\log n)$ Space: $O(n\\log n)$ class Solution : def numSquares ( self , n : int ) -> int : dp = [ n ] * ( n + 1 ) dp [ 0 ] = 0 dp [ 1 ] = 1 for i in range ( 2 , n + 1 ): j = 1 while j * j <= i : dp [ i ] = min ( dp [ i ], dp [ i - j * j ] + 1 ) j += 1 return dp [ n ] 280. Wiggle Sort $\\star\\star$ \ud83d\udd12","title":"0271-0280"},{"location":"python3/0201-0300/0271-0280/#271-encode-and-decode-strings-starstar","text":"","title":"271. Encode and Decode Strings $\\star\\star$ \ud83d\udd12"},{"location":"python3/0201-0300/0271-0280/#272-closest-binary-search-tree-value-ii-starstarstar","text":"","title":"272. Closest Binary Search Tree Value II $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/0201-0300/0271-0280/#273-integer-to-english-words-starstarstar","text":"class Solution : def numberToWords ( self , num : int ) -> str : def helper ( num : int ) -> str : if num < 20 : s = belowTwenty [ num ] elif num < 100 : s = tens [ num // 10 ] + \" \" + helper ( num % 10 ) elif num < 1000 : s = helper ( num // 100 ) + \" Hundred \" + helper ( num % 100 ) elif num < 1000000 : s = helper ( num // 1000 ) + \" Thousand \" + helper ( num % 1000 ) elif num < 1000000000 : s = helper ( num // 1000000 ) + \" Million \" + \\ helper ( num % 1000000 ) else : s = helper ( num // 1000000000 ) + \" Billion \" + \\ helper ( num % 1000000000 ) return s . strip () belowTwenty = [ \"\" , \"One\" , \"Two\" , \"Three\" , \"Four\" , \"Five\" , \"Six\" , \"Seven\" , \"Eight\" , \"Nine\" , \"Ten\" , \"Eleven\" , \"Twelve\" , \"Thirteen\" , \"Fourteen\" , \"Fifteen\" , \"Sixteen\" , \"Seventeen\" , \"Eighteen\" , \"Nineteen\" ] tens = [ \"\" , \"Ten\" , \"Twenty\" , \"Thirty\" , \"Forty\" , \"Fifty\" , \"Sixty\" , \"Seventy\" , \"Eighty\" , \"Ninety\" ] if num == 0 : return \"Zero\" return helper ( num )","title":"273. Integer to English Words $\\star\\star\\star$"},{"location":"python3/0201-0300/0271-0280/#274-h-index-starstar","text":"Time: $O(n\\log n)$ Space: $O(n)$ class Solution : def hIndex ( self , citations : List [ int ]) -> int : n = len ( citations ) citations . sort () for i , citation in enumerate ( citations ): if citation >= n - i : return n - i return 0","title":"274. H-Index $\\star\\star$"},{"location":"python3/0201-0300/0271-0280/#275-h-index-ii-starstar","text":"","title":"275. H-Index II $\\star\\star$"},{"location":"python3/0201-0300/0271-0280/#276-paint-fence-star","text":"","title":"276. Paint Fence $\\star$ \ud83d\udd12"},{"location":"python3/0201-0300/0271-0280/#277-find-the-celebrity-starstar","text":"","title":"277. Find the Celebrity $\\star\\star$ \ud83d\udd12"},{"location":"python3/0201-0300/0271-0280/#278-first-bad-version-star","text":"Time: $O(\\log n)$ Space: $O(1)$ class Solution : def firstBadVersion ( self , n : int ) -> int : l = 1 r = n while l < r : m = ( l + r ) >> 1 if isBadVersion ( m ): r = m else : l = m + 1 return l","title":"278. First Bad Version $\\star$"},{"location":"python3/0201-0300/0271-0280/#279-perfect-squares-starstar","text":"Time: $O(\\log n)$ Space: $O(n\\log n)$ class Solution : def numSquares ( self , n : int ) -> int : dp = [ n ] * ( n + 1 ) dp [ 0 ] = 0 dp [ 1 ] = 1 for i in range ( 2 , n + 1 ): j = 1 while j * j <= i : dp [ i ] = min ( dp [ i ], dp [ i - j * j ] + 1 ) j += 1 return dp [ n ]","title":"279. Perfect Squares $\\star\\star$"},{"location":"python3/0201-0300/0271-0280/#280-wiggle-sort-starstar","text":"","title":"280. Wiggle Sort $\\star\\star$ \ud83d\udd12"},{"location":"python3/0201-0300/0281-0290/","text":"281. Zigzag Iterator $\\star\\star$ \ud83d\udd12 282. Expression Add Operators $\\star\\star\\star$ 283. Move Zeroes $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def moveZeroes ( self , nums : List [ int ]) -> None : j = 0 for num in nums : if num != 0 : nums [ j ] = num j += 1 for i in range ( j , len ( nums )): nums [ i ] = 0 284. Peeking Iterator $\\star\\star$ 285. Inorder Successor in BST $\\star\\star$ \ud83d\udd12 286. Walls and Gates $\\star\\star$ \ud83d\udd12 287. Find the Duplicate Number $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def findDuplicate ( self , nums : List [ int ]) -> int : slow = nums [ nums [ 0 ]] fast = nums [ nums [ nums [ 0 ]]] while slow != fast : slow = nums [ slow ] fast = nums [ nums [ fast ]] slow = nums [ 0 ] while slow != fast : slow = nums [ slow ] fast = nums [ fast ] return slow 288. Unique Word Abbreviation $\\star\\star$ \ud83d\udd12 289. Game of Life $\\star\\star$ Time: $O(mn)$ Space: $O(1)$ class Solution : def gameOfLife ( self , board : List [ List [ int ]]) -> None : m = len ( board ) n = len ( board [ 0 ]) for i in range ( m ): for j in range ( n ): ones = 0 for y in range ( max ( 0 , i - 1 ), min ( m , i + 2 )): for x in range ( max ( 0 , j - 1 ), min ( n , j + 2 )): ones += board [ y ][ x ] & 1 if ( board [ i ][ j ] == 1 and ( ones == 3 or ones == 4 )) or ( board [ i ][ j ] == 0 and ones == 3 ): board [ i ][ j ] |= 0b10 for i in range ( m ): for j in range ( n ): board [ i ][ j ] >>= 1 290. Word Pattern $\\star$ class Solution : def wordPattern ( self , pattern : str , str : str ) -> bool : t = str . split () return [ * map ( pattern . index , pattern )] == [ * map ( t . index , t )]","title":"0281-0290"},{"location":"python3/0201-0300/0281-0290/#281-zigzag-iterator-starstar","text":"","title":"281. Zigzag Iterator $\\star\\star$ \ud83d\udd12"},{"location":"python3/0201-0300/0281-0290/#282-expression-add-operators-starstarstar","text":"","title":"282. Expression Add Operators $\\star\\star\\star$"},{"location":"python3/0201-0300/0281-0290/#283-move-zeroes-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def moveZeroes ( self , nums : List [ int ]) -> None : j = 0 for num in nums : if num != 0 : nums [ j ] = num j += 1 for i in range ( j , len ( nums )): nums [ i ] = 0","title":"283. Move Zeroes $\\star$"},{"location":"python3/0201-0300/0281-0290/#284-peeking-iterator-starstar","text":"","title":"284. Peeking Iterator $\\star\\star$"},{"location":"python3/0201-0300/0281-0290/#285-inorder-successor-in-bst-starstar","text":"","title":"285. Inorder Successor in BST $\\star\\star$ \ud83d\udd12"},{"location":"python3/0201-0300/0281-0290/#286-walls-and-gates-starstar","text":"","title":"286. Walls and Gates $\\star\\star$ \ud83d\udd12"},{"location":"python3/0201-0300/0281-0290/#287-find-the-duplicate-number-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def findDuplicate ( self , nums : List [ int ]) -> int : slow = nums [ nums [ 0 ]] fast = nums [ nums [ nums [ 0 ]]] while slow != fast : slow = nums [ slow ] fast = nums [ nums [ fast ]] slow = nums [ 0 ] while slow != fast : slow = nums [ slow ] fast = nums [ fast ] return slow","title":"287. Find the Duplicate Number $\\star\\star$"},{"location":"python3/0201-0300/0281-0290/#288-unique-word-abbreviation-starstar","text":"","title":"288. Unique Word Abbreviation $\\star\\star$ \ud83d\udd12"},{"location":"python3/0201-0300/0281-0290/#289-game-of-life-starstar","text":"Time: $O(mn)$ Space: $O(1)$ class Solution : def gameOfLife ( self , board : List [ List [ int ]]) -> None : m = len ( board ) n = len ( board [ 0 ]) for i in range ( m ): for j in range ( n ): ones = 0 for y in range ( max ( 0 , i - 1 ), min ( m , i + 2 )): for x in range ( max ( 0 , j - 1 ), min ( n , j + 2 )): ones += board [ y ][ x ] & 1 if ( board [ i ][ j ] == 1 and ( ones == 3 or ones == 4 )) or ( board [ i ][ j ] == 0 and ones == 3 ): board [ i ][ j ] |= 0b10 for i in range ( m ): for j in range ( n ): board [ i ][ j ] >>= 1","title":"289. Game of Life $\\star\\star$"},{"location":"python3/0201-0300/0281-0290/#290-word-pattern-star","text":"class Solution : def wordPattern ( self , pattern : str , str : str ) -> bool : t = str . split () return [ * map ( pattern . index , pattern )] == [ * map ( t . index , t )]","title":"290. Word Pattern $\\star$"},{"location":"python3/0201-0300/0291-0300/","text":"291. Word Pattern II $\\star\\star\\star$ \ud83d\udd12 292. Nim Game $\\star$ 293. Flip Game $\\star$ \ud83d\udd12 294. Flip Game II $\\star\\star$ \ud83d\udd12 295. Find Median from Data Stream $\\star\\star\\star$ 296. Best Meeting Point $\\star\\star\\star$ \ud83d\udd12 297. Serialize and Deserialize Binary Tree $\\star\\star\\star$ 298. Binary Tree Longest Consecutive Sequence $\\star\\star$ \ud83d\udd12 299. Bulls and Cows $\\star$ Time: $O(n)$ Space: $O(10)$ class Solution : def getHint ( self , secret : str , guess : str ) -> str : bulls = sum ( map ( operator . eq , secret , guess )) bovine = sum ( min ( secret . count ( x ), guess . count ( x )) for x in set ( guess )) return ' %d A %d B' % ( bulls , bovine - bulls ) 300. Longest Increasing Subsequence $\\star\\star$","title":"0291-0300"},{"location":"python3/0201-0300/0291-0300/#291-word-pattern-ii-starstarstar","text":"","title":"291. Word Pattern II $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/0201-0300/0291-0300/#292-nim-game-star","text":"","title":"292. Nim Game $\\star$"},{"location":"python3/0201-0300/0291-0300/#293-flip-game-star","text":"","title":"293. Flip Game $\\star$ \ud83d\udd12"},{"location":"python3/0201-0300/0291-0300/#294-flip-game-ii-starstar","text":"","title":"294. Flip Game II $\\star\\star$ \ud83d\udd12"},{"location":"python3/0201-0300/0291-0300/#295-find-median-from-data-stream-starstarstar","text":"","title":"295. Find Median from Data Stream $\\star\\star\\star$"},{"location":"python3/0201-0300/0291-0300/#296-best-meeting-point-starstarstar","text":"","title":"296. Best Meeting Point $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/0201-0300/0291-0300/#297-serialize-and-deserialize-binary-tree-starstarstar","text":"","title":"297. Serialize and Deserialize Binary Tree $\\star\\star\\star$"},{"location":"python3/0201-0300/0291-0300/#298-binary-tree-longest-consecutive-sequence-starstar","text":"","title":"298. Binary Tree Longest Consecutive Sequence $\\star\\star$ \ud83d\udd12"},{"location":"python3/0201-0300/0291-0300/#299-bulls-and-cows-star","text":"Time: $O(n)$ Space: $O(10)$ class Solution : def getHint ( self , secret : str , guess : str ) -> str : bulls = sum ( map ( operator . eq , secret , guess )) bovine = sum ( min ( secret . count ( x ), guess . count ( x )) for x in set ( guess )) return ' %d A %d B' % ( bulls , bovine - bulls )","title":"299. Bulls and Cows $\\star$"},{"location":"python3/0201-0300/0291-0300/#300-longest-increasing-subsequence-starstar","text":"","title":"300. Longest Increasing Subsequence $\\star\\star$"},{"location":"python3/0301-0400/0301-0310/","text":"301. Remove Invalid Parentheses $\\star\\star\\star$ Time: $O(2^n)$ class Solution : def removeInvalidParentheses ( self , s : str ) -> List [ str ]: def isValid ( s : str ): count = 0 for c in s : if c == '(' : count += 1 elif c == ')' : count -= 1 if count < 0 : return False return True def dfs ( s : str , start : int , l : int , r : int ) -> None : if l == 0 and r == 0 and isValid ( s ): ans . append ( s ) return for i in range ( start , len ( s )): if i > start and s [ i ] == s [ i - 1 ]: continue if r > 0 and s [ i ] == ')' : dfs ( s [: i ] + s [ i + 1 :], i , l , r - 1 ) elif l > 0 and s [ i ] == '(' : dfs ( s [: i ] + s [ i + 1 :], i , l - 1 , r ) ans = [] l = 0 r = 0 for c in s : if c == '(' : l += 1 elif c == ')' : if l == 0 : r += 1 else : l -= 1 dfs ( s , 0 , l , r ) return ans 302. Smallest Rectangle Enclosing Black Pixels $\\star\\star\\star$ \ud83d\udd12 303. Range Sum Query - Immutable $\\star$ 304. Range Sum Query 2D - Immutable $\\star\\star$ 305. Number of Islands II $\\star\\star\\star$ \ud83d\udd12 306. Additive Number $\\star\\star$ 307. Range Sum Query - Mutable $\\star\\star$ 308. Range Sum Query 2D - Mutable $\\star\\star\\star$ \ud83d\udd12 309. Best Time to Buy and Sell Stock with Cooldown $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def maxProfit ( self , prices : List [ int ]) -> int : sell = 0 hold = float ( '-inf' ) prev = 0 for price in prices : cache = sell sell = max ( sell , hold + price ) hold = max ( hold , prev - price ) prev = cache return sell 310. Minimum Height Trees $\\star\\star$","title":"0301-0310"},{"location":"python3/0301-0400/0301-0310/#301-remove-invalid-parentheses-starstarstar","text":"Time: $O(2^n)$ class Solution : def removeInvalidParentheses ( self , s : str ) -> List [ str ]: def isValid ( s : str ): count = 0 for c in s : if c == '(' : count += 1 elif c == ')' : count -= 1 if count < 0 : return False return True def dfs ( s : str , start : int , l : int , r : int ) -> None : if l == 0 and r == 0 and isValid ( s ): ans . append ( s ) return for i in range ( start , len ( s )): if i > start and s [ i ] == s [ i - 1 ]: continue if r > 0 and s [ i ] == ')' : dfs ( s [: i ] + s [ i + 1 :], i , l , r - 1 ) elif l > 0 and s [ i ] == '(' : dfs ( s [: i ] + s [ i + 1 :], i , l - 1 , r ) ans = [] l = 0 r = 0 for c in s : if c == '(' : l += 1 elif c == ')' : if l == 0 : r += 1 else : l -= 1 dfs ( s , 0 , l , r ) return ans","title":"301. Remove Invalid Parentheses $\\star\\star\\star$"},{"location":"python3/0301-0400/0301-0310/#302-smallest-rectangle-enclosing-black-pixels-starstarstar","text":"","title":"302. Smallest Rectangle Enclosing Black Pixels $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/0301-0400/0301-0310/#303-range-sum-query-immutable-star","text":"","title":"303. Range Sum Query - Immutable $\\star$"},{"location":"python3/0301-0400/0301-0310/#304-range-sum-query-2d-immutable-starstar","text":"","title":"304. Range Sum Query 2D - Immutable $\\star\\star$"},{"location":"python3/0301-0400/0301-0310/#305-number-of-islands-ii-starstarstar","text":"","title":"305. Number of Islands II $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/0301-0400/0301-0310/#306-additive-number-starstar","text":"","title":"306. Additive Number $\\star\\star$"},{"location":"python3/0301-0400/0301-0310/#307-range-sum-query-mutable-starstar","text":"","title":"307. Range Sum Query - Mutable $\\star\\star$"},{"location":"python3/0301-0400/0301-0310/#308-range-sum-query-2d-mutable-starstarstar","text":"","title":"308. Range Sum Query 2D - Mutable $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/0301-0400/0301-0310/#309-best-time-to-buy-and-sell-stock-with-cooldown-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def maxProfit ( self , prices : List [ int ]) -> int : sell = 0 hold = float ( '-inf' ) prev = 0 for price in prices : cache = sell sell = max ( sell , hold + price ) hold = max ( hold , prev - price ) prev = cache return sell","title":"309. Best Time to Buy and Sell Stock with Cooldown $\\star\\star$"},{"location":"python3/0301-0400/0301-0310/#310-minimum-height-trees-starstar","text":"","title":"310. Minimum Height Trees $\\star\\star$"},{"location":"python3/0301-0400/0311-0320/","text":"311. Sparse Matrix Multiplication $\\star\\star$ \ud83d\udd12 312. Burst Balloons $\\star\\star\\star$ Time: $O(n^3)$ Space: $O(n^2)$ class Solution : def maxCoins ( self , nums : List [ int ]) -> int : n = len ( nums ) nums = [ 1 ] + nums + [ 1 ] dp = [[ 0 ] * ( n + 2 ) for _ in range ( n + 2 )] for length in range ( 1 , n + 1 ): for i in range ( 1 , n - length + 2 ): j = i + length - 1 for k in range ( i , j + 1 ): dp [ i ][ j ] = max ( dp [ i ][ j ], dp [ i ][ k - 1 ] + dp [ k + 1 ] [ j ] + nums [ i - 1 ] * nums [ k ] * nums [ j + 1 ]) return dp [ 1 ][ n ] 313. Super Ugly Number $\\star\\star$ Time: $O(n\\log k)$ Space: $O(k)$ class Solution : def nthSuperUglyNumber ( self , n : int , primes : List [ int ]) -> int : k = len ( primes ) nums = [ 1 ] indices = [ 0 ] * k while len ( nums ) < n : nexts = [ 0 ] * k for i in range ( k ): nexts [ i ] = nums [ indices [ i ]] * primes [ i ] next = min ( nexts ) for i in range ( k ): if next == nexts [ i ]: indices [ i ] += 1 nums . append ( next ) return nums [ - 1 ] 314. Binary Tree Vertical Order Traversal $\\star\\star$ \ud83d\udd12 315. Count of Smaller Numbers After Self $\\star\\star\\star$ 316. Remove Duplicate Letters $\\star\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def removeDuplicateLetters ( self , s : str ) -> str : ans = [] count = collections . Counter ( s ) used = [ False ] * 26 for c in s : count [ c ] -= 1 if used [ ord ( c ) - ord ( 'a' )]: continue while ans and ans [ - 1 ] > c and count [ ans [ - 1 ]] > 0 : used [ ord ( ans [ - 1 ]) - ord ( 'a' )] = False ans . pop () ans . append ( c ) used [ ord ( ans [ - 1 ]) - ord ( 'a' )] = True return '' . join ( ans ) 317. Shortest Distance from All Buildings $\\star\\star\\star$ \ud83d\udd12 318. Maximum Product of Word Lengths $\\star\\star$ 319. Bulb Switcher $\\star\\star$ Time: $O(1)$ Space: $O(1)$ class Solution : def bulbSwitch ( self , n : int ) -> int : return int ( sqrt ( n )) 320. Generalized Abbreviation $\\star\\star$ \ud83d\udd12","title":"0311-0320"},{"location":"python3/0301-0400/0311-0320/#311-sparse-matrix-multiplication-starstar","text":"","title":"311. Sparse Matrix Multiplication $\\star\\star$ \ud83d\udd12"},{"location":"python3/0301-0400/0311-0320/#312-burst-balloons-starstarstar","text":"Time: $O(n^3)$ Space: $O(n^2)$ class Solution : def maxCoins ( self , nums : List [ int ]) -> int : n = len ( nums ) nums = [ 1 ] + nums + [ 1 ] dp = [[ 0 ] * ( n + 2 ) for _ in range ( n + 2 )] for length in range ( 1 , n + 1 ): for i in range ( 1 , n - length + 2 ): j = i + length - 1 for k in range ( i , j + 1 ): dp [ i ][ j ] = max ( dp [ i ][ j ], dp [ i ][ k - 1 ] + dp [ k + 1 ] [ j ] + nums [ i - 1 ] * nums [ k ] * nums [ j + 1 ]) return dp [ 1 ][ n ]","title":"312. Burst Balloons $\\star\\star\\star$"},{"location":"python3/0301-0400/0311-0320/#313-super-ugly-number-starstar","text":"Time: $O(n\\log k)$ Space: $O(k)$ class Solution : def nthSuperUglyNumber ( self , n : int , primes : List [ int ]) -> int : k = len ( primes ) nums = [ 1 ] indices = [ 0 ] * k while len ( nums ) < n : nexts = [ 0 ] * k for i in range ( k ): nexts [ i ] = nums [ indices [ i ]] * primes [ i ] next = min ( nexts ) for i in range ( k ): if next == nexts [ i ]: indices [ i ] += 1 nums . append ( next ) return nums [ - 1 ]","title":"313. Super Ugly Number $\\star\\star$"},{"location":"python3/0301-0400/0311-0320/#314-binary-tree-vertical-order-traversal-starstar","text":"","title":"314. Binary Tree Vertical Order Traversal $\\star\\star$ \ud83d\udd12"},{"location":"python3/0301-0400/0311-0320/#315-count-of-smaller-numbers-after-self-starstarstar","text":"","title":"315. Count of Smaller Numbers After Self $\\star\\star\\star$"},{"location":"python3/0301-0400/0311-0320/#316-remove-duplicate-letters-starstarstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def removeDuplicateLetters ( self , s : str ) -> str : ans = [] count = collections . Counter ( s ) used = [ False ] * 26 for c in s : count [ c ] -= 1 if used [ ord ( c ) - ord ( 'a' )]: continue while ans and ans [ - 1 ] > c and count [ ans [ - 1 ]] > 0 : used [ ord ( ans [ - 1 ]) - ord ( 'a' )] = False ans . pop () ans . append ( c ) used [ ord ( ans [ - 1 ]) - ord ( 'a' )] = True return '' . join ( ans )","title":"316. Remove Duplicate Letters $\\star\\star\\star$"},{"location":"python3/0301-0400/0311-0320/#317-shortest-distance-from-all-buildings-starstarstar","text":"","title":"317. Shortest Distance from All Buildings $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/0301-0400/0311-0320/#318-maximum-product-of-word-lengths-starstar","text":"","title":"318. Maximum Product of Word Lengths $\\star\\star$"},{"location":"python3/0301-0400/0311-0320/#319-bulb-switcher-starstar","text":"Time: $O(1)$ Space: $O(1)$ class Solution : def bulbSwitch ( self , n : int ) -> int : return int ( sqrt ( n ))","title":"319. Bulb Switcher $\\star\\star$"},{"location":"python3/0301-0400/0311-0320/#320-generalized-abbreviation-starstar","text":"","title":"320. Generalized Abbreviation $\\star\\star$ \ud83d\udd12"},{"location":"python3/0301-0400/0321-0330/","text":"321. Create Maximum Number $\\star\\star\\star$ 322. Coin Change $\\star\\star$ Time: $O(nk)$, where n = len(coins) and k = amount Space: $O(k)$ class Solution : def coinChange ( self , coins : List [ int ], amount : int ) -> int : dp = [ 0 ] + [ amount + 1 ] * amount for i in range ( 1 , amount + 1 ): for coin in coins : if coin <= i : dp [ i ] = min ( dp [ i ], dp [ i - coin ] + 1 ) return dp [ - 1 ] if dp [ - 1 ] < amount + 1 else - 1 323. Number of Connected Components in an Undirected Graph $\\star\\star$ \ud83d\udd12 324. Wiggle Sort II $\\star\\star$ 325. Maximum Size Subarray Sum Equals k $\\star\\star$ \ud83d\udd12 326. Power of Three $\\star$ class Solution : def isPowerOfThree ( self , n : int ) -> bool : return n > 0 and 3 ** 19 % n == 0 327. Count of Range Sum $\\star\\star\\star$ 328. Odd Even Linked List $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def oddEvenList ( self , head : ListNode ) -> ListNode : oddHead = ListNode ( 0 ) evenHead = ListNode ( 0 ) odd = oddHead even = evenHead isOdd = True while head : if isOdd : odd . next = head odd = head else : even . next = head even = head head = head . next isOdd = not isOdd even . next = None odd . next = evenHead . next return oddHead . next 329. Longest Increasing Path in a Matrix $\\star\\star\\star$ Time: $O(mn)$ Space: $O(mn)$ class Solution : def longestIncreasingPath ( self , matrix : List [ List [ int ]]) -> int : def dfs ( i : int , j : int , maxi : int ) -> int : if not 0 <= i < len ( matrix ) or not 0 <= j < len ( matrix [ 0 ]) or matrix [ i ][ j ] <= maxi : return 0 if cached [ i ][ j ] != 0 : return cached [ i ][ j ] cached [ i ][ j ] = 1 + max ( dfs ( i + 1 , j , matrix [ i ][ j ]), dfs ( i - 1 , j , matrix [ i ][ j ]), dfs ( i , j + 1 , matrix [ i ][ j ]), dfs ( i , j - 1 , matrix [ i ][ j ])) return cached [ i ][ j ] if not matrix : return 0 ans = 0 cached = [[ 0 ] * len ( matrix [ 0 ]) for _ in range ( len ( matrix ))] for i in range ( len ( matrix )): for j in range ( len ( matrix [ 0 ])): ans = max ( ans , dfs ( i , j , float ( '-inf' ))) return ans 330. Patching Array $\\star\\star\\star$","title":"0321-0330"},{"location":"python3/0301-0400/0321-0330/#321-create-maximum-number-starstarstar","text":"","title":"321. Create Maximum Number $\\star\\star\\star$"},{"location":"python3/0301-0400/0321-0330/#322-coin-change-starstar","text":"Time: $O(nk)$, where n = len(coins) and k = amount Space: $O(k)$ class Solution : def coinChange ( self , coins : List [ int ], amount : int ) -> int : dp = [ 0 ] + [ amount + 1 ] * amount for i in range ( 1 , amount + 1 ): for coin in coins : if coin <= i : dp [ i ] = min ( dp [ i ], dp [ i - coin ] + 1 ) return dp [ - 1 ] if dp [ - 1 ] < amount + 1 else - 1","title":"322. Coin Change $\\star\\star$"},{"location":"python3/0301-0400/0321-0330/#323-number-of-connected-components-in-an-undirected-graph-starstar","text":"","title":"323. Number of Connected Components in an Undirected Graph $\\star\\star$ \ud83d\udd12"},{"location":"python3/0301-0400/0321-0330/#324-wiggle-sort-ii-starstar","text":"","title":"324. Wiggle Sort II $\\star\\star$"},{"location":"python3/0301-0400/0321-0330/#325-maximum-size-subarray-sum-equals-k-starstar","text":"","title":"325. Maximum Size Subarray Sum Equals k $\\star\\star$ \ud83d\udd12"},{"location":"python3/0301-0400/0321-0330/#326-power-of-three-star","text":"class Solution : def isPowerOfThree ( self , n : int ) -> bool : return n > 0 and 3 ** 19 % n == 0","title":"326. Power of Three $\\star$"},{"location":"python3/0301-0400/0321-0330/#327-count-of-range-sum-starstarstar","text":"","title":"327. Count of Range Sum $\\star\\star\\star$"},{"location":"python3/0301-0400/0321-0330/#328-odd-even-linked-list-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def oddEvenList ( self , head : ListNode ) -> ListNode : oddHead = ListNode ( 0 ) evenHead = ListNode ( 0 ) odd = oddHead even = evenHead isOdd = True while head : if isOdd : odd . next = head odd = head else : even . next = head even = head head = head . next isOdd = not isOdd even . next = None odd . next = evenHead . next return oddHead . next","title":"328. Odd Even Linked List $\\star\\star$"},{"location":"python3/0301-0400/0321-0330/#329-longest-increasing-path-in-a-matrix-starstarstar","text":"Time: $O(mn)$ Space: $O(mn)$ class Solution : def longestIncreasingPath ( self , matrix : List [ List [ int ]]) -> int : def dfs ( i : int , j : int , maxi : int ) -> int : if not 0 <= i < len ( matrix ) or not 0 <= j < len ( matrix [ 0 ]) or matrix [ i ][ j ] <= maxi : return 0 if cached [ i ][ j ] != 0 : return cached [ i ][ j ] cached [ i ][ j ] = 1 + max ( dfs ( i + 1 , j , matrix [ i ][ j ]), dfs ( i - 1 , j , matrix [ i ][ j ]), dfs ( i , j + 1 , matrix [ i ][ j ]), dfs ( i , j - 1 , matrix [ i ][ j ])) return cached [ i ][ j ] if not matrix : return 0 ans = 0 cached = [[ 0 ] * len ( matrix [ 0 ]) for _ in range ( len ( matrix ))] for i in range ( len ( matrix )): for j in range ( len ( matrix [ 0 ])): ans = max ( ans , dfs ( i , j , float ( '-inf' ))) return ans","title":"329. Longest Increasing Path in a Matrix $\\star\\star\\star$"},{"location":"python3/0301-0400/0321-0330/#330-patching-array-starstarstar","text":"","title":"330. Patching Array $\\star\\star\\star$"},{"location":"python3/0301-0400/0331-0340/","text":"331. Verify Preorder Serialization of a Binary Tree $\\star\\star$ 332. Reconstruct Itinerary $\\star\\star$ Time: $O(|E|\\log |E|)$ Space: $O(|E|)$ class Solution : def findItinerary ( self , tickets : List [ List [ str ]]) -> List [ str ]: def dfs ( airport : str ) -> None : while airport in graph and graph [ airport ]: dfs ( graph [ airport ] . pop ()) ans . append ( airport ) ans = [] graph = collections . defaultdict ( list ) for a , b in sorted ( tickets )[:: - 1 ]: graph [ a ] . append ( b ) dfs ( 'JFK' ) return ans [:: - 1 ] 333. Largest BST Subtree $\\star\\star$ \ud83d\udd12 334. Increasing Triplet Subsequence $\\star\\star$ 335. Self Crossing $\\star\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def isSelfCrossing ( self , x : List [ int ]) -> bool : if len ( x ) <= 3 : return False for i in range ( 3 , len ( x )): if x [ i - 2 ] <= x [ i ] and x [ i - 1 ] <= x [ i - 3 ]: return True if i >= 4 and x [ i - 1 ] == x [ i - 3 ] and x [ i - 2 ] <= x [ i ] + x [ i - 4 ]: return True if i >= 5 and x [ i - 4 ] <= x [ i - 2 ] and x [ i - 2 ] <= x [ i ] + x [ i - 4 ] and x [ i - 1 ] <= x [ i - 3 ] and x [ i - 3 ] <= x [ i - 1 ] + x [ i - 5 ]: return True return False 336. Palindrome Pairs $\\star\\star\\star$ Time: $O(nk^2)$, where n = len(words) and k = len(words[i]) Space: $O(nk)$ class Solution : def palindromePairs ( self , words : List [ str ]) -> List [ List [ int ]]: ans = [] dict = { word [:: - 1 ]: i for i , word in enumerate ( words )} for i , word in enumerate ( words ): if \"\" in dict and dict [ \"\" ] != i and word == word [:: - 1 ]: ans . append ([ i , dict [ \"\" ]]) for j in range ( 1 , len ( word ) + 1 ): l = word [: j ] r = word [ j :] if l in dict and dict [ l ] != i and r == r [:: - 1 ]: ans . append ([ i , dict [ l ]]) if r in dict and dict [ r ] != i and l == l [:: - 1 ]: ans . append ([ dict [ r ], i ]) return ans 337. House Robber III $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution : def rob ( self , root : TreeNode ) -> int : def robOrNot ( root : TreeNode ) -> tuple : if not root : return ( 0 , 0 ) robLeft , notRobLeft = robOrNot ( root . left ) robRight , notRobRight = robOrNot ( root . right ) return ( root . val + notRobLeft + notRobRight , max ( robLeft , notRobLeft ) + max ( robRight , notRobRight )) return max ( robOrNot ( root )) 338. Counting Bits $\\star\\star$ 339. Nested List Weight Sum $\\star$ \ud83d\udd12 340. Longest Substring with At Most K Distinct Characters $\\star\\star\\star$ \ud83d\udd12","title":"0331-0340"},{"location":"python3/0301-0400/0331-0340/#331-verify-preorder-serialization-of-a-binary-tree-starstar","text":"","title":"331. Verify Preorder Serialization of a Binary Tree $\\star\\star$"},{"location":"python3/0301-0400/0331-0340/#332-reconstruct-itinerary-starstar","text":"Time: $O(|E|\\log |E|)$ Space: $O(|E|)$ class Solution : def findItinerary ( self , tickets : List [ List [ str ]]) -> List [ str ]: def dfs ( airport : str ) -> None : while airport in graph and graph [ airport ]: dfs ( graph [ airport ] . pop ()) ans . append ( airport ) ans = [] graph = collections . defaultdict ( list ) for a , b in sorted ( tickets )[:: - 1 ]: graph [ a ] . append ( b ) dfs ( 'JFK' ) return ans [:: - 1 ]","title":"332. Reconstruct Itinerary $\\star\\star$"},{"location":"python3/0301-0400/0331-0340/#333-largest-bst-subtree-starstar","text":"","title":"333. Largest BST Subtree $\\star\\star$ \ud83d\udd12"},{"location":"python3/0301-0400/0331-0340/#334-increasing-triplet-subsequence-starstar","text":"","title":"334. Increasing Triplet Subsequence $\\star\\star$"},{"location":"python3/0301-0400/0331-0340/#335-self-crossing-starstarstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def isSelfCrossing ( self , x : List [ int ]) -> bool : if len ( x ) <= 3 : return False for i in range ( 3 , len ( x )): if x [ i - 2 ] <= x [ i ] and x [ i - 1 ] <= x [ i - 3 ]: return True if i >= 4 and x [ i - 1 ] == x [ i - 3 ] and x [ i - 2 ] <= x [ i ] + x [ i - 4 ]: return True if i >= 5 and x [ i - 4 ] <= x [ i - 2 ] and x [ i - 2 ] <= x [ i ] + x [ i - 4 ] and x [ i - 1 ] <= x [ i - 3 ] and x [ i - 3 ] <= x [ i - 1 ] + x [ i - 5 ]: return True return False","title":"335. Self Crossing $\\star\\star\\star$"},{"location":"python3/0301-0400/0331-0340/#336-palindrome-pairs-starstarstar","text":"Time: $O(nk^2)$, where n = len(words) and k = len(words[i]) Space: $O(nk)$ class Solution : def palindromePairs ( self , words : List [ str ]) -> List [ List [ int ]]: ans = [] dict = { word [:: - 1 ]: i for i , word in enumerate ( words )} for i , word in enumerate ( words ): if \"\" in dict and dict [ \"\" ] != i and word == word [:: - 1 ]: ans . append ([ i , dict [ \"\" ]]) for j in range ( 1 , len ( word ) + 1 ): l = word [: j ] r = word [ j :] if l in dict and dict [ l ] != i and r == r [:: - 1 ]: ans . append ([ i , dict [ l ]]) if r in dict and dict [ r ] != i and l == l [:: - 1 ]: ans . append ([ dict [ r ], i ]) return ans","title":"336. Palindrome Pairs $\\star\\star\\star$"},{"location":"python3/0301-0400/0331-0340/#337-house-robber-iii-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution : def rob ( self , root : TreeNode ) -> int : def robOrNot ( root : TreeNode ) -> tuple : if not root : return ( 0 , 0 ) robLeft , notRobLeft = robOrNot ( root . left ) robRight , notRobRight = robOrNot ( root . right ) return ( root . val + notRobLeft + notRobRight , max ( robLeft , notRobLeft ) + max ( robRight , notRobRight )) return max ( robOrNot ( root ))","title":"337. House Robber III $\\star\\star$"},{"location":"python3/0301-0400/0331-0340/#338-counting-bits-starstar","text":"","title":"338. Counting Bits $\\star\\star$"},{"location":"python3/0301-0400/0331-0340/#339-nested-list-weight-sum-star","text":"","title":"339. Nested List Weight Sum $\\star$ \ud83d\udd12"},{"location":"python3/0301-0400/0331-0340/#340-longest-substring-with-at-most-k-distinct-characters-starstarstar","text":"","title":"340. Longest Substring with At Most K Distinct Characters $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/0301-0400/0341-0350/","text":"341. Flatten Nested List Iterator $\\star\\star$ 342. Power of Four $\\star$ 343. Integer Break $\\star\\star$ Time: $O(n / 3)$ Space: $O(1)$ class Solution : def integerBreak ( self , n : int ) -> int : if n == 2 : return 1 if n == 3 : return 2 ans = 1 while n > 4 : n -= 3 ans *= 3 ans *= n return ans 344. Reverse String $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def reverseString ( self , s : List [ str ]) -> None : l = 0 r = len ( s ) - 1 while l < r : s [ l ], s [ r ] = s [ r ], s [ l ] l += 1 r -= 1 345. Reverse Vowels of a String $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def reverseVowels ( self , s : str ) -> str : charList = list ( s ) vowels = { 'a' , 'e' , 'i' , 'o' , 'u' , 'A' , 'E' , 'I' , 'O' , 'U' } l = 0 r = len ( s ) - 1 while l < r : while l < r and charList [ l ] not in vowels : l += 1 while l < r and charList [ r ] not in vowels : r -= 1 charList [ l ], charList [ r ] = charList [ r ], charList [ l ] l += 1 r -= 1 return '' . join ( charList ) 346. Moving Average from Data Stream $\\star$ \ud83d\udd12 347. Top K Frequent Elements $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution : def topKFrequent ( self , nums : List [ int ], k : int ) -> List [ int ]: ans = [] bucket = [[] for _ in range ( len ( nums ) + 1 )] for num , freq in collections . Counter ( nums ) . items (): bucket [ freq ] . append ( num ) for b in bucket [:: - 1 ]: ans += b if len ( ans ) == k : return ans 348. Design Tic-Tac-Toe $\\star\\star$ \ud83d\udd12 349. Intersection of Two Arrays $\\star$ Time: $O(n)$ Space: $O(n)$ class Solution : def intersection ( self , nums1 : List [ int ], nums2 : List [ int ]) -> List [ int ]: ans = [] nums1 = set ( nums1 ) for num in nums2 : if num in nums1 : ans . append ( num ) nums1 . remove ( num ) return ans 350. Intersection of Two Arrays II $\\star$ Time: $O(n)$ Space: $O(n)$ class Solution : def intersect ( self , nums1 : List [ int ], nums2 : List [ int ]) -> List [ int ]: ans = [] count = collections . Counter ( nums1 ) for num in nums2 : if count [ num ] > 0 : ans . append ( num ) count [ num ] -= 1 return ans","title":"0341-0350"},{"location":"python3/0301-0400/0341-0350/#341-flatten-nested-list-iterator-starstar","text":"","title":"341. Flatten Nested List Iterator $\\star\\star$"},{"location":"python3/0301-0400/0341-0350/#342-power-of-four-star","text":"","title":"342. Power of Four $\\star$"},{"location":"python3/0301-0400/0341-0350/#343-integer-break-starstar","text":"Time: $O(n / 3)$ Space: $O(1)$ class Solution : def integerBreak ( self , n : int ) -> int : if n == 2 : return 1 if n == 3 : return 2 ans = 1 while n > 4 : n -= 3 ans *= 3 ans *= n return ans","title":"343. Integer Break $\\star\\star$"},{"location":"python3/0301-0400/0341-0350/#344-reverse-string-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def reverseString ( self , s : List [ str ]) -> None : l = 0 r = len ( s ) - 1 while l < r : s [ l ], s [ r ] = s [ r ], s [ l ] l += 1 r -= 1","title":"344. Reverse String $\\star$"},{"location":"python3/0301-0400/0341-0350/#345-reverse-vowels-of-a-string-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def reverseVowels ( self , s : str ) -> str : charList = list ( s ) vowels = { 'a' , 'e' , 'i' , 'o' , 'u' , 'A' , 'E' , 'I' , 'O' , 'U' } l = 0 r = len ( s ) - 1 while l < r : while l < r and charList [ l ] not in vowels : l += 1 while l < r and charList [ r ] not in vowels : r -= 1 charList [ l ], charList [ r ] = charList [ r ], charList [ l ] l += 1 r -= 1 return '' . join ( charList )","title":"345. Reverse Vowels of a String $\\star$"},{"location":"python3/0301-0400/0341-0350/#346-moving-average-from-data-stream-star","text":"","title":"346. Moving Average from Data Stream $\\star$ \ud83d\udd12"},{"location":"python3/0301-0400/0341-0350/#347-top-k-frequent-elements-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution : def topKFrequent ( self , nums : List [ int ], k : int ) -> List [ int ]: ans = [] bucket = [[] for _ in range ( len ( nums ) + 1 )] for num , freq in collections . Counter ( nums ) . items (): bucket [ freq ] . append ( num ) for b in bucket [:: - 1 ]: ans += b if len ( ans ) == k : return ans","title":"347. Top K Frequent Elements $\\star\\star$"},{"location":"python3/0301-0400/0341-0350/#348-design-tic-tac-toe-starstar","text":"","title":"348. Design Tic-Tac-Toe $\\star\\star$ \ud83d\udd12"},{"location":"python3/0301-0400/0341-0350/#349-intersection-of-two-arrays-star","text":"Time: $O(n)$ Space: $O(n)$ class Solution : def intersection ( self , nums1 : List [ int ], nums2 : List [ int ]) -> List [ int ]: ans = [] nums1 = set ( nums1 ) for num in nums2 : if num in nums1 : ans . append ( num ) nums1 . remove ( num ) return ans","title":"349. Intersection of Two Arrays $\\star$"},{"location":"python3/0301-0400/0341-0350/#350-intersection-of-two-arrays-ii-star","text":"Time: $O(n)$ Space: $O(n)$ class Solution : def intersect ( self , nums1 : List [ int ], nums2 : List [ int ]) -> List [ int ]: ans = [] count = collections . Counter ( nums1 ) for num in nums2 : if count [ num ] > 0 : ans . append ( num ) count [ num ] -= 1 return ans","title":"350. Intersection of Two Arrays II $\\star$"},{"location":"python3/0301-0400/0351-0360/","text":"351. Android Unlock Patterns $\\star\\star$ \ud83d\udd12 352. Data Stream as Disjoint Intervals $\\star\\star\\star$ 353. Design Snake Game $\\star\\star$ \ud83d\udd12 354. Russian Doll Envelopes $\\star\\star\\star$ 355. Design Twitter $\\star\\star$ Time: $O(n + k\\log n)$, where n = len(tweets) and k = min(10, len(tweets)) Space: $O(n)$ class Twitter : def __init__ ( self ): self . timer = itertools . count ( step =- 1 ) self . tweets = collections . defaultdict ( collections . deque ) self . followees = collections . defaultdict ( set ) def postTweet ( self , userId : int , tweetId : int ) -> None : self . tweets [ userId ] . appendleft (( next ( self . timer ), tweetId )) if len ( self . tweets [ userId ]) > 10 : self . tweets [ userId ] . pop () def getNewsFeed ( self , userId : int ) -> List [ int ]: tweets = list ( heapq . merge ( * ( self . tweets [ followee ] for followee in self . followees [ userId ] | { userId }))) return [ tweetId for _ , tweetId in tweets [: 10 ]] def follow ( self , followerId : int , followeeId : int ) -> None : self . followees [ followerId ] . add ( followeeId ) def unfollow ( self , followerId : int , followeeId : int ) -> None : self . followees [ followerId ] . discard ( followeeId ) 356. Line Reflection $\\star\\star$ \ud83d\udd12 357. Count Numbers with Unique Digits $\\star\\star$ Time: $O(9)$ Space: $O(1)$ class Solution : def countNumbersWithUniqueDigits ( self , n : int ) -> int : if n == 0 : return 1 ans = 10 uniqueDigits = 9 availableNum = 9 while n > 1 and availableNum > 0 : uniqueDigits *= availableNum ans += uniqueDigits n -= 1 availableNum -= 1 return ans 358. Rearrange String k Distance Apart $\\star\\star\\star$ \ud83d\udd12 359. Logger Rate Limiter $\\star$ \ud83d\udd12 360. Sort Transformed Array $\\star\\star$ \ud83d\udd12","title":"0351-0360"},{"location":"python3/0301-0400/0351-0360/#351-android-unlock-patterns-starstar","text":"","title":"351. Android Unlock Patterns $\\star\\star$ \ud83d\udd12"},{"location":"python3/0301-0400/0351-0360/#352-data-stream-as-disjoint-intervals-starstarstar","text":"","title":"352. Data Stream as Disjoint Intervals $\\star\\star\\star$"},{"location":"python3/0301-0400/0351-0360/#353-design-snake-game-starstar","text":"","title":"353. Design Snake Game $\\star\\star$ \ud83d\udd12"},{"location":"python3/0301-0400/0351-0360/#354-russian-doll-envelopes-starstarstar","text":"","title":"354. Russian Doll Envelopes $\\star\\star\\star$"},{"location":"python3/0301-0400/0351-0360/#355-design-twitter-starstar","text":"Time: $O(n + k\\log n)$, where n = len(tweets) and k = min(10, len(tweets)) Space: $O(n)$ class Twitter : def __init__ ( self ): self . timer = itertools . count ( step =- 1 ) self . tweets = collections . defaultdict ( collections . deque ) self . followees = collections . defaultdict ( set ) def postTweet ( self , userId : int , tweetId : int ) -> None : self . tweets [ userId ] . appendleft (( next ( self . timer ), tweetId )) if len ( self . tweets [ userId ]) > 10 : self . tweets [ userId ] . pop () def getNewsFeed ( self , userId : int ) -> List [ int ]: tweets = list ( heapq . merge ( * ( self . tweets [ followee ] for followee in self . followees [ userId ] | { userId }))) return [ tweetId for _ , tweetId in tweets [: 10 ]] def follow ( self , followerId : int , followeeId : int ) -> None : self . followees [ followerId ] . add ( followeeId ) def unfollow ( self , followerId : int , followeeId : int ) -> None : self . followees [ followerId ] . discard ( followeeId )","title":"355. Design Twitter $\\star\\star$"},{"location":"python3/0301-0400/0351-0360/#356-line-reflection-starstar","text":"","title":"356. Line Reflection $\\star\\star$ \ud83d\udd12"},{"location":"python3/0301-0400/0351-0360/#357-count-numbers-with-unique-digits-starstar","text":"Time: $O(9)$ Space: $O(1)$ class Solution : def countNumbersWithUniqueDigits ( self , n : int ) -> int : if n == 0 : return 1 ans = 10 uniqueDigits = 9 availableNum = 9 while n > 1 and availableNum > 0 : uniqueDigits *= availableNum ans += uniqueDigits n -= 1 availableNum -= 1 return ans","title":"357. Count Numbers with Unique Digits $\\star\\star$"},{"location":"python3/0301-0400/0351-0360/#358-rearrange-string-k-distance-apart-starstarstar","text":"","title":"358. Rearrange String k Distance Apart $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/0301-0400/0351-0360/#359-logger-rate-limiter-star","text":"","title":"359. Logger Rate Limiter $\\star$ \ud83d\udd12"},{"location":"python3/0301-0400/0351-0360/#360-sort-transformed-array-starstar","text":"","title":"360. Sort Transformed Array $\\star\\star$ \ud83d\udd12"},{"location":"python3/0301-0400/0361-0370/","text":"361. Bomb Enemy $\\star\\star$ \ud83d\udd12 362. Design Hit Counter $\\star\\star$ \ud83d\udd12 363. Max Sum of Rectangle No Larger Than K $\\star\\star\\star$ 364. Nested List Weight Sum II $\\star\\star$ \ud83d\udd12 365. Water and Jug Problem $\\star\\star$ Time: $O(1)$ Space: $O(1)$ from fractions import gcd class Solution : def canMeasureWater ( self , x : int , y : int , z : int ) -> bool : return z == 0 or x + y >= z and z % gcd ( x , y ) == 0 366. Find Leaves of Binary Tree $\\star\\star$ \ud83d\udd12 367. Valid Perfect Square $\\star$ Time: $O(\\log num)$ Space: $O(1)$ class Solution : def isPerfectSquare ( self , num : int ) -> bool : l = 1 r = num + 1 while l < r : m = ( l + r ) // 2 if m > num / m : r = m else : l = m + 1 return ( l - 1 ) * ( l - 1 ) == num 368. Largest Divisible Subset $\\star\\star$ Time: $O(n^2)$ Space: $O(n)$ class Solution : def largestDivisibleSubset ( self , nums : List [ int ]) -> List [ int ]: n = len ( nums ) ans = [] count = [ 1 ] * n prevIndex = [ - 1 ] * n maxCount = 0 index = - 1 nums . sort () for i , num in enumerate ( nums ): for j in range ( i )[:: - 1 ]: if num % nums [ j ] == 0 and count [ i ] < count [ j ] + 1 : count [ i ] = count [ j ] + 1 prevIndex [ i ] = j if count [ i ] > maxCount : maxCount = count [ i ] index = i while index != - 1 : ans . append ( nums [ index ]) index = prevIndex [ index ] return ans 369. Plus One Linked List $\\star\\star$ \ud83d\udd12 370. Range Addition $\\star\\star$ \ud83d\udd12","title":"0361-0370"},{"location":"python3/0301-0400/0361-0370/#361-bomb-enemy-starstar","text":"","title":"361. Bomb Enemy $\\star\\star$ \ud83d\udd12"},{"location":"python3/0301-0400/0361-0370/#362-design-hit-counter-starstar","text":"","title":"362. Design Hit Counter $\\star\\star$ \ud83d\udd12"},{"location":"python3/0301-0400/0361-0370/#363-max-sum-of-rectangle-no-larger-than-k-starstarstar","text":"","title":"363. Max Sum of Rectangle No Larger Than K $\\star\\star\\star$"},{"location":"python3/0301-0400/0361-0370/#364-nested-list-weight-sum-ii-starstar","text":"","title":"364. Nested List Weight Sum II $\\star\\star$ \ud83d\udd12"},{"location":"python3/0301-0400/0361-0370/#365-water-and-jug-problem-starstar","text":"Time: $O(1)$ Space: $O(1)$ from fractions import gcd class Solution : def canMeasureWater ( self , x : int , y : int , z : int ) -> bool : return z == 0 or x + y >= z and z % gcd ( x , y ) == 0","title":"365. Water and Jug Problem $\\star\\star$"},{"location":"python3/0301-0400/0361-0370/#366-find-leaves-of-binary-tree-starstar","text":"","title":"366. Find Leaves of Binary Tree $\\star\\star$ \ud83d\udd12"},{"location":"python3/0301-0400/0361-0370/#367-valid-perfect-square-star","text":"Time: $O(\\log num)$ Space: $O(1)$ class Solution : def isPerfectSquare ( self , num : int ) -> bool : l = 1 r = num + 1 while l < r : m = ( l + r ) // 2 if m > num / m : r = m else : l = m + 1 return ( l - 1 ) * ( l - 1 ) == num","title":"367. Valid Perfect Square $\\star$"},{"location":"python3/0301-0400/0361-0370/#368-largest-divisible-subset-starstar","text":"Time: $O(n^2)$ Space: $O(n)$ class Solution : def largestDivisibleSubset ( self , nums : List [ int ]) -> List [ int ]: n = len ( nums ) ans = [] count = [ 1 ] * n prevIndex = [ - 1 ] * n maxCount = 0 index = - 1 nums . sort () for i , num in enumerate ( nums ): for j in range ( i )[:: - 1 ]: if num % nums [ j ] == 0 and count [ i ] < count [ j ] + 1 : count [ i ] = count [ j ] + 1 prevIndex [ i ] = j if count [ i ] > maxCount : maxCount = count [ i ] index = i while index != - 1 : ans . append ( nums [ index ]) index = prevIndex [ index ] return ans","title":"368. Largest Divisible Subset $\\star\\star$"},{"location":"python3/0301-0400/0361-0370/#369-plus-one-linked-list-starstar","text":"","title":"369. Plus One Linked List $\\star\\star$ \ud83d\udd12"},{"location":"python3/0301-0400/0361-0370/#370-range-addition-starstar","text":"","title":"370. Range Addition $\\star\\star$ \ud83d\udd12"},{"location":"python3/0301-0400/0371-0380/","text":"371. Sum of Two Integers $\\star$ 372. Super Pow $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def superPow ( self , a : int , b : List [ int ]) -> int : def powMod ( x : int , y : int ) -> int : pow = 1 for _ in range ( y ): pow = ( pow * x ) % k return pow k = 1337 ans = 1 for i in b : ans = powMod ( ans , 10 ) * powMod ( a , i ) % k return ans 373. Find K Pairs with Smallest Sums $\\star\\star$ 374. Guess Number Higher or Lower $\\star$ 375. Guess Number Higher or Lower II $\\star\\star$ 376. Wiggle Subsequence $\\star\\star$ 377. Combination Sum IV $\\star\\star$ Time: $O(nk)$, where n = len(coins) and k = target Space: $O(k)$ class Solution : def combinationSum4 ( self , nums : List [ int ], target : int ) -> int : m = [ - 1 ] * ( target + 1 ) m [ 0 ] = 1 return self . dp ( nums , target , m ) def dp ( self , nums : List [ int ], target : int , m : List [ int ]) -> int : if target < 0 : return 0 if m [ target ] != - 1 : return m [ target ] ans = 0 for num in nums : ans += self . dp ( nums , target - num , m ) m [ target ] = ans return ans 378. Kth Smallest Element in a Sorted Matrix $\\star\\star$ class Solution : def kthSmallest ( self , matrix : List [ List [ int ]], k : int ) -> int : l = matrix [ 0 ][ 0 ] r = matrix [ - 1 ][ - 1 ] while l < r : m = ( l + r ) >> 1 count = 0 for row in matrix : count += bisect . bisect ( row , m ) if count >= k : r = m else : l = m + 1 return l 379. Design Phone Directory $\\star\\star$ \ud83d\udd12 380. Insert Delete GetRandom O(1) $\\star\\star$ class RandomizedSet : def __init__ ( self ): self . vals = [] self . dict = collections . defaultdict ( int ) def insert ( self , val : int ) -> bool : if val in self . dict : return False self . dict [ val ] = len ( self . vals ) self . vals . append ( val ) return True def remove ( self , val : int ) -> bool : if val not in self . dict : return False index = self . dict [ val ] self . dict [ self . vals [ - 1 ]] = index del self . dict [ val ] self . vals [ index ] = self . vals [ - 1 ] self . vals . pop () return True def getRandom ( self ) -> int : index = random . randint ( 0 , len ( self . vals ) - 1 ) return self . vals [ index ]","title":"0371-0380"},{"location":"python3/0301-0400/0371-0380/#371-sum-of-two-integers-star","text":"","title":"371. Sum of Two Integers $\\star$"},{"location":"python3/0301-0400/0371-0380/#372-super-pow-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def superPow ( self , a : int , b : List [ int ]) -> int : def powMod ( x : int , y : int ) -> int : pow = 1 for _ in range ( y ): pow = ( pow * x ) % k return pow k = 1337 ans = 1 for i in b : ans = powMod ( ans , 10 ) * powMod ( a , i ) % k return ans","title":"372. Super Pow $\\star\\star$"},{"location":"python3/0301-0400/0371-0380/#373-find-k-pairs-with-smallest-sums-starstar","text":"","title":"373. Find K Pairs with Smallest Sums $\\star\\star$"},{"location":"python3/0301-0400/0371-0380/#374-guess-number-higher-or-lower-star","text":"","title":"374. Guess Number Higher or Lower $\\star$"},{"location":"python3/0301-0400/0371-0380/#375-guess-number-higher-or-lower-ii-starstar","text":"","title":"375. Guess Number Higher or Lower II $\\star\\star$"},{"location":"python3/0301-0400/0371-0380/#376-wiggle-subsequence-starstar","text":"","title":"376. Wiggle Subsequence $\\star\\star$"},{"location":"python3/0301-0400/0371-0380/#377-combination-sum-iv-starstar","text":"Time: $O(nk)$, where n = len(coins) and k = target Space: $O(k)$ class Solution : def combinationSum4 ( self , nums : List [ int ], target : int ) -> int : m = [ - 1 ] * ( target + 1 ) m [ 0 ] = 1 return self . dp ( nums , target , m ) def dp ( self , nums : List [ int ], target : int , m : List [ int ]) -> int : if target < 0 : return 0 if m [ target ] != - 1 : return m [ target ] ans = 0 for num in nums : ans += self . dp ( nums , target - num , m ) m [ target ] = ans return ans","title":"377. Combination Sum IV $\\star\\star$"},{"location":"python3/0301-0400/0371-0380/#378-kth-smallest-element-in-a-sorted-matrix-starstar","text":"class Solution : def kthSmallest ( self , matrix : List [ List [ int ]], k : int ) -> int : l = matrix [ 0 ][ 0 ] r = matrix [ - 1 ][ - 1 ] while l < r : m = ( l + r ) >> 1 count = 0 for row in matrix : count += bisect . bisect ( row , m ) if count >= k : r = m else : l = m + 1 return l","title":"378. Kth Smallest Element in a Sorted Matrix $\\star\\star$"},{"location":"python3/0301-0400/0371-0380/#379-design-phone-directory-starstar","text":"","title":"379. Design Phone Directory $\\star\\star$ \ud83d\udd12"},{"location":"python3/0301-0400/0371-0380/#380-insert-delete-getrandom-o1-starstar","text":"class RandomizedSet : def __init__ ( self ): self . vals = [] self . dict = collections . defaultdict ( int ) def insert ( self , val : int ) -> bool : if val in self . dict : return False self . dict [ val ] = len ( self . vals ) self . vals . append ( val ) return True def remove ( self , val : int ) -> bool : if val not in self . dict : return False index = self . dict [ val ] self . dict [ self . vals [ - 1 ]] = index del self . dict [ val ] self . vals [ index ] = self . vals [ - 1 ] self . vals . pop () return True def getRandom ( self ) -> int : index = random . randint ( 0 , len ( self . vals ) - 1 ) return self . vals [ index ]","title":"380. Insert Delete GetRandom O(1) $\\star\\star$"},{"location":"python3/0301-0400/0381-0390/","text":"381. Insert Delete GetRandom O(1) - Duplicates allowed $\\star\\star\\star$ class RandomizedCollection : def __init__ ( self ): self . vals = [] self . dict = collections . defaultdict ( list ) def insert ( self , val : int ) -> bool : self . dict [ val ] . append ( len ( self . vals )) self . vals . append ([ val , len ( self . dict [ val ]) - 1 ]) return len ( self . dict [ val ]) == 1 def remove ( self , val : int ) -> bool : if val not in self . dict or self . dict [ val ] == []: return False index = self . dict [ val ][ - 1 ] self . dict [ self . vals [ - 1 ][ 0 ]][ self . vals [ - 1 ][ 1 ]] = index self . dict [ val ] . pop () self . vals [ index ] = self . vals [ - 1 ] self . vals . pop () return True def getRandom ( self ) -> int : index = random . randint ( 0 , len ( self . vals ) - 1 ) return self . vals [ index ][ 0 ] 382. Linked List Random Node $\\star\\star$ 383. Ransom Note $\\star$ Time: $O(n + m)$, where n = ransomNote and m = magazine Space: $O(26)$ class Solution : def canConstruct ( self , ransomNote : str , magazine : str ) -> bool : count1 = collections . Counter ( ransomNote ) count2 = collections . Counter ( magazine ) return all ( count1 [ c ] <= count2 [ c ] for c in string . ascii_lowercase ) 384. Shuffle an Array $\\star\\star$ 385. Mini Parser $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution : def deserialize ( self , s : str ) -> NestedInteger : if s [ 0 ] != '[' : return NestedInteger ( int ( s )) stack = [] for i , c in enumerate ( s ): if c == '[' : stack . append ( NestedInteger ()) start = i + 1 elif c == ',' : if i > start : num = int ( s [ start : i ]) stack [ - 1 ] . add ( NestedInteger ( num )) start = i + 1 elif c == ']' : popped = stack . pop () if i > start : num = int ( s [ start : i ]) popped . add ( NestedInteger ( num )) if stack : stack [ - 1 ] . add ( popped ) else : return popped start = i + 1 386. Lexicographical Numbers $\\star\\star$ 387. First Unique Character in a String $\\star$ Time: $O(n)$ Space: $O(26)$ class Solution : def firstUniqChar ( self , s : str ) -> int : count = collections . Counter ( s ) for i , c in enumerate ( s ): if count [ c ] == 1 : return i return - 1 388. Longest Absolute File Path $\\star\\star$ 389. Find the Difference $\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def findTheDifference ( self , s : str , t : str ) -> str : count = collections . Counter ( s ) for i , c in enumerate ( t ): count [ c ] -= 1 if count [ c ] == - 1 : return c 390. Elimination Game $\\star\\star$","title":"0381-0390"},{"location":"python3/0301-0400/0381-0390/#381-insert-delete-getrandom-o1-duplicates-allowed-starstarstar","text":"class RandomizedCollection : def __init__ ( self ): self . vals = [] self . dict = collections . defaultdict ( list ) def insert ( self , val : int ) -> bool : self . dict [ val ] . append ( len ( self . vals )) self . vals . append ([ val , len ( self . dict [ val ]) - 1 ]) return len ( self . dict [ val ]) == 1 def remove ( self , val : int ) -> bool : if val not in self . dict or self . dict [ val ] == []: return False index = self . dict [ val ][ - 1 ] self . dict [ self . vals [ - 1 ][ 0 ]][ self . vals [ - 1 ][ 1 ]] = index self . dict [ val ] . pop () self . vals [ index ] = self . vals [ - 1 ] self . vals . pop () return True def getRandom ( self ) -> int : index = random . randint ( 0 , len ( self . vals ) - 1 ) return self . vals [ index ][ 0 ]","title":"381. Insert Delete GetRandom O(1) - Duplicates allowed $\\star\\star\\star$"},{"location":"python3/0301-0400/0381-0390/#382-linked-list-random-node-starstar","text":"","title":"382. Linked List Random Node $\\star\\star$"},{"location":"python3/0301-0400/0381-0390/#383-ransom-note-star","text":"Time: $O(n + m)$, where n = ransomNote and m = magazine Space: $O(26)$ class Solution : def canConstruct ( self , ransomNote : str , magazine : str ) -> bool : count1 = collections . Counter ( ransomNote ) count2 = collections . Counter ( magazine ) return all ( count1 [ c ] <= count2 [ c ] for c in string . ascii_lowercase )","title":"383. Ransom Note $\\star$"},{"location":"python3/0301-0400/0381-0390/#384-shuffle-an-array-starstar","text":"","title":"384. Shuffle an Array $\\star\\star$"},{"location":"python3/0301-0400/0381-0390/#385-mini-parser-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution : def deserialize ( self , s : str ) -> NestedInteger : if s [ 0 ] != '[' : return NestedInteger ( int ( s )) stack = [] for i , c in enumerate ( s ): if c == '[' : stack . append ( NestedInteger ()) start = i + 1 elif c == ',' : if i > start : num = int ( s [ start : i ]) stack [ - 1 ] . add ( NestedInteger ( num )) start = i + 1 elif c == ']' : popped = stack . pop () if i > start : num = int ( s [ start : i ]) popped . add ( NestedInteger ( num )) if stack : stack [ - 1 ] . add ( popped ) else : return popped start = i + 1","title":"385. Mini Parser $\\star\\star$"},{"location":"python3/0301-0400/0381-0390/#386-lexicographical-numbers-starstar","text":"","title":"386. Lexicographical Numbers $\\star\\star$"},{"location":"python3/0301-0400/0381-0390/#387-first-unique-character-in-a-string-star","text":"Time: $O(n)$ Space: $O(26)$ class Solution : def firstUniqChar ( self , s : str ) -> int : count = collections . Counter ( s ) for i , c in enumerate ( s ): if count [ c ] == 1 : return i return - 1","title":"387. First Unique Character in a String $\\star$"},{"location":"python3/0301-0400/0381-0390/#388-longest-absolute-file-path-starstar","text":"","title":"388. Longest Absolute File Path $\\star\\star$"},{"location":"python3/0301-0400/0381-0390/#389-find-the-difference-star","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def findTheDifference ( self , s : str , t : str ) -> str : count = collections . Counter ( s ) for i , c in enumerate ( t ): count [ c ] -= 1 if count [ c ] == - 1 : return c","title":"389. Find the Difference $\\star$"},{"location":"python3/0301-0400/0381-0390/#390-elimination-game-starstar","text":"","title":"390. Elimination Game $\\star\\star$"},{"location":"python3/0301-0400/0391-0400/","text":"391. Perfect Rectangle $\\star\\star\\star$ 392. Is Subsequence $\\star$ 393. UTF-8 Validation $\\star\\star$ 394. Decode String $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution : def decodeString ( self , s : str ) -> str : currNum = 0 currStr = '' stack = [] for c in s : if c . isdigit (): currNum = currNum * 10 + int ( c ) elif c == '[' : stack . append ( currStr ) stack . append ( currNum ) currStr = '' currNum = 0 elif c == ']' : num = stack . pop () prevStr = stack . pop () currStr = prevStr + num * currStr else : currStr += c return currStr 395. Longest Substring with At Least K Repeating Characters $\\star\\star$ 396. Rotate Function $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def maxRotateFunction ( self , A : List [ int ]) -> int : f = sum ( i * a for i , a in enumerate ( A )) ans = f summ = sum ( A ) for a in reversed ( A ): f += summ - len ( A ) * a ans = max ( ans , f ) return ans 397. Integer Replacement $\\star\\star$ Time: $O(\\log n)$ Space: $O(1)$ class Solution : def integerReplacement ( self , n : int ) -> int : ans = 0 while n > 1 : if ( n & 1 ) == 0 : n >>= 1 elif n == 3 or (( n >> 1 ) & 1 ) == 0 : n -= 1 else : n += 1 ans += 1 return ans 398. Random Pick Index $\\star\\star$ 399. Evaluate Division $\\star\\star$ 400. Nth Digit $\\star\\star$ class Solution : def findNthDigit ( self , n : int ) -> int : def getDigit ( num : int , pos : int , digitSize : int ): if pos == 0 : return num % 10 for _ in range ( digitSize - pos ): num //= 10 return num % 10 digitSize = 1 startNum = 1 count = 9 while digitSize * count < n : n -= digitSize * count digitSize += 1 startNum *= 10 count *= 10 targetNum = startNum + ( n - 1 ) // digitSize pos = n % digitSize return getDigit ( targetNum , pos , digitSize )","title":"0391-0300"},{"location":"python3/0301-0400/0391-0400/#391-perfect-rectangle-starstarstar","text":"","title":"391. Perfect Rectangle $\\star\\star\\star$"},{"location":"python3/0301-0400/0391-0400/#392-is-subsequence-star","text":"","title":"392. Is Subsequence $\\star$"},{"location":"python3/0301-0400/0391-0400/#393-utf-8-validation-starstar","text":"","title":"393. UTF-8 Validation $\\star\\star$"},{"location":"python3/0301-0400/0391-0400/#394-decode-string-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution : def decodeString ( self , s : str ) -> str : currNum = 0 currStr = '' stack = [] for c in s : if c . isdigit (): currNum = currNum * 10 + int ( c ) elif c == '[' : stack . append ( currStr ) stack . append ( currNum ) currStr = '' currNum = 0 elif c == ']' : num = stack . pop () prevStr = stack . pop () currStr = prevStr + num * currStr else : currStr += c return currStr","title":"394. Decode String $\\star\\star$"},{"location":"python3/0301-0400/0391-0400/#395-longest-substring-with-at-least-k-repeating-characters-starstar","text":"","title":"395. Longest Substring with At Least K Repeating Characters $\\star\\star$"},{"location":"python3/0301-0400/0391-0400/#396-rotate-function-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def maxRotateFunction ( self , A : List [ int ]) -> int : f = sum ( i * a for i , a in enumerate ( A )) ans = f summ = sum ( A ) for a in reversed ( A ): f += summ - len ( A ) * a ans = max ( ans , f ) return ans","title":"396. Rotate Function $\\star\\star$"},{"location":"python3/0301-0400/0391-0400/#397-integer-replacement-starstar","text":"Time: $O(\\log n)$ Space: $O(1)$ class Solution : def integerReplacement ( self , n : int ) -> int : ans = 0 while n > 1 : if ( n & 1 ) == 0 : n >>= 1 elif n == 3 or (( n >> 1 ) & 1 ) == 0 : n -= 1 else : n += 1 ans += 1 return ans","title":"397. Integer Replacement $\\star\\star$"},{"location":"python3/0301-0400/0391-0400/#398-random-pick-index-starstar","text":"","title":"398. Random Pick Index $\\star\\star$"},{"location":"python3/0301-0400/0391-0400/#399-evaluate-division-starstar","text":"","title":"399. Evaluate Division $\\star\\star$"},{"location":"python3/0301-0400/0391-0400/#400-nth-digit-starstar","text":"class Solution : def findNthDigit ( self , n : int ) -> int : def getDigit ( num : int , pos : int , digitSize : int ): if pos == 0 : return num % 10 for _ in range ( digitSize - pos ): num //= 10 return num % 10 digitSize = 1 startNum = 1 count = 9 while digitSize * count < n : n -= digitSize * count digitSize += 1 startNum *= 10 count *= 10 targetNum = startNum + ( n - 1 ) // digitSize pos = n % digitSize return getDigit ( targetNum , pos , digitSize )","title":"400. Nth Digit $\\star\\star$"},{"location":"python3/0401-0500/0401-0410/","text":"401. Binary Watch $\\star$ 402. Remove K Digits $\\star\\star$ 403. Frog Jump $\\star\\star\\star$ 404. Sum of Left Leaves $\\star$ 405. Convert a Number to Hexadecimal $\\star$ 406. Queue Reconstruction by Height $\\star\\star$ 407. Trapping Rain Water II $\\star\\star\\star$ 408. Valid Word Abbreviation $\\star$ \ud83d\udd12 409. Longest Palindrome $\\star$ class Solution : def longestPalindrome ( self , s : str ) -> int : ans = 0 count = collections . Counter ( s ) for c in count . values (): ans += c if c % 2 == 0 else c - 1 hasOddCount = any ( c % 2 == 1 for c in count . values ()) return ans + hasOddCount 410. Split Array Largest Sum $\\star\\star\\star$","title":"0401-0410"},{"location":"python3/0401-0500/0401-0410/#401-binary-watch-star","text":"","title":"401. Binary Watch $\\star$"},{"location":"python3/0401-0500/0401-0410/#402-remove-k-digits-starstar","text":"","title":"402. Remove K Digits $\\star\\star$"},{"location":"python3/0401-0500/0401-0410/#403-frog-jump-starstarstar","text":"","title":"403. Frog Jump $\\star\\star\\star$"},{"location":"python3/0401-0500/0401-0410/#404-sum-of-left-leaves-star","text":"","title":"404. Sum of Left Leaves $\\star$"},{"location":"python3/0401-0500/0401-0410/#405-convert-a-number-to-hexadecimal-star","text":"","title":"405. Convert a Number to Hexadecimal $\\star$"},{"location":"python3/0401-0500/0401-0410/#406-queue-reconstruction-by-height-starstar","text":"","title":"406. Queue Reconstruction by Height $\\star\\star$"},{"location":"python3/0401-0500/0401-0410/#407-trapping-rain-water-ii-starstarstar","text":"","title":"407. Trapping Rain Water II $\\star\\star\\star$"},{"location":"python3/0401-0500/0401-0410/#408-valid-word-abbreviation-star","text":"","title":"408. Valid Word Abbreviation $\\star$ \ud83d\udd12"},{"location":"python3/0401-0500/0401-0410/#409-longest-palindrome-star","text":"class Solution : def longestPalindrome ( self , s : str ) -> int : ans = 0 count = collections . Counter ( s ) for c in count . values (): ans += c if c % 2 == 0 else c - 1 hasOddCount = any ( c % 2 == 1 for c in count . values ()) return ans + hasOddCount","title":"409. Longest Palindrome $\\star$"},{"location":"python3/0401-0500/0401-0410/#410-split-array-largest-sum-starstarstar","text":"","title":"410. Split Array Largest Sum $\\star\\star\\star$"},{"location":"python3/0401-0500/0411-0420/","text":"411. Minimum Unique Word Abbreviation $\\star\\star\\star$ \ud83d\udd12 412. Fizz Buzz $\\star$ 413. Arithmetic Slices $\\star\\star$ class Solution : def numberOfArithmeticSlices ( self , A : List [ int ]) -> int : ans = 0 dp = 0 for i in range ( 2 , len ( A )): if A [ i ] - A [ i - 1 ] == A [ i - 1 ] - A [ i - 2 ]: dp += 1 ans += dp else : dp = 0 return ans 414. Third Maximum Number $\\star$ class Solution : def thirdMax ( self , nums : List [ int ]) -> int : pq = [] seen = set () for num in nums : if num not in seen : seen . add ( num ) heapq . heappush ( pq , num ) if len ( pq ) > 3 : heapq . heappop ( pq ) if len ( pq ) == 2 : heapq . heappop ( pq ) return pq [ 0 ] 415. Add Strings $\\star$ class Solution : def addStrings ( self , num1 : str , num2 : str ) -> str : ans = [] carry = 0 i = len ( num1 ) - 1 j = len ( num2 ) - 1 while i >= 0 or j >= 0 or carry : if i >= 0 : carry += int ( num1 [ i ]) if j >= 0 : carry += int ( num2 [ j ]) ans . append ( str ( carry % 10 )) carry //= 10 i -= 1 j -= 1 return '' . join ( reversed ( ans )) 416. Partition Equal Subset Sum $\\star\\star$ class Solution : def canPartition ( self , nums : List [ int ]) -> bool : summ = sum ( nums ) if summ & 1 : return False dp = [ True ] + [ False ] * ( summ // 2 ) for num in nums : for w in range ( summ // 2 , num - 1 , - 1 ): dp [ w ] = dp [ w ] or dp [ w - num ] return dp [ summ // 2 ] 417. Pacific Atlantic Water Flow $\\star\\star$ class Solution : def pacificAtlantic ( self , matrix : List [ List [ int ]]) -> List [ List [ int ]]: def bfs ( q : collections . deque , seen : List [ List [ bool ]]): while q : [ i , j ] = q . popleft () h = matrix [ i ][ j ] seen [ i ][ j ] = True for k in range ( 4 ): x = i + dirs [ k ] y = j + dirs [ k + 1 ] if not 0 <= x < m or not 0 <= y < n or matrix [ x ][ y ] < h or seen [ x ][ y ]: continue q . append (( x , y )) if not matrix : return [] m = len ( matrix ) n = len ( matrix [ 0 ]) dirs = [ 0 , 1 , 0 , - 1 , 0 ] qP = collections . deque () qA = collections . deque () seenP = [[ False ] * n for _ in range ( m )] seenA = [[ False ] * n for _ in range ( m )] for i in range ( m ): qP . append (( i , 0 )) qA . append (( i , n - 1 )) for j in range ( n ): qP . append (( 0 , j )) qA . append (( m - 1 , j )) bfs ( qP , seenP ) bfs ( qA , seenA ) return [[ i , j ] for i in range ( m ) for j in range ( n ) if seenP [ i ][ j ] and seenA [ i ][ j ]] 418. Sentence Screen Fitting $\\star\\star$ \ud83d\udd12 419. Battleships in a Board $\\star\\star$ 420. Strong Password Checker $\\star\\star\\star$","title":"0411-0420"},{"location":"python3/0401-0500/0411-0420/#411-minimum-unique-word-abbreviation-starstarstar","text":"","title":"411. Minimum Unique Word Abbreviation $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/0401-0500/0411-0420/#412-fizz-buzz-star","text":"","title":"412. Fizz Buzz $\\star$"},{"location":"python3/0401-0500/0411-0420/#413-arithmetic-slices-starstar","text":"class Solution : def numberOfArithmeticSlices ( self , A : List [ int ]) -> int : ans = 0 dp = 0 for i in range ( 2 , len ( A )): if A [ i ] - A [ i - 1 ] == A [ i - 1 ] - A [ i - 2 ]: dp += 1 ans += dp else : dp = 0 return ans","title":"413. Arithmetic Slices $\\star\\star$"},{"location":"python3/0401-0500/0411-0420/#414-third-maximum-number-star","text":"class Solution : def thirdMax ( self , nums : List [ int ]) -> int : pq = [] seen = set () for num in nums : if num not in seen : seen . add ( num ) heapq . heappush ( pq , num ) if len ( pq ) > 3 : heapq . heappop ( pq ) if len ( pq ) == 2 : heapq . heappop ( pq ) return pq [ 0 ]","title":"414. Third Maximum Number $\\star$"},{"location":"python3/0401-0500/0411-0420/#415-add-strings-star","text":"class Solution : def addStrings ( self , num1 : str , num2 : str ) -> str : ans = [] carry = 0 i = len ( num1 ) - 1 j = len ( num2 ) - 1 while i >= 0 or j >= 0 or carry : if i >= 0 : carry += int ( num1 [ i ]) if j >= 0 : carry += int ( num2 [ j ]) ans . append ( str ( carry % 10 )) carry //= 10 i -= 1 j -= 1 return '' . join ( reversed ( ans ))","title":"415. Add Strings $\\star$"},{"location":"python3/0401-0500/0411-0420/#416-partition-equal-subset-sum-starstar","text":"class Solution : def canPartition ( self , nums : List [ int ]) -> bool : summ = sum ( nums ) if summ & 1 : return False dp = [ True ] + [ False ] * ( summ // 2 ) for num in nums : for w in range ( summ // 2 , num - 1 , - 1 ): dp [ w ] = dp [ w ] or dp [ w - num ] return dp [ summ // 2 ]","title":"416. Partition Equal Subset Sum $\\star\\star$"},{"location":"python3/0401-0500/0411-0420/#417-pacific-atlantic-water-flow-starstar","text":"class Solution : def pacificAtlantic ( self , matrix : List [ List [ int ]]) -> List [ List [ int ]]: def bfs ( q : collections . deque , seen : List [ List [ bool ]]): while q : [ i , j ] = q . popleft () h = matrix [ i ][ j ] seen [ i ][ j ] = True for k in range ( 4 ): x = i + dirs [ k ] y = j + dirs [ k + 1 ] if not 0 <= x < m or not 0 <= y < n or matrix [ x ][ y ] < h or seen [ x ][ y ]: continue q . append (( x , y )) if not matrix : return [] m = len ( matrix ) n = len ( matrix [ 0 ]) dirs = [ 0 , 1 , 0 , - 1 , 0 ] qP = collections . deque () qA = collections . deque () seenP = [[ False ] * n for _ in range ( m )] seenA = [[ False ] * n for _ in range ( m )] for i in range ( m ): qP . append (( i , 0 )) qA . append (( i , n - 1 )) for j in range ( n ): qP . append (( 0 , j )) qA . append (( m - 1 , j )) bfs ( qP , seenP ) bfs ( qA , seenA ) return [[ i , j ] for i in range ( m ) for j in range ( n ) if seenP [ i ][ j ] and seenA [ i ][ j ]]","title":"417. Pacific Atlantic Water Flow $\\star\\star$"},{"location":"python3/0401-0500/0411-0420/#418-sentence-screen-fitting-starstar","text":"","title":"418. Sentence Screen Fitting $\\star\\star$ \ud83d\udd12"},{"location":"python3/0401-0500/0411-0420/#419-battleships-in-a-board-starstar","text":"","title":"419. Battleships in a Board $\\star\\star$"},{"location":"python3/0401-0500/0411-0420/#420-strong-password-checker-starstarstar","text":"","title":"420. Strong Password Checker $\\star\\star\\star$"},{"location":"python3/0401-0500/0421-0430/","text":"421. Maximum XOR of Two Numbers in an Array $\\star\\star$ 422. Valid Word Square $\\star$ \ud83d\udd12 423. Reconstruct Original Digits from English $\\star\\star$ class Solution : def originalDigits ( self , s : str ) -> str : count = [ 0 ] * 10 for c in s : if c == 'z' : count [ 0 ] += 1 if c == 'o' : count [ 1 ] += 1 if c == 'w' : count [ 2 ] += 1 if c == 'h' : count [ 3 ] += 1 if c == 'u' : count [ 4 ] += 1 if c == 'f' : count [ 5 ] += 1 if c == 'x' : count [ 6 ] += 1 if c == 's' : count [ 7 ] += 1 if c == 'g' : count [ 8 ] += 1 if c == 'i' : count [ 9 ] += 1 count [ 1 ] -= count [ 0 ] + count [ 2 ] + count [ 4 ] count [ 3 ] -= count [ 8 ] count [ 5 ] -= count [ 4 ] count [ 7 ] -= count [ 6 ] count [ 9 ] -= count [ 5 ] + count [ 6 ] + count [ 8 ] return '' . join ( chr ( i + ord ( '0' )) for i , c in enumerate ( count ) for j in range ( c )) 424. Longest Repeating Character Replacement $\\star\\star$ class Solution : def characterReplacement ( self , s : str , k : int ) -> int : ans = 0 maxFreq = 0 count = collections . Counter () l = 0 for r , c in enumerate ( s ): count [ c ] += 1 maxFreq = max ( maxFreq , count [ c ]) while maxFreq + k < r - l + 1 : count [ s [ l ]] -= 1 l += 1 ans = max ( ans , r - l + 1 ) return ans 425. Word Squares $\\star\\star\\star$ \ud83d\udd12 426. Convert Binary Search Tree to Sorted Doubly Linked List $\\star\\star$ \ud83d\udd12 427. Construct Quad Tree $\\star\\star$ 428. Serialize and Deserialize N-ary Tree $\\star\\star\\star$ \ud83d\udd12 429. N-ary Tree Level Order Traversal $\\star\\star$ 430. Flatten a Multilevel Doubly Linked List $\\star\\star$ class Solution : def flatten ( self , head : 'Node' ) -> 'Node' : curr = head while curr : if curr . child : cachedNext = curr . next curr . next = curr . child curr . child . prev = curr curr . child = None tail = curr . next while tail . next : tail = tail . next tail . next = cachedNext if cachedNext : cachedNext . prev = tail curr = curr . next return head","title":"0421-0430"},{"location":"python3/0401-0500/0421-0430/#421-maximum-xor-of-two-numbers-in-an-array-starstar","text":"","title":"421. Maximum XOR of Two Numbers in an Array $\\star\\star$"},{"location":"python3/0401-0500/0421-0430/#422-valid-word-square-star","text":"","title":"422. Valid Word Square $\\star$ \ud83d\udd12"},{"location":"python3/0401-0500/0421-0430/#423-reconstruct-original-digits-from-english-starstar","text":"class Solution : def originalDigits ( self , s : str ) -> str : count = [ 0 ] * 10 for c in s : if c == 'z' : count [ 0 ] += 1 if c == 'o' : count [ 1 ] += 1 if c == 'w' : count [ 2 ] += 1 if c == 'h' : count [ 3 ] += 1 if c == 'u' : count [ 4 ] += 1 if c == 'f' : count [ 5 ] += 1 if c == 'x' : count [ 6 ] += 1 if c == 's' : count [ 7 ] += 1 if c == 'g' : count [ 8 ] += 1 if c == 'i' : count [ 9 ] += 1 count [ 1 ] -= count [ 0 ] + count [ 2 ] + count [ 4 ] count [ 3 ] -= count [ 8 ] count [ 5 ] -= count [ 4 ] count [ 7 ] -= count [ 6 ] count [ 9 ] -= count [ 5 ] + count [ 6 ] + count [ 8 ] return '' . join ( chr ( i + ord ( '0' )) for i , c in enumerate ( count ) for j in range ( c ))","title":"423. Reconstruct Original Digits from English $\\star\\star$"},{"location":"python3/0401-0500/0421-0430/#424-longest-repeating-character-replacement-starstar","text":"class Solution : def characterReplacement ( self , s : str , k : int ) -> int : ans = 0 maxFreq = 0 count = collections . Counter () l = 0 for r , c in enumerate ( s ): count [ c ] += 1 maxFreq = max ( maxFreq , count [ c ]) while maxFreq + k < r - l + 1 : count [ s [ l ]] -= 1 l += 1 ans = max ( ans , r - l + 1 ) return ans","title":"424. Longest Repeating Character Replacement $\\star\\star$"},{"location":"python3/0401-0500/0421-0430/#425-word-squares-starstarstar","text":"","title":"425. Word Squares $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/0401-0500/0421-0430/#426-convert-binary-search-tree-to-sorted-doubly-linked-list-starstar","text":"","title":"426. Convert Binary Search Tree to Sorted Doubly Linked List $\\star\\star$ \ud83d\udd12"},{"location":"python3/0401-0500/0421-0430/#427-construct-quad-tree-starstar","text":"","title":"427. Construct Quad Tree $\\star\\star$"},{"location":"python3/0401-0500/0421-0430/#428-serialize-and-deserialize-n-ary-tree-starstarstar","text":"","title":"428. Serialize and Deserialize N-ary Tree $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/0401-0500/0421-0430/#429-n-ary-tree-level-order-traversal-starstar","text":"","title":"429. N-ary Tree Level Order Traversal $\\star\\star$"},{"location":"python3/0401-0500/0421-0430/#430-flatten-a-multilevel-doubly-linked-list-starstar","text":"class Solution : def flatten ( self , head : 'Node' ) -> 'Node' : curr = head while curr : if curr . child : cachedNext = curr . next curr . next = curr . child curr . child . prev = curr curr . child = None tail = curr . next while tail . next : tail = tail . next tail . next = cachedNext if cachedNext : cachedNext . prev = tail curr = curr . next return head","title":"430. Flatten a Multilevel Doubly Linked List $\\star\\star$"},{"location":"python3/0401-0500/0431-0440/","text":"431. Encode N-ary Tree to Binary Tree $\\star\\star\\star$ \ud83d\udd12 432. All O`one Data Structure $\\star\\star\\star$ 433. Minimum Genetic Mutation $\\star\\star$ 434. Number of Segments in a String $\\star$ class Solution : def countSegments ( self , s : str ) -> int : return len ( s . split ()) 435. Non-overlapping Intervals $\\star\\star$ class Solution : def eraseOverlapIntervals ( self , intervals : List [ List [ int ]]) -> int : ans = 0 currentEnd = float ( '-inf' ) for interval in sorted ( intervals , key = lambda x : x [ 1 ]): if interval [ 0 ] >= currentEnd : currentEnd = interval [ 1 ] else : ans += 1 return ans 436. Find Right Interval $\\star\\star$ 437. Path Sum III $\\star$ class Solution : def pathSum ( self , root : TreeNode , sum : int ) -> int : if not root : return 0 return self . helper ( root , sum ) + \\ self . pathSum ( root . left , sum ) + \\ self . pathSum ( root . right , sum ) def helper ( self , root : TreeNode , sum : int ) -> int : if not root : return 0 return ( sum == root . val ) + \\ self . helper ( root . left , sum - root . val ) + \\ self . helper ( root . right , sum - root . val ) 438. Find All Anagrams in a String $\\star\\star$ class Solution : def findAnagrams ( self , s : str , p : str ) -> List [ int ]: ans = [] count = collections . Counter ( p ) required = len ( p ) for r , c in enumerate ( s ): count [ c ] -= 1 if count [ c ] >= 0 : required -= 1 if r >= len ( p ): count [ s [ r - len ( p )]] += 1 if count [ s [ r - len ( p )]] > 0 : required += 1 if required == 0 : ans . append ( r - len ( p ) + 1 ) return ans 439. Ternary Expression Parser $\\star\\star$ \ud83d\udd12 440. K-th Smallest in Lexicographical Order $\\star\\star\\star$","title":"0431-0440"},{"location":"python3/0401-0500/0431-0440/#431-encode-n-ary-tree-to-binary-tree-starstarstar","text":"","title":"431. Encode N-ary Tree to Binary Tree $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/0401-0500/0431-0440/#432-all-oone-data-structure-starstarstar","text":"","title":"432. All O`one Data Structure $\\star\\star\\star$"},{"location":"python3/0401-0500/0431-0440/#433-minimum-genetic-mutation-starstar","text":"","title":"433. Minimum Genetic Mutation $\\star\\star$"},{"location":"python3/0401-0500/0431-0440/#434-number-of-segments-in-a-string-star","text":"class Solution : def countSegments ( self , s : str ) -> int : return len ( s . split ())","title":"434. Number of Segments in a String $\\star$"},{"location":"python3/0401-0500/0431-0440/#435-non-overlapping-intervals-starstar","text":"class Solution : def eraseOverlapIntervals ( self , intervals : List [ List [ int ]]) -> int : ans = 0 currentEnd = float ( '-inf' ) for interval in sorted ( intervals , key = lambda x : x [ 1 ]): if interval [ 0 ] >= currentEnd : currentEnd = interval [ 1 ] else : ans += 1 return ans","title":"435. Non-overlapping Intervals $\\star\\star$"},{"location":"python3/0401-0500/0431-0440/#436-find-right-interval-starstar","text":"","title":"436. Find Right Interval $\\star\\star$"},{"location":"python3/0401-0500/0431-0440/#437-path-sum-iii-star","text":"class Solution : def pathSum ( self , root : TreeNode , sum : int ) -> int : if not root : return 0 return self . helper ( root , sum ) + \\ self . pathSum ( root . left , sum ) + \\ self . pathSum ( root . right , sum ) def helper ( self , root : TreeNode , sum : int ) -> int : if not root : return 0 return ( sum == root . val ) + \\ self . helper ( root . left , sum - root . val ) + \\ self . helper ( root . right , sum - root . val )","title":"437. Path Sum III $\\star$"},{"location":"python3/0401-0500/0431-0440/#438-find-all-anagrams-in-a-string-starstar","text":"class Solution : def findAnagrams ( self , s : str , p : str ) -> List [ int ]: ans = [] count = collections . Counter ( p ) required = len ( p ) for r , c in enumerate ( s ): count [ c ] -= 1 if count [ c ] >= 0 : required -= 1 if r >= len ( p ): count [ s [ r - len ( p )]] += 1 if count [ s [ r - len ( p )]] > 0 : required += 1 if required == 0 : ans . append ( r - len ( p ) + 1 ) return ans","title":"438. Find All Anagrams in a String $\\star\\star$"},{"location":"python3/0401-0500/0431-0440/#439-ternary-expression-parser-starstar","text":"","title":"439. Ternary Expression Parser $\\star\\star$ \ud83d\udd12"},{"location":"python3/0401-0500/0431-0440/#440-k-th-smallest-in-lexicographical-order-starstarstar","text":"","title":"440. K-th Smallest in Lexicographical Order $\\star\\star\\star$"},{"location":"python3/0401-0500/0441-0450/","text":"441. Arranging Coins $\\star$ class Solution : def arrangeCoins ( self , n : int ) -> int : return int (( - 1 + sqrt ( 8 * n + 1 )) // 2 ) 442. Find All Duplicates in an Array $\\star\\star$ class Solution : def findDuplicates ( self , nums : List [ int ]) -> List [ int ]: ans = [] for num in nums : nums [ abs ( num ) - 1 ] *= - 1 if nums [ abs ( num ) - 1 ] > 0 : ans . append ( abs ( num )) return ans 443. String Compression $\\star$ class Solution : def compress ( self , chars : List [ str ]) -> int : ans = 0 i = 0 while i < len ( chars ): letter = chars [ i ] count = 0 while i < len ( chars ) and chars [ i ] == letter : count += 1 i += 1 chars [ ans ] = letter ans += 1 if count > 1 : for c in str ( count ): chars [ ans ] = c ans += 1 return ans 444. Sequence Reconstruction $\\star\\star$ \ud83d\udd12 445. Add Two Numbers II $\\star\\star$ class Solution : def addTwoNumbers ( self , l1 : ListNode , l2 : ListNode ) -> ListNode : stack1 = [] stack2 = [] while l1 : stack1 . append ( l1 ) l1 = l1 . next while l2 : stack2 . append ( l2 ) l2 = l2 . next head = None carry = 0 while carry or stack1 or stack2 : if stack1 : carry += stack1 . pop () . val if stack2 : carry += stack2 . pop () . val node = ListNode ( carry % 10 ) node . next = head head = node carry //= 10 return head 446. Arithmetic Slices II - Subsequence $\\star\\star\\star$ 447. Number of Boomerangs $\\star$ class Solution : def numberOfBoomerangs ( self , points : List [ List [ int ]]) -> int : ans = 0 for x1 , y1 in points : count = collections . defaultdict ( int ) for x2 , y2 in points : ans += 2 * count [( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ] count [( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ] += 1 return ans 448. Find All Numbers Disappeared in an Array $\\star$ class Solution : def findDisappearedNumbers ( self , nums : List [ int ]) -> List [ int ]: for num in nums : index = abs ( num ) - 1 nums [ index ] = - abs ( nums [ index ]) return [ i + 1 for i , num in enumerate ( nums ) if num > 0 ] 449. Serialize and Deserialize BST $\\star\\star$ 450. Delete Node in a BST $\\star\\star$","title":"0441-0450"},{"location":"python3/0401-0500/0441-0450/#441-arranging-coins-star","text":"class Solution : def arrangeCoins ( self , n : int ) -> int : return int (( - 1 + sqrt ( 8 * n + 1 )) // 2 )","title":"441. Arranging Coins $\\star$"},{"location":"python3/0401-0500/0441-0450/#442-find-all-duplicates-in-an-array-starstar","text":"class Solution : def findDuplicates ( self , nums : List [ int ]) -> List [ int ]: ans = [] for num in nums : nums [ abs ( num ) - 1 ] *= - 1 if nums [ abs ( num ) - 1 ] > 0 : ans . append ( abs ( num )) return ans","title":"442. Find All Duplicates in an Array $\\star\\star$"},{"location":"python3/0401-0500/0441-0450/#443-string-compression-star","text":"class Solution : def compress ( self , chars : List [ str ]) -> int : ans = 0 i = 0 while i < len ( chars ): letter = chars [ i ] count = 0 while i < len ( chars ) and chars [ i ] == letter : count += 1 i += 1 chars [ ans ] = letter ans += 1 if count > 1 : for c in str ( count ): chars [ ans ] = c ans += 1 return ans","title":"443. String Compression $\\star$"},{"location":"python3/0401-0500/0441-0450/#444-sequence-reconstruction-starstar","text":"","title":"444. Sequence Reconstruction $\\star\\star$ \ud83d\udd12"},{"location":"python3/0401-0500/0441-0450/#445-add-two-numbers-ii-starstar","text":"class Solution : def addTwoNumbers ( self , l1 : ListNode , l2 : ListNode ) -> ListNode : stack1 = [] stack2 = [] while l1 : stack1 . append ( l1 ) l1 = l1 . next while l2 : stack2 . append ( l2 ) l2 = l2 . next head = None carry = 0 while carry or stack1 or stack2 : if stack1 : carry += stack1 . pop () . val if stack2 : carry += stack2 . pop () . val node = ListNode ( carry % 10 ) node . next = head head = node carry //= 10 return head","title":"445. Add Two Numbers II $\\star\\star$"},{"location":"python3/0401-0500/0441-0450/#446-arithmetic-slices-ii-subsequence-starstarstar","text":"","title":"446. Arithmetic Slices II - Subsequence $\\star\\star\\star$"},{"location":"python3/0401-0500/0441-0450/#447-number-of-boomerangs-star","text":"class Solution : def numberOfBoomerangs ( self , points : List [ List [ int ]]) -> int : ans = 0 for x1 , y1 in points : count = collections . defaultdict ( int ) for x2 , y2 in points : ans += 2 * count [( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ] count [( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ] += 1 return ans","title":"447. Number of Boomerangs $\\star$"},{"location":"python3/0401-0500/0441-0450/#448-find-all-numbers-disappeared-in-an-array-star","text":"class Solution : def findDisappearedNumbers ( self , nums : List [ int ]) -> List [ int ]: for num in nums : index = abs ( num ) - 1 nums [ index ] = - abs ( nums [ index ]) return [ i + 1 for i , num in enumerate ( nums ) if num > 0 ]","title":"448. Find All Numbers Disappeared in an Array $\\star$"},{"location":"python3/0401-0500/0441-0450/#449-serialize-and-deserialize-bst-starstar","text":"","title":"449. Serialize and Deserialize BST $\\star\\star$"},{"location":"python3/0401-0500/0441-0450/#450-delete-node-in-a-bst-starstar","text":"","title":"450. Delete Node in a BST $\\star\\star$"},{"location":"python3/0401-0500/0451-0460/","text":"451. Sort Characters By Frequency $\\star\\star$ class Solution : def frequencySort ( self , s : str ) -> str : ans = \"\" bucket = [[] for _ in range ( len ( s ) + 1 )] for c , freq in collections . Counter ( s ) . items (): bucket [ freq ] . append ( c ) for freq in range ( len ( bucket ))[:: - 1 ]: for c in bucket [ freq ]: ans += c * freq return ans 452. Minimum Number of Arrows to Burst Balloons $\\star\\star$ class Solution : def findMinArrowShots ( self , points : List [ List [ int ]]) -> int : ans = 0 arrowX = float ( '-inf' ) for point in sorted ( points , key = lambda x : x [ 1 ]): if point [ 0 ] > arrowX : ans += 1 arrowX = point [ 1 ] return ans 453. Minimum Moves to Equal Array Elements $\\star$ class Solution : def minMoves ( self , nums : List [ int ]) -> int : mini = min ( nums ) return sum ( num - mini for num in nums ) 454. 4Sum II $\\star\\star$ class Solution : def fourSumCount ( self , A : List [ int ], B : List [ int ], C : List [ int ], D : List [ int ]) -> int : count = collections . Counter ( a + b for a in A for b in B ) return sum ( count [ - c - d ] for c in C for d in D ) 455. Assign Cookies $\\star$ 456. 132 Pattern $\\star\\star$ 457. Circular Array Loop $\\star\\star$ class Solution : def circularArrayLoop ( self , nums : List [ int ]) -> bool : def advance ( i : int ) -> int : return ( i + nums [ i ]) % len ( nums ) if len ( nums ) < 2 : return False for i , num in enumerate ( nums ): if num == 0 : continue slow = i fast = advance ( slow ) while num * nums [ fast ] > 0 and num * nums [ advance ( fast )] > 0 : if slow == fast : if slow == advance ( slow ): break return True slow = advance ( slow ) fast = advance ( advance ( fast )) slow = i sign = num while sign * nums [ slow ] > 0 : next = advance ( slow ) nums [ slow ] = 0 slow = next return False 458. Poor Pigs $\\star\\star\\star$ class Solution : def poorPigs ( self , buckets : int , minutesToDie : int , minutesToTest : int ) -> int : return math . ceil ( math . log ( buckets ) / math . log ( minutesToTest // minutesToDie + 1 )) 459. Repeated Substring Pattern $\\star$ class Solution : def repeatedSubstringPattern ( self , s : str ) -> bool : return s in ( s + s )[ 1 : - 1 ] 460. LFU Cache $\\star\\star\\star$","title":"0451-0460"},{"location":"python3/0401-0500/0451-0460/#451-sort-characters-by-frequency-starstar","text":"class Solution : def frequencySort ( self , s : str ) -> str : ans = \"\" bucket = [[] for _ in range ( len ( s ) + 1 )] for c , freq in collections . Counter ( s ) . items (): bucket [ freq ] . append ( c ) for freq in range ( len ( bucket ))[:: - 1 ]: for c in bucket [ freq ]: ans += c * freq return ans","title":"451. Sort Characters By Frequency $\\star\\star$"},{"location":"python3/0401-0500/0451-0460/#452-minimum-number-of-arrows-to-burst-balloons-starstar","text":"class Solution : def findMinArrowShots ( self , points : List [ List [ int ]]) -> int : ans = 0 arrowX = float ( '-inf' ) for point in sorted ( points , key = lambda x : x [ 1 ]): if point [ 0 ] > arrowX : ans += 1 arrowX = point [ 1 ] return ans","title":"452. Minimum Number of Arrows to Burst Balloons $\\star\\star$"},{"location":"python3/0401-0500/0451-0460/#453-minimum-moves-to-equal-array-elements-star","text":"class Solution : def minMoves ( self , nums : List [ int ]) -> int : mini = min ( nums ) return sum ( num - mini for num in nums )","title":"453. Minimum Moves to Equal Array Elements $\\star$"},{"location":"python3/0401-0500/0451-0460/#454-4sum-ii-starstar","text":"class Solution : def fourSumCount ( self , A : List [ int ], B : List [ int ], C : List [ int ], D : List [ int ]) -> int : count = collections . Counter ( a + b for a in A for b in B ) return sum ( count [ - c - d ] for c in C for d in D )","title":"454. 4Sum II $\\star\\star$"},{"location":"python3/0401-0500/0451-0460/#455-assign-cookies-star","text":"","title":"455. Assign Cookies $\\star$"},{"location":"python3/0401-0500/0451-0460/#456-132-pattern-starstar","text":"","title":"456. 132 Pattern $\\star\\star$"},{"location":"python3/0401-0500/0451-0460/#457-circular-array-loop-starstar","text":"class Solution : def circularArrayLoop ( self , nums : List [ int ]) -> bool : def advance ( i : int ) -> int : return ( i + nums [ i ]) % len ( nums ) if len ( nums ) < 2 : return False for i , num in enumerate ( nums ): if num == 0 : continue slow = i fast = advance ( slow ) while num * nums [ fast ] > 0 and num * nums [ advance ( fast )] > 0 : if slow == fast : if slow == advance ( slow ): break return True slow = advance ( slow ) fast = advance ( advance ( fast )) slow = i sign = num while sign * nums [ slow ] > 0 : next = advance ( slow ) nums [ slow ] = 0 slow = next return False","title":"457. Circular Array Loop $\\star\\star$"},{"location":"python3/0401-0500/0451-0460/#458-poor-pigs-starstarstar","text":"class Solution : def poorPigs ( self , buckets : int , minutesToDie : int , minutesToTest : int ) -> int : return math . ceil ( math . log ( buckets ) / math . log ( minutesToTest // minutesToDie + 1 ))","title":"458. Poor Pigs $\\star\\star\\star$"},{"location":"python3/0401-0500/0451-0460/#459-repeated-substring-pattern-star","text":"class Solution : def repeatedSubstringPattern ( self , s : str ) -> bool : return s in ( s + s )[ 1 : - 1 ]","title":"459. Repeated Substring Pattern $\\star$"},{"location":"python3/0401-0500/0451-0460/#460-lfu-cache-starstarstar","text":"","title":"460. LFU Cache $\\star\\star\\star$"},{"location":"python3/0401-0500/0461-0470/","text":"461. Hamming Distance $\\star$ 462. Minimum Moves to Equal Array Elements II $\\star\\star$ import statistics class Solution : def minMoves2 ( self , nums : List [ int ]) -> int : median = int ( statistics . median ( nums )) return sum ( abs ( num - median ) for num in nums ) 463. Island Perimeter $\\star$ class Solution : def islandPerimeter ( self , grid : List [ List [ int ]]) -> int : m = len ( grid ) n = len ( grid [ 0 ]) islands = 0 neighbors = 0 for i in range ( m ): for j in range ( n ): if grid [ i ][ j ] == 1 : islands += 1 if i + 1 < m and grid [ i + 1 ][ j ] == 1 : neighbors += 1 if j + 1 < n and grid [ i ][ j + 1 ] == 1 : neighbors += 1 return islands * 4 - neighbors * 2 464. Can I Win $\\star\\star$ 465. Optimal Account Balancing $\\star\\star\\star$ \ud83d\udd12 466. Count The Repetitions $\\star\\star\\star$ 467. Unique Substrings in Wraparound String $\\star\\star$ 468. Validate IP Address $\\star\\star$ 469. Convex Polygon $\\star\\star$ \ud83d\udd12 470. Implement Rand10() Using Rand7() $\\star\\star$","title":"0461-0470"},{"location":"python3/0401-0500/0461-0470/#461-hamming-distance-star","text":"","title":"461. Hamming Distance $\\star$"},{"location":"python3/0401-0500/0461-0470/#462-minimum-moves-to-equal-array-elements-ii-starstar","text":"import statistics class Solution : def minMoves2 ( self , nums : List [ int ]) -> int : median = int ( statistics . median ( nums )) return sum ( abs ( num - median ) for num in nums )","title":"462. Minimum Moves to Equal Array Elements II $\\star\\star$"},{"location":"python3/0401-0500/0461-0470/#463-island-perimeter-star","text":"class Solution : def islandPerimeter ( self , grid : List [ List [ int ]]) -> int : m = len ( grid ) n = len ( grid [ 0 ]) islands = 0 neighbors = 0 for i in range ( m ): for j in range ( n ): if grid [ i ][ j ] == 1 : islands += 1 if i + 1 < m and grid [ i + 1 ][ j ] == 1 : neighbors += 1 if j + 1 < n and grid [ i ][ j + 1 ] == 1 : neighbors += 1 return islands * 4 - neighbors * 2","title":"463. Island Perimeter $\\star$"},{"location":"python3/0401-0500/0461-0470/#464-can-i-win-starstar","text":"","title":"464. Can I Win $\\star\\star$"},{"location":"python3/0401-0500/0461-0470/#465-optimal-account-balancing-starstarstar","text":"","title":"465. Optimal Account Balancing $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/0401-0500/0461-0470/#466-count-the-repetitions-starstarstar","text":"","title":"466. Count The Repetitions $\\star\\star\\star$"},{"location":"python3/0401-0500/0461-0470/#467-unique-substrings-in-wraparound-string-starstar","text":"","title":"467. Unique Substrings in Wraparound String $\\star\\star$"},{"location":"python3/0401-0500/0461-0470/#468-validate-ip-address-starstar","text":"","title":"468. Validate IP Address $\\star\\star$"},{"location":"python3/0401-0500/0461-0470/#469-convex-polygon-starstar","text":"","title":"469. Convex Polygon $\\star\\star$ \ud83d\udd12"},{"location":"python3/0401-0500/0461-0470/#470-implement-rand10-using-rand7-starstar","text":"","title":"470. Implement Rand10() Using Rand7() $\\star\\star$"},{"location":"python3/0401-0500/0471-0480/","text":"471. Encode String with Shortest Length $\\star\\star\\star$ \ud83d\udd12 472. Concatenated Words $\\star\\star\\star$ class Solution : def findAllConcatenatedWordsInADict ( self , words : List [ str ]) -> List [ str ]: def isConcat ( word : str ) -> bool : if word in memo : return memo [ word ] for i in range ( 1 , len ( word )): prefix = word [: i ] suffix = word [ i :] if prefix in wordSet and ( suffix in wordSet or isConcat ( suffix )): memo [ word ] = True return True memo [ word ] = False return False wordSet = set ( words ) memo = {} return [ word for word in words if isConcat ( word )] 473. Matchsticks to Square $\\star\\star$ class Solution : def makesquare ( self , nums : List [ int ]) -> bool : def dfs ( selected : int , edges : List [ int ]) -> bool : if selected == len ( nums ): return all ( edge == edges [ 0 ] for edge in edges ) for i , edge in enumerate ( edges ): if nums [ selected ] > edge : continue edges [ i ] -= nums [ selected ] if dfs ( selected + 1 , edges ): return True edges [ i ] += nums [ selected ] return False if len ( nums ) < 4 : return False perimeter = sum ( nums ) if perimeter % 4 != 0 : return False nums = sorted ( nums )[:: - 1 ] return dfs ( 0 , [ perimeter // 4 ] * 4 ) 474. Ones and Zeroes $\\star\\star$ class Solution : def findMaxForm ( self , strs : List [ str ], m : int , n : int ) -> int : dp = [[ 0 ] * ( n + 1 ) for _ in range ( m + 1 )] for s in strs : count0 = s . count ( '0' ) count1 = len ( s ) - count0 for i in range ( m , count0 - 1 , - 1 ): for j in range ( n , count1 - 1 , - 1 ): dp [ i ][ j ] = max ( dp [ i ][ j ], dp [ i - count0 ][ j - count1 ] + 1 ) return dp [ m ][ n ] 475. Heaters $\\star$ 476. Number Complement $\\star$ 477. Total Hamming Distance $\\star\\star$ 478. Generate Random Point in a Circle $\\star\\star$ class Solution : def __init__ ( self , radius : float , x_center : float , y_center : float ): self . radius = radius self . x_center = x_center self . y_center = y_center def randPoint ( self ) -> List [ float ]: length = sqrt ( random . uniform ( 0 , 1 )) * self . radius degree = random . uniform ( 0 , 1 ) * 2 * math . pi x = self . x_center + length * math . cos ( degree ) y = self . y_center + length * math . sin ( degree ) return [ x , y ] 479. Largest Palindrome Product $\\star\\star\\star$ 480. Sliding Window Median $\\star\\star\\star$","title":"0471-0480"},{"location":"python3/0401-0500/0471-0480/#471-encode-string-with-shortest-length-starstarstar","text":"","title":"471. Encode String with Shortest Length $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/0401-0500/0471-0480/#472-concatenated-words-starstarstar","text":"class Solution : def findAllConcatenatedWordsInADict ( self , words : List [ str ]) -> List [ str ]: def isConcat ( word : str ) -> bool : if word in memo : return memo [ word ] for i in range ( 1 , len ( word )): prefix = word [: i ] suffix = word [ i :] if prefix in wordSet and ( suffix in wordSet or isConcat ( suffix )): memo [ word ] = True return True memo [ word ] = False return False wordSet = set ( words ) memo = {} return [ word for word in words if isConcat ( word )]","title":"472. Concatenated Words $\\star\\star\\star$"},{"location":"python3/0401-0500/0471-0480/#473-matchsticks-to-square-starstar","text":"class Solution : def makesquare ( self , nums : List [ int ]) -> bool : def dfs ( selected : int , edges : List [ int ]) -> bool : if selected == len ( nums ): return all ( edge == edges [ 0 ] for edge in edges ) for i , edge in enumerate ( edges ): if nums [ selected ] > edge : continue edges [ i ] -= nums [ selected ] if dfs ( selected + 1 , edges ): return True edges [ i ] += nums [ selected ] return False if len ( nums ) < 4 : return False perimeter = sum ( nums ) if perimeter % 4 != 0 : return False nums = sorted ( nums )[:: - 1 ] return dfs ( 0 , [ perimeter // 4 ] * 4 )","title":"473. Matchsticks to Square $\\star\\star$"},{"location":"python3/0401-0500/0471-0480/#474-ones-and-zeroes-starstar","text":"class Solution : def findMaxForm ( self , strs : List [ str ], m : int , n : int ) -> int : dp = [[ 0 ] * ( n + 1 ) for _ in range ( m + 1 )] for s in strs : count0 = s . count ( '0' ) count1 = len ( s ) - count0 for i in range ( m , count0 - 1 , - 1 ): for j in range ( n , count1 - 1 , - 1 ): dp [ i ][ j ] = max ( dp [ i ][ j ], dp [ i - count0 ][ j - count1 ] + 1 ) return dp [ m ][ n ]","title":"474. Ones and Zeroes $\\star\\star$"},{"location":"python3/0401-0500/0471-0480/#475-heaters-star","text":"","title":"475. Heaters $\\star$"},{"location":"python3/0401-0500/0471-0480/#476-number-complement-star","text":"","title":"476. Number Complement $\\star$"},{"location":"python3/0401-0500/0471-0480/#477-total-hamming-distance-starstar","text":"","title":"477. Total Hamming Distance $\\star\\star$"},{"location":"python3/0401-0500/0471-0480/#478-generate-random-point-in-a-circle-starstar","text":"class Solution : def __init__ ( self , radius : float , x_center : float , y_center : float ): self . radius = radius self . x_center = x_center self . y_center = y_center def randPoint ( self ) -> List [ float ]: length = sqrt ( random . uniform ( 0 , 1 )) * self . radius degree = random . uniform ( 0 , 1 ) * 2 * math . pi x = self . x_center + length * math . cos ( degree ) y = self . y_center + length * math . sin ( degree ) return [ x , y ]","title":"478. Generate Random Point in a Circle $\\star\\star$"},{"location":"python3/0401-0500/0471-0480/#479-largest-palindrome-product-starstarstar","text":"","title":"479. Largest Palindrome Product $\\star\\star\\star$"},{"location":"python3/0401-0500/0471-0480/#480-sliding-window-median-starstarstar","text":"","title":"480. Sliding Window Median $\\star\\star\\star$"},{"location":"python3/0401-0500/0481-0490/","text":"481. Magical String $\\star\\star$ 482. License Key Formatting $\\star$ 483. Smallest Good Base $\\star\\star\\star$ class Solution : def smallestGoodBase ( self , n : str ) -> str : n = int ( n ) for m in range ( int ( math . log ( n , 2 )), 1 , - 1 ): k = int ( n ** m **- 1 ) if ( k ** ( m + 1 ) - 1 ) // ( k - 1 ) == n : return str ( k ) return str ( n - 1 ) 484. Find Permutation $\\star\\star$ \ud83d\udd12 485. Max Consecutive Ones $\\star$ class Solution : def findMaxConsecutiveOnes ( self , nums : List [ int ]) -> int : ans = 0 sum = 0 for num in nums : if num == 0 : sum = 0 else : sum += num ans = max ( ans , sum ) return ans 486. Predict the Winner $\\star\\star$ 487. Max Consecutive Ones II $\\star\\star$ \ud83d\udd12 488. Zuma Game $\\star\\star\\star$ 489. Robot Room Cleaner $\\star\\star\\star$ \ud83d\udd12 490. The Maze $\\star\\star$ \ud83d\udd12","title":"0481-0490"},{"location":"python3/0401-0500/0481-0490/#481-magical-string-starstar","text":"","title":"481. Magical String $\\star\\star$"},{"location":"python3/0401-0500/0481-0490/#482-license-key-formatting-star","text":"","title":"482. License Key Formatting $\\star$"},{"location":"python3/0401-0500/0481-0490/#483-smallest-good-base-starstarstar","text":"class Solution : def smallestGoodBase ( self , n : str ) -> str : n = int ( n ) for m in range ( int ( math . log ( n , 2 )), 1 , - 1 ): k = int ( n ** m **- 1 ) if ( k ** ( m + 1 ) - 1 ) // ( k - 1 ) == n : return str ( k ) return str ( n - 1 )","title":"483. Smallest Good Base $\\star\\star\\star$"},{"location":"python3/0401-0500/0481-0490/#484-find-permutation-starstar","text":"","title":"484. Find Permutation $\\star\\star$ \ud83d\udd12"},{"location":"python3/0401-0500/0481-0490/#485-max-consecutive-ones-star","text":"class Solution : def findMaxConsecutiveOnes ( self , nums : List [ int ]) -> int : ans = 0 sum = 0 for num in nums : if num == 0 : sum = 0 else : sum += num ans = max ( ans , sum ) return ans","title":"485. Max Consecutive Ones $\\star$"},{"location":"python3/0401-0500/0481-0490/#486-predict-the-winner-starstar","text":"","title":"486. Predict the Winner $\\star\\star$"},{"location":"python3/0401-0500/0481-0490/#487-max-consecutive-ones-ii-starstar","text":"","title":"487. Max Consecutive Ones II $\\star\\star$ \ud83d\udd12"},{"location":"python3/0401-0500/0481-0490/#488-zuma-game-starstarstar","text":"","title":"488. Zuma Game $\\star\\star\\star$"},{"location":"python3/0401-0500/0481-0490/#489-robot-room-cleaner-starstarstar","text":"","title":"489. Robot Room Cleaner $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/0401-0500/0481-0490/#490-the-maze-starstar","text":"","title":"490. The Maze $\\star\\star$ \ud83d\udd12"},{"location":"python3/0401-0500/0491-0500/","text":"491. Increasing Subsequences $\\star\\star$ class Solution : def findSubsequences ( self , nums : List [ int ]) -> List [ List [ int ]]: def dfs ( s : int , path : List [ int ]) -> None : if len ( path ) > 1 : ans . append ( path ) used = set () for i in range ( s , len ( nums )): if nums [ i ] in used : continue if not path or nums [ i ] >= path [ - 1 ]: used . add ( nums [ i ]) dfs ( i + 1 , path + [ nums [ i ]]) ans = [] dfs ( 0 , []) return ans 492. Construct the Rectangle $\\star$ 493. Reverse Pairs $\\star\\star\\star$ 494. Target Sum $\\star\\star$ class Solution : def findTargetSumWays ( self , nums : List [ int ], S : int ) -> int : summ = sum ( nums ) if summ < S or ( summ + S ) & 1 : return 0 def subsetSum ( s : int ) -> int : dp = [ 1 ] + [ 0 ] * summ for num in nums : for w in range ( summ , num - 1 , - 1 ): dp [ w ] += dp [ w - num ] return dp [ s ] return subsetSum (( summ + S ) // 2 ) 495. Teemo Attacking $\\star\\star$ class Solution : def findPoisonedDuration ( self , timeSeries : List [ int ], duration : int ) -> int : if timeSeries == [] or duration == 0 : return 0 ans = 0 for i in range ( 0 , len ( timeSeries ) - 1 ): ans += min ( timeSeries [ i + 1 ] - timeSeries [ i ], duration ) return ans + duration 496. Next Greater Element I $\\star$ 497. Random Point in Non-overlapping Rectangles $\\star\\star$ 498. Diagonal Traverse $\\star\\star$ 499. The Maze III $\\star\\star\\star$ \ud83d\udd12 500. Keyboard Row $\\star$ class Solution : def findWords ( self , words : List [ str ]) -> List [ str ]: ans = [] rows = [ set ( 'qwertyuiop' ), set ( 'asdfghjkl' ), set ( 'zxcvbnm' )] for word in words : lowerWord = set ( word . lower ()) if any ( lowerWord <= row for row in rows ): ans . append ( word ) return ans","title":"0491-0500"},{"location":"python3/0401-0500/0491-0500/#491-increasing-subsequences-starstar","text":"class Solution : def findSubsequences ( self , nums : List [ int ]) -> List [ List [ int ]]: def dfs ( s : int , path : List [ int ]) -> None : if len ( path ) > 1 : ans . append ( path ) used = set () for i in range ( s , len ( nums )): if nums [ i ] in used : continue if not path or nums [ i ] >= path [ - 1 ]: used . add ( nums [ i ]) dfs ( i + 1 , path + [ nums [ i ]]) ans = [] dfs ( 0 , []) return ans","title":"491. Increasing Subsequences $\\star\\star$"},{"location":"python3/0401-0500/0491-0500/#492-construct-the-rectangle-star","text":"","title":"492. Construct the Rectangle $\\star$"},{"location":"python3/0401-0500/0491-0500/#493-reverse-pairs-starstarstar","text":"","title":"493. Reverse Pairs $\\star\\star\\star$"},{"location":"python3/0401-0500/0491-0500/#494-target-sum-starstar","text":"class Solution : def findTargetSumWays ( self , nums : List [ int ], S : int ) -> int : summ = sum ( nums ) if summ < S or ( summ + S ) & 1 : return 0 def subsetSum ( s : int ) -> int : dp = [ 1 ] + [ 0 ] * summ for num in nums : for w in range ( summ , num - 1 , - 1 ): dp [ w ] += dp [ w - num ] return dp [ s ] return subsetSum (( summ + S ) // 2 )","title":"494. Target Sum $\\star\\star$"},{"location":"python3/0401-0500/0491-0500/#495-teemo-attacking-starstar","text":"class Solution : def findPoisonedDuration ( self , timeSeries : List [ int ], duration : int ) -> int : if timeSeries == [] or duration == 0 : return 0 ans = 0 for i in range ( 0 , len ( timeSeries ) - 1 ): ans += min ( timeSeries [ i + 1 ] - timeSeries [ i ], duration ) return ans + duration","title":"495. Teemo Attacking $\\star\\star$"},{"location":"python3/0401-0500/0491-0500/#496-next-greater-element-i-star","text":"","title":"496. Next Greater Element I $\\star$"},{"location":"python3/0401-0500/0491-0500/#497-random-point-in-non-overlapping-rectangles-starstar","text":"","title":"497. Random Point in Non-overlapping Rectangles $\\star\\star$"},{"location":"python3/0401-0500/0491-0500/#498-diagonal-traverse-starstar","text":"","title":"498. Diagonal Traverse $\\star\\star$"},{"location":"python3/0401-0500/0491-0500/#499-the-maze-iii-starstarstar","text":"","title":"499. The Maze III $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/0401-0500/0491-0500/#500-keyboard-row-star","text":"class Solution : def findWords ( self , words : List [ str ]) -> List [ str ]: ans = [] rows = [ set ( 'qwertyuiop' ), set ( 'asdfghjkl' ), set ( 'zxcvbnm' )] for word in words : lowerWord = set ( word . lower ()) if any ( lowerWord <= row for row in rows ): ans . append ( word ) return ans","title":"500. Keyboard Row $\\star$"},{"location":"python3/0501-0600/0501-0510/","text":"501. Find Mode in Binary Search Tree $\\star$ 502. IPO $\\star\\star\\star$ 503. Next Greater Element II $\\star\\star$ class Solution : def nextGreaterElements ( self , nums : List [ int ]) -> List [ int ]: ans = [ - 1 ] * len ( nums ) stack = [] for i in range ( len ( nums ) * 2 ): num = nums [ i % len ( nums )] while stack and nums [ stack [ - 1 ]] < num : ans [ stack . pop ()] = num if i < len ( nums ): stack . append ( i ) return ans 504. Base 7 $\\star$ 505. The Maze II $\\star\\star$ \ud83d\udd12 506. Relative Ranks $\\star$ 507. Perfect Number $\\star$ class Solution : def checkPerfectNumber ( self , num : int ) -> bool : return num in { 6 , 28 , 496 , 8128 , 33550336 } 508. Most Frequent Subtree Sum $\\star\\star$ class Solution : def findFrequentTreeSum ( self , root : TreeNode ) -> List [ int ]: def dfs ( root : TreeNode ) -> int : if root is None : return 0 sum = root . val + dfs ( root . left ) + dfs ( root . right ) count [ sum ] += 1 return sum if root is None : return [] count = collections . Counter () dfs ( root ) maxFreq = max ( count . values ()) return [ sum for sum in count if count [ sum ] == maxFreq ] 509. Fibonacci Number $\\star$ class Solution : def fib ( self , N : int ) -> int : if N < 2 : return N dp = [ 0 , 0 , 1 ] for i in range ( 2 , N + 1 ): dp [ 0 ] = dp [ 1 ] dp [ 1 ] = dp [ 2 ] dp [ 2 ] = dp [ 0 ] + dp [ 1 ] return dp [ 2 ] 510. Inorder Successor in BST II $\\star\\star$ \ud83d\udd12","title":"0501-0510"},{"location":"python3/0501-0600/0501-0510/#501-find-mode-in-binary-search-tree-star","text":"","title":"501. Find Mode in Binary Search Tree $\\star$"},{"location":"python3/0501-0600/0501-0510/#502-ipo-starstarstar","text":"","title":"502. IPO $\\star\\star\\star$"},{"location":"python3/0501-0600/0501-0510/#503-next-greater-element-ii-starstar","text":"class Solution : def nextGreaterElements ( self , nums : List [ int ]) -> List [ int ]: ans = [ - 1 ] * len ( nums ) stack = [] for i in range ( len ( nums ) * 2 ): num = nums [ i % len ( nums )] while stack and nums [ stack [ - 1 ]] < num : ans [ stack . pop ()] = num if i < len ( nums ): stack . append ( i ) return ans","title":"503. Next Greater Element II $\\star\\star$"},{"location":"python3/0501-0600/0501-0510/#504-base-7-star","text":"","title":"504. Base 7 $\\star$"},{"location":"python3/0501-0600/0501-0510/#505-the-maze-ii-starstar","text":"","title":"505. The Maze II $\\star\\star$ \ud83d\udd12"},{"location":"python3/0501-0600/0501-0510/#506-relative-ranks-star","text":"","title":"506. Relative Ranks $\\star$"},{"location":"python3/0501-0600/0501-0510/#507-perfect-number-star","text":"class Solution : def checkPerfectNumber ( self , num : int ) -> bool : return num in { 6 , 28 , 496 , 8128 , 33550336 }","title":"507. Perfect Number $\\star$"},{"location":"python3/0501-0600/0501-0510/#508-most-frequent-subtree-sum-starstar","text":"class Solution : def findFrequentTreeSum ( self , root : TreeNode ) -> List [ int ]: def dfs ( root : TreeNode ) -> int : if root is None : return 0 sum = root . val + dfs ( root . left ) + dfs ( root . right ) count [ sum ] += 1 return sum if root is None : return [] count = collections . Counter () dfs ( root ) maxFreq = max ( count . values ()) return [ sum for sum in count if count [ sum ] == maxFreq ]","title":"508. Most Frequent Subtree Sum $\\star\\star$"},{"location":"python3/0501-0600/0501-0510/#509-fibonacci-number-star","text":"class Solution : def fib ( self , N : int ) -> int : if N < 2 : return N dp = [ 0 , 0 , 1 ] for i in range ( 2 , N + 1 ): dp [ 0 ] = dp [ 1 ] dp [ 1 ] = dp [ 2 ] dp [ 2 ] = dp [ 0 ] + dp [ 1 ] return dp [ 2 ]","title":"509. Fibonacci Number $\\star$"},{"location":"python3/0501-0600/0501-0510/#510-inorder-successor-in-bst-ii-starstar","text":"","title":"510. Inorder Successor in BST II $\\star\\star$ \ud83d\udd12"},{"location":"python3/0501-0600/0511-0520/","text":"511. Game Play Analysis I $\\star$ \ud83d\udd12 512. Game Play Analysis II $\\star$ \ud83d\udd12 513. Find Bottom Left Tree Value $\\star\\star$ class Solution : def findBottomLeftValue ( self , root : TreeNode ) -> int : queue = collections . deque ([ root ]) while queue : root = queue . popleft () if root . right : queue . append ( root . right ) if root . left : queue . append ( root . left ) return root . val 514. Freedom Trail $\\star\\star\\star$ class Solution : def findRotateSteps ( self , ring : str , key : str ) -> int : def dfs ( ring : str , index : int ) -> int : if index == len ( key ): return 0 if ( ring , index ) in memo : return memo [( ring , index )] ans = float ( 'inf' ) for i , r in enumerate ( ring ): if r == key [ index ]: diff = min ( i , len ( ring ) - i ) step = dfs ( ring [ i :] + ring [: i ], index + 1 ) ans = min ( ans , diff + step ) memo [( ring , index )] = ans return ans memo = {} return dfs ( ring , 0 ) + len ( key ) 515. Find Largest Value in Each Tree Row $\\star\\star$ class Solution : def largestValues ( self , root : TreeNode ) -> List [ int ]: if not root : return [] ans = [] queue = collections . deque ([ root ]) while queue : maxi = float ( '-inf' ) for _ in range ( len ( queue )): root = queue . popleft () maxi = max ( maxi , root . val ) if root . left : queue . append ( root . left ) if root . right : queue . append ( root . right ) ans . append ( maxi ) return ans 516. Longest Palindromic Subsequence $\\star\\star$ 517. Super Washing Machines $\\star\\star\\star$ class Solution : def findMinMoves ( self , machines : List [ int ]) -> int : dresses = sum ( machines ) if dresses % len ( machines ) != 0 : return - 1 ans = 0 average = dresses // len ( machines ) inout = 0 for dress in machines : inout += dress - average ans = max ( ans , abs ( inout ), dress - average ) return ans 518. Coin Change 2 $\\star\\star$ Time: $O(nk)$, where n = len(coins) and k = target Space: $O(k)$ class Solution : def change ( self , amount : int , coins : List [ int ]) -> int : dp = [ 1 ] + [ 0 ] * amount for coin in coins : for i in range ( coin , amount + 1 ): dp [ i ] += dp [ i - coin ] return dp [ amount ] 519. Random Flip Matrix $\\star\\star$ 520. Detect Capital $\\star$ class Solution : def detectCapitalUse ( self , word : str ) -> bool : return word . isupper () or word . islower () or word . istitle ()","title":"0511-0520"},{"location":"python3/0501-0600/0511-0520/#511-game-play-analysis-i-star","text":"","title":"511. Game Play Analysis I $\\star$ \ud83d\udd12"},{"location":"python3/0501-0600/0511-0520/#512-game-play-analysis-ii-star","text":"","title":"512. Game Play Analysis II $\\star$ \ud83d\udd12"},{"location":"python3/0501-0600/0511-0520/#513-find-bottom-left-tree-value-starstar","text":"class Solution : def findBottomLeftValue ( self , root : TreeNode ) -> int : queue = collections . deque ([ root ]) while queue : root = queue . popleft () if root . right : queue . append ( root . right ) if root . left : queue . append ( root . left ) return root . val","title":"513. Find Bottom Left Tree Value $\\star\\star$"},{"location":"python3/0501-0600/0511-0520/#514-freedom-trail-starstarstar","text":"class Solution : def findRotateSteps ( self , ring : str , key : str ) -> int : def dfs ( ring : str , index : int ) -> int : if index == len ( key ): return 0 if ( ring , index ) in memo : return memo [( ring , index )] ans = float ( 'inf' ) for i , r in enumerate ( ring ): if r == key [ index ]: diff = min ( i , len ( ring ) - i ) step = dfs ( ring [ i :] + ring [: i ], index + 1 ) ans = min ( ans , diff + step ) memo [( ring , index )] = ans return ans memo = {} return dfs ( ring , 0 ) + len ( key )","title":"514. Freedom Trail $\\star\\star\\star$"},{"location":"python3/0501-0600/0511-0520/#515-find-largest-value-in-each-tree-row-starstar","text":"class Solution : def largestValues ( self , root : TreeNode ) -> List [ int ]: if not root : return [] ans = [] queue = collections . deque ([ root ]) while queue : maxi = float ( '-inf' ) for _ in range ( len ( queue )): root = queue . popleft () maxi = max ( maxi , root . val ) if root . left : queue . append ( root . left ) if root . right : queue . append ( root . right ) ans . append ( maxi ) return ans","title":"515. Find Largest Value in Each Tree Row $\\star\\star$"},{"location":"python3/0501-0600/0511-0520/#516-longest-palindromic-subsequence-starstar","text":"","title":"516. Longest Palindromic Subsequence $\\star\\star$"},{"location":"python3/0501-0600/0511-0520/#517-super-washing-machines-starstarstar","text":"class Solution : def findMinMoves ( self , machines : List [ int ]) -> int : dresses = sum ( machines ) if dresses % len ( machines ) != 0 : return - 1 ans = 0 average = dresses // len ( machines ) inout = 0 for dress in machines : inout += dress - average ans = max ( ans , abs ( inout ), dress - average ) return ans","title":"517. Super Washing Machines $\\star\\star\\star$"},{"location":"python3/0501-0600/0511-0520/#518-coin-change-2-starstar","text":"Time: $O(nk)$, where n = len(coins) and k = target Space: $O(k)$ class Solution : def change ( self , amount : int , coins : List [ int ]) -> int : dp = [ 1 ] + [ 0 ] * amount for coin in coins : for i in range ( coin , amount + 1 ): dp [ i ] += dp [ i - coin ] return dp [ amount ]","title":"518. Coin Change 2 $\\star\\star$"},{"location":"python3/0501-0600/0511-0520/#519-random-flip-matrix-starstar","text":"","title":"519. Random Flip Matrix $\\star\\star$"},{"location":"python3/0501-0600/0511-0520/#520-detect-capital-star","text":"class Solution : def detectCapitalUse ( self , word : str ) -> bool : return word . isupper () or word . islower () or word . istitle ()","title":"520. Detect Capital $\\star$"},{"location":"python3/0501-0600/0521-0530/","text":"521. Longest Uncommon Subsequence I $\\star$ class Solution : def findLUSlength ( self , a : str , b : str ) -> int : return - 1 if a == b else max ( len ( a ), len ( b )) 522. Longest Uncommon Subsequence II $\\star\\star$ class Solution : def findLUSlength ( self , strs : List [ str ]) -> int : def isSubsequence ( a : str , b : str ) -> bool : i = 0 j = 0 while i < len ( a ) and j < len ( b ): if a [ i ] == b [ j ]: i += 1 j += 1 return i == len ( a ) seen = set () duplicates = set () for s in strs : if s in seen : duplicates . add ( s ) seen . add ( s ) strs . sort ( key = lambda s : - len ( s )) for i in range ( len ( strs )): if strs [ i ] in duplicates : continue isASubsequence = False for j in range ( i ): isASubsequence |= isSubsequence ( strs [ i ], strs [ j ]) if not isASubsequence : return len ( strs [ i ]) return - 1 523. Continuous Subarray Sum $\\star\\star$ class Solution : def checkSubarraySum ( self , nums : List [ int ], k : int ) -> bool : prefixSum = 0 prefixSumToIndex = { 0 : - 1 } for i , num in enumerate ( nums ): prefixSum += num if k != 0 : prefixSum %= k if prefixSum in prefixSumToIndex : if i - prefixSumToIndex [ prefixSum ] > 1 : return True else : prefixSumToIndex [ prefixSum ] = i return False 524. Longest Word in Dictionary through Deleting $\\star\\star$ class Solution : def findLongestWord ( self , s : str , d : List [ str ]) -> str : ans = '' for word in d : i = 0 for c in s : if i < len ( word ) and c == word [ i ]: i += 1 if i == len ( word ): if len ( word ) > len ( ans ) or len ( word ) == len ( ans ) and word < ans : ans = word return ans 525. Contiguous Array $\\star\\star$ class Solution : def findMaxLength ( self , nums : List [ int ]) -> int : ans = 0 prefixSum = 0 prefixSumToIndex = { 0 : - 1 } for i , num in enumerate ( nums ): prefixSum += 1 if num else - 1 if prefixSum in prefixSumToIndex : ans = max ( ans , i - prefixSumToIndex [ prefixSum ]) else : prefixSumToIndex [ prefixSum ] = i return ans 526. Beautiful Arrangement $\\star\\star$ 527. Word Abbreviation $\\star\\star\\star$ \ud83d\udd12 528. Random Pick with Weight $\\star\\star$ 529. Minesweeper $\\star\\star$ class Solution : def updateBoard ( self , board : List [ List [ str ]], click : List [ int ]) -> List [ List [ str ]]: def dfs ( i : int , j : int ) -> None : if not 0 <= i < len ( board ) or not 0 <= j < len ( board [ 0 ]) or board [ i ][ j ] != 'E' : return minesCount = 0 for dx , dy in dirs : x = i + dx y = j + dy if 0 <= x < len ( board ) and 0 <= y < len ( board [ 0 ]) and board [ x ][ y ] == 'M' : minesCount += 1 board [ i ][ j ] = str ( minesCount ) if minesCount > 0 else 'B' if minesCount == 0 : for dx , dy in dirs : dfs ( i + dx , j + dy ) if board [ click [ 0 ]][ click [ 1 ]] == 'M' : board [ click [ 0 ]][ click [ 1 ]] = 'X' return board dirs = [( - 1 , - 1 ), ( - 1 , 0 ), ( - 1 , 1 ), ( 0 , - 1 ), ( 0 , 1 ), ( 1 , - 1 ), ( 1 , 0 ), ( 1 , 1 )] dfs ( click [ 0 ], click [ 1 ]) return board 530. Minimum Absolute Difference in BST $\\star$","title":"0521-0530"},{"location":"python3/0501-0600/0521-0530/#521-longest-uncommon-subsequence-i-star","text":"class Solution : def findLUSlength ( self , a : str , b : str ) -> int : return - 1 if a == b else max ( len ( a ), len ( b ))","title":"521. Longest Uncommon Subsequence I  $\\star$"},{"location":"python3/0501-0600/0521-0530/#522-longest-uncommon-subsequence-ii-starstar","text":"class Solution : def findLUSlength ( self , strs : List [ str ]) -> int : def isSubsequence ( a : str , b : str ) -> bool : i = 0 j = 0 while i < len ( a ) and j < len ( b ): if a [ i ] == b [ j ]: i += 1 j += 1 return i == len ( a ) seen = set () duplicates = set () for s in strs : if s in seen : duplicates . add ( s ) seen . add ( s ) strs . sort ( key = lambda s : - len ( s )) for i in range ( len ( strs )): if strs [ i ] in duplicates : continue isASubsequence = False for j in range ( i ): isASubsequence |= isSubsequence ( strs [ i ], strs [ j ]) if not isASubsequence : return len ( strs [ i ]) return - 1","title":"522. Longest Uncommon Subsequence II $\\star\\star$"},{"location":"python3/0501-0600/0521-0530/#523-continuous-subarray-sum-starstar","text":"class Solution : def checkSubarraySum ( self , nums : List [ int ], k : int ) -> bool : prefixSum = 0 prefixSumToIndex = { 0 : - 1 } for i , num in enumerate ( nums ): prefixSum += num if k != 0 : prefixSum %= k if prefixSum in prefixSumToIndex : if i - prefixSumToIndex [ prefixSum ] > 1 : return True else : prefixSumToIndex [ prefixSum ] = i return False","title":"523. Continuous Subarray Sum $\\star\\star$"},{"location":"python3/0501-0600/0521-0530/#524-longest-word-in-dictionary-through-deleting-starstar","text":"class Solution : def findLongestWord ( self , s : str , d : List [ str ]) -> str : ans = '' for word in d : i = 0 for c in s : if i < len ( word ) and c == word [ i ]: i += 1 if i == len ( word ): if len ( word ) > len ( ans ) or len ( word ) == len ( ans ) and word < ans : ans = word return ans","title":"524. Longest Word in Dictionary through Deleting $\\star\\star$"},{"location":"python3/0501-0600/0521-0530/#525-contiguous-array-starstar","text":"class Solution : def findMaxLength ( self , nums : List [ int ]) -> int : ans = 0 prefixSum = 0 prefixSumToIndex = { 0 : - 1 } for i , num in enumerate ( nums ): prefixSum += 1 if num else - 1 if prefixSum in prefixSumToIndex : ans = max ( ans , i - prefixSumToIndex [ prefixSum ]) else : prefixSumToIndex [ prefixSum ] = i return ans","title":"525. Contiguous Array $\\star\\star$"},{"location":"python3/0501-0600/0521-0530/#526-beautiful-arrangement-starstar","text":"","title":"526. Beautiful Arrangement $\\star\\star$"},{"location":"python3/0501-0600/0521-0530/#527-word-abbreviation-starstarstar","text":"","title":"527. Word Abbreviation $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/0501-0600/0521-0530/#528-random-pick-with-weight-starstar","text":"","title":"528. Random Pick with Weight $\\star\\star$"},{"location":"python3/0501-0600/0521-0530/#529-minesweeper-starstar","text":"class Solution : def updateBoard ( self , board : List [ List [ str ]], click : List [ int ]) -> List [ List [ str ]]: def dfs ( i : int , j : int ) -> None : if not 0 <= i < len ( board ) or not 0 <= j < len ( board [ 0 ]) or board [ i ][ j ] != 'E' : return minesCount = 0 for dx , dy in dirs : x = i + dx y = j + dy if 0 <= x < len ( board ) and 0 <= y < len ( board [ 0 ]) and board [ x ][ y ] == 'M' : minesCount += 1 board [ i ][ j ] = str ( minesCount ) if minesCount > 0 else 'B' if minesCount == 0 : for dx , dy in dirs : dfs ( i + dx , j + dy ) if board [ click [ 0 ]][ click [ 1 ]] == 'M' : board [ click [ 0 ]][ click [ 1 ]] = 'X' return board dirs = [( - 1 , - 1 ), ( - 1 , 0 ), ( - 1 , 1 ), ( 0 , - 1 ), ( 0 , 1 ), ( 1 , - 1 ), ( 1 , 0 ), ( 1 , 1 )] dfs ( click [ 0 ], click [ 1 ]) return board","title":"529. Minesweeper $\\star\\star$"},{"location":"python3/0501-0600/0521-0530/#530-minimum-absolute-difference-in-bst-star","text":"","title":"530. Minimum Absolute Difference in BST $\\star$"},{"location":"python3/0501-0600/0531-0540/","text":"531. Lonely Pixel I $\\star\\star$ \ud83d\udd12 532. K-diff Pairs in an Array $\\star$ class Solution : def findPairs ( self , nums : List [ int ], k : int ) -> int : if k < 0 : return 0 ans = 0 dict = { num : i for i , num in enumerate ( nums )} for i , num in enumerate ( nums ): target = num + k if target in dict and dict [ target ] != i : ans += 1 del dict [ target ] return ans 533. Lonely Pixel II $\\star\\star$ \ud83d\udd12 534. Game Play Analysis III $\\star\\star$ \ud83d\udd12 535. Encode and Decode TinyURL $\\star\\star$ class Codec : alphabets = string . ascii_letters + '0123456789' urlToCode = {} codeToUrl = {} def encode ( self , longUrl : str ) -> str : while longUrl not in self . urlToCode : code = '' . join ( random . choice ( self . alphabets ) for _ in range ( 6 )) if code not in self . codeToUrl : self . codeToUrl [ code ] = longUrl self . urlToCode [ longUrl ] = code return 'http://tinyurl.com/' + self . urlToCode [ longUrl ] def decode ( self , shortUrl : str ) -> str : return self . codeToUrl [ shortUrl [ - 6 :]] 536. Construct Binary Tree from String $\\star\\star$ \ud83d\udd12 537. Complex Number Multiplication $\\star\\star$ class Solution : def complexNumberMultiply ( self , a : str , b : str ) -> str : def getRealAndImag ( s : str ) -> tuple : return int ( s [: s . index ( '+' )]), int ( s [ s . index ( '+' ) + 1 : - 1 ]) A , B = getRealAndImag ( a ) C , D = getRealAndImag ( b ) return str ( A * C - B * D ) + '+' + str ( A * D + B * C ) + 'i' 538. Convert BST to Greater Tree $\\star$ 539. Minimum Time Difference $\\star\\star$ class Solution : def findMinDifference ( self , timePoints : List [ str ]) -> int : ans = 24 * 60 nums = sorted ([ int ( timePoint [: 2 ]) * 60 + int ( timePoint [ 3 :]) for timePoint in timePoints ]) for a , b in zip ( nums , nums [ 1 :]): ans = min ( ans , b - a ) return min ( ans , 24 * 60 - nums [ - 1 ] + nums [ 0 ]) 540. Single Element in a Sorted Array $\\star\\star$ class Solution : def singleNonDuplicate ( self , nums : List [ int ]) -> int : l = 0 r = len ( nums ) - 1 while l < r : m = ( l + r ) // 2 if m % 2 == 1 : m -= 1 if nums [ m ] == nums [ m + 1 ]: l = m + 2 else : r = m return nums [ l ]","title":"0531-0540"},{"location":"python3/0501-0600/0531-0540/#531-lonely-pixel-i-starstar","text":"","title":"531. Lonely Pixel I $\\star\\star$ \ud83d\udd12"},{"location":"python3/0501-0600/0531-0540/#532-k-diff-pairs-in-an-array-star","text":"class Solution : def findPairs ( self , nums : List [ int ], k : int ) -> int : if k < 0 : return 0 ans = 0 dict = { num : i for i , num in enumerate ( nums )} for i , num in enumerate ( nums ): target = num + k if target in dict and dict [ target ] != i : ans += 1 del dict [ target ] return ans","title":"532. K-diff Pairs in an Array $\\star$"},{"location":"python3/0501-0600/0531-0540/#533-lonely-pixel-ii-starstar","text":"","title":"533. Lonely Pixel II $\\star\\star$ \ud83d\udd12"},{"location":"python3/0501-0600/0531-0540/#534-game-play-analysis-iii-starstar","text":"","title":"534. Game Play Analysis III $\\star\\star$ \ud83d\udd12"},{"location":"python3/0501-0600/0531-0540/#535-encode-and-decode-tinyurl-starstar","text":"class Codec : alphabets = string . ascii_letters + '0123456789' urlToCode = {} codeToUrl = {} def encode ( self , longUrl : str ) -> str : while longUrl not in self . urlToCode : code = '' . join ( random . choice ( self . alphabets ) for _ in range ( 6 )) if code not in self . codeToUrl : self . codeToUrl [ code ] = longUrl self . urlToCode [ longUrl ] = code return 'http://tinyurl.com/' + self . urlToCode [ longUrl ] def decode ( self , shortUrl : str ) -> str : return self . codeToUrl [ shortUrl [ - 6 :]]","title":"535. Encode and Decode TinyURL $\\star\\star$"},{"location":"python3/0501-0600/0531-0540/#536-construct-binary-tree-from-string-starstar","text":"","title":"536. Construct Binary Tree from String $\\star\\star$ \ud83d\udd12"},{"location":"python3/0501-0600/0531-0540/#537-complex-number-multiplication-starstar","text":"class Solution : def complexNumberMultiply ( self , a : str , b : str ) -> str : def getRealAndImag ( s : str ) -> tuple : return int ( s [: s . index ( '+' )]), int ( s [ s . index ( '+' ) + 1 : - 1 ]) A , B = getRealAndImag ( a ) C , D = getRealAndImag ( b ) return str ( A * C - B * D ) + '+' + str ( A * D + B * C ) + 'i'","title":"537. Complex Number Multiplication $\\star\\star$"},{"location":"python3/0501-0600/0531-0540/#538-convert-bst-to-greater-tree-star","text":"","title":"538. Convert BST to Greater Tree $\\star$"},{"location":"python3/0501-0600/0531-0540/#539-minimum-time-difference-starstar","text":"class Solution : def findMinDifference ( self , timePoints : List [ str ]) -> int : ans = 24 * 60 nums = sorted ([ int ( timePoint [: 2 ]) * 60 + int ( timePoint [ 3 :]) for timePoint in timePoints ]) for a , b in zip ( nums , nums [ 1 :]): ans = min ( ans , b - a ) return min ( ans , 24 * 60 - nums [ - 1 ] + nums [ 0 ])","title":"539. Minimum Time Difference $\\star\\star$"},{"location":"python3/0501-0600/0531-0540/#540-single-element-in-a-sorted-array-starstar","text":"class Solution : def singleNonDuplicate ( self , nums : List [ int ]) -> int : l = 0 r = len ( nums ) - 1 while l < r : m = ( l + r ) // 2 if m % 2 == 1 : m -= 1 if nums [ m ] == nums [ m + 1 ]: l = m + 2 else : r = m return nums [ l ]","title":"540. Single Element in a Sorted Array $\\star\\star$"},{"location":"python3/0501-0600/0541-0550/","text":"541. Reverse String II $\\star$ class Solution : def reverseStr ( self , s : str , k : int ) -> str : return s [: k ][:: - 1 ] + s [ k : 2 * k ] + self . reverseStr ( s [ 2 * k :], k ) if s else \"\" 542. 01 Matrix $\\star\\star$ class Solution : def updateMatrix ( self , matrix : List [ List [ int ]]) -> List [ List [ int ]]: dirs = [ 0 , 1 , 0 , - 1 , 0 ] queue = collections . deque () for i in range ( len ( matrix )): for j in range ( len ( matrix [ 0 ])): if matrix [ i ][ j ] == 0 : queue . append ([ i , j ]) else : matrix [ i ][ j ] = float ( 'inf' ) while queue : i , j = queue . popleft () for k in range ( 4 ): x = i + dirs [ k ] y = j + dirs [ k + 1 ] if x < 0 or x >= len ( matrix ) or y < 0 or y >= len ( matrix [ 0 ]) or matrix [ x ][ y ] <= matrix [ i ][ j ] + 1 : continue queue . append ([ x , y ]) matrix [ x ][ y ] = matrix [ i ][ j ] + 1 return matrix 543. Diameter of Binary Tree $\\star$ 544. Output Contest Matches $\\star\\star$ \ud83d\udd12 545. Boundary of Binary Tree $\\star\\star$ \ud83d\udd12 546. Remove Boxes $\\star\\star\\star$ 547. Friend Circles $\\star\\star$ class Solution : def findCircleNum ( self , M : List [ List [ int ]]) -> int : n = len ( M ) uf = UF ( n ) friendCircle = set () for i in range ( n ): for j in range ( i , n ): if M [ i ][ j ] == 1 : uf . union ( i , j ) for i in range ( n ): friendCircle . add ( uf . find ( i )) return len ( friendCircle ) class UF : def __init__ ( self , n : int ): self . rank = [ 0 ] * ( n + 1 ) self . parent = [ i for i in range ( n + 1 )] def union ( self , u : int , v : int ) -> None : pu = self . find ( u ) pv = self . find ( v ) if pu == pv : return if self . rank [ pu ] < self . rank [ pv ]: self . parent [ pu ] = pv elif self . rank [ pv ] < self . rank [ pu ]: self . parent [ pv ] = pu else : self . parent [ pu ] = pv self . rank [ pv ] += 1 def find ( self , u : int ) -> int : while u != self . parent [ u ]: self . parent [ u ] = self . parent [ self . parent [ u ]] u = self . parent [ u ] return u 548. Split Array with Equal Sum $\\star\\star$ \ud83d\udd12 549. Binary Tree Longest Consecutive Sequence II $\\star\\star$ \ud83d\udd12 550. Game Play Analysis IV $\\star\\star$ \ud83d\udd12","title":"0541-0550"},{"location":"python3/0501-0600/0541-0550/#541-reverse-string-ii-star","text":"class Solution : def reverseStr ( self , s : str , k : int ) -> str : return s [: k ][:: - 1 ] + s [ k : 2 * k ] + self . reverseStr ( s [ 2 * k :], k ) if s else \"\"","title":"541. Reverse String II $\\star$"},{"location":"python3/0501-0600/0541-0550/#542-01-matrix-starstar","text":"class Solution : def updateMatrix ( self , matrix : List [ List [ int ]]) -> List [ List [ int ]]: dirs = [ 0 , 1 , 0 , - 1 , 0 ] queue = collections . deque () for i in range ( len ( matrix )): for j in range ( len ( matrix [ 0 ])): if matrix [ i ][ j ] == 0 : queue . append ([ i , j ]) else : matrix [ i ][ j ] = float ( 'inf' ) while queue : i , j = queue . popleft () for k in range ( 4 ): x = i + dirs [ k ] y = j + dirs [ k + 1 ] if x < 0 or x >= len ( matrix ) or y < 0 or y >= len ( matrix [ 0 ]) or matrix [ x ][ y ] <= matrix [ i ][ j ] + 1 : continue queue . append ([ x , y ]) matrix [ x ][ y ] = matrix [ i ][ j ] + 1 return matrix","title":"542. 01 Matrix $\\star\\star$"},{"location":"python3/0501-0600/0541-0550/#543-diameter-of-binary-tree-star","text":"","title":"543. Diameter of Binary Tree $\\star$"},{"location":"python3/0501-0600/0541-0550/#544-output-contest-matches-starstar","text":"","title":"544. Output Contest Matches $\\star\\star$ \ud83d\udd12"},{"location":"python3/0501-0600/0541-0550/#545-boundary-of-binary-tree-starstar","text":"","title":"545. Boundary of Binary Tree $\\star\\star$ \ud83d\udd12"},{"location":"python3/0501-0600/0541-0550/#546-remove-boxes-starstarstar","text":"","title":"546. Remove Boxes $\\star\\star\\star$"},{"location":"python3/0501-0600/0541-0550/#547-friend-circles-starstar","text":"class Solution : def findCircleNum ( self , M : List [ List [ int ]]) -> int : n = len ( M ) uf = UF ( n ) friendCircle = set () for i in range ( n ): for j in range ( i , n ): if M [ i ][ j ] == 1 : uf . union ( i , j ) for i in range ( n ): friendCircle . add ( uf . find ( i )) return len ( friendCircle ) class UF : def __init__ ( self , n : int ): self . rank = [ 0 ] * ( n + 1 ) self . parent = [ i for i in range ( n + 1 )] def union ( self , u : int , v : int ) -> None : pu = self . find ( u ) pv = self . find ( v ) if pu == pv : return if self . rank [ pu ] < self . rank [ pv ]: self . parent [ pu ] = pv elif self . rank [ pv ] < self . rank [ pu ]: self . parent [ pv ] = pu else : self . parent [ pu ] = pv self . rank [ pv ] += 1 def find ( self , u : int ) -> int : while u != self . parent [ u ]: self . parent [ u ] = self . parent [ self . parent [ u ]] u = self . parent [ u ] return u","title":"547. Friend Circles $\\star\\star$"},{"location":"python3/0501-0600/0541-0550/#548-split-array-with-equal-sum-starstar","text":"","title":"548. Split Array with Equal Sum $\\star\\star$ \ud83d\udd12"},{"location":"python3/0501-0600/0541-0550/#549-binary-tree-longest-consecutive-sequence-ii-starstar","text":"","title":"549. Binary Tree Longest Consecutive Sequence II $\\star\\star$ \ud83d\udd12"},{"location":"python3/0501-0600/0541-0550/#550-game-play-analysis-iv-starstar","text":"","title":"550. Game Play Analysis IV $\\star\\star$ \ud83d\udd12"},{"location":"python3/0501-0600/0551-0560/","text":"551. Student Attendance Record I $\\star$ class Solution : def checkRecord ( self , s : str ) -> bool : return s . count ( 'A' ) <= 1 and 'LLL' not in s 552. Student Attendance Record II $\\star\\star\\star$ 553. Optimal Division $\\star\\star$ class Solution : def optimalDivision ( self , nums : List [ int ]) -> str : ans = str ( nums [ 0 ]) if len ( nums ) == 1 : return ans if len ( nums ) == 2 : return ans + '/' + str ( nums [ 1 ]) ans += '/(' + str ( nums [ 1 ]) for i in range ( 2 , len ( nums )): ans += '/' + str ( nums [ i ]) ans += ')' return ans 554. Brick Wall $\\star\\star$ class Solution : def leastBricks ( self , wall : List [ List [ int ]]) -> int : maxFreq = 0 count = collections . defaultdict ( int ) for row in wall : prefixSum = 0 for i in range ( len ( row ) - 1 ): prefixSum += row [ i ] count [ prefixSum ] += 1 maxFreq = max ( maxFreq , count [ prefixSum ]) return len ( wall ) - maxFreq 555. Split Concatenated Strings $\\star\\star$ \ud83d\udd12 556. Next Greater Element III $\\star\\star$ class Solution : def nextGreaterElement ( self , n : int ) -> int : def nextPermutation ( s : List [ chr ]) -> str : i = len ( s ) - 2 while i >= 0 : if s [ i ] < s [ i + 1 ]: break i -= 1 if i >= 0 : for j in range ( len ( s ) - 1 , i , - 1 ): if s [ j ] > s [ i ]: break s [ i ], s [ j ] = s [ j ], s [ i ] reverse ( s , i + 1 , len ( s ) - 1 ) return '' . join ( s ) def reverse ( s : List [ chr ], l : int , r : int ): while l < r : s [ l ], s [ r ] = s [ r ], s [ l ] l += 1 r -= 1 s = nextPermutation ( list ( str ( n ))) ans = int ( s ) return - 1 if ans > 2 ** 31 - 1 or ans <= n else ans 557. Reverse Words in a String III $\\star$ 558. Logical OR of Two Binary Grids Represented as Quad-Trees $\\star\\star$ 559. Maximum Depth of N-ary Tree $\\star$ class Solution : def maxDepth ( self , root : 'Node' ) -> int : if not root : return 0 if not root . children : return 1 return 1 + max ( self . maxDepth ( child ) for child in root . children ) 560. Subarray Sum Equals K $\\star\\star$ class Solution : def subarraySum ( self , nums : List [ int ], k : int ) -> int : ans = 0 sum = 0 count = collections . Counter () count [ 0 ] = 1 for num in nums : sum += num ans += count [ sum - k ] count [ sum ] += 1 return ans","title":"0551-0560"},{"location":"python3/0501-0600/0551-0560/#551-student-attendance-record-i-star","text":"class Solution : def checkRecord ( self , s : str ) -> bool : return s . count ( 'A' ) <= 1 and 'LLL' not in s","title":"551. Student Attendance Record I $\\star$"},{"location":"python3/0501-0600/0551-0560/#552-student-attendance-record-ii-starstarstar","text":"","title":"552. Student Attendance Record II $\\star\\star\\star$"},{"location":"python3/0501-0600/0551-0560/#553-optimal-division-starstar","text":"class Solution : def optimalDivision ( self , nums : List [ int ]) -> str : ans = str ( nums [ 0 ]) if len ( nums ) == 1 : return ans if len ( nums ) == 2 : return ans + '/' + str ( nums [ 1 ]) ans += '/(' + str ( nums [ 1 ]) for i in range ( 2 , len ( nums )): ans += '/' + str ( nums [ i ]) ans += ')' return ans","title":"553. Optimal Division $\\star\\star$"},{"location":"python3/0501-0600/0551-0560/#554-brick-wall-starstar","text":"class Solution : def leastBricks ( self , wall : List [ List [ int ]]) -> int : maxFreq = 0 count = collections . defaultdict ( int ) for row in wall : prefixSum = 0 for i in range ( len ( row ) - 1 ): prefixSum += row [ i ] count [ prefixSum ] += 1 maxFreq = max ( maxFreq , count [ prefixSum ]) return len ( wall ) - maxFreq","title":"554. Brick Wall $\\star\\star$"},{"location":"python3/0501-0600/0551-0560/#555-split-concatenated-strings-starstar","text":"","title":"555. Split Concatenated Strings $\\star\\star$ \ud83d\udd12"},{"location":"python3/0501-0600/0551-0560/#556-next-greater-element-iii-starstar","text":"class Solution : def nextGreaterElement ( self , n : int ) -> int : def nextPermutation ( s : List [ chr ]) -> str : i = len ( s ) - 2 while i >= 0 : if s [ i ] < s [ i + 1 ]: break i -= 1 if i >= 0 : for j in range ( len ( s ) - 1 , i , - 1 ): if s [ j ] > s [ i ]: break s [ i ], s [ j ] = s [ j ], s [ i ] reverse ( s , i + 1 , len ( s ) - 1 ) return '' . join ( s ) def reverse ( s : List [ chr ], l : int , r : int ): while l < r : s [ l ], s [ r ] = s [ r ], s [ l ] l += 1 r -= 1 s = nextPermutation ( list ( str ( n ))) ans = int ( s ) return - 1 if ans > 2 ** 31 - 1 or ans <= n else ans","title":"556. Next Greater Element III $\\star\\star$"},{"location":"python3/0501-0600/0551-0560/#557-reverse-words-in-a-string-iii-star","text":"","title":"557. Reverse Words in a String III $\\star$"},{"location":"python3/0501-0600/0551-0560/#558-logical-or-of-two-binary-grids-represented-as-quad-trees-starstar","text":"","title":"558. Logical OR of Two Binary Grids Represented as Quad-Trees $\\star\\star$"},{"location":"python3/0501-0600/0551-0560/#559-maximum-depth-of-n-ary-tree-star","text":"class Solution : def maxDepth ( self , root : 'Node' ) -> int : if not root : return 0 if not root . children : return 1 return 1 + max ( self . maxDepth ( child ) for child in root . children )","title":"559. Maximum Depth of N-ary Tree $\\star$"},{"location":"python3/0501-0600/0551-0560/#560-subarray-sum-equals-k-starstar","text":"class Solution : def subarraySum ( self , nums : List [ int ], k : int ) -> int : ans = 0 sum = 0 count = collections . Counter () count [ 0 ] = 1 for num in nums : sum += num ans += count [ sum - k ] count [ sum ] += 1 return ans","title":"560. Subarray Sum Equals K $\\star\\star$"},{"location":"python3/0501-0600/0561-0570/","text":"561. Array Partition I $\\star$ class Solution : def arrayPairSum ( self , nums : List [ int ]) -> int : return sum ( sorted ( nums )[:: 2 ]) 562. Longest Line of Consecutive One in Matrix $\\star\\star$ \ud83d\udd12 563. Binary Tree Tilt $\\star$ 564. Find the Closest Palindrome $\\star\\star\\star$ class Solution : def nearestPalindromic ( self , n : str ) -> str : def getPalindromes ( s : str ) -> tuple : num = int ( s ) k = len ( s ) palindromes = [] half = s [ 0 :( k + 1 ) // 2 ] reversedHalf = half [: k // 2 ][:: - 1 ] candidate = int ( half + reversedHalf ) if candidate < num : palindromes . append ( candidate ) else : prevHalf = str ( int ( half ) - 1 ) reversedPrevHalf = prevHalf [: k // 2 ][:: - 1 ] if k % 2 == 0 and int ( prevHalf ) == 0 : palindromes . append ( 9 ) elif k % 2 == 0 and ( int ( prevHalf ) + 1 ) % 10 == 0 : palindromes . append ( int ( prevHalf + '9' + reversedPrevHalf )) else : palindromes . append ( int ( prevHalf + reversedPrevHalf )) if candidate > num : palindromes . append ( candidate ) else : nextHalf = str ( int ( half ) + 1 ) reversedNextHalf = nextHalf [: k // 2 ][:: - 1 ] palindromes . append ( int ( nextHalf + reversedNextHalf )) return palindromes prevPalindrome , nextPalindrome = getPalindromes ( n ) return str ( prevPalindrome ) if abs ( prevPalindrome - int ( n )) <= abs ( nextPalindrome - int ( n )) else str ( nextPalindrome ) 565. Array Nesting $\\star\\star$ class Solution : def arrayNesting ( self , nums : List [ int ]) -> int : ans = 0 for num in nums : if num == - 1 : continue index = num count = 0 while nums [ index ] != - 1 : temp = index index = nums [ index ] nums [ temp ] = - 1 count += 1 ans = max ( ans , count ) return ans 566. Reshape the Matrix $\\star$ class Solution : def matrixReshape ( self , nums : List [ List [ int ]], r : int , c : int ) -> List [ List [ int ]]: if nums == [] or r * c != len ( nums ) * len ( nums [ 0 ]): return nums ans = [[ 0 for j in range ( c )] for i in range ( r )] k = 0 for row in nums : for num in row : ans [ k // c ][ k % c ] = num k += 1 return ans 567. Permutation in String $\\star\\star$ class Solution : def checkInclusion ( self , s1 : str , s2 : str ) -> bool : count1 = collections . Counter ( s1 ) required = len ( s1 ) for r , c in enumerate ( s2 ): count1 [ c ] -= 1 if count1 [ c ] >= 0 : required -= 1 if r >= len ( s1 ): count1 [ s2 [ r - len ( s1 )]] += 1 if count1 [ s2 [ r - len ( s1 )]] > 0 : required += 1 if required == 0 : return True return False 568. Maximum Vacation Days $\\star\\star\\star$ \ud83d\udd12 569. Median Employee Salary $\\star\\star\\star$ \ud83d\udd12 570. Managers with at Least 5 Direct Reports $\\star\\star$ \ud83d\udd12","title":"0561-0570"},{"location":"python3/0501-0600/0561-0570/#561-array-partition-i-star","text":"class Solution : def arrayPairSum ( self , nums : List [ int ]) -> int : return sum ( sorted ( nums )[:: 2 ])","title":"561. Array Partition I $\\star$"},{"location":"python3/0501-0600/0561-0570/#562-longest-line-of-consecutive-one-in-matrix-starstar","text":"","title":"562. Longest Line of Consecutive One in Matrix $\\star\\star$ \ud83d\udd12"},{"location":"python3/0501-0600/0561-0570/#563-binary-tree-tilt-star","text":"","title":"563. Binary Tree Tilt $\\star$"},{"location":"python3/0501-0600/0561-0570/#564-find-the-closest-palindrome-starstarstar","text":"class Solution : def nearestPalindromic ( self , n : str ) -> str : def getPalindromes ( s : str ) -> tuple : num = int ( s ) k = len ( s ) palindromes = [] half = s [ 0 :( k + 1 ) // 2 ] reversedHalf = half [: k // 2 ][:: - 1 ] candidate = int ( half + reversedHalf ) if candidate < num : palindromes . append ( candidate ) else : prevHalf = str ( int ( half ) - 1 ) reversedPrevHalf = prevHalf [: k // 2 ][:: - 1 ] if k % 2 == 0 and int ( prevHalf ) == 0 : palindromes . append ( 9 ) elif k % 2 == 0 and ( int ( prevHalf ) + 1 ) % 10 == 0 : palindromes . append ( int ( prevHalf + '9' + reversedPrevHalf )) else : palindromes . append ( int ( prevHalf + reversedPrevHalf )) if candidate > num : palindromes . append ( candidate ) else : nextHalf = str ( int ( half ) + 1 ) reversedNextHalf = nextHalf [: k // 2 ][:: - 1 ] palindromes . append ( int ( nextHalf + reversedNextHalf )) return palindromes prevPalindrome , nextPalindrome = getPalindromes ( n ) return str ( prevPalindrome ) if abs ( prevPalindrome - int ( n )) <= abs ( nextPalindrome - int ( n )) else str ( nextPalindrome )","title":"564. Find the Closest Palindrome $\\star\\star\\star$"},{"location":"python3/0501-0600/0561-0570/#565-array-nesting-starstar","text":"class Solution : def arrayNesting ( self , nums : List [ int ]) -> int : ans = 0 for num in nums : if num == - 1 : continue index = num count = 0 while nums [ index ] != - 1 : temp = index index = nums [ index ] nums [ temp ] = - 1 count += 1 ans = max ( ans , count ) return ans","title":"565. Array Nesting $\\star\\star$"},{"location":"python3/0501-0600/0561-0570/#566-reshape-the-matrix-star","text":"class Solution : def matrixReshape ( self , nums : List [ List [ int ]], r : int , c : int ) -> List [ List [ int ]]: if nums == [] or r * c != len ( nums ) * len ( nums [ 0 ]): return nums ans = [[ 0 for j in range ( c )] for i in range ( r )] k = 0 for row in nums : for num in row : ans [ k // c ][ k % c ] = num k += 1 return ans","title":"566. Reshape the Matrix $\\star$"},{"location":"python3/0501-0600/0561-0570/#567-permutation-in-string-starstar","text":"class Solution : def checkInclusion ( self , s1 : str , s2 : str ) -> bool : count1 = collections . Counter ( s1 ) required = len ( s1 ) for r , c in enumerate ( s2 ): count1 [ c ] -= 1 if count1 [ c ] >= 0 : required -= 1 if r >= len ( s1 ): count1 [ s2 [ r - len ( s1 )]] += 1 if count1 [ s2 [ r - len ( s1 )]] > 0 : required += 1 if required == 0 : return True return False","title":"567. Permutation in String $\\star\\star$"},{"location":"python3/0501-0600/0561-0570/#568-maximum-vacation-days-starstarstar","text":"","title":"568. Maximum Vacation Days $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/0501-0600/0561-0570/#569-median-employee-salary-starstarstar","text":"","title":"569. Median Employee Salary $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/0501-0600/0561-0570/#570-managers-with-at-least-5-direct-reports-starstar","text":"","title":"570. Managers with at Least 5 Direct Reports $\\star\\star$ \ud83d\udd12"},{"location":"python3/0501-0600/0571-0580/","text":"571. Find Median Given Frequency of Numbers $\\star\\star\\star$ \ud83d\udd12 572. Subtree of Another Tree $\\star$ 573. Squirrel Simulation $\\star\\star$ \ud83d\udd12 574. Winning Candidate $\\star\\star$ \ud83d\udd12 575. Distribute Candies $\\star$ class Solution : def distributeCandies ( self , candies : List [ int ]) -> int : return min ( len ( candies ) // 2 , len ( set ( candies ))) 576. Out of Boundary Paths $\\star\\star$ 577. Employee Bonus $\\star$ \ud83d\udd12 578. Get Highest Answer Rate Question $\\star\\star$ \ud83d\udd12 579. Find Cumulative Salary of an Employee $\\star\\star\\star$ \ud83d\udd12 580. Count Student Number in Departments $\\star\\star$ \ud83d\udd12","title":"0571-0580"},{"location":"python3/0501-0600/0571-0580/#571-find-median-given-frequency-of-numbers-starstarstar","text":"","title":"571. Find Median Given Frequency of Numbers $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/0501-0600/0571-0580/#572-subtree-of-another-tree-star","text":"","title":"572. Subtree of Another Tree $\\star$"},{"location":"python3/0501-0600/0571-0580/#573-squirrel-simulation-starstar","text":"","title":"573. Squirrel Simulation $\\star\\star$ \ud83d\udd12"},{"location":"python3/0501-0600/0571-0580/#574-winning-candidate-starstar","text":"","title":"574. Winning Candidate $\\star\\star$ \ud83d\udd12"},{"location":"python3/0501-0600/0571-0580/#575-distribute-candies-star","text":"class Solution : def distributeCandies ( self , candies : List [ int ]) -> int : return min ( len ( candies ) // 2 , len ( set ( candies )))","title":"575. Distribute Candies $\\star$"},{"location":"python3/0501-0600/0571-0580/#576-out-of-boundary-paths-starstar","text":"","title":"576. Out of Boundary Paths $\\star\\star$"},{"location":"python3/0501-0600/0571-0580/#577-employee-bonus-star","text":"","title":"577. Employee Bonus $\\star$ \ud83d\udd12"},{"location":"python3/0501-0600/0571-0580/#578-get-highest-answer-rate-question-starstar","text":"","title":"578. Get Highest Answer Rate Question $\\star\\star$ \ud83d\udd12"},{"location":"python3/0501-0600/0571-0580/#579-find-cumulative-salary-of-an-employee-starstarstar","text":"","title":"579. Find Cumulative Salary of an Employee $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/0501-0600/0571-0580/#580-count-student-number-in-departments-starstar","text":"","title":"580. Count Student Number in Departments $\\star\\star$ \ud83d\udd12"},{"location":"python3/0501-0600/0581-0590/","text":"581. Shortest Unsorted Continuous Subarray $\\star$ class Solution : def findUnsortedSubarray ( self , nums : List [ int ]) -> int : mini = float ( 'inf' ) maxi = float ( '-inf' ) flag = False for i in range ( 1 , len ( nums )): if nums [ i ] < nums [ i - 1 ]: flag = True if flag : mini = min ( mini , nums [ i ]) flag = False for i in range ( len ( nums ) - 2 , - 1 , - 1 ): if nums [ i ] > nums [ i + 1 ]: flag = True if flag : maxi = max ( maxi , nums [ i ]) for l in range ( len ( nums )): if nums [ l ] > mini : break for r in range ( len ( nums ) - 1 , - 1 , - 1 ): if nums [ r ] < maxi : break return 0 if l >= r else r - l + 1 582. Kill Process $\\star\\star$ \ud83d\udd12 583. Delete Operation for Two Strings $\\star\\star$ 584. Find Customer Referee $\\star$ \ud83d\udd12 585. Investments in 2016 $\\star\\star$ \ud83d\udd12 586. Customer Placing the Largest Number of Orders $\\star$ \ud83d\udd12 587. Erect the Fence $\\star\\star\\star$ 588. Design In-Memory File System $\\star\\star\\star$ \ud83d\udd12 589. N-ary Tree Preorder Traversal $\\star$ 590. N-ary Tree Postorder Traversal $\\star$","title":"0581-0590"},{"location":"python3/0501-0600/0581-0590/#581-shortest-unsorted-continuous-subarray-star","text":"class Solution : def findUnsortedSubarray ( self , nums : List [ int ]) -> int : mini = float ( 'inf' ) maxi = float ( '-inf' ) flag = False for i in range ( 1 , len ( nums )): if nums [ i ] < nums [ i - 1 ]: flag = True if flag : mini = min ( mini , nums [ i ]) flag = False for i in range ( len ( nums ) - 2 , - 1 , - 1 ): if nums [ i ] > nums [ i + 1 ]: flag = True if flag : maxi = max ( maxi , nums [ i ]) for l in range ( len ( nums )): if nums [ l ] > mini : break for r in range ( len ( nums ) - 1 , - 1 , - 1 ): if nums [ r ] < maxi : break return 0 if l >= r else r - l + 1","title":"581. Shortest Unsorted Continuous Subarray $\\star$"},{"location":"python3/0501-0600/0581-0590/#582-kill-process-starstar","text":"","title":"582. Kill Process $\\star\\star$ \ud83d\udd12"},{"location":"python3/0501-0600/0581-0590/#583-delete-operation-for-two-strings-starstar","text":"","title":"583. Delete Operation for Two Strings $\\star\\star$"},{"location":"python3/0501-0600/0581-0590/#584-find-customer-referee-star","text":"","title":"584. Find Customer Referee $\\star$ \ud83d\udd12"},{"location":"python3/0501-0600/0581-0590/#585-investments-in-2016-starstar","text":"","title":"585. Investments in 2016 $\\star\\star$ \ud83d\udd12"},{"location":"python3/0501-0600/0581-0590/#586-customer-placing-the-largest-number-of-orders-star","text":"","title":"586. Customer Placing the Largest Number of Orders $\\star$ \ud83d\udd12"},{"location":"python3/0501-0600/0581-0590/#587-erect-the-fence-starstarstar","text":"","title":"587. Erect the Fence $\\star\\star\\star$"},{"location":"python3/0501-0600/0581-0590/#588-design-in-memory-file-system-starstarstar","text":"","title":"588. Design In-Memory File System $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/0501-0600/0581-0590/#589-n-ary-tree-preorder-traversal-star","text":"","title":"589. N-ary Tree Preorder Traversal $\\star$"},{"location":"python3/0501-0600/0581-0590/#590-n-ary-tree-postorder-traversal-star","text":"","title":"590. N-ary Tree Postorder Traversal $\\star$"},{"location":"python3/0501-0600/0591-0600/","text":"591. Tag Validator $\\star\\star\\star$ 592. Fraction Addition and Subtraction $\\star\\star$ class Solution : def fractionAddition ( self , expression : str ) -> str : ints = list ( map ( int , re . findall ( '[+-]?[0-9]+' , expression ))) A = 0 B = 1 for a , b in zip ( ints [:: 2 ], ints [ 1 :: 2 ]): A = A * b + a * B B *= b g = math . gcd ( A , B ) A //= g B //= g return str ( A ) + '/' + str ( B ) 593. Valid Square $\\star\\star$ class Solution : def validSquare ( self , p1 : List [ int ], p2 : List [ int ], p3 : List [ int ], p4 : List [ int ]) -> bool : def dist ( p1 : List [ int ], p2 : List [ int ]) -> int : return ( p1 [ 0 ] - p2 [ 0 ]) ** 2 + ( p1 [ 1 ] - p2 [ 1 ]) ** 2 distSet = set () points = [ p1 , p2 , p3 , p4 ] for i in range ( 4 ): for j in range ( i + 1 , 4 ): distSet . add ( dist ( points [ i ], points [ j ])) return 0 not in distSet and len ( distSet ) == 2 594. Longest Harmonious Subsequence $\\star$ class Solution : def findLHS ( self , nums : List [ int ]) -> int : ans = 0 count = collections . Counter ( nums ) for num , freq in count . items (): if num + 1 in count : ans = max ( ans , freq + count [ num + 1 ]) return ans 595. Big Countries $\\star$ 596. Classes More Than 5 Students $\\star$ 597. Friend Requests I: Overall Acceptance Rate $\\star$ \ud83d\udd12 598. Range Addition II $\\star$ class Solution : def maxCount ( self , m : int , n : int , ops : List [ List [ int ]]) -> int : minY = m minX = n for y , x in ops : minY = min ( minY , y ) minX = min ( minX , x ) return minX * minY 599. Minimum Index Sum of Two Lists $\\star$ class Solution : def findRestaurant ( self , list1 : List [ str ], list2 : List [ str ]) -> List [ str ]: ans = [] restaurantToIndex = { restaurant : i for i , restaurant in enumerate ( list1 )} minSum = float ( 'inf' ) for i , restaurant in enumerate ( list2 ): if restaurant in restaurantToIndex : sum = restaurantToIndex [ restaurant ] + i if sum < minSum : ans . clear () if sum <= minSum : ans . append ( restaurant ) minSum = sum return ans 600. Non-negative Integers without Consecutive Ones $\\star\\star\\star$","title":"0591-0600"},{"location":"python3/0501-0600/0591-0600/#591-tag-validator-starstarstar","text":"","title":"591. Tag Validator $\\star\\star\\star$"},{"location":"python3/0501-0600/0591-0600/#592-fraction-addition-and-subtraction-starstar","text":"class Solution : def fractionAddition ( self , expression : str ) -> str : ints = list ( map ( int , re . findall ( '[+-]?[0-9]+' , expression ))) A = 0 B = 1 for a , b in zip ( ints [:: 2 ], ints [ 1 :: 2 ]): A = A * b + a * B B *= b g = math . gcd ( A , B ) A //= g B //= g return str ( A ) + '/' + str ( B )","title":"592. Fraction Addition and Subtraction $\\star\\star$"},{"location":"python3/0501-0600/0591-0600/#593-valid-square-starstar","text":"class Solution : def validSquare ( self , p1 : List [ int ], p2 : List [ int ], p3 : List [ int ], p4 : List [ int ]) -> bool : def dist ( p1 : List [ int ], p2 : List [ int ]) -> int : return ( p1 [ 0 ] - p2 [ 0 ]) ** 2 + ( p1 [ 1 ] - p2 [ 1 ]) ** 2 distSet = set () points = [ p1 , p2 , p3 , p4 ] for i in range ( 4 ): for j in range ( i + 1 , 4 ): distSet . add ( dist ( points [ i ], points [ j ])) return 0 not in distSet and len ( distSet ) == 2","title":"593. Valid Square $\\star\\star$"},{"location":"python3/0501-0600/0591-0600/#594-longest-harmonious-subsequence-star","text":"class Solution : def findLHS ( self , nums : List [ int ]) -> int : ans = 0 count = collections . Counter ( nums ) for num , freq in count . items (): if num + 1 in count : ans = max ( ans , freq + count [ num + 1 ]) return ans","title":"594. Longest Harmonious Subsequence $\\star$"},{"location":"python3/0501-0600/0591-0600/#595-big-countries-star","text":"","title":"595. Big Countries $\\star$"},{"location":"python3/0501-0600/0591-0600/#596-classes-more-than-5-students-star","text":"","title":"596. Classes More Than 5 Students $\\star$"},{"location":"python3/0501-0600/0591-0600/#597-friend-requests-i-overall-acceptance-rate-star","text":"","title":"597. Friend Requests I: Overall Acceptance Rate $\\star$ \ud83d\udd12"},{"location":"python3/0501-0600/0591-0600/#598-range-addition-ii-star","text":"class Solution : def maxCount ( self , m : int , n : int , ops : List [ List [ int ]]) -> int : minY = m minX = n for y , x in ops : minY = min ( minY , y ) minX = min ( minX , x ) return minX * minY","title":"598. Range Addition II $\\star$"},{"location":"python3/0501-0600/0591-0600/#599-minimum-index-sum-of-two-lists-star","text":"class Solution : def findRestaurant ( self , list1 : List [ str ], list2 : List [ str ]) -> List [ str ]: ans = [] restaurantToIndex = { restaurant : i for i , restaurant in enumerate ( list1 )} minSum = float ( 'inf' ) for i , restaurant in enumerate ( list2 ): if restaurant in restaurantToIndex : sum = restaurantToIndex [ restaurant ] + i if sum < minSum : ans . clear () if sum <= minSum : ans . append ( restaurant ) minSum = sum return ans","title":"599. Minimum Index Sum of Two Lists $\\star$"},{"location":"python3/0501-0600/0591-0600/#600-non-negative-integers-without-consecutive-ones-starstarstar","text":"","title":"600. Non-negative Integers without Consecutive Ones $\\star\\star\\star$"},{"location":"python3/0601-0700/0601-0610/","text":"601. Human Traffic of Stadium $\\star\\star\\star$ 602. Friend Requests II: Who Has the Most Friends $\\star\\star$ \ud83d\udd12 603. Consecutive Available Seats $\\star$ \ud83d\udd12 604. Design Compressed String Iterator $\\star$ \ud83d\udd12 605. Can Place Flowers $\\star$ class Solution : def canPlaceFlowers ( self , flowerbed : List [ int ], n : int ) -> bool : for i , flower in enumerate ( flowerbed ): if flower == 0 and ( i == 0 or flowerbed [ i - 1 ] == 0 ) and ( i == len ( flowerbed ) - 1 or flowerbed [ i + 1 ] == 0 ): flowerbed [ i ] = 1 n -= 1 if n <= 0 : return True return False 606. Construct String from Binary Tree $\\star$ class Solution : def tree2str ( self , t : TreeNode ) -> str : def dfs ( root : TreeNode ) -> str : if not root : return '' if root . right : return str ( root . val ) + '(' + dfs ( root . left ) + ')(' + dfs ( root . right ) + ')' if root . left : return str ( root . val ) + '(' + dfs ( root . left ) + ')' return str ( root . val ) return dfs ( t ) 607. Sales Person $\\star$ \ud83d\udd12 608. Tree Node $\\star\\star$ \ud83d\udd12 609. Find Duplicate File in System $\\star\\star$ class Solution : def findDuplicate ( self , paths : List [ str ]) -> List [ List [ str ]]: files = {} for path in paths : words = path . split ( ' ' ) root = words [ 0 ] for i in range ( 1 , len ( words )): s = words [ i ] filePath = root + '/' + s [ 0 : s . find ( '(' )] fileContent = s [ s . find ( '(' ) + 1 : s . find ( ')' )] if fileContent not in files : files [ fileContent ] = [] files [ fileContent ] . append ( filePath ) return [ filePath for filePath in files . values () if len ( filePath ) > 1 ] 610. Triangle Judgement $\\star$ \ud83d\udd12","title":"0601-0610"},{"location":"python3/0601-0700/0601-0610/#601-human-traffic-of-stadium-starstarstar","text":"","title":"601. Human Traffic of Stadium $\\star\\star\\star$"},{"location":"python3/0601-0700/0601-0610/#602-friend-requests-ii-who-has-the-most-friends-starstar","text":"","title":"602. Friend Requests II: Who Has the Most Friends $\\star\\star$ \ud83d\udd12"},{"location":"python3/0601-0700/0601-0610/#603-consecutive-available-seats-star","text":"","title":"603. Consecutive Available Seats $\\star$ \ud83d\udd12"},{"location":"python3/0601-0700/0601-0610/#604-design-compressed-string-iterator-star","text":"","title":"604. Design Compressed String Iterator $\\star$ \ud83d\udd12"},{"location":"python3/0601-0700/0601-0610/#605-can-place-flowers-star","text":"class Solution : def canPlaceFlowers ( self , flowerbed : List [ int ], n : int ) -> bool : for i , flower in enumerate ( flowerbed ): if flower == 0 and ( i == 0 or flowerbed [ i - 1 ] == 0 ) and ( i == len ( flowerbed ) - 1 or flowerbed [ i + 1 ] == 0 ): flowerbed [ i ] = 1 n -= 1 if n <= 0 : return True return False","title":"605. Can Place Flowers $\\star$"},{"location":"python3/0601-0700/0601-0610/#606-construct-string-from-binary-tree-star","text":"class Solution : def tree2str ( self , t : TreeNode ) -> str : def dfs ( root : TreeNode ) -> str : if not root : return '' if root . right : return str ( root . val ) + '(' + dfs ( root . left ) + ')(' + dfs ( root . right ) + ')' if root . left : return str ( root . val ) + '(' + dfs ( root . left ) + ')' return str ( root . val ) return dfs ( t )","title":"606. Construct String from Binary Tree $\\star$"},{"location":"python3/0601-0700/0601-0610/#607-sales-person-star","text":"","title":"607. Sales Person $\\star$ \ud83d\udd12"},{"location":"python3/0601-0700/0601-0610/#608-tree-node-starstar","text":"","title":"608. Tree Node $\\star\\star$ \ud83d\udd12"},{"location":"python3/0601-0700/0601-0610/#609-find-duplicate-file-in-system-starstar","text":"class Solution : def findDuplicate ( self , paths : List [ str ]) -> List [ List [ str ]]: files = {} for path in paths : words = path . split ( ' ' ) root = words [ 0 ] for i in range ( 1 , len ( words )): s = words [ i ] filePath = root + '/' + s [ 0 : s . find ( '(' )] fileContent = s [ s . find ( '(' ) + 1 : s . find ( ')' )] if fileContent not in files : files [ fileContent ] = [] files [ fileContent ] . append ( filePath ) return [ filePath for filePath in files . values () if len ( filePath ) > 1 ]","title":"609. Find Duplicate File in System $\\star\\star$"},{"location":"python3/0601-0700/0601-0610/#610-triangle-judgement-star","text":"","title":"610. Triangle Judgement $\\star$ \ud83d\udd12"},{"location":"python3/0601-0700/0611-0620/","text":"611. Valid Triangle Number $\\star\\star$ class Solution : def triangleNumber ( self , nums : List [ int ]) -> int : ans = 0 nums . sort () for k in range ( len ( nums ) - 1 , 1 , - 1 ): i = 0 j = k - 1 while i < j : if nums [ i ] + nums [ j ] > nums [ k ]: ans += j - i j -= 1 else : i += 1 return ans 612. Shortest Distance in a Plane $\\star\\star$ \ud83d\udd12 613. Shortest Distance in a Line $\\star$ \ud83d\udd12 614. Second Degree Follower $\\star\\star$ \ud83d\udd12 615. Average Salary: Departments VS Company $\\star\\star\\star$ \ud83d\udd12 616. Add Bold Tag in String $\\star\\star$ \ud83d\udd12 617. Merge Two Binary Trees $\\star$ 618. Students Report By Geography $\\star\\star\\star$ \ud83d\udd12 619. Biggest Single Number $\\star$ \ud83d\udd12 620. Not Boring Movies $\\star$","title":"0611-0620"},{"location":"python3/0601-0700/0611-0620/#611-valid-triangle-number-starstar","text":"class Solution : def triangleNumber ( self , nums : List [ int ]) -> int : ans = 0 nums . sort () for k in range ( len ( nums ) - 1 , 1 , - 1 ): i = 0 j = k - 1 while i < j : if nums [ i ] + nums [ j ] > nums [ k ]: ans += j - i j -= 1 else : i += 1 return ans","title":"611. Valid Triangle Number $\\star\\star$"},{"location":"python3/0601-0700/0611-0620/#612-shortest-distance-in-a-plane-starstar","text":"","title":"612. Shortest Distance in a Plane $\\star\\star$ \ud83d\udd12"},{"location":"python3/0601-0700/0611-0620/#613-shortest-distance-in-a-line-star","text":"","title":"613. Shortest Distance in a Line $\\star$ \ud83d\udd12"},{"location":"python3/0601-0700/0611-0620/#614-second-degree-follower-starstar","text":"","title":"614. Second Degree Follower $\\star\\star$ \ud83d\udd12"},{"location":"python3/0601-0700/0611-0620/#615-average-salary-departments-vs-company-starstarstar","text":"","title":"615. Average Salary: Departments VS Company $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/0601-0700/0611-0620/#616-add-bold-tag-in-string-starstar","text":"","title":"616. Add Bold Tag in String $\\star\\star$ \ud83d\udd12"},{"location":"python3/0601-0700/0611-0620/#617-merge-two-binary-trees-star","text":"","title":"617. Merge Two Binary Trees $\\star$"},{"location":"python3/0601-0700/0611-0620/#618-students-report-by-geography-starstarstar","text":"","title":"618. Students Report By Geography $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/0601-0700/0611-0620/#619-biggest-single-number-star","text":"","title":"619. Biggest Single Number $\\star$ \ud83d\udd12"},{"location":"python3/0601-0700/0611-0620/#620-not-boring-movies-star","text":"","title":"620. Not Boring Movies $\\star$"},{"location":"python3/0601-0700/0621-0630/","text":"621. Task Scheduler $\\star\\star$ class Solution : def leastInterval ( self , tasks : List [ str ], n : int ) -> int : count = collections . Counter ( tasks ) maxFreq = max ( count . values ()) ans = ( maxFreq - 1 ) * ( n + 1 ) ans += sum ( map ( lambda value : value == maxFreq , count . values ())) return max ( ans , len ( tasks )) 622. Design Circular Queue $\\star\\star$ 623. Add One Row to Tree $\\star\\star$ 624. Maximum Distance in Arrays $\\star$ \ud83d\udd12 625. Minimum Factorization $\\star\\star$ \ud83d\udd12 626. Exchange Seats $\\star\\star$ 627. Swap Salary $\\star$ 628. Maximum Product of Three Numbers $\\star$ class Solution : def maximumProduct ( self , nums : List [ int ]) -> int : mini = float ( 'inf' ) secondMin = float ( 'inf' ) maxi = float ( '-inf' ) secondMax = float ( '-inf' ) thirdMax = float ( '-inf' ) for num in nums : if num <= mini : secondMin = mini mini = num elif num <= secondMin : secondMin = num if num >= maxi : thirdMax = secondMax secondMax = maxi maxi = num elif num >= secondMax : thirdMax = secondMax secondMax = num elif num >= thirdMax : thirdMax = num return max ( mini * secondMin * maxi , maxi * secondMax * thirdMax ) 629. K Inverse Pairs Array $\\star\\star\\star$ 630. Course Schedule III $\\star\\star\\star$","title":"0621-0630"},{"location":"python3/0601-0700/0621-0630/#621-task-scheduler-starstar","text":"class Solution : def leastInterval ( self , tasks : List [ str ], n : int ) -> int : count = collections . Counter ( tasks ) maxFreq = max ( count . values ()) ans = ( maxFreq - 1 ) * ( n + 1 ) ans += sum ( map ( lambda value : value == maxFreq , count . values ())) return max ( ans , len ( tasks ))","title":"621. Task Scheduler $\\star\\star$"},{"location":"python3/0601-0700/0621-0630/#622-design-circular-queue-starstar","text":"","title":"622. Design Circular Queue $\\star\\star$"},{"location":"python3/0601-0700/0621-0630/#623-add-one-row-to-tree-starstar","text":"","title":"623. Add One Row to Tree $\\star\\star$"},{"location":"python3/0601-0700/0621-0630/#624-maximum-distance-in-arrays-star","text":"","title":"624. Maximum Distance in Arrays $\\star$ \ud83d\udd12"},{"location":"python3/0601-0700/0621-0630/#625-minimum-factorization-starstar","text":"","title":"625. Minimum Factorization $\\star\\star$ \ud83d\udd12"},{"location":"python3/0601-0700/0621-0630/#626-exchange-seats-starstar","text":"","title":"626. Exchange Seats $\\star\\star$"},{"location":"python3/0601-0700/0621-0630/#627-swap-salary-star","text":"","title":"627. Swap Salary $\\star$"},{"location":"python3/0601-0700/0621-0630/#628-maximum-product-of-three-numbers-star","text":"class Solution : def maximumProduct ( self , nums : List [ int ]) -> int : mini = float ( 'inf' ) secondMin = float ( 'inf' ) maxi = float ( '-inf' ) secondMax = float ( '-inf' ) thirdMax = float ( '-inf' ) for num in nums : if num <= mini : secondMin = mini mini = num elif num <= secondMin : secondMin = num if num >= maxi : thirdMax = secondMax secondMax = maxi maxi = num elif num >= secondMax : thirdMax = secondMax secondMax = num elif num >= thirdMax : thirdMax = num return max ( mini * secondMin * maxi , maxi * secondMax * thirdMax )","title":"628. Maximum Product of Three Numbers $\\star$"},{"location":"python3/0601-0700/0621-0630/#629-k-inverse-pairs-array-starstarstar","text":"","title":"629. K Inverse Pairs Array $\\star\\star\\star$"},{"location":"python3/0601-0700/0621-0630/#630-course-schedule-iii-starstarstar","text":"","title":"630. Course Schedule III $\\star\\star\\star$"},{"location":"python3/0601-0700/0631-0640/","text":"631. Design Excel Sum Formula $\\star\\star\\star$ \ud83d\udd12 632. Smallest Range Covering Elements from K Lists $\\star\\star\\star$ class Solution : def smallestRange ( self , nums : List [ List [ int ]]) -> List [ int ]: pq = [( row [ 0 ], i , 0 ) for i , row in enumerate ( nums )] heapq . heapify ( pq ) maxRange = max ( row [ 0 ] for row in nums ) minRange = heapq . nsmallest ( 1 , pq )[ 0 ][ 0 ] ans = [ minRange , maxRange ] while len ( pq ) == len ( nums ): num , r , c = heapq . heappop ( pq ) if c + 1 < len ( nums [ r ]): heapq . heappush ( pq , ( nums [ r ][ c + 1 ], r , c + 1 )) maxRange = max ( maxRange , nums [ r ][ c + 1 ]) minRange = heapq . nsmallest ( 1 , pq )[ 0 ][ 0 ] if maxRange - minRange < ans [ 1 ] - ans [ 0 ]: ans [ 0 ], ans [ 1 ] = minRange , maxRange return ans 633. Sum of Square Numbers $\\star$ class Solution : def judgeSquareSum ( self , c : int ) -> bool : l = 0 r = int ( sqrt ( c )) while l <= r : summ = l * l + r * r if summ == c : return True if summ < c : l += 1 else : r -= 1 return False 634. Find the Derangement of An Array $\\star\\star$ \ud83d\udd12 635. Design Log Storage System $\\star\\star$ \ud83d\udd12 636. Exclusive Time of Functions $\\star\\star$ 637. Average of Levels in Binary Tree $\\star$ 638. Shopping Offers $\\star\\star$ class Solution : def shoppingOffers ( self , price : List [ int ], special : List [ List [ int ]], needs : List [ int ]) -> int : def dfs ( s : int ) -> int : ans = 0 for i , need in enumerate ( needs ): ans += need * price [ i ] for i in range ( s , len ( special )): if all ( special [ i ][ j ] <= need for j , need in enumerate ( needs )): for j , need in enumerate ( needs ): needs [ j ] -= special [ i ][ j ] ans = min ( ans , special [ i ][ - 1 ] + dfs ( i )) for j , need in enumerate ( needs ): needs [ j ] += special [ i ][ j ] return ans return dfs ( 0 ) 639. Decode Ways II $\\star\\star\\star$ 640. Solve the Equation $\\star\\star$ class Solution : def solveEquation ( self , equation : str ) -> str : def calculate ( s : str ) -> tuple : coefficient = 0 constant = 0 num = 0 sign = 1 for i , c in enumerate ( s ): if c . isdigit (): num = num * 10 + ord ( c ) - ord ( '0' ) elif c in '+-' : constant += sign * num sign = 1 if c == '+' else - 1 num = 0 else : if i > 0 and num == 0 and s [ i - 1 ] == '0' : continue coefficient += sign if num == 0 else sign * num num = 0 return coefficient , constant + sign * num lhsEquation , rhsEquation = equation . split ( '=' ) lhsCoefficient , lhsConstant = calculate ( lhsEquation ) rhsCoefficient , rhsConstant = calculate ( rhsEquation ) coefficient = lhsCoefficient - rhsCoefficient constant = rhsConstant - lhsConstant if coefficient == 0 and constant == 0 : return \"Infinite solutions\" if coefficient == 0 and constant != 0 : return \"No solution\" return \"x=\" + str ( constant // coefficient )","title":"0631-0640"},{"location":"python3/0601-0700/0631-0640/#631-design-excel-sum-formula-starstarstar","text":"","title":"631. Design Excel Sum Formula $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/0601-0700/0631-0640/#632-smallest-range-covering-elements-from-k-lists-starstarstar","text":"class Solution : def smallestRange ( self , nums : List [ List [ int ]]) -> List [ int ]: pq = [( row [ 0 ], i , 0 ) for i , row in enumerate ( nums )] heapq . heapify ( pq ) maxRange = max ( row [ 0 ] for row in nums ) minRange = heapq . nsmallest ( 1 , pq )[ 0 ][ 0 ] ans = [ minRange , maxRange ] while len ( pq ) == len ( nums ): num , r , c = heapq . heappop ( pq ) if c + 1 < len ( nums [ r ]): heapq . heappush ( pq , ( nums [ r ][ c + 1 ], r , c + 1 )) maxRange = max ( maxRange , nums [ r ][ c + 1 ]) minRange = heapq . nsmallest ( 1 , pq )[ 0 ][ 0 ] if maxRange - minRange < ans [ 1 ] - ans [ 0 ]: ans [ 0 ], ans [ 1 ] = minRange , maxRange return ans","title":"632. Smallest Range Covering Elements from K Lists $\\star\\star\\star$"},{"location":"python3/0601-0700/0631-0640/#633-sum-of-square-numbers-star","text":"class Solution : def judgeSquareSum ( self , c : int ) -> bool : l = 0 r = int ( sqrt ( c )) while l <= r : summ = l * l + r * r if summ == c : return True if summ < c : l += 1 else : r -= 1 return False","title":"633. Sum of Square Numbers $\\star$"},{"location":"python3/0601-0700/0631-0640/#634-find-the-derangement-of-an-array-starstar","text":"","title":"634. Find the Derangement of An Array $\\star\\star$ \ud83d\udd12"},{"location":"python3/0601-0700/0631-0640/#635-design-log-storage-system-starstar","text":"","title":"635. Design Log Storage System $\\star\\star$ \ud83d\udd12"},{"location":"python3/0601-0700/0631-0640/#636-exclusive-time-of-functions-starstar","text":"","title":"636. Exclusive Time of Functions $\\star\\star$"},{"location":"python3/0601-0700/0631-0640/#637-average-of-levels-in-binary-tree-star","text":"","title":"637. Average of Levels in Binary Tree $\\star$"},{"location":"python3/0601-0700/0631-0640/#638-shopping-offers-starstar","text":"class Solution : def shoppingOffers ( self , price : List [ int ], special : List [ List [ int ]], needs : List [ int ]) -> int : def dfs ( s : int ) -> int : ans = 0 for i , need in enumerate ( needs ): ans += need * price [ i ] for i in range ( s , len ( special )): if all ( special [ i ][ j ] <= need for j , need in enumerate ( needs )): for j , need in enumerate ( needs ): needs [ j ] -= special [ i ][ j ] ans = min ( ans , special [ i ][ - 1 ] + dfs ( i )) for j , need in enumerate ( needs ): needs [ j ] += special [ i ][ j ] return ans return dfs ( 0 )","title":"638. Shopping Offers $\\star\\star$"},{"location":"python3/0601-0700/0631-0640/#639-decode-ways-ii-starstarstar","text":"","title":"639. Decode Ways II $\\star\\star\\star$"},{"location":"python3/0601-0700/0631-0640/#640-solve-the-equation-starstar","text":"class Solution : def solveEquation ( self , equation : str ) -> str : def calculate ( s : str ) -> tuple : coefficient = 0 constant = 0 num = 0 sign = 1 for i , c in enumerate ( s ): if c . isdigit (): num = num * 10 + ord ( c ) - ord ( '0' ) elif c in '+-' : constant += sign * num sign = 1 if c == '+' else - 1 num = 0 else : if i > 0 and num == 0 and s [ i - 1 ] == '0' : continue coefficient += sign if num == 0 else sign * num num = 0 return coefficient , constant + sign * num lhsEquation , rhsEquation = equation . split ( '=' ) lhsCoefficient , lhsConstant = calculate ( lhsEquation ) rhsCoefficient , rhsConstant = calculate ( rhsEquation ) coefficient = lhsCoefficient - rhsCoefficient constant = rhsConstant - lhsConstant if coefficient == 0 and constant == 0 : return \"Infinite solutions\" if coefficient == 0 and constant != 0 : return \"No solution\" return \"x=\" + str ( constant // coefficient )","title":"640. Solve the Equation $\\star\\star$"},{"location":"python3/0601-0700/0641-0650/","text":"641. Design Circular Deque $\\star\\star$ 642. Design Search Autocomplete System $\\star\\star\\star$ \ud83d\udd12 643. Maximum Average Subarray I $\\star$ class Solution : def findMaxAverage ( self , nums : List [ int ], k : int ) -> float : summ = sum ( nums [: k ]) ans = summ for i in range ( k , len ( nums )): summ += nums [ i ] - nums [ i - k ] ans = max ( ans , summ ) return ans / k 644. Maximum Average Subarray II $\\star\\star\\star$ \ud83d\udd12 645. Set Mismatch $\\star$ class Solution : def findErrorNums ( self , nums : List [ int ]) -> List [ int ]: for num in nums : if nums [ abs ( num ) - 1 ] < 0 : duplicate = abs ( num ) else : nums [ abs ( num ) - 1 ] *= - 1 for i , num in enumerate ( nums ): if num > 0 : return [ duplicate , i + 1 ] 646. Maximum Length of Pair Chain $\\star\\star$ 647. Palindromic Substrings $\\star\\star$ class Solution : def countSubstrings ( self , s : str ) -> int : def extendPalindromes ( l : int , r : int ) -> int : count = 0 while l >= 0 and r < len ( s ) and s [ l ] == s [ r ]: count += 1 l -= 1 r += 1 return count ans = 0 for i in range ( len ( s )): ans += extendPalindromes ( i , i ) ans += extendPalindromes ( i , i + 1 ) return ans 648. Replace Words $\\star\\star$ class Solution : def __init__ ( self ): self . root = {} def insert ( self , word : str ) -> None : node = self . root for c in word : if c not in node : node [ c ] = {} node = node [ c ] node [ 'word' ] = word def search ( self , word : str ) -> str : node = self . root for c in word : if 'word' in node : return node [ 'word' ] if c not in node : return word node = node [ c ] return word def replaceWords ( self , dict : List [ str ], sentence : str ) -> str : for word in dict : self . insert ( word ) words = sentence . split ( ' ' ) return ' ' . join ([ self . search ( word ) for word in words ]) 649. Dota2 Senate $\\star\\star$ 650. 2 Keys Keyboard $\\star\\star$ class Solution : def minSteps ( self , n : int ) -> int : dp = [ i for i in range ( n + 1 )] for i in range ( 2 , n + 1 ): for j in range ( i // 2 , 2 , - 1 ): if i % j == 0 : dp [ i ] = dp [ j ] + i // j break return dp [ n ] if n > 1 else 0","title":"0641-0650"},{"location":"python3/0601-0700/0641-0650/#641-design-circular-deque-starstar","text":"","title":"641. Design Circular Deque $\\star\\star$"},{"location":"python3/0601-0700/0641-0650/#642-design-search-autocomplete-system-starstarstar","text":"","title":"642. Design Search Autocomplete System $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/0601-0700/0641-0650/#643-maximum-average-subarray-i-star","text":"class Solution : def findMaxAverage ( self , nums : List [ int ], k : int ) -> float : summ = sum ( nums [: k ]) ans = summ for i in range ( k , len ( nums )): summ += nums [ i ] - nums [ i - k ] ans = max ( ans , summ ) return ans / k","title":"643. Maximum Average Subarray I $\\star$"},{"location":"python3/0601-0700/0641-0650/#644-maximum-average-subarray-ii-starstarstar","text":"","title":"644. Maximum Average Subarray II $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/0601-0700/0641-0650/#645-set-mismatch-star","text":"class Solution : def findErrorNums ( self , nums : List [ int ]) -> List [ int ]: for num in nums : if nums [ abs ( num ) - 1 ] < 0 : duplicate = abs ( num ) else : nums [ abs ( num ) - 1 ] *= - 1 for i , num in enumerate ( nums ): if num > 0 : return [ duplicate , i + 1 ]","title":"645. Set Mismatch $\\star$"},{"location":"python3/0601-0700/0641-0650/#646-maximum-length-of-pair-chain-starstar","text":"","title":"646. Maximum Length of Pair Chain $\\star\\star$"},{"location":"python3/0601-0700/0641-0650/#647-palindromic-substrings-starstar","text":"class Solution : def countSubstrings ( self , s : str ) -> int : def extendPalindromes ( l : int , r : int ) -> int : count = 0 while l >= 0 and r < len ( s ) and s [ l ] == s [ r ]: count += 1 l -= 1 r += 1 return count ans = 0 for i in range ( len ( s )): ans += extendPalindromes ( i , i ) ans += extendPalindromes ( i , i + 1 ) return ans","title":"647. Palindromic Substrings $\\star\\star$"},{"location":"python3/0601-0700/0641-0650/#648-replace-words-starstar","text":"class Solution : def __init__ ( self ): self . root = {} def insert ( self , word : str ) -> None : node = self . root for c in word : if c not in node : node [ c ] = {} node = node [ c ] node [ 'word' ] = word def search ( self , word : str ) -> str : node = self . root for c in word : if 'word' in node : return node [ 'word' ] if c not in node : return word node = node [ c ] return word def replaceWords ( self , dict : List [ str ], sentence : str ) -> str : for word in dict : self . insert ( word ) words = sentence . split ( ' ' ) return ' ' . join ([ self . search ( word ) for word in words ])","title":"648. Replace Words $\\star\\star$"},{"location":"python3/0601-0700/0641-0650/#649-dota2-senate-starstar","text":"","title":"649. Dota2 Senate $\\star\\star$"},{"location":"python3/0601-0700/0641-0650/#650-2-keys-keyboard-starstar","text":"class Solution : def minSteps ( self , n : int ) -> int : dp = [ i for i in range ( n + 1 )] for i in range ( 2 , n + 1 ): for j in range ( i // 2 , 2 , - 1 ): if i % j == 0 : dp [ i ] = dp [ j ] + i // j break return dp [ n ] if n > 1 else 0","title":"650. 2 Keys Keyboard $\\star\\star$"},{"location":"python3/0601-0700/0651-0660/","text":"651. 4 Keys Keyboard $\\star\\star$ \ud83d\udd12 652. Find Duplicate Subtrees $\\star\\star$ 653. Two Sum IV - Input is a BST $\\star$ 654. Maximum Binary Tree $\\star\\star$ 655. Print Binary Tree $\\star\\star$ 656. Coin Path $\\star\\star\\star$ \ud83d\udd12 657. Robot Return to Origin $\\star$ class Solution : def judgeCircle ( self , moves : str ) -> bool : return moves . count ( 'R' ) == moves . count ( 'L' ) and moves . count ( 'U' ) == moves . count ( 'D' ) 658. Find K Closest Elements $\\star\\star$ 659. Split Array into Consecutive Subsequences $\\star\\star$ 660. Remove 9 $\\star\\star\\star$ \ud83d\udd12","title":"0651-0660"},{"location":"python3/0601-0700/0651-0660/#651-4-keys-keyboard-starstar","text":"","title":"651. 4 Keys Keyboard $\\star\\star$ \ud83d\udd12"},{"location":"python3/0601-0700/0651-0660/#652-find-duplicate-subtrees-starstar","text":"","title":"652. Find Duplicate Subtrees $\\star\\star$"},{"location":"python3/0601-0700/0651-0660/#653-two-sum-iv-input-is-a-bst-star","text":"","title":"653. Two Sum IV - Input is a BST $\\star$"},{"location":"python3/0601-0700/0651-0660/#654-maximum-binary-tree-starstar","text":"","title":"654. Maximum Binary Tree $\\star\\star$"},{"location":"python3/0601-0700/0651-0660/#655-print-binary-tree-starstar","text":"","title":"655. Print Binary Tree $\\star\\star$"},{"location":"python3/0601-0700/0651-0660/#656-coin-path-starstarstar","text":"","title":"656. Coin Path $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/0601-0700/0651-0660/#657-robot-return-to-origin-star","text":"class Solution : def judgeCircle ( self , moves : str ) -> bool : return moves . count ( 'R' ) == moves . count ( 'L' ) and moves . count ( 'U' ) == moves . count ( 'D' )","title":"657. Robot Return to Origin $\\star$"},{"location":"python3/0601-0700/0651-0660/#658-find-k-closest-elements-starstar","text":"","title":"658. Find K Closest Elements $\\star\\star$"},{"location":"python3/0601-0700/0651-0660/#659-split-array-into-consecutive-subsequences-starstar","text":"","title":"659. Split Array into Consecutive Subsequences $\\star\\star$"},{"location":"python3/0601-0700/0651-0660/#660-remove-9-starstarstar","text":"","title":"660. Remove 9 $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/0601-0700/0661-0670/","text":"661. Image Smoother $\\star$ class Solution : def imageSmoother ( self , M : List [ List [ int ]]) -> List [ List [ int ]]: m = len ( M ) n = len ( M [ 0 ]) ans = [[ 0 for j in range ( n )] for i in range ( m )] for i in range ( m ): for j in range ( n ): ones = 0 count = 0 for y in range ( max ( 0 , i - 1 ), min ( m , i + 2 )): for x in range ( max ( 0 , j - 1 ), min ( n , j + 2 )): ones += M [ y ][ x ] count += 1 ans [ i ][ j ] = ones // count return ans 662. Maximum Width of Binary Tree $\\star\\star$ 663. Equal Tree Partition $\\star\\star$ \ud83d\udd12 664. Strange Printer $\\star\\star\\star$ 665. Non-decreasing Array $\\star$ class Solution : def checkPossibility ( self , nums : List [ int ]) -> bool : j = None for i in range ( len ( nums ) - 1 ): if nums [ i ] > nums [ i + 1 ]: if j is not None : return False j = i return j is None or j == 0 or j == len ( nums ) - 2 or \\ nums [ j - 1 ] <= nums [ j + 1 ] or nums [ j ] <= nums [ j + 2 ] 666. Path Sum IV $\\star\\star$ \ud83d\udd12 667. Beautiful Arrangement II $\\star\\star$ class Solution : def constructArray ( self , n : int , k : int ) -> List [ int ]: ans = list ( range ( 1 , n - k + 1 )) for i in range ( k ): if i % 2 == 0 : ans . append ( n - i // 2 ) else : ans . append ( n - k + ( i + 1 ) // 2 ) return ans 668. Kth Smallest Number in Multiplication Table $\\star\\star\\star$ 669. Trim a Binary Search Tree $\\star$ 670. Maximum Swap $\\star\\star$ class Solution : def maximumSwap ( self , num : int ) -> int : s = list ( str ( num )) dict = { c : i for i , c in enumerate ( s )} for i , c in enumerate ( s ): for digit in reversed ( string . digits ): if digit <= c : break if digit in dict and dict [ digit ] > i : s [ i ], s [ dict [ digit ]] = digit , s [ i ] return int ( '' . join ( s )) return num","title":"0661-0670"},{"location":"python3/0601-0700/0661-0670/#661-image-smoother-star","text":"class Solution : def imageSmoother ( self , M : List [ List [ int ]]) -> List [ List [ int ]]: m = len ( M ) n = len ( M [ 0 ]) ans = [[ 0 for j in range ( n )] for i in range ( m )] for i in range ( m ): for j in range ( n ): ones = 0 count = 0 for y in range ( max ( 0 , i - 1 ), min ( m , i + 2 )): for x in range ( max ( 0 , j - 1 ), min ( n , j + 2 )): ones += M [ y ][ x ] count += 1 ans [ i ][ j ] = ones // count return ans","title":"661. Image Smoother $\\star$"},{"location":"python3/0601-0700/0661-0670/#662-maximum-width-of-binary-tree-starstar","text":"","title":"662. Maximum Width of Binary Tree $\\star\\star$"},{"location":"python3/0601-0700/0661-0670/#663-equal-tree-partition-starstar","text":"","title":"663. Equal Tree Partition $\\star\\star$ \ud83d\udd12"},{"location":"python3/0601-0700/0661-0670/#664-strange-printer-starstarstar","text":"","title":"664. Strange Printer $\\star\\star\\star$"},{"location":"python3/0601-0700/0661-0670/#665-non-decreasing-array-star","text":"class Solution : def checkPossibility ( self , nums : List [ int ]) -> bool : j = None for i in range ( len ( nums ) - 1 ): if nums [ i ] > nums [ i + 1 ]: if j is not None : return False j = i return j is None or j == 0 or j == len ( nums ) - 2 or \\ nums [ j - 1 ] <= nums [ j + 1 ] or nums [ j ] <= nums [ j + 2 ]","title":"665. Non-decreasing Array $\\star$"},{"location":"python3/0601-0700/0661-0670/#666-path-sum-iv-starstar","text":"","title":"666. Path Sum IV $\\star\\star$ \ud83d\udd12"},{"location":"python3/0601-0700/0661-0670/#667-beautiful-arrangement-ii-starstar","text":"class Solution : def constructArray ( self , n : int , k : int ) -> List [ int ]: ans = list ( range ( 1 , n - k + 1 )) for i in range ( k ): if i % 2 == 0 : ans . append ( n - i // 2 ) else : ans . append ( n - k + ( i + 1 ) // 2 ) return ans","title":"667. Beautiful Arrangement II $\\star\\star$"},{"location":"python3/0601-0700/0661-0670/#668-kth-smallest-number-in-multiplication-table-starstarstar","text":"","title":"668. Kth Smallest Number in Multiplication Table $\\star\\star\\star$"},{"location":"python3/0601-0700/0661-0670/#669-trim-a-binary-search-tree-star","text":"","title":"669. Trim a Binary Search Tree $\\star$"},{"location":"python3/0601-0700/0661-0670/#670-maximum-swap-starstar","text":"class Solution : def maximumSwap ( self , num : int ) -> int : s = list ( str ( num )) dict = { c : i for i , c in enumerate ( s )} for i , c in enumerate ( s ): for digit in reversed ( string . digits ): if digit <= c : break if digit in dict and dict [ digit ] > i : s [ i ], s [ dict [ digit ]] = digit , s [ i ] return int ( '' . join ( s )) return num","title":"670. Maximum Swap $\\star\\star$"},{"location":"python3/0601-0700/0671-0680/","text":"671. Second Minimum Node In a Binary Tree $\\star$ 672. Bulb Switcher II $\\star\\star$ class Solution : def flipLights ( self , n : int , m : int ) -> int : n = min ( n , 3 ) if m == 0 : return 1 if m == 1 : return [ 2 , 3 , 4 ][ n - 1 ] if m == 2 : return [ 2 , 4 , 7 ][ n - 1 ] return [ 2 , 4 , 8 ][ n - 1 ] 673. Number of Longest Increasing Subsequence $\\star\\star$ class Solution : def findNumberOfLIS ( self , nums : List [ int ]) -> int : ans = 0 maxLength = 0 length = [ 1 ] * len ( nums ) count = [ 1 ] * len ( nums ) for i , num in enumerate ( nums ): for j in range ( i ): if nums [ j ] < num : if length [ i ] == length [ j ] + 1 : count [ i ] += count [ j ] elif length [ i ] < length [ j ] + 1 : length [ i ] = length [ j ] + 1 count [ i ] = count [ j ] if maxLength == length [ i ]: ans += count [ i ] elif maxLength < length [ i ]: maxLength = length [ i ] ans = count [ i ] return ans 674. Longest Continuous Increasing Subsequence $\\star$ class Solution : def findLengthOfLCIS ( self , nums : List [ int ]) -> int : ans = 0 j = 0 for i in range ( len ( nums )): if i > 0 and nums [ i ] <= nums [ i - 1 ]: j = i ans = max ( ans , i - j + 1 ) return ans 675. Cut Off Trees for Golf Event $\\star\\star\\star$ 676. Implement Magic Dictionary $\\star\\star$ class MagicDictionary : def __init__ ( self ): self . dict = {} def buildDict ( self , dict : List [ str ]) -> None : for word in dict : for i , c in enumerate ( word ): modifiedWord = word [: i ] + '*' + word [ i + 1 :] if modifiedWord not in self . dict : self . dict [ modifiedWord ] = c elif self . dict [ modifiedWord ] != c : self . dict [ modifiedWord ] = '*' def search ( self , word : str ) -> bool : for i , c in enumerate ( word ): modifiedWord = word [: i ] + '*' + word [ i + 1 :] if modifiedWord in self . dict and self . dict [ modifiedWord ] != c : return True return False 677. Map Sum Pairs $\\star\\star$ 678. Valid Parenthesis String $\\star\\star$ class Solution : def checkValidString ( self , s : str ) -> bool : low = 0 high = 0 for c in s : if c == '(' : low += 1 high += 1 elif c == ')' : if low > 0 : low -= 1 high -= 1 else : if low > 0 : low -= 1 high += 1 if high < 0 : return False return low == 0 679. 24 Game $\\star\\star\\star$ class Solution : def judgePoint24 ( self , nums : List [ int ]) -> bool : def generate ( a : float , b : float ) -> List [ float ]: return [ a * b , float ( 'inf' ) if b == 0 else a / b , float ( 'inf' ) if a == 0 else b / a , a + b , a - b , b - a ] def dfs ( nums : List [ float ]) -> bool : if len ( nums ) == 1 : return abs ( nums [ 0 ] - 24.0 ) < 0.001 for i in range ( len ( nums )): for j in range ( i + 1 , len ( nums )): for num in generate ( nums [ i ], nums [ j ]): nextRound = [ num ] for k in range ( len ( nums )): if k == i or k == j : continue nextRound . append ( nums [ k ]) if dfs ( nextRound ): return True return False return dfs ( nums ) 680. Valid Palindrome II $\\star$ class Solution : def validPalindrome ( self , s : str ) -> bool : def validPalindrome ( l : int , r : int ) -> bool : return all ( s [ i ] == s [ r - i + l ] for i in range ( l , l + ( r - l ) // 2 + 1 )) n = len ( s ) for i in range ( n // 2 ): if s [ i ] != s [ ~ i ]: return validPalindrome ( i + 1 , n - 1 - i ) or validPalindrome ( i , n - 2 - i ) return True","title":"0671-0680"},{"location":"python3/0601-0700/0671-0680/#671-second-minimum-node-in-a-binary-tree-star","text":"","title":"671. Second Minimum Node In a Binary Tree $\\star$"},{"location":"python3/0601-0700/0671-0680/#672-bulb-switcher-ii-starstar","text":"class Solution : def flipLights ( self , n : int , m : int ) -> int : n = min ( n , 3 ) if m == 0 : return 1 if m == 1 : return [ 2 , 3 , 4 ][ n - 1 ] if m == 2 : return [ 2 , 4 , 7 ][ n - 1 ] return [ 2 , 4 , 8 ][ n - 1 ]","title":"672. Bulb Switcher II $\\star\\star$"},{"location":"python3/0601-0700/0671-0680/#673-number-of-longest-increasing-subsequence-starstar","text":"class Solution : def findNumberOfLIS ( self , nums : List [ int ]) -> int : ans = 0 maxLength = 0 length = [ 1 ] * len ( nums ) count = [ 1 ] * len ( nums ) for i , num in enumerate ( nums ): for j in range ( i ): if nums [ j ] < num : if length [ i ] == length [ j ] + 1 : count [ i ] += count [ j ] elif length [ i ] < length [ j ] + 1 : length [ i ] = length [ j ] + 1 count [ i ] = count [ j ] if maxLength == length [ i ]: ans += count [ i ] elif maxLength < length [ i ]: maxLength = length [ i ] ans = count [ i ] return ans","title":"673. Number of Longest Increasing Subsequence $\\star\\star$"},{"location":"python3/0601-0700/0671-0680/#674-longest-continuous-increasing-subsequence-star","text":"class Solution : def findLengthOfLCIS ( self , nums : List [ int ]) -> int : ans = 0 j = 0 for i in range ( len ( nums )): if i > 0 and nums [ i ] <= nums [ i - 1 ]: j = i ans = max ( ans , i - j + 1 ) return ans","title":"674. Longest Continuous Increasing Subsequence $\\star$"},{"location":"python3/0601-0700/0671-0680/#675-cut-off-trees-for-golf-event-starstarstar","text":"","title":"675. Cut Off Trees for Golf Event $\\star\\star\\star$"},{"location":"python3/0601-0700/0671-0680/#676-implement-magic-dictionary-starstar","text":"class MagicDictionary : def __init__ ( self ): self . dict = {} def buildDict ( self , dict : List [ str ]) -> None : for word in dict : for i , c in enumerate ( word ): modifiedWord = word [: i ] + '*' + word [ i + 1 :] if modifiedWord not in self . dict : self . dict [ modifiedWord ] = c elif self . dict [ modifiedWord ] != c : self . dict [ modifiedWord ] = '*' def search ( self , word : str ) -> bool : for i , c in enumerate ( word ): modifiedWord = word [: i ] + '*' + word [ i + 1 :] if modifiedWord in self . dict and self . dict [ modifiedWord ] != c : return True return False","title":"676. Implement Magic Dictionary $\\star\\star$"},{"location":"python3/0601-0700/0671-0680/#677-map-sum-pairs-starstar","text":"","title":"677. Map Sum Pairs $\\star\\star$"},{"location":"python3/0601-0700/0671-0680/#678-valid-parenthesis-string-starstar","text":"class Solution : def checkValidString ( self , s : str ) -> bool : low = 0 high = 0 for c in s : if c == '(' : low += 1 high += 1 elif c == ')' : if low > 0 : low -= 1 high -= 1 else : if low > 0 : low -= 1 high += 1 if high < 0 : return False return low == 0","title":"678. Valid Parenthesis String $\\star\\star$"},{"location":"python3/0601-0700/0671-0680/#679-24-game-starstarstar","text":"class Solution : def judgePoint24 ( self , nums : List [ int ]) -> bool : def generate ( a : float , b : float ) -> List [ float ]: return [ a * b , float ( 'inf' ) if b == 0 else a / b , float ( 'inf' ) if a == 0 else b / a , a + b , a - b , b - a ] def dfs ( nums : List [ float ]) -> bool : if len ( nums ) == 1 : return abs ( nums [ 0 ] - 24.0 ) < 0.001 for i in range ( len ( nums )): for j in range ( i + 1 , len ( nums )): for num in generate ( nums [ i ], nums [ j ]): nextRound = [ num ] for k in range ( len ( nums )): if k == i or k == j : continue nextRound . append ( nums [ k ]) if dfs ( nextRound ): return True return False return dfs ( nums )","title":"679. 24 Game $\\star\\star\\star$"},{"location":"python3/0601-0700/0671-0680/#680-valid-palindrome-ii-star","text":"class Solution : def validPalindrome ( self , s : str ) -> bool : def validPalindrome ( l : int , r : int ) -> bool : return all ( s [ i ] == s [ r - i + l ] for i in range ( l , l + ( r - l ) // 2 + 1 )) n = len ( s ) for i in range ( n // 2 ): if s [ i ] != s [ ~ i ]: return validPalindrome ( i + 1 , n - 1 - i ) or validPalindrome ( i , n - 2 - i ) return True","title":"680. Valid Palindrome II $\\star$"},{"location":"python3/0601-0700/0681-0690/","text":"681. Next Closest Time $\\star\\star$ \ud83d\udd12 682. Baseball Game $\\star$ 683. K Empty Slots $\\star\\star\\star$ \ud83d\udd12 684. Redundant Connection $\\star\\star$ class Solution : def findRedundantConnection ( self , edges : List [ List [ int ]]) -> List [ int ]: uf = UF ( len ( edges )) for edge in edges : if not uf . union ( edge [ 0 ], edge [ 1 ]): return edge class UF : def __init__ ( self , n : int ): self . rank = [ 0 ] * ( n + 1 ) self . parent = [ i for i in range ( n + 1 )] def union ( self , u : int , v : int ) -> bool : pu = self . find ( u ) pv = self . find ( v ) if pu == pv : return False if self . rank [ pu ] < self . rank [ pv ]: self . parent [ pu ] = pv elif self . rank [ pv ] < self . rank [ pu ]: self . parent [ pv ] = pu else : self . parent [ pu ] = pv self . rank [ pv ] += 1 return True def find ( self , u : int ) -> int : while u != self . parent [ u ]: self . parent [ u ] = self . parent [ self . parent [ u ]] u = self . parent [ u ] return u 685. Redundant Connection II $\\star\\star\\star$ class Solution : def findRedundantDirectedConnection ( self , edges : List [ List [ int ]]) -> List [ int ]: def findRedundantDirectedConnection ( skippedEdgeIndex : int ) -> List [ int ]: uf = UF ( len ( edges ) + 1 ) for i , edge in enumerate ( edges ): if i == skippedEdgeIndex : continue if not uf . union ( edge [ 0 ], edge [ 1 ]): return edge return [] parents = [ 0 ] * ( len ( edges ) + 1 ) nodeWithTwoParents = 0 for u , v in edges : parents [ v ] += 1 if parents [ v ] == 2 : nodeWithTwoParents = v if nodeWithTwoParents == 0 : return findRedundantDirectedConnection ( - 1 ) for i in range ( len ( edges ))[:: - 1 ]: u , v = edges [ i ] if v == nodeWithTwoParents : if findRedundantDirectedConnection ( i ) == []: return edges [ i ] class UF : def __init__ ( self , n : int ): self . rank = [ 0 ] * ( n + 1 ) self . parent = [ i for i in range ( n + 1 )] def union ( self , u : int , v : int ) -> bool : pu = self . find ( u ) pv = self . find ( v ) if pu == pv : return False if self . rank [ pu ] < self . rank [ pv ]: self . parent [ pu ] = pv elif self . rank [ pv ] < self . rank [ pu ]: self . parent [ pv ] = pu else : self . parent [ pu ] = pv self . rank [ pv ] += 1 return True def find ( self , u : int ) -> int : while u != self . parent [ u ]: self . parent [ u ] = self . parent [ self . parent [ u ]] u = self . parent [ u ] return u 686. Repeated String Match $\\star$ class Solution : def repeatedStringMatch ( self , A : str , B : str ) -> int : n = math . ceil ( len ( B ) / len ( A )) s = A * n if B in s : return n if B in s + A : return n + 1 return - 1 687. Longest Univalue Path $\\star$ 688. Knight Probability in Chessboard $\\star\\star$ class Solution : def knightProbability ( self , N : int , K : int , r : int , c : int ) -> float : dirs = [( 1 , 2 ), ( 2 , 1 ), ( 2 , - 1 ), ( 1 , - 2 ), ( - 1 , - 2 ), ( - 2 , - 1 ), ( - 2 , 1 ), ( - 1 , 2 )] dp = [[ 0 ] * N for _ in range ( N )] dp [ r ][ c ] = 1 for _ in range ( K ): newDp = [[ 0 ] * N for _ in range ( N )] for i in range ( N ): for j in range ( N ): for dx , dy in dirs : x = i + dx y = j + dy if 0 <= x < N and 0 <= y < N : newDp [ i ][ j ] += dp [ x ][ y ] dp = newDp return sum ( map ( sum , dp )) / 8 ** K 689. Maximum Sum of 3 Non-Overlapping Subarrays $\\star\\star\\star$ class Solution : def maxSumOfThreeSubarrays ( self , nums , k ): ans = [ - 1 ] * 3 subarrayCount = len ( nums ) - k + 1 dp = [ 0 ] * subarrayCount sum = 0 for i , num in enumerate ( nums ): sum += num if i >= k : sum -= nums [ i - k ] if i >= k - 1 : dp [ i - k + 1 ] = sum left = [ 0 ] * subarrayCount maxIndex = 0 for i in range ( subarrayCount ): if dp [ i ] > dp [ maxIndex ]: maxIndex = i left [ i ] = maxIndex right = [ 0 ] * subarrayCount maxIndex = subarrayCount - 1 for i in range ( subarrayCount - 1 , - 1 , - 1 ): if dp [ i ] >= dp [ maxIndex ]: maxIndex = i right [ i ] = maxIndex for i in range ( k , subarrayCount - k ): if ans [ 0 ] == - 1 or dp [ left [ i - k ]] + dp [ i ] + dp [ right [ i + k ]] > dp [ ans [ 0 ]] + dp [ ans [ 1 ]] + dp [ ans [ 2 ]]: ans = [ left [ i - k ], i , right [ i + k ]] return ans 690. Employee Importance $\\star$ class Solution : def getImportance ( self , employees : List [ 'Employee' ], id : int ) -> int : def dfs ( id : int ) -> int : subordinatesImportance = sum ( dfs ( subordinate ) for subordinate in idToEmployee [ id ] . subordinates ) return idToEmployee [ id ] . importance + subordinatesImportance idToEmployee = { employee . id : employee for employee in employees } return dfs ( id )","title":"0681-0690"},{"location":"python3/0601-0700/0681-0690/#681-next-closest-time-starstar","text":"","title":"681. Next Closest Time $\\star\\star$ \ud83d\udd12"},{"location":"python3/0601-0700/0681-0690/#682-baseball-game-star","text":"","title":"682. Baseball Game $\\star$"},{"location":"python3/0601-0700/0681-0690/#683-k-empty-slots-starstarstar","text":"","title":"683. K Empty Slots $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/0601-0700/0681-0690/#684-redundant-connection-starstar","text":"class Solution : def findRedundantConnection ( self , edges : List [ List [ int ]]) -> List [ int ]: uf = UF ( len ( edges )) for edge in edges : if not uf . union ( edge [ 0 ], edge [ 1 ]): return edge class UF : def __init__ ( self , n : int ): self . rank = [ 0 ] * ( n + 1 ) self . parent = [ i for i in range ( n + 1 )] def union ( self , u : int , v : int ) -> bool : pu = self . find ( u ) pv = self . find ( v ) if pu == pv : return False if self . rank [ pu ] < self . rank [ pv ]: self . parent [ pu ] = pv elif self . rank [ pv ] < self . rank [ pu ]: self . parent [ pv ] = pu else : self . parent [ pu ] = pv self . rank [ pv ] += 1 return True def find ( self , u : int ) -> int : while u != self . parent [ u ]: self . parent [ u ] = self . parent [ self . parent [ u ]] u = self . parent [ u ] return u","title":"684. Redundant Connection $\\star\\star$"},{"location":"python3/0601-0700/0681-0690/#685-redundant-connection-ii-starstarstar","text":"class Solution : def findRedundantDirectedConnection ( self , edges : List [ List [ int ]]) -> List [ int ]: def findRedundantDirectedConnection ( skippedEdgeIndex : int ) -> List [ int ]: uf = UF ( len ( edges ) + 1 ) for i , edge in enumerate ( edges ): if i == skippedEdgeIndex : continue if not uf . union ( edge [ 0 ], edge [ 1 ]): return edge return [] parents = [ 0 ] * ( len ( edges ) + 1 ) nodeWithTwoParents = 0 for u , v in edges : parents [ v ] += 1 if parents [ v ] == 2 : nodeWithTwoParents = v if nodeWithTwoParents == 0 : return findRedundantDirectedConnection ( - 1 ) for i in range ( len ( edges ))[:: - 1 ]: u , v = edges [ i ] if v == nodeWithTwoParents : if findRedundantDirectedConnection ( i ) == []: return edges [ i ] class UF : def __init__ ( self , n : int ): self . rank = [ 0 ] * ( n + 1 ) self . parent = [ i for i in range ( n + 1 )] def union ( self , u : int , v : int ) -> bool : pu = self . find ( u ) pv = self . find ( v ) if pu == pv : return False if self . rank [ pu ] < self . rank [ pv ]: self . parent [ pu ] = pv elif self . rank [ pv ] < self . rank [ pu ]: self . parent [ pv ] = pu else : self . parent [ pu ] = pv self . rank [ pv ] += 1 return True def find ( self , u : int ) -> int : while u != self . parent [ u ]: self . parent [ u ] = self . parent [ self . parent [ u ]] u = self . parent [ u ] return u","title":"685. Redundant Connection II $\\star\\star\\star$"},{"location":"python3/0601-0700/0681-0690/#686-repeated-string-match-star","text":"class Solution : def repeatedStringMatch ( self , A : str , B : str ) -> int : n = math . ceil ( len ( B ) / len ( A )) s = A * n if B in s : return n if B in s + A : return n + 1 return - 1","title":"686. Repeated String Match $\\star$"},{"location":"python3/0601-0700/0681-0690/#687-longest-univalue-path-star","text":"","title":"687. Longest Univalue Path $\\star$"},{"location":"python3/0601-0700/0681-0690/#688-knight-probability-in-chessboard-starstar","text":"class Solution : def knightProbability ( self , N : int , K : int , r : int , c : int ) -> float : dirs = [( 1 , 2 ), ( 2 , 1 ), ( 2 , - 1 ), ( 1 , - 2 ), ( - 1 , - 2 ), ( - 2 , - 1 ), ( - 2 , 1 ), ( - 1 , 2 )] dp = [[ 0 ] * N for _ in range ( N )] dp [ r ][ c ] = 1 for _ in range ( K ): newDp = [[ 0 ] * N for _ in range ( N )] for i in range ( N ): for j in range ( N ): for dx , dy in dirs : x = i + dx y = j + dy if 0 <= x < N and 0 <= y < N : newDp [ i ][ j ] += dp [ x ][ y ] dp = newDp return sum ( map ( sum , dp )) / 8 ** K","title":"688. Knight Probability in Chessboard $\\star\\star$"},{"location":"python3/0601-0700/0681-0690/#689-maximum-sum-of-3-non-overlapping-subarrays-starstarstar","text":"class Solution : def maxSumOfThreeSubarrays ( self , nums , k ): ans = [ - 1 ] * 3 subarrayCount = len ( nums ) - k + 1 dp = [ 0 ] * subarrayCount sum = 0 for i , num in enumerate ( nums ): sum += num if i >= k : sum -= nums [ i - k ] if i >= k - 1 : dp [ i - k + 1 ] = sum left = [ 0 ] * subarrayCount maxIndex = 0 for i in range ( subarrayCount ): if dp [ i ] > dp [ maxIndex ]: maxIndex = i left [ i ] = maxIndex right = [ 0 ] * subarrayCount maxIndex = subarrayCount - 1 for i in range ( subarrayCount - 1 , - 1 , - 1 ): if dp [ i ] >= dp [ maxIndex ]: maxIndex = i right [ i ] = maxIndex for i in range ( k , subarrayCount - k ): if ans [ 0 ] == - 1 or dp [ left [ i - k ]] + dp [ i ] + dp [ right [ i + k ]] > dp [ ans [ 0 ]] + dp [ ans [ 1 ]] + dp [ ans [ 2 ]]: ans = [ left [ i - k ], i , right [ i + k ]] return ans","title":"689. Maximum Sum of 3 Non-Overlapping Subarrays $\\star\\star\\star$"},{"location":"python3/0601-0700/0681-0690/#690-employee-importance-star","text":"class Solution : def getImportance ( self , employees : List [ 'Employee' ], id : int ) -> int : def dfs ( id : int ) -> int : subordinatesImportance = sum ( dfs ( subordinate ) for subordinate in idToEmployee [ id ] . subordinates ) return idToEmployee [ id ] . importance + subordinatesImportance idToEmployee = { employee . id : employee for employee in employees } return dfs ( id )","title":"690. Employee Importance $\\star$"},{"location":"python3/0601-0700/0691-0700/","text":"691. Stickers to Spell Word $\\star\\star\\star$ 692. Top K Frequent Words $\\star\\star$ class Solution : def topKFrequent ( self , words : List [ str ], k : int ) -> List [ str ]: ans = [] bucket = [[] for _ in range ( len ( words ) + 1 )] for word , freq in collections . Counter ( words ) . items (): bucket [ freq ] . append ( word ) for b in bucket [:: - 1 ]: for word in sorted ( b ): ans . append ( word ) if len ( ans ) == k : return ans 693. Binary Number with Alternating Bits $\\star$ 694. Number of Distinct Islands $\\star\\star$ \ud83d\udd12 695. Max Area of Island $\\star\\star$ class Solution : def maxAreaOfIsland ( self , grid : List [ List [ int ]]) -> int : def dfs ( i : int , j : int ) -> int : if not 0 <= i < len ( grid ) or not 0 <= j < len ( grid [ 0 ]): return 0 if grid [ i ][ j ] == 0 or seen [ i ][ j ]: return 0 seen [ i ][ j ] = True return 1 + dfs ( i + 1 , j ) + dfs ( i - 1 , j ) + dfs ( i , j + 1 ) + dfs ( i , j - 1 ) ans = 0 seen = [[ False ] * len ( grid [ 0 ]) for _ in range ( len ( grid ))] for i in range ( len ( grid )): for j in range ( len ( grid [ 0 ])): ans = max ( ans , dfs ( i , j )) return ans 696. Count Binary Substrings $\\star$ class Solution : def countBinarySubstrings ( self , s : str ) -> int : ans = 0 prevCount = 0 equals = 1 for i in range ( len ( s ) - 1 ): if s [ i ] == s [ i + 1 ]: equals += 1 else : ans += min ( prevCount , equals ) prevCount = equals equals = 1 return ans + min ( prevCount , equals ) 697. Degree of an Array $\\star$ class Solution : def findShortestSubArray ( self , nums : List [ int ]) -> int : ans = 0 degree = 0 firstSeen = {} numCounts = collections . defaultdict ( int ) for i , num in enumerate ( nums ): if num not in firstSeen : firstSeen [ num ] = i numCounts [ num ] += 1 if numCounts [ num ] > degree : degree = numCounts [ num ] ans = i - firstSeen [ num ] + 1 elif numCounts [ num ] == degree : ans = min ( ans , i - firstSeen [ num ] + 1 ) return ans 698. Partition to K Equal Sum Subsets $\\star\\star$ 699. Falling Squares $\\star\\star\\star$ 700. Search in a Binary Search Tree $\\star$","title":"0691-0700"},{"location":"python3/0601-0700/0691-0700/#691-stickers-to-spell-word-starstarstar","text":"","title":"691. Stickers to Spell Word $\\star\\star\\star$"},{"location":"python3/0601-0700/0691-0700/#692-top-k-frequent-words-starstar","text":"class Solution : def topKFrequent ( self , words : List [ str ], k : int ) -> List [ str ]: ans = [] bucket = [[] for _ in range ( len ( words ) + 1 )] for word , freq in collections . Counter ( words ) . items (): bucket [ freq ] . append ( word ) for b in bucket [:: - 1 ]: for word in sorted ( b ): ans . append ( word ) if len ( ans ) == k : return ans","title":"692. Top K Frequent Words $\\star\\star$"},{"location":"python3/0601-0700/0691-0700/#693-binary-number-with-alternating-bits-star","text":"","title":"693. Binary Number with Alternating Bits $\\star$"},{"location":"python3/0601-0700/0691-0700/#694-number-of-distinct-islands-starstar","text":"","title":"694. Number of Distinct Islands $\\star\\star$ \ud83d\udd12"},{"location":"python3/0601-0700/0691-0700/#695-max-area-of-island-starstar","text":"class Solution : def maxAreaOfIsland ( self , grid : List [ List [ int ]]) -> int : def dfs ( i : int , j : int ) -> int : if not 0 <= i < len ( grid ) or not 0 <= j < len ( grid [ 0 ]): return 0 if grid [ i ][ j ] == 0 or seen [ i ][ j ]: return 0 seen [ i ][ j ] = True return 1 + dfs ( i + 1 , j ) + dfs ( i - 1 , j ) + dfs ( i , j + 1 ) + dfs ( i , j - 1 ) ans = 0 seen = [[ False ] * len ( grid [ 0 ]) for _ in range ( len ( grid ))] for i in range ( len ( grid )): for j in range ( len ( grid [ 0 ])): ans = max ( ans , dfs ( i , j )) return ans","title":"695. Max Area of Island $\\star\\star$"},{"location":"python3/0601-0700/0691-0700/#696-count-binary-substrings-star","text":"class Solution : def countBinarySubstrings ( self , s : str ) -> int : ans = 0 prevCount = 0 equals = 1 for i in range ( len ( s ) - 1 ): if s [ i ] == s [ i + 1 ]: equals += 1 else : ans += min ( prevCount , equals ) prevCount = equals equals = 1 return ans + min ( prevCount , equals )","title":"696. Count Binary Substrings $\\star$"},{"location":"python3/0601-0700/0691-0700/#697-degree-of-an-array-star","text":"class Solution : def findShortestSubArray ( self , nums : List [ int ]) -> int : ans = 0 degree = 0 firstSeen = {} numCounts = collections . defaultdict ( int ) for i , num in enumerate ( nums ): if num not in firstSeen : firstSeen [ num ] = i numCounts [ num ] += 1 if numCounts [ num ] > degree : degree = numCounts [ num ] ans = i - firstSeen [ num ] + 1 elif numCounts [ num ] == degree : ans = min ( ans , i - firstSeen [ num ] + 1 ) return ans","title":"697. Degree of an Array $\\star$"},{"location":"python3/0601-0700/0691-0700/#698-partition-to-k-equal-sum-subsets-starstar","text":"","title":"698. Partition to K Equal Sum Subsets $\\star\\star$"},{"location":"python3/0601-0700/0691-0700/#699-falling-squares-starstarstar","text":"","title":"699. Falling Squares $\\star\\star\\star$"},{"location":"python3/0601-0700/0691-0700/#700-search-in-a-binary-search-tree-star","text":"","title":"700. Search in a Binary Search Tree $\\star$"},{"location":"python3/0701-0800/0701-0710/","text":"701. Insert into a Binary Search Tree $\\star\\star$ 702. Search in a Sorted Array of Unknown Size $\\star\\star$ \ud83d\udd12 703. Kth Largest Element in a Stream $\\star$ 704. Binary Search $\\star$ 705. Design HashSet $\\star$ class MyHashSet : def __init__ ( self ): self . set = [ False ] * 1000001 def add ( self , key : int ) -> None : self . set [ key ] = True def remove ( self , key : int ) -> None : self . set [ key ] = False def contains ( self , key : int ) -> bool : return self . set [ key ] 706. Design HashMap $\\star$ 707. Design Linked List $\\star\\star$ class ListNode : def __init__ ( self , x ): self . val = x self . next = None class MyLinkedList : def __init__ ( self ): self . length = 0 self . dummy = ListNode ( 0 ) def get ( self , index : int ) -> int : if index < 0 or index >= self . length : return - 1 curr = self . dummy . next for _ in range ( index ): curr = curr . next return curr . val def addAtHead ( self , val : int ) -> None : curr = self . dummy . next self . dummy . next = ListNode ( val ) self . dummy . next . next = curr self . length += 1 def addAtTail ( self , val : int ) -> None : curr = self . dummy while curr . next : curr = curr . next curr . next = ListNode ( val ) self . length += 1 def addAtIndex ( self , index : int , val : int ) -> None : if index > self . length : return curr = self . dummy for _ in range ( index ): curr = curr . next temp = curr . next curr . next = ListNode ( val ) curr . next . next = temp self . length += 1 def deleteAtIndex ( self , index : int ) -> None : if index < 0 or index >= self . length : return curr = self . dummy for _ in range ( index ): curr = curr . next temp = curr . next curr . next = temp . next self . length -= 1 708. Insert into a Sorted Circular Linked List $\\star\\star$ \ud83d\udd12 709. To Lower Case $\\star$ 710. Random Pick with Blacklist $\\star\\star\\star$ class Solution : def __init__ ( self , N : int , blacklist : List [ int ]): self . validRange = N - len ( blacklist ) self . dict = {} for b in blacklist : self . dict [ b ] = - 1 for b in blacklist : if b < self . validRange : while N - 1 in self . dict : N -= 1 self . dict [ b ] = N - 1 N -= 1 def pick ( self ) -> int : value = random . randint ( 0 , self . validRange - 1 ) if value in self . dict : return self . dict [ value ] return value","title":"0701-0710"},{"location":"python3/0701-0800/0701-0710/#701-insert-into-a-binary-search-tree-starstar","text":"","title":"701. Insert into a Binary Search Tree $\\star\\star$"},{"location":"python3/0701-0800/0701-0710/#702-search-in-a-sorted-array-of-unknown-size-starstar","text":"","title":"702. Search in a Sorted Array of Unknown Size $\\star\\star$ \ud83d\udd12"},{"location":"python3/0701-0800/0701-0710/#703-kth-largest-element-in-a-stream-star","text":"","title":"703. Kth Largest Element in a Stream $\\star$"},{"location":"python3/0701-0800/0701-0710/#704-binary-search-star","text":"","title":"704. Binary Search $\\star$"},{"location":"python3/0701-0800/0701-0710/#705-design-hashset-star","text":"class MyHashSet : def __init__ ( self ): self . set = [ False ] * 1000001 def add ( self , key : int ) -> None : self . set [ key ] = True def remove ( self , key : int ) -> None : self . set [ key ] = False def contains ( self , key : int ) -> bool : return self . set [ key ]","title":"705. Design HashSet $\\star$"},{"location":"python3/0701-0800/0701-0710/#706-design-hashmap-star","text":"","title":"706. Design HashMap $\\star$"},{"location":"python3/0701-0800/0701-0710/#707-design-linked-list-starstar","text":"class ListNode : def __init__ ( self , x ): self . val = x self . next = None class MyLinkedList : def __init__ ( self ): self . length = 0 self . dummy = ListNode ( 0 ) def get ( self , index : int ) -> int : if index < 0 or index >= self . length : return - 1 curr = self . dummy . next for _ in range ( index ): curr = curr . next return curr . val def addAtHead ( self , val : int ) -> None : curr = self . dummy . next self . dummy . next = ListNode ( val ) self . dummy . next . next = curr self . length += 1 def addAtTail ( self , val : int ) -> None : curr = self . dummy while curr . next : curr = curr . next curr . next = ListNode ( val ) self . length += 1 def addAtIndex ( self , index : int , val : int ) -> None : if index > self . length : return curr = self . dummy for _ in range ( index ): curr = curr . next temp = curr . next curr . next = ListNode ( val ) curr . next . next = temp self . length += 1 def deleteAtIndex ( self , index : int ) -> None : if index < 0 or index >= self . length : return curr = self . dummy for _ in range ( index ): curr = curr . next temp = curr . next curr . next = temp . next self . length -= 1","title":"707. Design Linked List $\\star\\star$"},{"location":"python3/0701-0800/0701-0710/#708-insert-into-a-sorted-circular-linked-list-starstar","text":"","title":"708. Insert into a Sorted Circular Linked List $\\star\\star$ \ud83d\udd12"},{"location":"python3/0701-0800/0701-0710/#709-to-lower-case-star","text":"","title":"709. To Lower Case $\\star$"},{"location":"python3/0701-0800/0701-0710/#710-random-pick-with-blacklist-starstarstar","text":"class Solution : def __init__ ( self , N : int , blacklist : List [ int ]): self . validRange = N - len ( blacklist ) self . dict = {} for b in blacklist : self . dict [ b ] = - 1 for b in blacklist : if b < self . validRange : while N - 1 in self . dict : N -= 1 self . dict [ b ] = N - 1 N -= 1 def pick ( self ) -> int : value = random . randint ( 0 , self . validRange - 1 ) if value in self . dict : return self . dict [ value ] return value","title":"710. Random Pick with Blacklist $\\star\\star\\star$"},{"location":"python3/0701-0800/0711-0720/","text":"711. Number of Distinct Islands II $\\star\\star\\star$ \ud83d\udd12 712. Minimum ASCII Delete Sum for Two Strings $\\star\\star$ 713. Subarray Product Less Than K $\\star\\star$ Time: $O(n)$ Space: $O(n)$ class Solution : def numSubarrayProductLessThanK ( self , nums : List [ int ], k : int ) -> int : if k <= 1 : return 0 ans = 0 prod = 1 j = 0 for i , num in enumerate ( nums ): prod *= num while prod >= k : prod /= nums [ j ] j += 1 ans += i - j + 1 return ans 714. Best Time to Buy and Sell Stock with Transaction Fee $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def maxProfit ( self , prices : List [ int ], fee : int ) -> int : sell = 0 hold = float ( '-inf' ) for price in prices : sell = max ( sell , hold + price ) hold = max ( hold , sell - price - fee ) return sell 715. Range Module $\\star\\star\\star$ 716. Max Stack $\\star$ \ud83d\udd12 717. 1-bit and 2-bit Characters $\\star$ class Solution : def isOneBitCharacter ( self , bits : List [ int ]) -> bool : i = 0 while i < len ( bits ) - 1 : i += bits [ i ] + 1 return i == len ( bits ) - 1 718. Maximum Length of Repeated Subarray $\\star\\star$ class Solution : def findLength ( self , A : List [ int ], B : List [ int ]) -> int : ans = 0 dp = [ 0 ] * ( len ( B ) + 1 ) for i , a in reversed ( list ( enumerate ( A ))): for j , b in enumerate ( B ): dp [ j ] = dp [ j + 1 ] + 1 if a == b else 0 ans = max ( ans , dp [ j ]) return ans 719. Find K-th Smallest Pair Distance $\\star\\star\\star$ class Solution : def smallestDistancePair ( self , nums : List [ int ], k : int ) -> int : nums . sort () l = 0 r = nums [ - 1 ] - nums [ 0 ] while l < r : m = ( l + r ) // 2 count = 0 j = 0 for i in range ( len ( nums )): while j < len ( nums ) and nums [ j ] <= nums [ i ] + m : j += 1 count += j - i - 1 if count < k : l = m + 1 else : r = m return l 720. Longest Word in Dictionary $\\star$ class Solution : def longestWord ( self , words : List [ str ]) -> str : def dfs ( node : dict ) -> str : ans = node [ 'word' ] if 'word' in node else '' for child in node : if 'word' in node [ child ] and len ( node [ child ][ 'word' ]) > 0 : childWord = dfs ( node [ child ]) if len ( childWord ) > len ( ans ) or ( len ( childWord ) == len ( ans ) and childWord < ans ): ans = childWord return ans self . root = {} for word in words : node = self . root for c in word : if c not in node : node [ c ] = {} node = node [ c ] node [ 'word' ] = word return dfs ( self . root )","title":"0711-0720"},{"location":"python3/0701-0800/0711-0720/#711-number-of-distinct-islands-ii-starstarstar","text":"","title":"711. Number of Distinct Islands II $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/0701-0800/0711-0720/#712-minimum-ascii-delete-sum-for-two-strings-starstar","text":"","title":"712. Minimum ASCII Delete Sum for Two Strings $\\star\\star$"},{"location":"python3/0701-0800/0711-0720/#713-subarray-product-less-than-k-starstar","text":"Time: $O(n)$ Space: $O(n)$ class Solution : def numSubarrayProductLessThanK ( self , nums : List [ int ], k : int ) -> int : if k <= 1 : return 0 ans = 0 prod = 1 j = 0 for i , num in enumerate ( nums ): prod *= num while prod >= k : prod /= nums [ j ] j += 1 ans += i - j + 1 return ans","title":"713. Subarray Product Less Than K $\\star\\star$"},{"location":"python3/0701-0800/0711-0720/#714-best-time-to-buy-and-sell-stock-with-transaction-fee-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def maxProfit ( self , prices : List [ int ], fee : int ) -> int : sell = 0 hold = float ( '-inf' ) for price in prices : sell = max ( sell , hold + price ) hold = max ( hold , sell - price - fee ) return sell","title":"714. Best Time to Buy and Sell Stock with Transaction Fee $\\star\\star$"},{"location":"python3/0701-0800/0711-0720/#715-range-module-starstarstar","text":"","title":"715. Range Module $\\star\\star\\star$"},{"location":"python3/0701-0800/0711-0720/#716-max-stack-star","text":"","title":"716. Max Stack $\\star$ \ud83d\udd12"},{"location":"python3/0701-0800/0711-0720/#717-1-bit-and-2-bit-characters-star","text":"class Solution : def isOneBitCharacter ( self , bits : List [ int ]) -> bool : i = 0 while i < len ( bits ) - 1 : i += bits [ i ] + 1 return i == len ( bits ) - 1","title":"717. 1-bit and 2-bit Characters $\\star$"},{"location":"python3/0701-0800/0711-0720/#718-maximum-length-of-repeated-subarray-starstar","text":"class Solution : def findLength ( self , A : List [ int ], B : List [ int ]) -> int : ans = 0 dp = [ 0 ] * ( len ( B ) + 1 ) for i , a in reversed ( list ( enumerate ( A ))): for j , b in enumerate ( B ): dp [ j ] = dp [ j + 1 ] + 1 if a == b else 0 ans = max ( ans , dp [ j ]) return ans","title":"718. Maximum Length of Repeated Subarray $\\star\\star$"},{"location":"python3/0701-0800/0711-0720/#719-find-k-th-smallest-pair-distance-starstarstar","text":"class Solution : def smallestDistancePair ( self , nums : List [ int ], k : int ) -> int : nums . sort () l = 0 r = nums [ - 1 ] - nums [ 0 ] while l < r : m = ( l + r ) // 2 count = 0 j = 0 for i in range ( len ( nums )): while j < len ( nums ) and nums [ j ] <= nums [ i ] + m : j += 1 count += j - i - 1 if count < k : l = m + 1 else : r = m return l","title":"719. Find K-th Smallest Pair Distance $\\star\\star\\star$"},{"location":"python3/0701-0800/0711-0720/#720-longest-word-in-dictionary-star","text":"class Solution : def longestWord ( self , words : List [ str ]) -> str : def dfs ( node : dict ) -> str : ans = node [ 'word' ] if 'word' in node else '' for child in node : if 'word' in node [ child ] and len ( node [ child ][ 'word' ]) > 0 : childWord = dfs ( node [ child ]) if len ( childWord ) > len ( ans ) or ( len ( childWord ) == len ( ans ) and childWord < ans ): ans = childWord return ans self . root = {} for word in words : node = self . root for c in word : if c not in node : node [ c ] = {} node = node [ c ] node [ 'word' ] = word return dfs ( self . root )","title":"720. Longest Word in Dictionary $\\star$"},{"location":"python3/0701-0800/0721-0730/","text":"721. Accounts Merge $\\star\\star$ 722. Remove Comments $\\star\\star$ class Solution : def removeComments ( self , source : List [ str ]) -> List [ str ]: ans = [] commenting = False modified = '' for line in source : i = 0 while i < len ( line ): if i + 1 == len ( line ): if not commenting : modified += line [ i ] i += 1 break twoChars = line [ i : i + 2 ] if twoChars == '/*' and not commenting : commenting = True i += 2 elif twoChars == '*/' and commenting : commenting = False i += 2 elif twoChars == '//' : if not commenting : break else : i += 2 else : if not commenting : modified += line [ i ] i += 1 if modified and not commenting : ans . append ( modified ) modified = '' return ans 723. Candy Crush $\\star\\star$ \ud83d\udd12 724. Find Pivot Index $\\star$ class Solution : def pivotIndex ( self , nums : List [ int ]) -> int : summ = sum ( nums ) prefixSum = 0 for i , num in enumerate ( nums ): if prefixSum == summ - prefixSum - num : return i prefixSum += num return - 1 725. Split Linked List in Parts $\\star\\star$ class Solution : def splitListToParts ( self , root : ListNode , k : int ) -> List [ ListNode ]: ans = [[] for _ in range ( k )] length = 0 curr = root while curr : length += 1 curr = curr . next subLength = length // k remainder = length % k prev = None head = root for i in range ( k ): ans [ i ] = head for j in range ( subLength + ( 1 if remainder > 0 else 0 )): prev = head head = head . next if prev : prev . next = None remainder -= 1 return ans 726. Number of Atoms $\\star\\star\\star$ class Solution : def countOfAtoms ( self , formula : str ) -> str : def parse () -> dict : ans = collections . defaultdict ( int ) nonlocal i while i < n : if formula [ i ] == '(' : i += 1 for elem , freq in parse () . items (): ans [ elem ] += freq elif formula [ i ] == ')' : i += 1 numStart = i while i < n and formula [ i ] . isdigit (): i += 1 factor = int ( formula [ numStart : i ]) for elem , freq in ans . items (): ans [ elem ] *= factor return ans elif formula [ i ] . isupper (): elemStart = i i += 1 while i < n and formula [ i ] . islower (): i += 1 elem = formula [ elemStart : i ] numStart = i while i < n and formula [ i ] . isdigit (): i += 1 num = 1 if i == numStart else int ( formula [ numStart : i ]) ans [ elem ] += num return ans n = len ( formula ) ans = \"\" i = 0 count = parse () for elem in sorted ( count . keys ()): ans += elem if count [ elem ] > 1 : ans += str ( count [ elem ]) return ans 727. Minimum Window Subsequence $\\star\\star\\star$ \ud83d\udd12 728. Self Dividing Numbers $\\star$ class Solution : def selfDividingNumbers ( self , left : int , right : int ) -> List [ int ]: return [ num for num in range ( left , right + 1 ) if all ( n != 0 and num % n == 0 for n in map ( int , str ( num )))] 729. My Calendar I $\\star\\star$ class MyCalendar : def __init__ ( self ): self . tree = self . Tree () def book ( self , start : int , end : int ) -> bool : return self . tree . insert ( self . Node ( start , end )) class Node : def __init__ ( self , start : int , end : int ): self . start = start self . end = end self . left = None self . right = None class Tree : def __init__ ( self ): self . root = None def insert ( self , node , root = None ): if not root : if not self . root : self . root = node return True else : root = self . root if node . start >= root . end : if not root . right : root . right = node return True return self . insert ( node , root . right ) elif node . end <= root . start : if not root . left : root . left = node return True return self . insert ( node , root . left ) else : return False 730. Count Different Palindromic Subsequences $\\star\\star\\star$ class Solution : def countPalindromicSubsequences ( self , S : str ) -> int : def count ( l : int , r : int ) -> int : if l > r : return 0 if l == r : return 1 key = l * len ( S ) + r if key in memo : return memo [ key ] if S [ l ] == S [ r ]: lo = l + 1 hi = r - 1 while lo <= hi and S [ lo ] != S [ l ]: lo += 1 while lo <= hi and S [ hi ] != S [ l ]: hi -= 1 if lo > hi : ans = count ( l + 1 , r - 1 ) * 2 + 2 elif lo == hi : ans = count ( l + 1 , r - 1 ) * 2 + 1 else : ans = count ( l + 1 , r - 1 ) * 2 - count ( lo + 1 , hi - 1 ) else : ans = count ( l , r - 1 ) + count ( l + 1 , r ) - count ( l + 1 , r - 1 ) memo [ key ] = ( ans + kMod ) % kMod return memo [ key ] kMod = int ( 1e9 + 7 ) memo = {} return count ( 0 , len ( S ) - 1 )","title":"0721-0730"},{"location":"python3/0701-0800/0721-0730/#721-accounts-merge-starstar","text":"","title":"721. Accounts Merge $\\star\\star$"},{"location":"python3/0701-0800/0721-0730/#722-remove-comments-starstar","text":"class Solution : def removeComments ( self , source : List [ str ]) -> List [ str ]: ans = [] commenting = False modified = '' for line in source : i = 0 while i < len ( line ): if i + 1 == len ( line ): if not commenting : modified += line [ i ] i += 1 break twoChars = line [ i : i + 2 ] if twoChars == '/*' and not commenting : commenting = True i += 2 elif twoChars == '*/' and commenting : commenting = False i += 2 elif twoChars == '//' : if not commenting : break else : i += 2 else : if not commenting : modified += line [ i ] i += 1 if modified and not commenting : ans . append ( modified ) modified = '' return ans","title":"722. Remove Comments $\\star\\star$"},{"location":"python3/0701-0800/0721-0730/#723-candy-crush-starstar","text":"","title":"723. Candy Crush $\\star\\star$ \ud83d\udd12"},{"location":"python3/0701-0800/0721-0730/#724-find-pivot-index-star","text":"class Solution : def pivotIndex ( self , nums : List [ int ]) -> int : summ = sum ( nums ) prefixSum = 0 for i , num in enumerate ( nums ): if prefixSum == summ - prefixSum - num : return i prefixSum += num return - 1","title":"724. Find Pivot Index $\\star$"},{"location":"python3/0701-0800/0721-0730/#725-split-linked-list-in-parts-starstar","text":"class Solution : def splitListToParts ( self , root : ListNode , k : int ) -> List [ ListNode ]: ans = [[] for _ in range ( k )] length = 0 curr = root while curr : length += 1 curr = curr . next subLength = length // k remainder = length % k prev = None head = root for i in range ( k ): ans [ i ] = head for j in range ( subLength + ( 1 if remainder > 0 else 0 )): prev = head head = head . next if prev : prev . next = None remainder -= 1 return ans","title":"725. Split Linked List in Parts $\\star\\star$"},{"location":"python3/0701-0800/0721-0730/#726-number-of-atoms-starstarstar","text":"class Solution : def countOfAtoms ( self , formula : str ) -> str : def parse () -> dict : ans = collections . defaultdict ( int ) nonlocal i while i < n : if formula [ i ] == '(' : i += 1 for elem , freq in parse () . items (): ans [ elem ] += freq elif formula [ i ] == ')' : i += 1 numStart = i while i < n and formula [ i ] . isdigit (): i += 1 factor = int ( formula [ numStart : i ]) for elem , freq in ans . items (): ans [ elem ] *= factor return ans elif formula [ i ] . isupper (): elemStart = i i += 1 while i < n and formula [ i ] . islower (): i += 1 elem = formula [ elemStart : i ] numStart = i while i < n and formula [ i ] . isdigit (): i += 1 num = 1 if i == numStart else int ( formula [ numStart : i ]) ans [ elem ] += num return ans n = len ( formula ) ans = \"\" i = 0 count = parse () for elem in sorted ( count . keys ()): ans += elem if count [ elem ] > 1 : ans += str ( count [ elem ]) return ans","title":"726. Number of Atoms $\\star\\star\\star$"},{"location":"python3/0701-0800/0721-0730/#727-minimum-window-subsequence-starstarstar","text":"","title":"727. Minimum Window Subsequence $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/0701-0800/0721-0730/#728-self-dividing-numbers-star","text":"class Solution : def selfDividingNumbers ( self , left : int , right : int ) -> List [ int ]: return [ num for num in range ( left , right + 1 ) if all ( n != 0 and num % n == 0 for n in map ( int , str ( num )))]","title":"728. Self Dividing Numbers $\\star$"},{"location":"python3/0701-0800/0721-0730/#729-my-calendar-i-starstar","text":"class MyCalendar : def __init__ ( self ): self . tree = self . Tree () def book ( self , start : int , end : int ) -> bool : return self . tree . insert ( self . Node ( start , end )) class Node : def __init__ ( self , start : int , end : int ): self . start = start self . end = end self . left = None self . right = None class Tree : def __init__ ( self ): self . root = None def insert ( self , node , root = None ): if not root : if not self . root : self . root = node return True else : root = self . root if node . start >= root . end : if not root . right : root . right = node return True return self . insert ( node , root . right ) elif node . end <= root . start : if not root . left : root . left = node return True return self . insert ( node , root . left ) else : return False","title":"729. My Calendar I $\\star\\star$"},{"location":"python3/0701-0800/0721-0730/#730-count-different-palindromic-subsequences-starstarstar","text":"class Solution : def countPalindromicSubsequences ( self , S : str ) -> int : def count ( l : int , r : int ) -> int : if l > r : return 0 if l == r : return 1 key = l * len ( S ) + r if key in memo : return memo [ key ] if S [ l ] == S [ r ]: lo = l + 1 hi = r - 1 while lo <= hi and S [ lo ] != S [ l ]: lo += 1 while lo <= hi and S [ hi ] != S [ l ]: hi -= 1 if lo > hi : ans = count ( l + 1 , r - 1 ) * 2 + 2 elif lo == hi : ans = count ( l + 1 , r - 1 ) * 2 + 1 else : ans = count ( l + 1 , r - 1 ) * 2 - count ( lo + 1 , hi - 1 ) else : ans = count ( l , r - 1 ) + count ( l + 1 , r ) - count ( l + 1 , r - 1 ) memo [ key ] = ( ans + kMod ) % kMod return memo [ key ] kMod = int ( 1e9 + 7 ) memo = {} return count ( 0 , len ( S ) - 1 )","title":"730. Count Different Palindromic Subsequences $\\star\\star\\star$"},{"location":"python3/0701-0800/0731-0740/","text":"731. My Calendar II $\\star\\star$ 732. My Calendar III $\\star\\star\\star$ 733. Flood Fill $\\star$ class Solution : def floodFill ( self , image : List [ List [ int ]], sr : int , sc : int , newColor : int ) -> List [ List [ int ]]: def dfs ( i : int , j : int ) -> None : if not 0 <= i < len ( image ) or not 0 <= j < len ( image [ 0 ]): return if image [ i ][ j ] != startColor or seen [ i ][ j ]: return image [ i ][ j ] = newColor seen [ i ][ j ] = True dfs ( i + 1 , j ) dfs ( i - 1 , j ) dfs ( i , j + 1 ) dfs ( i , j - 1 ) startColor = image [ sr ][ sc ] seen = [[ False ] * len ( image [ 0 ]) for _ in range ( len ( image ))] dfs ( sr , sc ) return image 734. Sentence Similarity $\\star$ \ud83d\udd12 735. Asteroid Collision $\\star\\star$ 736. Parse Lisp Expression $\\star\\star\\star$ class Solution : def evaluate ( self , expression : str ) -> int : def evaluate ( e : str , prevScope : dict ) -> int : if e [ 0 ] . isdigit () or e [ 0 ] == '-' : return int ( e ) if e in prevScope : return prevScope [ e ] scope = prevScope . copy () nextExpression = e [ e . index ( ' ' ) + 1 : - 1 ] tokens = parse ( nextExpression ) if e [ 1 ] == 'a' : return evaluate ( tokens [ 0 ], scope ) + evaluate ( tokens [ 1 ], scope ) if e [ 1 ] == 'm' : return evaluate ( tokens [ 0 ], scope ) * evaluate ( tokens [ 1 ], scope ) for i in range ( 0 , len ( tokens ) - 2 , 2 ): scope [ tokens [ i ]] = evaluate ( tokens [ i + 1 ], scope ) return evaluate ( tokens [ - 1 ], scope ) def parse ( e : str ): tokens = [] s = '' parenthesis = 0 for c in e : if c == '(' : parenthesis += 1 elif c == ')' : parenthesis -= 1 if parenthesis == 0 and c == ' ' : tokens . append ( s ) s = '' else : s += c if len ( s ) > 0 : tokens . append ( s ) return tokens return evaluate ( expression , {}) 737. Sentence Similarity II $\\star\\star$ \ud83d\udd12 738. Monotone Increasing Digits $\\star\\star$ 739. Daily Temperatures $\\star\\star$ class Solution : def dailyTemperatures ( self , T : List [ int ]) -> List [ int ]: ans = [ 0 ] * len ( T ) stack = [] for i , t in enumerate ( T ): while stack != [] and t > T [ stack [ - 1 ]]: index = stack . pop () ans [ index ] = i - index stack . append ( i ) return ans 740. Delete and Earn $\\star\\star$","title":"0731-0740"},{"location":"python3/0701-0800/0731-0740/#731-my-calendar-ii-starstar","text":"","title":"731. My Calendar II $\\star\\star$"},{"location":"python3/0701-0800/0731-0740/#732-my-calendar-iii-starstarstar","text":"","title":"732. My Calendar III $\\star\\star\\star$"},{"location":"python3/0701-0800/0731-0740/#733-flood-fill-star","text":"class Solution : def floodFill ( self , image : List [ List [ int ]], sr : int , sc : int , newColor : int ) -> List [ List [ int ]]: def dfs ( i : int , j : int ) -> None : if not 0 <= i < len ( image ) or not 0 <= j < len ( image [ 0 ]): return if image [ i ][ j ] != startColor or seen [ i ][ j ]: return image [ i ][ j ] = newColor seen [ i ][ j ] = True dfs ( i + 1 , j ) dfs ( i - 1 , j ) dfs ( i , j + 1 ) dfs ( i , j - 1 ) startColor = image [ sr ][ sc ] seen = [[ False ] * len ( image [ 0 ]) for _ in range ( len ( image ))] dfs ( sr , sc ) return image","title":"733. Flood Fill $\\star$"},{"location":"python3/0701-0800/0731-0740/#734-sentence-similarity-star","text":"","title":"734. Sentence Similarity $\\star$ \ud83d\udd12"},{"location":"python3/0701-0800/0731-0740/#735-asteroid-collision-starstar","text":"","title":"735. Asteroid Collision $\\star\\star$"},{"location":"python3/0701-0800/0731-0740/#736-parse-lisp-expression-starstarstar","text":"class Solution : def evaluate ( self , expression : str ) -> int : def evaluate ( e : str , prevScope : dict ) -> int : if e [ 0 ] . isdigit () or e [ 0 ] == '-' : return int ( e ) if e in prevScope : return prevScope [ e ] scope = prevScope . copy () nextExpression = e [ e . index ( ' ' ) + 1 : - 1 ] tokens = parse ( nextExpression ) if e [ 1 ] == 'a' : return evaluate ( tokens [ 0 ], scope ) + evaluate ( tokens [ 1 ], scope ) if e [ 1 ] == 'm' : return evaluate ( tokens [ 0 ], scope ) * evaluate ( tokens [ 1 ], scope ) for i in range ( 0 , len ( tokens ) - 2 , 2 ): scope [ tokens [ i ]] = evaluate ( tokens [ i + 1 ], scope ) return evaluate ( tokens [ - 1 ], scope ) def parse ( e : str ): tokens = [] s = '' parenthesis = 0 for c in e : if c == '(' : parenthesis += 1 elif c == ')' : parenthesis -= 1 if parenthesis == 0 and c == ' ' : tokens . append ( s ) s = '' else : s += c if len ( s ) > 0 : tokens . append ( s ) return tokens return evaluate ( expression , {})","title":"736. Parse Lisp Expression $\\star\\star\\star$"},{"location":"python3/0701-0800/0731-0740/#737-sentence-similarity-ii-starstar","text":"","title":"737. Sentence Similarity II $\\star\\star$ \ud83d\udd12"},{"location":"python3/0701-0800/0731-0740/#738-monotone-increasing-digits-starstar","text":"","title":"738. Monotone Increasing Digits $\\star\\star$"},{"location":"python3/0701-0800/0731-0740/#739-daily-temperatures-starstar","text":"class Solution : def dailyTemperatures ( self , T : List [ int ]) -> List [ int ]: ans = [ 0 ] * len ( T ) stack = [] for i , t in enumerate ( T ): while stack != [] and t > T [ stack [ - 1 ]]: index = stack . pop () ans [ index ] = i - index stack . append ( i ) return ans","title":"739. Daily Temperatures $\\star\\star$"},{"location":"python3/0701-0800/0731-0740/#740-delete-and-earn-starstar","text":"","title":"740. Delete and Earn $\\star\\star$"},{"location":"python3/0701-0800/0741-0750/","text":"741. Cherry Pickup $\\star\\star\\star$ 742. Closest Leaf in a Binary Tree $\\star\\star$ \ud83d\udd12 743. Network Delay Time $\\star\\star$ 744. Find Smallest Letter Greater Than Target $\\star$ class Solution : def nextGreatestLetter ( self , letters : List [ str ], target : str ) -> str : l = 0 r = len ( letters ) while l < r : m = ( l + r ) >> 1 if letters [ m ] <= target : l = m + 1 else : r = m return letters [ l % len ( letters )] 745. Prefix and Suffix Search $\\star\\star\\star$ 746. Min Cost Climbing Stairs $\\star$ class Solution : def minCostClimbingStairs ( self , cost : List [ int ]) -> int : cost . append ( 0 ) for i in range ( 2 , len ( cost )): cost [ i ] += min ( cost [ i - 1 ], cost [ i - 2 ]) return cost [ - 1 ] 747. Largest Number At Least Twice of Others $\\star$ class Solution : def dominantIndex ( self , nums : List [ int ]) -> int : max = 0 secondMax = 0 for i , num in enumerate ( nums ): if num > max : secondMax = max max = num ans = i elif num > secondMax : secondMax = num return ans if max >= 2 * secondMax else - 1 748. Shortest Completing Word $\\star$ class Solution : def shortestCompletingWord ( self , licensePlate : str , words : List [ str ]) -> str : def isMatch ( word : str ) -> bool : wordCount = collections . Counter ( word ) return False if any ( wordCount [ i ] < count [ i ] for i in string . ascii_letters ) else True ans = '*' * 16 count = collections . defaultdict ( int ) for c in licensePlate : if c . isalpha (): count [ c . lower ()] += 1 for word in words : if len ( word ) < len ( ans ) and isMatch ( word ): ans = word return ans 749. Contain Virus $\\star\\star\\star$ 750. Number Of Corner Rectangles $\\star\\star$ \ud83d\udd12","title":"0741-0750"},{"location":"python3/0701-0800/0741-0750/#741-cherry-pickup-starstarstar","text":"","title":"741. Cherry Pickup $\\star\\star\\star$"},{"location":"python3/0701-0800/0741-0750/#742-closest-leaf-in-a-binary-tree-starstar","text":"","title":"742. Closest Leaf in a Binary Tree $\\star\\star$ \ud83d\udd12"},{"location":"python3/0701-0800/0741-0750/#743-network-delay-time-starstar","text":"","title":"743. Network Delay Time $\\star\\star$"},{"location":"python3/0701-0800/0741-0750/#744-find-smallest-letter-greater-than-target-star","text":"class Solution : def nextGreatestLetter ( self , letters : List [ str ], target : str ) -> str : l = 0 r = len ( letters ) while l < r : m = ( l + r ) >> 1 if letters [ m ] <= target : l = m + 1 else : r = m return letters [ l % len ( letters )]","title":"744. Find Smallest Letter Greater Than Target $\\star$"},{"location":"python3/0701-0800/0741-0750/#745-prefix-and-suffix-search-starstarstar","text":"","title":"745. Prefix and Suffix Search $\\star\\star\\star$"},{"location":"python3/0701-0800/0741-0750/#746-min-cost-climbing-stairs-star","text":"class Solution : def minCostClimbingStairs ( self , cost : List [ int ]) -> int : cost . append ( 0 ) for i in range ( 2 , len ( cost )): cost [ i ] += min ( cost [ i - 1 ], cost [ i - 2 ]) return cost [ - 1 ]","title":"746. Min Cost Climbing Stairs $\\star$"},{"location":"python3/0701-0800/0741-0750/#747-largest-number-at-least-twice-of-others-star","text":"class Solution : def dominantIndex ( self , nums : List [ int ]) -> int : max = 0 secondMax = 0 for i , num in enumerate ( nums ): if num > max : secondMax = max max = num ans = i elif num > secondMax : secondMax = num return ans if max >= 2 * secondMax else - 1","title":"747. Largest Number At Least Twice of Others $\\star$"},{"location":"python3/0701-0800/0741-0750/#748-shortest-completing-word-star","text":"class Solution : def shortestCompletingWord ( self , licensePlate : str , words : List [ str ]) -> str : def isMatch ( word : str ) -> bool : wordCount = collections . Counter ( word ) return False if any ( wordCount [ i ] < count [ i ] for i in string . ascii_letters ) else True ans = '*' * 16 count = collections . defaultdict ( int ) for c in licensePlate : if c . isalpha (): count [ c . lower ()] += 1 for word in words : if len ( word ) < len ( ans ) and isMatch ( word ): ans = word return ans","title":"748. Shortest Completing Word $\\star$"},{"location":"python3/0701-0800/0741-0750/#749-contain-virus-starstarstar","text":"","title":"749. Contain Virus $\\star\\star\\star$"},{"location":"python3/0701-0800/0741-0750/#750-number-of-corner-rectangles-starstar","text":"","title":"750. Number Of Corner Rectangles $\\star\\star$ \ud83d\udd12"},{"location":"python3/0701-0800/0751-0760/","text":"751. IP to CIDR $\\star$ \ud83d\udd12 752. Open the Lock $\\star\\star$ 753. Cracking the Safe $\\star\\star\\star$ class Solution : def crackSafe ( self , n : int , k : int ) -> str : def dfs ( path : str ) -> str : if len ( seen ) == passwordSize : return path for c in map ( str , range ( k )): node = path [ - n + 1 :] + c if n > 1 else c if node not in seen : seen . add ( node ) res = dfs ( path + c ) if res : return res seen . remove ( node ) passwordSize = k ** n path = '0' * n seen = set () seen . add ( path ) return dfs ( path ) 754. Reach a Number $\\star\\star$ class Solution : def reachNumber ( self , target : int ) -> int : ans = 0 pos = 0 target = abs ( target ) while pos < target : ans += 1 pos += ans while ( pos - target ) & 1 : ans += 1 pos += ans return ans 755. Pour Water $\\star\\star$ \ud83d\udd12 756. Pyramid Transition Matrix $\\star\\star$ class Solution : def pyramidTransition ( self , bottom : str , allowed : List [ str ]) -> bool : def dfs ( row : str , nextRow : str , i : int ) -> bool : if len ( row ) == 1 : return True if len ( nextRow ) + 1 == len ( row ): return dfs ( nextRow , '' , 0 ) for c in prefixToBlocks [ row [ i : i + 2 ]]: if dfs ( row , nextRow + c , i + 1 ): return True return False prefixToBlocks = collections . defaultdict ( list ) for a in allowed : prefixToBlocks [ a [: 2 ]] . append ( a [ 2 ]) return dfs ( bottom , '' , 0 ) 757. Set Intersection Size At Least Two $\\star\\star\\star$ 758. Bold Words in String $\\star$ \ud83d\udd12 759. Employee Free Time $\\star\\star\\star$ \ud83d\udd12 760. Find Anagram Mappings $\\star$ \ud83d\udd12","title":"0751-0760"},{"location":"python3/0701-0800/0751-0760/#751-ip-to-cidr-star","text":"","title":"751. IP to CIDR $\\star$ \ud83d\udd12"},{"location":"python3/0701-0800/0751-0760/#752-open-the-lock-starstar","text":"","title":"752. Open the Lock $\\star\\star$"},{"location":"python3/0701-0800/0751-0760/#753-cracking-the-safe-starstarstar","text":"class Solution : def crackSafe ( self , n : int , k : int ) -> str : def dfs ( path : str ) -> str : if len ( seen ) == passwordSize : return path for c in map ( str , range ( k )): node = path [ - n + 1 :] + c if n > 1 else c if node not in seen : seen . add ( node ) res = dfs ( path + c ) if res : return res seen . remove ( node ) passwordSize = k ** n path = '0' * n seen = set () seen . add ( path ) return dfs ( path )","title":"753. Cracking the Safe $\\star\\star\\star$"},{"location":"python3/0701-0800/0751-0760/#754-reach-a-number-starstar","text":"class Solution : def reachNumber ( self , target : int ) -> int : ans = 0 pos = 0 target = abs ( target ) while pos < target : ans += 1 pos += ans while ( pos - target ) & 1 : ans += 1 pos += ans return ans","title":"754. Reach a Number $\\star\\star$"},{"location":"python3/0701-0800/0751-0760/#755-pour-water-starstar","text":"","title":"755. Pour Water $\\star\\star$ \ud83d\udd12"},{"location":"python3/0701-0800/0751-0760/#756-pyramid-transition-matrix-starstar","text":"class Solution : def pyramidTransition ( self , bottom : str , allowed : List [ str ]) -> bool : def dfs ( row : str , nextRow : str , i : int ) -> bool : if len ( row ) == 1 : return True if len ( nextRow ) + 1 == len ( row ): return dfs ( nextRow , '' , 0 ) for c in prefixToBlocks [ row [ i : i + 2 ]]: if dfs ( row , nextRow + c , i + 1 ): return True return False prefixToBlocks = collections . defaultdict ( list ) for a in allowed : prefixToBlocks [ a [: 2 ]] . append ( a [ 2 ]) return dfs ( bottom , '' , 0 )","title":"756. Pyramid Transition Matrix $\\star\\star$"},{"location":"python3/0701-0800/0751-0760/#757-set-intersection-size-at-least-two-starstarstar","text":"","title":"757. Set Intersection Size At Least Two $\\star\\star\\star$"},{"location":"python3/0701-0800/0751-0760/#758-bold-words-in-string-star","text":"","title":"758. Bold Words in String $\\star$ \ud83d\udd12"},{"location":"python3/0701-0800/0751-0760/#759-employee-free-time-starstarstar","text":"","title":"759. Employee Free Time $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/0701-0800/0751-0760/#760-find-anagram-mappings-star","text":"","title":"760. Find Anagram Mappings $\\star$ \ud83d\udd12"},{"location":"python3/0701-0800/0761-0770/","text":"761. Special Binary String $\\star\\star\\star$ class Solution : def makeLargestSpecial ( self , S : str ) -> str : specials = [] count = 0 i = 0 for j , c in enumerate ( S ): count += 1 if c == '1' else - 1 if count == 0 : specials . append ( '1' + self . makeLargestSpecial ( S [ i + 1 : j ]) + '0' ) i = j + 1 return '' . join ( sorted ( specials )[:: - 1 ]) 762. Prime Number of Set Bits in Binary Representation $\\star$ 763. Partition Labels $\\star\\star$ Time: $O(n)$ Space: $O(26)$ class Solution : def partitionLabels ( self , S : str ) -> List [ int ]: ans = [] dict = { c : i for i , c in enumerate ( S )} start = 0 end = 0 for i , c in enumerate ( S ): end = max ( end , dict [ c ]) if i == end : ans . append ( end - start + 1 ) start = end + 1 return ans 764. Largest Plus Sign $\\star\\star$ 765. Couples Holding Hands $\\star\\star\\star$ 766. Toeplitz Matrix $\\star$ class Solution : def isToeplitzMatrix ( self , matrix : List [ List [ int ]]) -> bool : for i in range ( len ( matrix ) - 1 ): for j in range ( len ( matrix [ 0 ]) - 1 ): if matrix [ i ][ j ] != matrix [ i + 1 ][ j + 1 ]: return False return True 767. Reorganize String $\\star\\star$ class Solution : def reorganizeString ( self , S : str ) -> str : n = len ( S ) count = collections . Counter ( S ) maxCount = max ( count . values ()) if maxCount > ( n + 1 ) // 2 : return '' if maxCount == ( n + 1 ) // 2 : maxLetter = max ( count , key = count . get ) ans = [ maxLetter if i % 2 == 0 else '' for i in range ( n )] del count [ maxLetter ] i = 1 else : ans = [ '' ] * n i = 0 for c , freq in count . items (): for _ in range ( freq ): ans [ i ] = c i += 2 if i >= n : i = 1 return '' . join ( ans ) 768. Max Chunks To Make Sorted II $\\star\\star\\star$ class Solution : def maxChunksToSorted ( self , arr : List [ int ]) -> int : n = len ( arr ) ans = 0 maxi = float ( '-inf' ) mini = [ arr [ - 1 ]] * n for i in range ( n - 2 , - 1 , - 1 ): mini [ i ] = min ( mini [ i + 1 ], arr [ i ]) for i in range ( n - 1 ): maxi = max ( maxi , arr [ i ]) if maxi <= mini [ i + 1 ]: ans += 1 return ans + 1 769. Max Chunks To Make Sorted $\\star\\star$ class Solution : def maxChunksToSorted ( self , arr : List [ int ]) -> int : ans = 0 maxi = float ( '-inf' ) for i , a in enumerate ( arr ): maxi = max ( maxi , a ) if maxi == i : ans += 1 return ans 770. Basic Calculator IV $\\star\\star\\star$","title":"0761-0770"},{"location":"python3/0701-0800/0761-0770/#761-special-binary-string-starstarstar","text":"class Solution : def makeLargestSpecial ( self , S : str ) -> str : specials = [] count = 0 i = 0 for j , c in enumerate ( S ): count += 1 if c == '1' else - 1 if count == 0 : specials . append ( '1' + self . makeLargestSpecial ( S [ i + 1 : j ]) + '0' ) i = j + 1 return '' . join ( sorted ( specials )[:: - 1 ])","title":"761. Special Binary String $\\star\\star\\star$"},{"location":"python3/0701-0800/0761-0770/#762-prime-number-of-set-bits-in-binary-representation-star","text":"","title":"762. Prime Number of Set Bits in Binary Representation $\\star$"},{"location":"python3/0701-0800/0761-0770/#763-partition-labels-starstar","text":"Time: $O(n)$ Space: $O(26)$ class Solution : def partitionLabels ( self , S : str ) -> List [ int ]: ans = [] dict = { c : i for i , c in enumerate ( S )} start = 0 end = 0 for i , c in enumerate ( S ): end = max ( end , dict [ c ]) if i == end : ans . append ( end - start + 1 ) start = end + 1 return ans","title":"763. Partition Labels $\\star\\star$"},{"location":"python3/0701-0800/0761-0770/#764-largest-plus-sign-starstar","text":"","title":"764. Largest Plus Sign $\\star\\star$"},{"location":"python3/0701-0800/0761-0770/#765-couples-holding-hands-starstarstar","text":"","title":"765. Couples Holding Hands $\\star\\star\\star$"},{"location":"python3/0701-0800/0761-0770/#766-toeplitz-matrix-star","text":"class Solution : def isToeplitzMatrix ( self , matrix : List [ List [ int ]]) -> bool : for i in range ( len ( matrix ) - 1 ): for j in range ( len ( matrix [ 0 ]) - 1 ): if matrix [ i ][ j ] != matrix [ i + 1 ][ j + 1 ]: return False return True","title":"766. Toeplitz Matrix $\\star$"},{"location":"python3/0701-0800/0761-0770/#767-reorganize-string-starstar","text":"class Solution : def reorganizeString ( self , S : str ) -> str : n = len ( S ) count = collections . Counter ( S ) maxCount = max ( count . values ()) if maxCount > ( n + 1 ) // 2 : return '' if maxCount == ( n + 1 ) // 2 : maxLetter = max ( count , key = count . get ) ans = [ maxLetter if i % 2 == 0 else '' for i in range ( n )] del count [ maxLetter ] i = 1 else : ans = [ '' ] * n i = 0 for c , freq in count . items (): for _ in range ( freq ): ans [ i ] = c i += 2 if i >= n : i = 1 return '' . join ( ans )","title":"767. Reorganize String $\\star\\star$"},{"location":"python3/0701-0800/0761-0770/#768-max-chunks-to-make-sorted-ii-starstarstar","text":"class Solution : def maxChunksToSorted ( self , arr : List [ int ]) -> int : n = len ( arr ) ans = 0 maxi = float ( '-inf' ) mini = [ arr [ - 1 ]] * n for i in range ( n - 2 , - 1 , - 1 ): mini [ i ] = min ( mini [ i + 1 ], arr [ i ]) for i in range ( n - 1 ): maxi = max ( maxi , arr [ i ]) if maxi <= mini [ i + 1 ]: ans += 1 return ans + 1","title":"768. Max Chunks To Make Sorted II $\\star\\star\\star$"},{"location":"python3/0701-0800/0761-0770/#769-max-chunks-to-make-sorted-starstar","text":"class Solution : def maxChunksToSorted ( self , arr : List [ int ]) -> int : ans = 0 maxi = float ( '-inf' ) for i , a in enumerate ( arr ): maxi = max ( maxi , a ) if maxi == i : ans += 1 return ans","title":"769. Max Chunks To Make Sorted $\\star\\star$"},{"location":"python3/0701-0800/0761-0770/#770-basic-calculator-iv-starstarstar","text":"","title":"770. Basic Calculator IV $\\star\\star\\star$"},{"location":"python3/0701-0800/0771-0780/","text":"771. Jewels and Stones $\\star$ class Solution : def numJewelsInStones ( self , J : str , S : str ) -> int : jewels = set ( J ) return sum ( s in jewels for s in S ) 772. Basic Calculator III $\\star\\star\\star$ \ud83d\udd12 773. Sliding Puzzle $\\star\\star\\star$ 774. Minimize Max Distance to Gas Station $\\star\\star\\star$ \ud83d\udd12 775. Global and Local Inversions $\\star\\star$ class Solution : def isIdealPermutation ( self , A : List [ int ]) -> bool : for i , a in enumerate ( A ): if abs ( a - i ) > 1 : return False return True 776. Split BST $\\star\\star$ \ud83d\udd12 777. Swap Adjacent in LR String $\\star\\star$ 778. Swim in Rising Water $\\star\\star\\star$ 779. K-th Symbol in Grammar $\\star\\star$ 780. Reaching Points $\\star\\star\\star$ class Solution : def reachingPoints ( self , sx : int , sy : int , tx : int , ty : int ) -> bool : while sx < tx and sy < ty : tx , ty = tx % ty , ty % tx return sx == tx and sy <= ty and ( ty - sy ) % tx == 0 or \\ sy == ty and sx <= tx and ( tx - sx ) % ty == 0","title":"0771-0780"},{"location":"python3/0701-0800/0771-0780/#771-jewels-and-stones-star","text":"class Solution : def numJewelsInStones ( self , J : str , S : str ) -> int : jewels = set ( J ) return sum ( s in jewels for s in S )","title":"771. Jewels and Stones $\\star$"},{"location":"python3/0701-0800/0771-0780/#772-basic-calculator-iii-starstarstar","text":"","title":"772. Basic Calculator III $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/0701-0800/0771-0780/#773-sliding-puzzle-starstarstar","text":"","title":"773. Sliding Puzzle $\\star\\star\\star$"},{"location":"python3/0701-0800/0771-0780/#774-minimize-max-distance-to-gas-station-starstarstar","text":"","title":"774. Minimize Max Distance to Gas Station $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/0701-0800/0771-0780/#775-global-and-local-inversions-starstar","text":"class Solution : def isIdealPermutation ( self , A : List [ int ]) -> bool : for i , a in enumerate ( A ): if abs ( a - i ) > 1 : return False return True","title":"775. Global and Local Inversions $\\star\\star$"},{"location":"python3/0701-0800/0771-0780/#776-split-bst-starstar","text":"","title":"776. Split BST $\\star\\star$ \ud83d\udd12"},{"location":"python3/0701-0800/0771-0780/#777-swap-adjacent-in-lr-string-starstar","text":"","title":"777. Swap Adjacent in LR String $\\star\\star$"},{"location":"python3/0701-0800/0771-0780/#778-swim-in-rising-water-starstarstar","text":"","title":"778. Swim in Rising Water $\\star\\star\\star$"},{"location":"python3/0701-0800/0771-0780/#779-k-th-symbol-in-grammar-starstar","text":"","title":"779. K-th Symbol in Grammar $\\star\\star$"},{"location":"python3/0701-0800/0771-0780/#780-reaching-points-starstarstar","text":"class Solution : def reachingPoints ( self , sx : int , sy : int , tx : int , ty : int ) -> bool : while sx < tx and sy < ty : tx , ty = tx % ty , ty % tx return sx == tx and sy <= ty and ( ty - sy ) % tx == 0 or \\ sy == ty and sx <= tx and ( tx - sx ) % ty == 0","title":"780. Reaching Points $\\star\\star\\star$"},{"location":"python3/0701-0800/0781-0790/","text":"781. Rabbits in Forest $\\star\\star$ class Solution : def numRabbits ( self , answers : List [ int ]) -> int : ans = 0 count = collections . Counter () for answer in answers : if count [ answer ] % ( answer + 1 ) == 0 : ans += answer + 1 count [ answer ] += 1 return ans 782. Transform to Chessboard $\\star\\star\\star$ class Solution : def movesToChessboard ( self , board : List [ List [ int ]]) -> int : n = len ( board ) if any ( board [ 0 ][ 0 ] ^ board [ i ][ 0 ] ^ board [ 0 ][ j ] ^ board [ i ][ j ] for i in range ( n ) for j in range ( n )): return - 1 rowSum = sum ( board [ 0 ]) colSum = sum ( board [ i ][ 0 ] for i in range ( n )) if rowSum != n // 2 and rowSum != ( n + 1 ) // 2 : return - 1 if colSum != n // 2 and colSum != ( n + 1 ) // 2 : return - 1 rowSwaps = sum ( board [ i ][ 0 ] == ( i & 1 ) for i in range ( n )) colSwaps = sum ( board [ 0 ][ i ] == ( i & 1 ) for i in range ( n )) if n & 1 : if rowSwaps & 1 : rowSwaps = n - rowSwaps if colSwaps & 1 : colSwaps = n - colSwaps else : rowSwaps = min ( rowSwaps , n - rowSwaps ) colSwaps = min ( colSwaps , n - colSwaps ) return ( rowSwaps + colSwaps ) // 2 783. Minimum Distance Between BST Nodes $\\star$ 784. Letter Case Permutation $\\star$ 785. Is Graph Bipartite? $\\star\\star$ 786. K-th Smallest Prime Fraction $\\star\\star\\star$ class Solution : def kthSmallestPrimeFraction ( self , A : List [ int ], K : int ) -> List [ int ]: n = len ( A ) ans = [ 0 , 1 ] l = 0 r = 1 while True : m = ( l + r ) / 2 ans [ 0 ] = 0 count = 0 j = 1 for i in range ( n ): while j < n and A [ i ] > m * A [ j ]: j += 1 count += n - j if j == n : break if ans [ 0 ] * A [ j ] < ans [ 1 ] * A [ i ]: ans [ 0 ] = A [ i ] ans [ 1 ] = A [ j ] if count < K : l = m elif count > K : r = m else : return ans 787. Cheapest Flights Within K Stops $\\star\\star$ 788. Rotated Digits $\\star$ class Solution : def rotatedDigits ( self , N : int ) -> int : def isGoodNumber ( i : int ) -> bool : isRotated = False for c in str ( i ): if c == '0' or c == '1' or c == '8' : continue if c == '2' or c == '5' or c == '6' or c == '9' : isRotated = True else : return False return isRotated return sum ( isGoodNumber ( i ) for i in range ( 1 , N + 1 )) 789. Escape The Ghosts $\\star\\star$ class Solution : def escapeGhosts ( self , ghosts : List [ List [ int ]], target : List [ int ]) -> bool : ghostSteps = min ( abs ( x - target [ 0 ]) + abs ( y - target [ 1 ]) for x , y in ghosts ) return abs ( target [ 0 ]) + abs ( target [ 1 ]) < ghostSteps 790. Domino and Tromino Tiling $\\star\\star$ class Solution : def numTilings ( self , N : int ) -> int : kMod = int ( 1e9 + 7 ) dp = [ 0 , 1 , 2 , 5 ] + [ 0 ] * 997 for i in range ( 4 , N + 1 ): dp [ i ] = 2 * dp [ i - 1 ] + dp [ i - 3 ] return dp [ N ] % kMod","title":"0781-0790"},{"location":"python3/0701-0800/0781-0790/#781-rabbits-in-forest-starstar","text":"class Solution : def numRabbits ( self , answers : List [ int ]) -> int : ans = 0 count = collections . Counter () for answer in answers : if count [ answer ] % ( answer + 1 ) == 0 : ans += answer + 1 count [ answer ] += 1 return ans","title":"781. Rabbits in Forest $\\star\\star$"},{"location":"python3/0701-0800/0781-0790/#782-transform-to-chessboard-starstarstar","text":"class Solution : def movesToChessboard ( self , board : List [ List [ int ]]) -> int : n = len ( board ) if any ( board [ 0 ][ 0 ] ^ board [ i ][ 0 ] ^ board [ 0 ][ j ] ^ board [ i ][ j ] for i in range ( n ) for j in range ( n )): return - 1 rowSum = sum ( board [ 0 ]) colSum = sum ( board [ i ][ 0 ] for i in range ( n )) if rowSum != n // 2 and rowSum != ( n + 1 ) // 2 : return - 1 if colSum != n // 2 and colSum != ( n + 1 ) // 2 : return - 1 rowSwaps = sum ( board [ i ][ 0 ] == ( i & 1 ) for i in range ( n )) colSwaps = sum ( board [ 0 ][ i ] == ( i & 1 ) for i in range ( n )) if n & 1 : if rowSwaps & 1 : rowSwaps = n - rowSwaps if colSwaps & 1 : colSwaps = n - colSwaps else : rowSwaps = min ( rowSwaps , n - rowSwaps ) colSwaps = min ( colSwaps , n - colSwaps ) return ( rowSwaps + colSwaps ) // 2","title":"782. Transform to Chessboard $\\star\\star\\star$"},{"location":"python3/0701-0800/0781-0790/#783-minimum-distance-between-bst-nodes-star","text":"","title":"783. Minimum Distance Between BST Nodes $\\star$"},{"location":"python3/0701-0800/0781-0790/#784-letter-case-permutation-star","text":"","title":"784. Letter Case Permutation $\\star$"},{"location":"python3/0701-0800/0781-0790/#785-is-graph-bipartite-starstar","text":"","title":"785. Is Graph Bipartite? $\\star\\star$"},{"location":"python3/0701-0800/0781-0790/#786-k-th-smallest-prime-fraction-starstarstar","text":"class Solution : def kthSmallestPrimeFraction ( self , A : List [ int ], K : int ) -> List [ int ]: n = len ( A ) ans = [ 0 , 1 ] l = 0 r = 1 while True : m = ( l + r ) / 2 ans [ 0 ] = 0 count = 0 j = 1 for i in range ( n ): while j < n and A [ i ] > m * A [ j ]: j += 1 count += n - j if j == n : break if ans [ 0 ] * A [ j ] < ans [ 1 ] * A [ i ]: ans [ 0 ] = A [ i ] ans [ 1 ] = A [ j ] if count < K : l = m elif count > K : r = m else : return ans","title":"786. K-th Smallest Prime Fraction $\\star\\star\\star$"},{"location":"python3/0701-0800/0781-0790/#787-cheapest-flights-within-k-stops-starstar","text":"","title":"787. Cheapest Flights Within K Stops $\\star\\star$"},{"location":"python3/0701-0800/0781-0790/#788-rotated-digits-star","text":"class Solution : def rotatedDigits ( self , N : int ) -> int : def isGoodNumber ( i : int ) -> bool : isRotated = False for c in str ( i ): if c == '0' or c == '1' or c == '8' : continue if c == '2' or c == '5' or c == '6' or c == '9' : isRotated = True else : return False return isRotated return sum ( isGoodNumber ( i ) for i in range ( 1 , N + 1 ))","title":"788. Rotated Digits $\\star$"},{"location":"python3/0701-0800/0781-0790/#789-escape-the-ghosts-starstar","text":"class Solution : def escapeGhosts ( self , ghosts : List [ List [ int ]], target : List [ int ]) -> bool : ghostSteps = min ( abs ( x - target [ 0 ]) + abs ( y - target [ 1 ]) for x , y in ghosts ) return abs ( target [ 0 ]) + abs ( target [ 1 ]) < ghostSteps","title":"789. Escape The Ghosts $\\star\\star$"},{"location":"python3/0701-0800/0781-0790/#790-domino-and-tromino-tiling-starstar","text":"class Solution : def numTilings ( self , N : int ) -> int : kMod = int ( 1e9 + 7 ) dp = [ 0 , 1 , 2 , 5 ] + [ 0 ] * 997 for i in range ( 4 , N + 1 ): dp [ i ] = 2 * dp [ i - 1 ] + dp [ i - 3 ] return dp [ N ] % kMod","title":"790. Domino and Tromino Tiling $\\star\\star$"},{"location":"python3/0701-0800/0791-0800/","text":"791. Custom Sort String $\\star\\star$ class Solution : def customSortString ( self , S : str , T : str ) -> str : ans = \"\" count = [ 0 ] * 26 for c in T : count [ ord ( c ) - ord ( 'a' )] += 1 for c in S : while count [ ord ( c ) - ord ( 'a' )] > 0 : ans += c count [ ord ( c ) - ord ( 'a' )] -= 1 for c in string . ascii_lowercase : for _ in range ( count [ ord ( c ) - ord ( 'a' )]): ans += c return ans 792. Number of Matching Subsequences $\\star\\star$ class Solution : def numMatchingSubseq ( self , S : str , words : List [ str ]) -> int : def insert ( word : str ) -> None : node = self . root for c in word : if c not in node : node [ c ] = { 'count' : 0 } node = node [ c ] node [ 'count' ] += 1 def dfs ( S : str , s : int , node : dict ) -> int : ans = node [ 'count' ] if 'count' in node else 0 if s >= len ( S ): return ans for c in string . ascii_lowercase : if c in node : try : index = S . index ( c , s ) ans += dfs ( S , index + 1 , node [ c ]) except ValueError : continue return ans self . root = {} for word in words : insert ( word ) return dfs ( S , 0 , self . root ) 793. Preimage Size of Factorial Zeroes Function $\\star\\star\\star$ 794. Valid Tic-Tac-Toe State $\\star\\star$ class Solution : def validTicTacToe ( self , board : List [ str ]) -> bool : def isWin ( c : chr ) -> bool : return any ( row . count ( c ) == 3 for row in board ) or \\ any ( row . count ( c ) == 3 for row in list ( zip ( * board ))) or \\ all ( board [ i ][ i ] == c for i in range ( 3 )) or \\ all ( board [ i ][ 2 - i ] == c for i in range ( 3 )) countX = sum ( row . count ( 'X' ) for row in board ) countO = sum ( row . count ( 'O' ) for row in board ) if countX < countO or countX - countO > 1 : return False if isWin ( 'X' ) and countX == countO or isWin ( 'O' ) and countX != countO : return False return True 795. Number of Subarrays with Bounded Maximum $\\star\\star$ class Solution : def numSubarrayBoundedMax ( self , A : List [ int ], L : int , R : int ) -> int : ans = 0 l = - 1 r = - 1 for i , a in enumerate ( A ): if a > R : l = i if a >= L : r = i ans += r - l return ans 796. Rotate String $\\star$ 797. All Paths From Source to Target $\\star\\star$ 798. Smallest Rotation with Highest Score $\\star\\star\\star$ 799. Champagne Tower $\\star\\star$ 800. Similar RGB Color $\\star$ \ud83d\udd12","title":"0791-0800"},{"location":"python3/0701-0800/0791-0800/#791-custom-sort-string-starstar","text":"class Solution : def customSortString ( self , S : str , T : str ) -> str : ans = \"\" count = [ 0 ] * 26 for c in T : count [ ord ( c ) - ord ( 'a' )] += 1 for c in S : while count [ ord ( c ) - ord ( 'a' )] > 0 : ans += c count [ ord ( c ) - ord ( 'a' )] -= 1 for c in string . ascii_lowercase : for _ in range ( count [ ord ( c ) - ord ( 'a' )]): ans += c return ans","title":"791. Custom Sort String $\\star\\star$"},{"location":"python3/0701-0800/0791-0800/#792-number-of-matching-subsequences-starstar","text":"class Solution : def numMatchingSubseq ( self , S : str , words : List [ str ]) -> int : def insert ( word : str ) -> None : node = self . root for c in word : if c not in node : node [ c ] = { 'count' : 0 } node = node [ c ] node [ 'count' ] += 1 def dfs ( S : str , s : int , node : dict ) -> int : ans = node [ 'count' ] if 'count' in node else 0 if s >= len ( S ): return ans for c in string . ascii_lowercase : if c in node : try : index = S . index ( c , s ) ans += dfs ( S , index + 1 , node [ c ]) except ValueError : continue return ans self . root = {} for word in words : insert ( word ) return dfs ( S , 0 , self . root )","title":"792. Number of Matching Subsequences $\\star\\star$"},{"location":"python3/0701-0800/0791-0800/#793-preimage-size-of-factorial-zeroes-function-starstarstar","text":"","title":"793. Preimage Size of Factorial Zeroes Function $\\star\\star\\star$"},{"location":"python3/0701-0800/0791-0800/#794-valid-tic-tac-toe-state-starstar","text":"class Solution : def validTicTacToe ( self , board : List [ str ]) -> bool : def isWin ( c : chr ) -> bool : return any ( row . count ( c ) == 3 for row in board ) or \\ any ( row . count ( c ) == 3 for row in list ( zip ( * board ))) or \\ all ( board [ i ][ i ] == c for i in range ( 3 )) or \\ all ( board [ i ][ 2 - i ] == c for i in range ( 3 )) countX = sum ( row . count ( 'X' ) for row in board ) countO = sum ( row . count ( 'O' ) for row in board ) if countX < countO or countX - countO > 1 : return False if isWin ( 'X' ) and countX == countO or isWin ( 'O' ) and countX != countO : return False return True","title":"794. Valid Tic-Tac-Toe State $\\star\\star$"},{"location":"python3/0701-0800/0791-0800/#795-number-of-subarrays-with-bounded-maximum-starstar","text":"class Solution : def numSubarrayBoundedMax ( self , A : List [ int ], L : int , R : int ) -> int : ans = 0 l = - 1 r = - 1 for i , a in enumerate ( A ): if a > R : l = i if a >= L : r = i ans += r - l return ans","title":"795. Number of Subarrays with Bounded Maximum $\\star\\star$"},{"location":"python3/0701-0800/0791-0800/#796-rotate-string-star","text":"","title":"796. Rotate String $\\star$"},{"location":"python3/0701-0800/0791-0800/#797-all-paths-from-source-to-target-starstar","text":"","title":"797. All Paths From Source to Target $\\star\\star$"},{"location":"python3/0701-0800/0791-0800/#798-smallest-rotation-with-highest-score-starstarstar","text":"","title":"798. Smallest Rotation with Highest Score $\\star\\star\\star$"},{"location":"python3/0701-0800/0791-0800/#799-champagne-tower-starstar","text":"","title":"799. Champagne Tower $\\star\\star$"},{"location":"python3/0701-0800/0791-0800/#800-similar-rgb-color-star","text":"","title":"800. Similar RGB Color $\\star$ \ud83d\udd12"},{"location":"python3/0801-0900/0801-0810/","text":"801. Minimum Swaps To Make Sequences Increasing $\\star\\star$ class Solution : def minSwap ( self , A : List [ int ], B : List [ int ]) -> int : keepAt = [ float ( 'inf' )] * len ( A ) swapAt = [ float ( 'inf' )] * len ( A ) keepAt [ 0 ] = 0 swapAt [ 0 ] = 1 for i in range ( 1 , len ( A )): if A [ i ] > A [ i - 1 ] and B [ i ] > B [ i - 1 ]: keepAt [ i ] = keepAt [ i - 1 ] swapAt [ i ] = swapAt [ i - 1 ] + 1 if A [ i ] > B [ i - 1 ] and B [ i ] > A [ i - 1 ]: keepAt [ i ] = min ( keepAt [ i ], swapAt [ i - 1 ]) swapAt [ i ] = min ( swapAt [ i ], keepAt [ i - 1 ] + 1 ) return min ( keepAt [ - 1 ], swapAt [ - 1 ]) 802. Find Eventual Safe States $\\star\\star$ 803. Bricks Falling When Hit $\\star\\star\\star$ 804. Unique Morse Code Words $\\star$ class Solution : def uniqueMorseRepresentations ( self , words : List [ str ]) -> int : morse = [ \".-\" , \"-...\" , \"-.-.\" , \"-..\" , \".\" , \"..-.\" , \"--.\" , \"....\" , \"..\" , \".---\" , \"-.-\" , \".-..\" , \"--\" , \"-.\" , \"---\" , \".--.\" , \"--.-\" , \".-.\" , \"...\" , \"-\" , \"..-\" , \"...-\" , \".--\" , \"-..-\" , \"-.--\" , \"--..\" ] transformations = set () for word in words : transformation = '' . join ( morse [ ord ( c ) - ord ( 'a' )] for c in word ) transformations . add ( transformation ) return len ( transformations ) 805. Split Array With Same Average $\\star\\star\\star$ class Solution : def splitArraySameAverage ( self , A : List [ int ]) -> bool : n = len ( A ) summ = sum ( A ) if not any ( i * summ % n == 0 for i in range ( 1 , n // 2 + 1 )): return False sums = [ set () for _ in range ( n // 2 + 1 )] sums [ 0 ] . add ( 0 ) for a in A : for i in range ( n // 2 , 0 , - 1 ): for val in sums [ i - 1 ]: sums [ i ] . add ( a + val ) for i in range ( 1 , n // 2 + 1 ): if i * summ % n == 0 and i * summ // n in sums [ i ]: return True return False 806. Number of Lines To Write String $\\star$ 807. Max Increase to Keep City Skyline $\\star\\star$ 808. Soup Servings $\\star\\star$ class Solution : def soupServings ( self , N : int ) -> float : def dfs ( a : int , b : int ) -> float : if a <= 0 and b <= 0 : return 0.5 if a <= 0 : return 1.0 if b <= 0 : return 0.0 if memo [ a ][ b ] > 0 : return memo [ a ][ b ] memo [ a ][ b ] = 0.25 * ( dfs ( a - 4 , b ) + dfs ( a - 3 , b - 1 ) + dfs ( a - 2 , b - 2 ) + dfs ( a - 1 , b - 3 )) return memo [ a ][ b ] memo = [[ 0.0 ] * 192 for _ in range ( 192 )] return 1 if N >= 4800 else dfs (( N + 24 ) // 25 , ( N + 24 ) // 25 ) 809. Expressive Words $\\star\\star$ class Solution : def expressiveWords ( self , S : str , words : List [ str ]) -> int : def isStretchy ( word : str ) -> bool : n = len ( S ) m = len ( word ) j = 0 for i in range ( n ): if j < m and S [ i ] == word [ j ]: j += 1 elif i > 1 and S [ i ] == S [ i - 1 ] == S [ i - 2 ]: continue elif 0 < i < n - 1 and S [ i - 1 ] == S [ i ] == S [ i + 1 ]: continue else : return False return j == m return sum ( isStretchy ( word ) for word in words ) 810. Chalkboard XOR Game $\\star\\star\\star$ class Solution : def xorGame ( self , nums : List [ int ]) -> bool : xors = 0 for num in nums : xors ^= num return xors == 0 or len ( nums ) % 2 == 0","title":"0801-0810"},{"location":"python3/0801-0900/0801-0810/#801-minimum-swaps-to-make-sequences-increasing-starstar","text":"class Solution : def minSwap ( self , A : List [ int ], B : List [ int ]) -> int : keepAt = [ float ( 'inf' )] * len ( A ) swapAt = [ float ( 'inf' )] * len ( A ) keepAt [ 0 ] = 0 swapAt [ 0 ] = 1 for i in range ( 1 , len ( A )): if A [ i ] > A [ i - 1 ] and B [ i ] > B [ i - 1 ]: keepAt [ i ] = keepAt [ i - 1 ] swapAt [ i ] = swapAt [ i - 1 ] + 1 if A [ i ] > B [ i - 1 ] and B [ i ] > A [ i - 1 ]: keepAt [ i ] = min ( keepAt [ i ], swapAt [ i - 1 ]) swapAt [ i ] = min ( swapAt [ i ], keepAt [ i - 1 ] + 1 ) return min ( keepAt [ - 1 ], swapAt [ - 1 ])","title":"801. Minimum Swaps To Make Sequences Increasing $\\star\\star$"},{"location":"python3/0801-0900/0801-0810/#802-find-eventual-safe-states-starstar","text":"","title":"802. Find Eventual Safe States $\\star\\star$"},{"location":"python3/0801-0900/0801-0810/#803-bricks-falling-when-hit-starstarstar","text":"","title":"803. Bricks Falling When Hit $\\star\\star\\star$"},{"location":"python3/0801-0900/0801-0810/#804-unique-morse-code-words-star","text":"class Solution : def uniqueMorseRepresentations ( self , words : List [ str ]) -> int : morse = [ \".-\" , \"-...\" , \"-.-.\" , \"-..\" , \".\" , \"..-.\" , \"--.\" , \"....\" , \"..\" , \".---\" , \"-.-\" , \".-..\" , \"--\" , \"-.\" , \"---\" , \".--.\" , \"--.-\" , \".-.\" , \"...\" , \"-\" , \"..-\" , \"...-\" , \".--\" , \"-..-\" , \"-.--\" , \"--..\" ] transformations = set () for word in words : transformation = '' . join ( morse [ ord ( c ) - ord ( 'a' )] for c in word ) transformations . add ( transformation ) return len ( transformations )","title":"804. Unique Morse Code Words $\\star$"},{"location":"python3/0801-0900/0801-0810/#805-split-array-with-same-average-starstarstar","text":"class Solution : def splitArraySameAverage ( self , A : List [ int ]) -> bool : n = len ( A ) summ = sum ( A ) if not any ( i * summ % n == 0 for i in range ( 1 , n // 2 + 1 )): return False sums = [ set () for _ in range ( n // 2 + 1 )] sums [ 0 ] . add ( 0 ) for a in A : for i in range ( n // 2 , 0 , - 1 ): for val in sums [ i - 1 ]: sums [ i ] . add ( a + val ) for i in range ( 1 , n // 2 + 1 ): if i * summ % n == 0 and i * summ // n in sums [ i ]: return True return False","title":"805. Split Array With Same Average $\\star\\star\\star$"},{"location":"python3/0801-0900/0801-0810/#806-number-of-lines-to-write-string-star","text":"","title":"806. Number of Lines To Write String $\\star$"},{"location":"python3/0801-0900/0801-0810/#807-max-increase-to-keep-city-skyline-starstar","text":"","title":"807. Max Increase to Keep City Skyline $\\star\\star$"},{"location":"python3/0801-0900/0801-0810/#808-soup-servings-starstar","text":"class Solution : def soupServings ( self , N : int ) -> float : def dfs ( a : int , b : int ) -> float : if a <= 0 and b <= 0 : return 0.5 if a <= 0 : return 1.0 if b <= 0 : return 0.0 if memo [ a ][ b ] > 0 : return memo [ a ][ b ] memo [ a ][ b ] = 0.25 * ( dfs ( a - 4 , b ) + dfs ( a - 3 , b - 1 ) + dfs ( a - 2 , b - 2 ) + dfs ( a - 1 , b - 3 )) return memo [ a ][ b ] memo = [[ 0.0 ] * 192 for _ in range ( 192 )] return 1 if N >= 4800 else dfs (( N + 24 ) // 25 , ( N + 24 ) // 25 )","title":"808. Soup Servings $\\star\\star$"},{"location":"python3/0801-0900/0801-0810/#809-expressive-words-starstar","text":"class Solution : def expressiveWords ( self , S : str , words : List [ str ]) -> int : def isStretchy ( word : str ) -> bool : n = len ( S ) m = len ( word ) j = 0 for i in range ( n ): if j < m and S [ i ] == word [ j ]: j += 1 elif i > 1 and S [ i ] == S [ i - 1 ] == S [ i - 2 ]: continue elif 0 < i < n - 1 and S [ i - 1 ] == S [ i ] == S [ i + 1 ]: continue else : return False return j == m return sum ( isStretchy ( word ) for word in words )","title":"809. Expressive Words $\\star\\star$"},{"location":"python3/0801-0900/0801-0810/#810-chalkboard-xor-game-starstarstar","text":"class Solution : def xorGame ( self , nums : List [ int ]) -> bool : xors = 0 for num in nums : xors ^= num return xors == 0 or len ( nums ) % 2 == 0","title":"810. Chalkboard XOR Game $\\star\\star\\star$"},{"location":"python3/0801-0900/0811-0820/","text":"811. Subdomain Visit Count $\\star$ class Solution : def subdomainVisits ( self , cpdomains : List [ str ]) -> List [ str ]: ans = [] count = collections . Counter () for cpdomain in cpdomains : num , domains = cpdomain . split () num , domains = int ( num ), domains . split ( '.' ) for i in range ( len ( domains ))[:: - 1 ]: count [ '.' . join ( domains [ i :])] += num return [ str ( freq ) + ' ' + domain for domain , freq in count . items ()] 812. Largest Triangle Area $\\star$ class Solution : def largestTriangleArea ( self , points : List [ List [ int ]]) -> float : ans = 0 for Ax , Ay in points : for Bx , By in points : for Cx , Cy in points : ans = max ( ans , 0.5 * abs (( Bx - Ax ) * ( Cy - Ay ) - ( Cx - Ax ) * ( By - Ay ))) return ans 813. Largest Sum of Averages $\\star\\star$ 814. Binary Tree Pruning $\\star\\star$ 815. Bus Routes $\\star\\star\\star$ 816. Ambiguous Coordinates $\\star\\star$ class Solution : def ambiguousCoordinates ( self , S : str ) -> List [ str ]: def splits ( S : str ) -> List [ str ]: if not S or len ( S ) > 1 and S [ 0 ] == S [ - 1 ] == '0' : return [] if S [ - 1 ] == '0' : return [ S ] if S [ 0 ] == '0' : return [ S [ 0 ] + '.' + S [ 1 :]] return [ S ] + [ S [: i ] + '.' + S [ i :] for i in range ( 1 , len ( S ))] ans = [] S = S [ 1 : - 1 ] for i in range ( 1 , len ( S )): for x in splits ( S [: i ]): for y in splits ( S [ i :]): ans . append ( '( %s , %s )' % ( x , y )) return ans 817. Linked List Components $\\star\\star$ class Solution : def numComponents ( self , head : ListNode , G : List [ int ]) -> int : ans = 0 G = set ( G ) while head : if head . val in G and ( head . next == None or head . next . val not in G ): ans += 1 head = head . next return ans 818. Race Car $\\star\\star\\star$ 819. Most Common Word $\\star$ class Solution : def mostCommonWord ( self , paragraph : str , banned : List [ str ]) -> str : banned = set ( banned ) words = re . findall ( r '\\w+' , paragraph . lower ()) return collections . Counter ( word for word in words if word not in banned ) . most_common ( 1 )[ 0 ][ 0 ] 820. Short Encoding of Words $\\star\\star$","title":"0811-0820"},{"location":"python3/0801-0900/0811-0820/#811-subdomain-visit-count-star","text":"class Solution : def subdomainVisits ( self , cpdomains : List [ str ]) -> List [ str ]: ans = [] count = collections . Counter () for cpdomain in cpdomains : num , domains = cpdomain . split () num , domains = int ( num ), domains . split ( '.' ) for i in range ( len ( domains ))[:: - 1 ]: count [ '.' . join ( domains [ i :])] += num return [ str ( freq ) + ' ' + domain for domain , freq in count . items ()]","title":"811. Subdomain Visit Count $\\star$"},{"location":"python3/0801-0900/0811-0820/#812-largest-triangle-area-star","text":"class Solution : def largestTriangleArea ( self , points : List [ List [ int ]]) -> float : ans = 0 for Ax , Ay in points : for Bx , By in points : for Cx , Cy in points : ans = max ( ans , 0.5 * abs (( Bx - Ax ) * ( Cy - Ay ) - ( Cx - Ax ) * ( By - Ay ))) return ans","title":"812. Largest Triangle Area $\\star$"},{"location":"python3/0801-0900/0811-0820/#813-largest-sum-of-averages-starstar","text":"","title":"813. Largest Sum of Averages $\\star\\star$"},{"location":"python3/0801-0900/0811-0820/#814-binary-tree-pruning-starstar","text":"","title":"814. Binary Tree Pruning $\\star\\star$"},{"location":"python3/0801-0900/0811-0820/#815-bus-routes-starstarstar","text":"","title":"815. Bus Routes $\\star\\star\\star$"},{"location":"python3/0801-0900/0811-0820/#816-ambiguous-coordinates-starstar","text":"class Solution : def ambiguousCoordinates ( self , S : str ) -> List [ str ]: def splits ( S : str ) -> List [ str ]: if not S or len ( S ) > 1 and S [ 0 ] == S [ - 1 ] == '0' : return [] if S [ - 1 ] == '0' : return [ S ] if S [ 0 ] == '0' : return [ S [ 0 ] + '.' + S [ 1 :]] return [ S ] + [ S [: i ] + '.' + S [ i :] for i in range ( 1 , len ( S ))] ans = [] S = S [ 1 : - 1 ] for i in range ( 1 , len ( S )): for x in splits ( S [: i ]): for y in splits ( S [ i :]): ans . append ( '( %s , %s )' % ( x , y )) return ans","title":"816. Ambiguous Coordinates $\\star\\star$"},{"location":"python3/0801-0900/0811-0820/#817-linked-list-components-starstar","text":"class Solution : def numComponents ( self , head : ListNode , G : List [ int ]) -> int : ans = 0 G = set ( G ) while head : if head . val in G and ( head . next == None or head . next . val not in G ): ans += 1 head = head . next return ans","title":"817. Linked List Components $\\star\\star$"},{"location":"python3/0801-0900/0811-0820/#818-race-car-starstarstar","text":"","title":"818. Race Car $\\star\\star\\star$"},{"location":"python3/0801-0900/0811-0820/#819-most-common-word-star","text":"class Solution : def mostCommonWord ( self , paragraph : str , banned : List [ str ]) -> str : banned = set ( banned ) words = re . findall ( r '\\w+' , paragraph . lower ()) return collections . Counter ( word for word in words if word not in banned ) . most_common ( 1 )[ 0 ][ 0 ]","title":"819. Most Common Word $\\star$"},{"location":"python3/0801-0900/0811-0820/#820-short-encoding-of-words-starstar","text":"","title":"820. Short Encoding of Words $\\star\\star$"},{"location":"python3/0801-0900/0821-0830/","text":"821. Shortest Distance to a Character $\\star$ 822. Card Flipping Game $\\star\\star$ 823. Binary Trees With Factors $\\star\\star$ 824. Goat Latin $\\star$ class Solution : def toGoatLatin ( self , S : str ) -> str : ans = '' vowels = 'aeiouAEIOU' words = S . split () i = 1 for word in words : if i > 1 : ans += ' ' if word [ 0 ] in vowels : ans += word else : ans += word [ 1 :] + word [ 0 ] ans += 'ma' + 'a' * i i += 1 return ans 825. Friends Of Appropriate Ages $\\star\\star$ class Solution : def numFriendRequests ( self , ages : List [ int ]) -> int : ans = 0 count = [ 0 ] * 121 for age in ages : count [ age ] += 1 for i in range ( 15 , 121 ): ans += count [ i ] * ( count [ i ] - 1 ) for i in range ( 15 , 121 ): for j in range ( i // 2 + 8 , i ): ans += count [ i ] * count [ j ] return ans 826. Most Profit Assigning Work $\\star\\star$ class Solution : def maxProfitAssignment ( self , difficulty : List [ int ], profit : List [ int ], worker : List [ int ]) -> int : ans = 0 jobs = sorted ( zip ( difficulty , profit )) worker . sort ( reverse = 1 ) i = 0 maxProfit = 0 for w in sorted ( worker ): while i < len ( jobs ) and w >= jobs [ i ][ 0 ]: maxProfit = max ( maxProfit , jobs [ i ][ 1 ]) i += 1 ans += maxProfit return ans 827. Making A Large Island $\\star\\star\\star$ 828. Count Unique Characters of All Substrings of a Given String $\\star\\star\\star$ class Solution : def uniqueLetterString ( self , s : str ) -> int : ans = 0 count = 0 lastCount = [ 0 ] * 26 lastSeen = [ - 1 ] * 26 for i , c in enumerate ( s ): c = ord ( c ) - ord ( 'A' ) currentCount = i - lastSeen [ c ] count = count - lastCount [ c ] + currentCount lastCount [ c ] = currentCount lastSeen [ c ] = i ans += count return ans 829. Consecutive Numbers Sum $\\star\\star\\star$ class Solution : def consecutiveNumbersSum ( self , N : int ) -> int : ans = 0 i = 1 triangleNum = 1 while triangleNum <= N : if ( N - triangleNum ) % i == 0 : ans += 1 i += 1 triangleNum += i return ans 830. Positions of Large Groups $\\star$ class Solution : def largeGroupPositions ( self , S : str ) -> List [ List [ int ]]: n = len ( S ) ans = [] i = 0 j = 0 while i < n : while j < n and S [ j ] == S [ i ]: j += 1 if j - i >= 3 : ans . append ([ i , j - 1 ]) i = j return ans","title":"0821-0830"},{"location":"python3/0801-0900/0821-0830/#821-shortest-distance-to-a-character-star","text":"","title":"821. Shortest Distance to a Character $\\star$"},{"location":"python3/0801-0900/0821-0830/#822-card-flipping-game-starstar","text":"","title":"822. Card Flipping Game $\\star\\star$"},{"location":"python3/0801-0900/0821-0830/#823-binary-trees-with-factors-starstar","text":"","title":"823. Binary Trees With Factors $\\star\\star$"},{"location":"python3/0801-0900/0821-0830/#824-goat-latin-star","text":"class Solution : def toGoatLatin ( self , S : str ) -> str : ans = '' vowels = 'aeiouAEIOU' words = S . split () i = 1 for word in words : if i > 1 : ans += ' ' if word [ 0 ] in vowels : ans += word else : ans += word [ 1 :] + word [ 0 ] ans += 'ma' + 'a' * i i += 1 return ans","title":"824. Goat Latin $\\star$"},{"location":"python3/0801-0900/0821-0830/#825-friends-of-appropriate-ages-starstar","text":"class Solution : def numFriendRequests ( self , ages : List [ int ]) -> int : ans = 0 count = [ 0 ] * 121 for age in ages : count [ age ] += 1 for i in range ( 15 , 121 ): ans += count [ i ] * ( count [ i ] - 1 ) for i in range ( 15 , 121 ): for j in range ( i // 2 + 8 , i ): ans += count [ i ] * count [ j ] return ans","title":"825. Friends Of Appropriate Ages $\\star\\star$"},{"location":"python3/0801-0900/0821-0830/#826-most-profit-assigning-work-starstar","text":"class Solution : def maxProfitAssignment ( self , difficulty : List [ int ], profit : List [ int ], worker : List [ int ]) -> int : ans = 0 jobs = sorted ( zip ( difficulty , profit )) worker . sort ( reverse = 1 ) i = 0 maxProfit = 0 for w in sorted ( worker ): while i < len ( jobs ) and w >= jobs [ i ][ 0 ]: maxProfit = max ( maxProfit , jobs [ i ][ 1 ]) i += 1 ans += maxProfit return ans","title":"826. Most Profit Assigning Work $\\star\\star$"},{"location":"python3/0801-0900/0821-0830/#827-making-a-large-island-starstarstar","text":"","title":"827. Making A Large Island $\\star\\star\\star$"},{"location":"python3/0801-0900/0821-0830/#828-count-unique-characters-of-all-substrings-of-a-given-string-starstarstar","text":"class Solution : def uniqueLetterString ( self , s : str ) -> int : ans = 0 count = 0 lastCount = [ 0 ] * 26 lastSeen = [ - 1 ] * 26 for i , c in enumerate ( s ): c = ord ( c ) - ord ( 'A' ) currentCount = i - lastSeen [ c ] count = count - lastCount [ c ] + currentCount lastCount [ c ] = currentCount lastSeen [ c ] = i ans += count return ans","title":"828. Count Unique Characters of All Substrings of a Given String $\\star\\star\\star$"},{"location":"python3/0801-0900/0821-0830/#829-consecutive-numbers-sum-starstarstar","text":"class Solution : def consecutiveNumbersSum ( self , N : int ) -> int : ans = 0 i = 1 triangleNum = 1 while triangleNum <= N : if ( N - triangleNum ) % i == 0 : ans += 1 i += 1 triangleNum += i return ans","title":"829. Consecutive Numbers Sum $\\star\\star\\star$"},{"location":"python3/0801-0900/0821-0830/#830-positions-of-large-groups-star","text":"class Solution : def largeGroupPositions ( self , S : str ) -> List [ List [ int ]]: n = len ( S ) ans = [] i = 0 j = 0 while i < n : while j < n and S [ j ] == S [ i ]: j += 1 if j - i >= 3 : ans . append ([ i , j - 1 ]) i = j return ans","title":"830. Positions of Large Groups $\\star$"},{"location":"python3/0801-0900/0831-0840/","text":"831. Masking Personal Information $\\star\\star$ class Solution : def maskPII ( self , S : str ) -> str : atIndex = S . find ( '@' ) if atIndex != - 1 : S = S . lower () return S [ 0 ] + '*' * 5 + S [ atIndex - 1 :] ans = '' . join ( c for c in S if c . isdigit ()) if len ( ans ) == 10 : return '***-***-' + ans [ - 4 :] return '+' + '*' * ( len ( ans ) - 10 ) + '-***-***-' + ans [ - 4 :] 832. Flipping an Image $\\star$ class Solution : def flipAndInvertImage ( self , A : List [ List [ int ]]) -> List [ List [ int ]]: for row in A : for i in range (( len ( row ) + 1 ) // 2 ): row [ i ], row [ ~ i ] = row [ ~ i ] ^ 1 , row [ i ] ^ 1 return A 833. Find And Replace in String $\\star\\star$ class Solution : def findReplaceString ( self , S : str , indexes : List [ int ], sources : List [ str ], targets : List [ str ]) -> str : for index , source , target in sorted ( zip ( indexes , sources , targets ), reverse = True ): if S [ index : index + len ( source )] == source : S = S [: index ] + target + S [ index + len ( source ):] return S 834. Sum of Distances in Tree $\\star\\star\\star$ 835. Image Overlap $\\star\\star$ class Solution : def largestOverlap ( self , A : List [ List [ int ]], B : List [ List [ int ]]) -> int : n = len ( A ) magic = 100 onesA = [] onesB = [] dict = collections . defaultdict ( int ) for i in range ( n ): for j in range ( n ): if A [ i ][ j ] == 1 : onesA . append ([ i , j ]) if B [ i ][ j ] == 1 : onesB . append ([ i , j ]) for a in onesA : for b in onesB : dict [( a [ 0 ] - b [ 0 ]) * magic + ( a [ 1 ] - b [ 1 ])] += 1 return max ( dict . values ()) if dict else 0 836. Rectangle Overlap $\\star$ class Solution : def isRectangleOverlap ( self , rec1 : List [ int ], rec2 : List [ int ]) -> bool : return rec1 [ 0 ] < rec2 [ 2 ] and rec2 [ 0 ] < rec1 [ 2 ] and rec1 [ 1 ] < rec2 [ 3 ] and rec2 [ 1 ] < rec1 [ 3 ] 837. New 21 Game $\\star\\star$ 838. Push Dominoes $\\star\\star$ class Solution : def pushDominoes ( self , dominoes : str ) -> str : ans = list ( dominoes ) L = - 1 R = - 1 for i in range ( len ( dominoes ) + 1 ): if i == len ( dominoes ) or dominoes [ i ] == 'R' : if L < R : while R < i : ans [ R ] = 'R' R += 1 R = i elif dominoes [ i ] == 'L' : if R < L or ( L , R ) == ( - 1 , - 1 ): if ( L , R ) == ( - 1 , - 1 ): L += 1 while L < i : ans [ L ] = 'L' L += 1 else : l = R + 1 r = i - 1 while l < r : ans [ l ] = 'R' ans [ r ] = 'L' l += 1 r -= 1 L = i return '' . join ( ans ) 839. Similar String Groups $\\star\\star\\star$ 840. Magic Squares In Grid $\\star$ class Solution : def numMagicSquaresInside ( self , grid : List [ List [ int ]]) -> int : def isMagic ( i : int , j : int ) -> int : s = \"\" . join ( str ( grid [ i + num // 3 ][ j + num % 3 ]) for num in [ 0 , 1 , 2 , 5 , 8 , 7 , 6 , 3 ]) return s in \"43816729\" * 2 or s in \"43816729\" [:: - 1 ] * 2 ans = 0 for i in range ( len ( grid ) - 2 ): for j in range ( len ( grid [ 0 ]) - 2 ): if grid [ i ][ j ] % 2 == 0 and grid [ i + 1 ][ j + 1 ] == 5 : ans += isMagic ( i , j ) return ans","title":"0831-0840"},{"location":"python3/0801-0900/0831-0840/#831-masking-personal-information-starstar","text":"class Solution : def maskPII ( self , S : str ) -> str : atIndex = S . find ( '@' ) if atIndex != - 1 : S = S . lower () return S [ 0 ] + '*' * 5 + S [ atIndex - 1 :] ans = '' . join ( c for c in S if c . isdigit ()) if len ( ans ) == 10 : return '***-***-' + ans [ - 4 :] return '+' + '*' * ( len ( ans ) - 10 ) + '-***-***-' + ans [ - 4 :]","title":"831. Masking Personal Information $\\star\\star$"},{"location":"python3/0801-0900/0831-0840/#832-flipping-an-image-star","text":"class Solution : def flipAndInvertImage ( self , A : List [ List [ int ]]) -> List [ List [ int ]]: for row in A : for i in range (( len ( row ) + 1 ) // 2 ): row [ i ], row [ ~ i ] = row [ ~ i ] ^ 1 , row [ i ] ^ 1 return A","title":"832. Flipping an Image $\\star$"},{"location":"python3/0801-0900/0831-0840/#833-find-and-replace-in-string-starstar","text":"class Solution : def findReplaceString ( self , S : str , indexes : List [ int ], sources : List [ str ], targets : List [ str ]) -> str : for index , source , target in sorted ( zip ( indexes , sources , targets ), reverse = True ): if S [ index : index + len ( source )] == source : S = S [: index ] + target + S [ index + len ( source ):] return S","title":"833. Find And Replace in String $\\star\\star$"},{"location":"python3/0801-0900/0831-0840/#834-sum-of-distances-in-tree-starstarstar","text":"","title":"834. Sum of Distances in Tree $\\star\\star\\star$"},{"location":"python3/0801-0900/0831-0840/#835-image-overlap-starstar","text":"class Solution : def largestOverlap ( self , A : List [ List [ int ]], B : List [ List [ int ]]) -> int : n = len ( A ) magic = 100 onesA = [] onesB = [] dict = collections . defaultdict ( int ) for i in range ( n ): for j in range ( n ): if A [ i ][ j ] == 1 : onesA . append ([ i , j ]) if B [ i ][ j ] == 1 : onesB . append ([ i , j ]) for a in onesA : for b in onesB : dict [( a [ 0 ] - b [ 0 ]) * magic + ( a [ 1 ] - b [ 1 ])] += 1 return max ( dict . values ()) if dict else 0","title":"835. Image Overlap $\\star\\star$"},{"location":"python3/0801-0900/0831-0840/#836-rectangle-overlap-star","text":"class Solution : def isRectangleOverlap ( self , rec1 : List [ int ], rec2 : List [ int ]) -> bool : return rec1 [ 0 ] < rec2 [ 2 ] and rec2 [ 0 ] < rec1 [ 2 ] and rec1 [ 1 ] < rec2 [ 3 ] and rec2 [ 1 ] < rec1 [ 3 ]","title":"836. Rectangle Overlap $\\star$"},{"location":"python3/0801-0900/0831-0840/#837-new-21-game-starstar","text":"","title":"837. New 21 Game $\\star\\star$"},{"location":"python3/0801-0900/0831-0840/#838-push-dominoes-starstar","text":"class Solution : def pushDominoes ( self , dominoes : str ) -> str : ans = list ( dominoes ) L = - 1 R = - 1 for i in range ( len ( dominoes ) + 1 ): if i == len ( dominoes ) or dominoes [ i ] == 'R' : if L < R : while R < i : ans [ R ] = 'R' R += 1 R = i elif dominoes [ i ] == 'L' : if R < L or ( L , R ) == ( - 1 , - 1 ): if ( L , R ) == ( - 1 , - 1 ): L += 1 while L < i : ans [ L ] = 'L' L += 1 else : l = R + 1 r = i - 1 while l < r : ans [ l ] = 'R' ans [ r ] = 'L' l += 1 r -= 1 L = i return '' . join ( ans )","title":"838. Push Dominoes $\\star\\star$"},{"location":"python3/0801-0900/0831-0840/#839-similar-string-groups-starstarstar","text":"","title":"839. Similar String Groups $\\star\\star\\star$"},{"location":"python3/0801-0900/0831-0840/#840-magic-squares-in-grid-star","text":"class Solution : def numMagicSquaresInside ( self , grid : List [ List [ int ]]) -> int : def isMagic ( i : int , j : int ) -> int : s = \"\" . join ( str ( grid [ i + num // 3 ][ j + num % 3 ]) for num in [ 0 , 1 , 2 , 5 , 8 , 7 , 6 , 3 ]) return s in \"43816729\" * 2 or s in \"43816729\" [:: - 1 ] * 2 ans = 0 for i in range ( len ( grid ) - 2 ): for j in range ( len ( grid [ 0 ]) - 2 ): if grid [ i ][ j ] % 2 == 0 and grid [ i + 1 ][ j + 1 ] == 5 : ans += isMagic ( i , j ) return ans","title":"840. Magic Squares In Grid $\\star$"},{"location":"python3/0801-0900/0841-0850/","text":"841. Keys and Rooms $\\star\\star$ 842. Split Array into Fibonacci Sequence $\\star\\star$ 843. Guess the Word $\\star\\star\\star$ 844. Backspace String Compare $\\star$ class Solution : def backspaceCompare ( self , S : str , T : str ) -> bool : i = len ( S ) - 1 j = len ( T ) - 1 while i >= 0 or j >= 0 : backspace = 0 while i >= 0 and ( S [ i ] == '#' or backspace > 0 ): backspace += 1 if S [ i ] == '#' else - 1 i -= 1 backspace = 0 while j >= 0 and ( T [ j ] == '#' or backspace > 0 ): backspace += 1 if T [ j ] == '#' else - 1 j -= 1 if i >= 0 and j >= 0 and S [ i ] != T [ j ] or \\ i < 0 and j >= 0 and S [ j ] != '#' or \\ j < 0 and i >= 0 and S [ i ] != '#' : return False i -= 1 j -= 1 return True 845. Longest Mountain in Array $\\star\\star$ class Solution : def longestMountain ( self , A : List [ int ]) -> int : ans = 0 i = 0 while i + 1 < len ( A ): while i + 1 < len ( A ) and A [ i ] == A [ i + 1 ]: i += 1 increasing = 0 decreasing = 0 while i + 1 < len ( A ) and A [ i ] < A [ i + 1 ]: increasing += 1 i += 1 while i + 1 < len ( A ) and A [ i ] > A [ i + 1 ]: decreasing += 1 i += 1 if increasing > 0 and decreasing > 0 : ans = max ( ans , increasing + decreasing + 1 ) return ans 846. Hand of Straights $\\star\\star$ 847. Shortest Path Visiting All Nodes $\\star\\star\\star$ 848. Shifting Letters $\\star\\star$ class Solution : def shiftingLetters ( self , S : str , shifts : List [ int ]) -> str : ans = '' for i in range ( len ( shifts ) - 2 , - 1 , - 1 ): shifts [ i ] += shifts [ i + 1 ] for c , shift in zip ( S , shifts ): ans += chr (( ord ( c ) - ord ( 'a' ) + shift ) % 26 + ord ( 'a' )) return ans 849. Maximize Distance to Closest Person $\\star$ class Solution : def maxDistToClosest ( self , seats : List [ int ]) -> int : n = len ( seats ) ans = 0 j = - 1 for i in range ( n ): if seats [ i ] == 1 : ans = i if j == - 1 else max ( ans , ( i - j ) // 2 ) j = i return max ( ans , n - j - 1 ) 850. Rectangle Area II $\\star\\star\\star$","title":"0841-0850"},{"location":"python3/0801-0900/0841-0850/#841-keys-and-rooms-starstar","text":"","title":"841. Keys and Rooms $\\star\\star$"},{"location":"python3/0801-0900/0841-0850/#842-split-array-into-fibonacci-sequence-starstar","text":"","title":"842. Split Array into Fibonacci Sequence $\\star\\star$"},{"location":"python3/0801-0900/0841-0850/#843-guess-the-word-starstarstar","text":"","title":"843. Guess the Word $\\star\\star\\star$"},{"location":"python3/0801-0900/0841-0850/#844-backspace-string-compare-star","text":"class Solution : def backspaceCompare ( self , S : str , T : str ) -> bool : i = len ( S ) - 1 j = len ( T ) - 1 while i >= 0 or j >= 0 : backspace = 0 while i >= 0 and ( S [ i ] == '#' or backspace > 0 ): backspace += 1 if S [ i ] == '#' else - 1 i -= 1 backspace = 0 while j >= 0 and ( T [ j ] == '#' or backspace > 0 ): backspace += 1 if T [ j ] == '#' else - 1 j -= 1 if i >= 0 and j >= 0 and S [ i ] != T [ j ] or \\ i < 0 and j >= 0 and S [ j ] != '#' or \\ j < 0 and i >= 0 and S [ i ] != '#' : return False i -= 1 j -= 1 return True","title":"844. Backspace String Compare $\\star$"},{"location":"python3/0801-0900/0841-0850/#845-longest-mountain-in-array-starstar","text":"class Solution : def longestMountain ( self , A : List [ int ]) -> int : ans = 0 i = 0 while i + 1 < len ( A ): while i + 1 < len ( A ) and A [ i ] == A [ i + 1 ]: i += 1 increasing = 0 decreasing = 0 while i + 1 < len ( A ) and A [ i ] < A [ i + 1 ]: increasing += 1 i += 1 while i + 1 < len ( A ) and A [ i ] > A [ i + 1 ]: decreasing += 1 i += 1 if increasing > 0 and decreasing > 0 : ans = max ( ans , increasing + decreasing + 1 ) return ans","title":"845. Longest Mountain in Array $\\star\\star$"},{"location":"python3/0801-0900/0841-0850/#846-hand-of-straights-starstar","text":"","title":"846. Hand of Straights $\\star\\star$"},{"location":"python3/0801-0900/0841-0850/#847-shortest-path-visiting-all-nodes-starstarstar","text":"","title":"847. Shortest Path Visiting All Nodes $\\star\\star\\star$"},{"location":"python3/0801-0900/0841-0850/#848-shifting-letters-starstar","text":"class Solution : def shiftingLetters ( self , S : str , shifts : List [ int ]) -> str : ans = '' for i in range ( len ( shifts ) - 2 , - 1 , - 1 ): shifts [ i ] += shifts [ i + 1 ] for c , shift in zip ( S , shifts ): ans += chr (( ord ( c ) - ord ( 'a' ) + shift ) % 26 + ord ( 'a' )) return ans","title":"848. Shifting Letters $\\star\\star$"},{"location":"python3/0801-0900/0841-0850/#849-maximize-distance-to-closest-person-star","text":"class Solution : def maxDistToClosest ( self , seats : List [ int ]) -> int : n = len ( seats ) ans = 0 j = - 1 for i in range ( n ): if seats [ i ] == 1 : ans = i if j == - 1 else max ( ans , ( i - j ) // 2 ) j = i return max ( ans , n - j - 1 )","title":"849. Maximize Distance to Closest Person $\\star$"},{"location":"python3/0801-0900/0841-0850/#850-rectangle-area-ii-starstarstar","text":"","title":"850. Rectangle Area II $\\star\\star\\star$"},{"location":"python3/0801-0900/0851-0860/","text":"851. Loud and Rich $\\star\\star$ 852. Peak Index in a Mountain Array $\\star$ 853. Car Fleet $\\star\\star$ 854. K-Similar Strings $\\star\\star\\star$ 855. Exam Room $\\star\\star$ 856. Score of Parentheses $\\star\\star$ class Solution : def scoreOfParentheses ( self , S : str ) -> int : ans = 0 layer = 0 for a , b in zip ( S , S [ 1 :]): if a + b == '()' : ans += 1 << layer layer += 1 if a == '(' else - 1 return ans 857. Minimum Cost to Hire K Workers $\\star\\star\\star$ 858. Mirror Reflection $\\star\\star$ class Solution : def mirrorReflection ( self , p : int , q : int ) -> int : m = 1 n = 1 while m * p != n * q : n += 1 m = n * q // p if m % 2 == 0 and n % 2 == 1 : return 0 if m % 2 == 1 and n % 2 == 1 : return 1 if m % 2 == 1 and n % 2 == 0 : return 2 859. Buddy Strings $\\star$ class Solution : def buddyStrings ( self , A : str , B : str ) -> bool : if len ( A ) != len ( B ): return False if A == B and len ( set ( A )) < len ( A ): return True diff = [( a , b ) for a , b in zip ( A , B ) if a != b ] return len ( diff ) == 2 and diff [ 0 ] == diff [ 1 ][:: - 1 ] 860. Lemonade Change $\\star$","title":"0851-0860"},{"location":"python3/0801-0900/0851-0860/#851-loud-and-rich-starstar","text":"","title":"851. Loud and Rich $\\star\\star$"},{"location":"python3/0801-0900/0851-0860/#852-peak-index-in-a-mountain-array-star","text":"","title":"852. Peak Index in a Mountain Array $\\star$"},{"location":"python3/0801-0900/0851-0860/#853-car-fleet-starstar","text":"","title":"853. Car Fleet $\\star\\star$"},{"location":"python3/0801-0900/0851-0860/#854-k-similar-strings-starstarstar","text":"","title":"854. K-Similar Strings $\\star\\star\\star$"},{"location":"python3/0801-0900/0851-0860/#855-exam-room-starstar","text":"","title":"855. Exam Room $\\star\\star$"},{"location":"python3/0801-0900/0851-0860/#856-score-of-parentheses-starstar","text":"class Solution : def scoreOfParentheses ( self , S : str ) -> int : ans = 0 layer = 0 for a , b in zip ( S , S [ 1 :]): if a + b == '()' : ans += 1 << layer layer += 1 if a == '(' else - 1 return ans","title":"856. Score of Parentheses $\\star\\star$"},{"location":"python3/0801-0900/0851-0860/#857-minimum-cost-to-hire-k-workers-starstarstar","text":"","title":"857. Minimum Cost to Hire K Workers $\\star\\star\\star$"},{"location":"python3/0801-0900/0851-0860/#858-mirror-reflection-starstar","text":"class Solution : def mirrorReflection ( self , p : int , q : int ) -> int : m = 1 n = 1 while m * p != n * q : n += 1 m = n * q // p if m % 2 == 0 and n % 2 == 1 : return 0 if m % 2 == 1 and n % 2 == 1 : return 1 if m % 2 == 1 and n % 2 == 0 : return 2","title":"858. Mirror Reflection $\\star\\star$"},{"location":"python3/0801-0900/0851-0860/#859-buddy-strings-star","text":"class Solution : def buddyStrings ( self , A : str , B : str ) -> bool : if len ( A ) != len ( B ): return False if A == B and len ( set ( A )) < len ( A ): return True diff = [( a , b ) for a , b in zip ( A , B ) if a != b ] return len ( diff ) == 2 and diff [ 0 ] == diff [ 1 ][:: - 1 ]","title":"859. Buddy Strings $\\star$"},{"location":"python3/0801-0900/0851-0860/#860-lemonade-change-star","text":"","title":"860. Lemonade Change $\\star$"},{"location":"python3/0801-0900/0861-0870/","text":"861. Score After Flipping Matrix $\\star\\star$ 862. Shortest Subarray with Sum at Least K $\\star\\star\\star$ class Solution : def shortestSubarray ( self , A : List [ int ], K : int ) -> int : n = len ( A ) ans = n + 1 prefixSum = [ 0 ] * ( n + 1 ) for i in range ( n ): prefixSum [ i + 1 ] = prefixSum [ i ] + A [ i ] deque = collections . deque () for i in range ( n + 1 ): while deque and prefixSum [ i ] - prefixSum [ deque [ 0 ]] >= K : ans = min ( ans , i - deque . popleft ()) while deque and prefixSum [ i ] <= prefixSum [ deque [ - 1 ]]: deque . pop () deque . append ( i ) return ans if ans <= n else - 1 863. All Nodes Distance K in Binary Tree $\\star\\star$ 864. Shortest Path to Get All Keys $\\star\\star\\star$ 865. Smallest Subtree with all the Deepest Nodes $\\star\\star$ 866. Prime Palindrome $\\star\\star$ class Solution : def primePalindrome ( self , N : int ) -> int : def getPalindromes ( n : int ) -> int : length = n // 2 for i in range ( 10 ** ( length - 1 ), 10 ** length ): s = str ( i ) for j in range ( 10 ): yield int ( s + str ( j ) + s [:: - 1 ]) def isPrime ( num : int ) -> bool : return not any ( num % i == 0 for i in range ( 2 , int ( num ** 0.5 + 1 ))) if N <= 2 : return 2 if N == 3 : return 3 if N <= 5 : return 5 if N <= 7 : return 7 if N <= 11 : return 11 n = len ( str ( N )) while True : for num in getPalindromes ( n ): if num >= N and isPrime ( num ): return num n += 1 867. Transpose Matrix $\\star$ class Solution : def transpose ( self , A : List [ List [ int ]]) -> List [ List [ int ]]: ans = [[ 0 ] * len ( A ) for _ in range ( len ( A [ 0 ]))] for i in range ( len ( A )): for j in range ( len ( A [ 0 ])): ans [ j ][ i ] = A [ i ][ j ] return ans 868. Binary Gap $\\star$ class Solution : def binaryGap ( self , N : int ) -> int : ans = 0 prevOneIndex = 30 i = 0 n = N while n > 0 : if n % 2 == 1 : ans = max ( ans , i - prevOneIndex ) prevOneIndex = i n >>= 1 i += 1 return ans 869. Reordered Power of 2 $\\star\\star$ class Solution : def reorderedPowerOf2 ( self , N : int ) -> bool : count = collections . Counter ( str ( N )) return any ( collections . Counter ( str ( 1 << i )) == count for i in range ( 30 )) 870. Advantage Shuffle $\\star\\star$ from sortedcontainers import SortedList class Solution : def advantageCount ( self , A : List [ int ], B : List [ int ]) -> List [ int ]: sl = SortedList ( A ) for i , b in enumerate ( B ): index = 0 if sl [ - 1 ] <= b else sl . bisect_right ( b ) A [ i ] = sl [ index ] del sl [ index ] return A","title":"0861-0870"},{"location":"python3/0801-0900/0861-0870/#861-score-after-flipping-matrix-starstar","text":"","title":"861. Score After Flipping Matrix $\\star\\star$"},{"location":"python3/0801-0900/0861-0870/#862-shortest-subarray-with-sum-at-least-k-starstarstar","text":"class Solution : def shortestSubarray ( self , A : List [ int ], K : int ) -> int : n = len ( A ) ans = n + 1 prefixSum = [ 0 ] * ( n + 1 ) for i in range ( n ): prefixSum [ i + 1 ] = prefixSum [ i ] + A [ i ] deque = collections . deque () for i in range ( n + 1 ): while deque and prefixSum [ i ] - prefixSum [ deque [ 0 ]] >= K : ans = min ( ans , i - deque . popleft ()) while deque and prefixSum [ i ] <= prefixSum [ deque [ - 1 ]]: deque . pop () deque . append ( i ) return ans if ans <= n else - 1","title":"862. Shortest Subarray with Sum at Least K $\\star\\star\\star$"},{"location":"python3/0801-0900/0861-0870/#863-all-nodes-distance-k-in-binary-tree-starstar","text":"","title":"863. All Nodes Distance K in Binary Tree $\\star\\star$"},{"location":"python3/0801-0900/0861-0870/#864-shortest-path-to-get-all-keys-starstarstar","text":"","title":"864. Shortest Path to Get All Keys $\\star\\star\\star$"},{"location":"python3/0801-0900/0861-0870/#865-smallest-subtree-with-all-the-deepest-nodes-starstar","text":"","title":"865. Smallest Subtree with all the Deepest Nodes $\\star\\star$"},{"location":"python3/0801-0900/0861-0870/#866-prime-palindrome-starstar","text":"class Solution : def primePalindrome ( self , N : int ) -> int : def getPalindromes ( n : int ) -> int : length = n // 2 for i in range ( 10 ** ( length - 1 ), 10 ** length ): s = str ( i ) for j in range ( 10 ): yield int ( s + str ( j ) + s [:: - 1 ]) def isPrime ( num : int ) -> bool : return not any ( num % i == 0 for i in range ( 2 , int ( num ** 0.5 + 1 ))) if N <= 2 : return 2 if N == 3 : return 3 if N <= 5 : return 5 if N <= 7 : return 7 if N <= 11 : return 11 n = len ( str ( N )) while True : for num in getPalindromes ( n ): if num >= N and isPrime ( num ): return num n += 1","title":"866. Prime Palindrome $\\star\\star$"},{"location":"python3/0801-0900/0861-0870/#867-transpose-matrix-star","text":"class Solution : def transpose ( self , A : List [ List [ int ]]) -> List [ List [ int ]]: ans = [[ 0 ] * len ( A ) for _ in range ( len ( A [ 0 ]))] for i in range ( len ( A )): for j in range ( len ( A [ 0 ])): ans [ j ][ i ] = A [ i ][ j ] return ans","title":"867. Transpose Matrix $\\star$"},{"location":"python3/0801-0900/0861-0870/#868-binary-gap-star","text":"class Solution : def binaryGap ( self , N : int ) -> int : ans = 0 prevOneIndex = 30 i = 0 n = N while n > 0 : if n % 2 == 1 : ans = max ( ans , i - prevOneIndex ) prevOneIndex = i n >>= 1 i += 1 return ans","title":"868. Binary Gap $\\star$"},{"location":"python3/0801-0900/0861-0870/#869-reordered-power-of-2-starstar","text":"class Solution : def reorderedPowerOf2 ( self , N : int ) -> bool : count = collections . Counter ( str ( N )) return any ( collections . Counter ( str ( 1 << i )) == count for i in range ( 30 ))","title":"869. Reordered Power of 2 $\\star\\star$"},{"location":"python3/0801-0900/0861-0870/#870-advantage-shuffle-starstar","text":"from sortedcontainers import SortedList class Solution : def advantageCount ( self , A : List [ int ], B : List [ int ]) -> List [ int ]: sl = SortedList ( A ) for i , b in enumerate ( B ): index = 0 if sl [ - 1 ] <= b else sl . bisect_right ( b ) A [ i ] = sl [ index ] del sl [ index ] return A","title":"870. Advantage Shuffle $\\star\\star$"},{"location":"python3/0801-0900/0871-0880/","text":"871. Minimum Number of Refueling Stops $\\star\\star\\star$ class Solution : def minRefuelStops ( self , target : int , startFuel : int , stations : List [ List [ int ]]) -> int : dp = [ startFuel ] + [ 0 ] * len ( stations ) for i , station in enumerate ( stations ): for j in range ( i + 1 , 0 , - 1 ): if dp [ j - 1 ] >= station [ 0 ]: dp [ j ] = max ( dp [ j ], dp [ j - 1 ] + station [ 1 ]) for i , d in enumerate ( dp ): if d >= target : return i return - 1 872. Leaf-Similar Trees $\\star$ 873. Length of Longest Fibonacci Subsequence $\\star\\star$ class Solution : def lenLongestFibSubseq ( self , A : List [ int ]) -> int : n = len ( A ) ans = 0 indices = { a : i for i , a in enumerate ( A )} dp = [[ 2 ] * n for _ in range ( n )] for j in range ( n ): for k in range ( j + 1 , n ): ai = A [ k ] - A [ j ] if ai < A [ j ] and ai in indices : i = indices [ ai ] dp [ j ][ k ] = dp [ i ][ j ] + 1 ans = max ( ans , dp [ j ][ k ]) return ans 874. Walking Robot Simulation $\\star$ 875. Koko Eating Bananas $\\star\\star$ class Solution : def minEatingSpeed ( self , piles : List [ int ], H : int ) -> int : l = 1 r = max ( piles ) + 1 while l < r : m = ( l + r ) // 2 hour = 0 for pile in piles : hour += ( pile - 1 ) // m + 1 if hour > H : l = m + 1 else : r = m return l 876. Middle of the Linked List $\\star$ class Solution : def middleNode ( self , head : ListNode ) -> ListNode : slow = head fast = head while fast and fast . next : slow = slow . next fast = fast . next . next return slow 877. Stone Game $\\star\\star$ class Solution : def stoneGame ( self , piles : List [ int ]) -> bool : n = len ( piles ) dp = [[ 0 ] * n for _ in range ( n )] for i , pile in enumerate ( piles ): dp [ i ][ i ] = pile for d in range ( 1 , n ): for i in range ( n - d ): dp [ i ][ i + d ] = max ( piles [ i ] - dp [ i + 1 ][ i + d ], piles [ i + d ] - dp [ i ][ i + d - 1 ]) return dp [ 0 ][ n - 1 ] > 0 878. Nth Magical Number $\\star\\star\\star$ class Solution : def nthMagicalNumber ( self , N : int , A : int , B : int ) -> int : kMod = int ( 1e9 + 7 ) lcm = A * B // math . gcd ( A , B ) l = min ( A , B ) r = min ( A , B ) * N while l < r : m = ( l + r ) // 2 if m // A + m // B - m // lcm < N : l = m + 1 else : r = m return l % kMod 879. Profitable Schemes $\\star\\star\\star$ 880. Decoded String at Index $\\star\\star$","title":"0871-0880"},{"location":"python3/0801-0900/0871-0880/#871-minimum-number-of-refueling-stops-starstarstar","text":"class Solution : def minRefuelStops ( self , target : int , startFuel : int , stations : List [ List [ int ]]) -> int : dp = [ startFuel ] + [ 0 ] * len ( stations ) for i , station in enumerate ( stations ): for j in range ( i + 1 , 0 , - 1 ): if dp [ j - 1 ] >= station [ 0 ]: dp [ j ] = max ( dp [ j ], dp [ j - 1 ] + station [ 1 ]) for i , d in enumerate ( dp ): if d >= target : return i return - 1","title":"871. Minimum Number of Refueling Stops $\\star\\star\\star$"},{"location":"python3/0801-0900/0871-0880/#872-leaf-similar-trees-star","text":"","title":"872. Leaf-Similar Trees $\\star$"},{"location":"python3/0801-0900/0871-0880/#873-length-of-longest-fibonacci-subsequence-starstar","text":"class Solution : def lenLongestFibSubseq ( self , A : List [ int ]) -> int : n = len ( A ) ans = 0 indices = { a : i for i , a in enumerate ( A )} dp = [[ 2 ] * n for _ in range ( n )] for j in range ( n ): for k in range ( j + 1 , n ): ai = A [ k ] - A [ j ] if ai < A [ j ] and ai in indices : i = indices [ ai ] dp [ j ][ k ] = dp [ i ][ j ] + 1 ans = max ( ans , dp [ j ][ k ]) return ans","title":"873. Length of Longest Fibonacci Subsequence $\\star\\star$"},{"location":"python3/0801-0900/0871-0880/#874-walking-robot-simulation-star","text":"","title":"874. Walking Robot Simulation $\\star$"},{"location":"python3/0801-0900/0871-0880/#875-koko-eating-bananas-starstar","text":"class Solution : def minEatingSpeed ( self , piles : List [ int ], H : int ) -> int : l = 1 r = max ( piles ) + 1 while l < r : m = ( l + r ) // 2 hour = 0 for pile in piles : hour += ( pile - 1 ) // m + 1 if hour > H : l = m + 1 else : r = m return l","title":"875. Koko Eating Bananas $\\star\\star$"},{"location":"python3/0801-0900/0871-0880/#876-middle-of-the-linked-list-star","text":"class Solution : def middleNode ( self , head : ListNode ) -> ListNode : slow = head fast = head while fast and fast . next : slow = slow . next fast = fast . next . next return slow","title":"876. Middle of the Linked List $\\star$"},{"location":"python3/0801-0900/0871-0880/#877-stone-game-starstar","text":"class Solution : def stoneGame ( self , piles : List [ int ]) -> bool : n = len ( piles ) dp = [[ 0 ] * n for _ in range ( n )] for i , pile in enumerate ( piles ): dp [ i ][ i ] = pile for d in range ( 1 , n ): for i in range ( n - d ): dp [ i ][ i + d ] = max ( piles [ i ] - dp [ i + 1 ][ i + d ], piles [ i + d ] - dp [ i ][ i + d - 1 ]) return dp [ 0 ][ n - 1 ] > 0","title":"877. Stone Game $\\star\\star$"},{"location":"python3/0801-0900/0871-0880/#878-nth-magical-number-starstarstar","text":"class Solution : def nthMagicalNumber ( self , N : int , A : int , B : int ) -> int : kMod = int ( 1e9 + 7 ) lcm = A * B // math . gcd ( A , B ) l = min ( A , B ) r = min ( A , B ) * N while l < r : m = ( l + r ) // 2 if m // A + m // B - m // lcm < N : l = m + 1 else : r = m return l % kMod","title":"878. Nth Magical Number $\\star\\star\\star$"},{"location":"python3/0801-0900/0871-0880/#879-profitable-schemes-starstarstar","text":"","title":"879. Profitable Schemes $\\star\\star\\star$"},{"location":"python3/0801-0900/0871-0880/#880-decoded-string-at-index-starstar","text":"","title":"880. Decoded String at Index $\\star\\star$"},{"location":"python3/0801-0900/0881-0890/","text":"881. Boats to Save People $\\star\\star$ class Solution : def numRescueBoats ( self , people : List [ int ], limit : int ) -> int : ans = 0 i = 0 j = len ( people ) - 1 people . sort () while i <= j : remain = limit - people [ j ] j -= 1 if people [ i ] <= remain : i += 1 ans += 1 return ans 882. Reachable Nodes In Subdivided Graph $\\star\\star\\star$ 883. Projection Area of 3D Shapes $\\star$ class Solution : def projectionArea ( self , grid : List [ List [ int ]]) -> int : return sum ( a > 0 for row in grid for a in row ) + sum ( max ( row ) for row in grid ) + sum ( max ( col ) for col in zip ( * grid )) 884. Uncommon Words from Two Sentences $\\star$ class Solution : def uncommonFromSentences ( self , A : str , B : str ) -> List [ str ]: count = collections . Counter (( A + ' ' + B ) . split ()) return [ word for word , freq in count . items () if freq == 1 ] 885. Spiral Matrix III $\\star\\star$ class Solution : def spiralMatrixIII ( self , R : int , C : int , r0 : int , c0 : int ) -> List [ List [ int ]]: ans = [[ r0 , c0 ]] dx = [ 1 , 0 , - 1 , 0 ] dy = [ 0 , 1 , 0 , - 1 ] i = 0 while len ( ans ) < R * C : for _ in range ( i // 2 + 1 ): r0 += dy [ i % 4 ] c0 += dx [ i % 4 ] if 0 <= r0 < R and 0 <= c0 < C : ans . append ([ r0 , c0 ]) i += 1 return ans 886. Possible Bipartition $\\star\\star$ 887. Super Egg Drop $\\star\\star\\star$ class Solution : def superEggDrop ( self , K : int , N : int ) -> int : moves = 0 dp = [[ 0 ] * ( K + 1 ) for _ in range ( N + 1 )] while dp [ moves ][ K ] < N : moves += 1 for eggs in range ( 1 , K + 1 ): dp [ moves ][ eggs ] = dp [ moves - 1 ][ eggs - 1 ] + \\ dp [ moves - 1 ][ eggs ] + 1 return moves 888. Fair Candy Swap $\\star$ class Solution : def fairCandySwap ( self , A : List [ int ], B : List [ int ]) -> List [ int ]: diff = ( sum ( A ) - sum ( B )) // 2 B = set ( B ) for a in A : if a - diff in B : return [ a , a - diff ] 889. Construct Binary Tree from Preorder and Postorder Traversal $\\star\\star$ class Solution : def constructFromPrePost ( self , pre : List [ int ], post : List [ int ]) -> TreeNode : return self . helper ( 0 , 0 , len ( pre ), pre , post ) def helper ( self , i : int , j : int , n : int , pre : List [ int ], post : List [ int ]) -> TreeNode : if n == 0 : return None root = TreeNode ( pre [ i ]) if n == 1 : return root k = j while post [ k ] != pre [ i + 1 ]: k += 1 l = k - j + 1 root . left = self . helper ( i + 1 , j , l , pre , post ) root . right = self . helper ( i + l + 1 , j + l , n - l - 1 , pre , post ) return root 890. Find and Replace Pattern $\\star\\star$ class Solution : def findAndReplacePattern ( self , words : List [ str ], pattern : str ) -> List [ str ]: def isIsomorphic ( w : str , p : str ) -> bool : return [ * map ( w . index , w )] == [ * map ( p . index , p )] return [ word for word in words if isIsomorphic ( word , pattern )]","title":"0881-0890"},{"location":"python3/0801-0900/0881-0890/#881-boats-to-save-people-starstar","text":"class Solution : def numRescueBoats ( self , people : List [ int ], limit : int ) -> int : ans = 0 i = 0 j = len ( people ) - 1 people . sort () while i <= j : remain = limit - people [ j ] j -= 1 if people [ i ] <= remain : i += 1 ans += 1 return ans","title":"881. Boats to Save People $\\star\\star$"},{"location":"python3/0801-0900/0881-0890/#882-reachable-nodes-in-subdivided-graph-starstarstar","text":"","title":"882. Reachable Nodes In Subdivided Graph $\\star\\star\\star$"},{"location":"python3/0801-0900/0881-0890/#883-projection-area-of-3d-shapes-star","text":"class Solution : def projectionArea ( self , grid : List [ List [ int ]]) -> int : return sum ( a > 0 for row in grid for a in row ) + sum ( max ( row ) for row in grid ) + sum ( max ( col ) for col in zip ( * grid ))","title":"883. Projection Area of 3D Shapes $\\star$"},{"location":"python3/0801-0900/0881-0890/#884-uncommon-words-from-two-sentences-star","text":"class Solution : def uncommonFromSentences ( self , A : str , B : str ) -> List [ str ]: count = collections . Counter (( A + ' ' + B ) . split ()) return [ word for word , freq in count . items () if freq == 1 ]","title":"884. Uncommon Words from Two Sentences $\\star$"},{"location":"python3/0801-0900/0881-0890/#885-spiral-matrix-iii-starstar","text":"class Solution : def spiralMatrixIII ( self , R : int , C : int , r0 : int , c0 : int ) -> List [ List [ int ]]: ans = [[ r0 , c0 ]] dx = [ 1 , 0 , - 1 , 0 ] dy = [ 0 , 1 , 0 , - 1 ] i = 0 while len ( ans ) < R * C : for _ in range ( i // 2 + 1 ): r0 += dy [ i % 4 ] c0 += dx [ i % 4 ] if 0 <= r0 < R and 0 <= c0 < C : ans . append ([ r0 , c0 ]) i += 1 return ans","title":"885. Spiral Matrix III $\\star\\star$"},{"location":"python3/0801-0900/0881-0890/#886-possible-bipartition-starstar","text":"","title":"886. Possible Bipartition $\\star\\star$"},{"location":"python3/0801-0900/0881-0890/#887-super-egg-drop-starstarstar","text":"class Solution : def superEggDrop ( self , K : int , N : int ) -> int : moves = 0 dp = [[ 0 ] * ( K + 1 ) for _ in range ( N + 1 )] while dp [ moves ][ K ] < N : moves += 1 for eggs in range ( 1 , K + 1 ): dp [ moves ][ eggs ] = dp [ moves - 1 ][ eggs - 1 ] + \\ dp [ moves - 1 ][ eggs ] + 1 return moves","title":"887. Super Egg Drop $\\star\\star\\star$"},{"location":"python3/0801-0900/0881-0890/#888-fair-candy-swap-star","text":"class Solution : def fairCandySwap ( self , A : List [ int ], B : List [ int ]) -> List [ int ]: diff = ( sum ( A ) - sum ( B )) // 2 B = set ( B ) for a in A : if a - diff in B : return [ a , a - diff ]","title":"888. Fair Candy Swap $\\star$"},{"location":"python3/0801-0900/0881-0890/#889-construct-binary-tree-from-preorder-and-postorder-traversal-starstar","text":"class Solution : def constructFromPrePost ( self , pre : List [ int ], post : List [ int ]) -> TreeNode : return self . helper ( 0 , 0 , len ( pre ), pre , post ) def helper ( self , i : int , j : int , n : int , pre : List [ int ], post : List [ int ]) -> TreeNode : if n == 0 : return None root = TreeNode ( pre [ i ]) if n == 1 : return root k = j while post [ k ] != pre [ i + 1 ]: k += 1 l = k - j + 1 root . left = self . helper ( i + 1 , j , l , pre , post ) root . right = self . helper ( i + l + 1 , j + l , n - l - 1 , pre , post ) return root","title":"889. Construct Binary Tree from Preorder and Postorder Traversal $\\star\\star$"},{"location":"python3/0801-0900/0881-0890/#890-find-and-replace-pattern-starstar","text":"class Solution : def findAndReplacePattern ( self , words : List [ str ], pattern : str ) -> List [ str ]: def isIsomorphic ( w : str , p : str ) -> bool : return [ * map ( w . index , w )] == [ * map ( p . index , p )] return [ word for word in words if isIsomorphic ( word , pattern )]","title":"890. Find and Replace Pattern $\\star\\star$"},{"location":"python3/0801-0900/0891-0900/","text":"891. Sum of Subsequence Widths $\\star\\star\\star$ class Solution : def sumSubseqWidths ( self , A : List [ int ]) -> int : n = len ( A ) kMod = int ( 1e9 + 7 ) ans = 0 exp = 1 A . sort () for i in range ( n ): ans = ( ans + A [ i ] * exp - A [ n - i - 1 ] * exp ) % kMod exp = exp * 2 % kMod return ans 892. Surface Area of 3D Shapes $\\star$ class Solution : def surfaceArea ( self , grid : List [ List [ int ]]) -> int : ans = 0 for i in range ( len ( grid )): for j in range ( len ( grid )): if grid [ i ][ j ]: ans += grid [ i ][ j ] * 4 + 2 if i : ans -= min ( grid [ i ][ j ], grid [ i - 1 ][ j ]) * 2 if j : ans -= min ( grid [ i ][ j ], grid [ i ][ j - 1 ]) * 2 return ans 893. Groups of Special-Equivalent Strings $\\star$ class Solution : def numSpecialEquivGroups ( self , A : List [ str ]) -> int : return len ({ '' . join ( sorted ( s [:: 2 ])) + '' . join ( sorted ( s [ 1 :: 2 ])) for s in A }) 894. All Possible Full Binary Trees $\\star\\star$ 895. Maximum Frequency Stack $\\star\\star\\star$ class FreqStack : def __init__ ( self ): self . count = collections . Counter () self . countToStack = collections . defaultdict ( list ) self . maxFreq = 0 def push ( self , x : int ) -> None : self . count [ x ] += 1 self . maxFreq = max ( self . maxFreq , self . count [ x ]) self . countToStack [ self . count [ x ]] . append ( x ) def pop ( self ) -> int : value = self . countToStack [ self . maxFreq ] . pop () self . count [ value ] -= 1 if not self . countToStack [ self . maxFreq ]: self . maxFreq -= 1 return value 896. Monotonic Array $\\star$ class Solution : def isMonotonic ( self , A : List [ int ]) -> bool : increasing = True decreasing = True for i in range ( 1 , len ( A )): increasing &= A [ i - 1 ] <= A [ i ] decreasing &= A [ i - 1 ] >= A [ i ] return increasing or decreasing 897. Increasing Order Search Tree $\\star$ 898. Bitwise ORs of Subarrays $\\star\\star$ 899. Orderly Queue $\\star\\star\\star$ class Solution : def orderlyQueue ( self , S : str , K : int ) -> str : return '' . join ( sorted ( S )) if K > 1 else min ( S [ i :] + S [: i ] for i in range ( len ( S ))) 900. RLE Iterator $\\star\\star$ class RLEIterator : def __init__ ( self , A : List [ int ]): self . A = A self . index = 0 def next ( self , n : int ) -> int : while self . index < len ( self . A ) and self . A [ self . index ] < n : n -= self . A [ self . index ] self . index += 2 if self . index == len ( self . A ): return - 1 self . A [ self . index ] -= n return self . A [ self . index + 1 ]","title":"0891-0900"},{"location":"python3/0801-0900/0891-0900/#891-sum-of-subsequence-widths-starstarstar","text":"class Solution : def sumSubseqWidths ( self , A : List [ int ]) -> int : n = len ( A ) kMod = int ( 1e9 + 7 ) ans = 0 exp = 1 A . sort () for i in range ( n ): ans = ( ans + A [ i ] * exp - A [ n - i - 1 ] * exp ) % kMod exp = exp * 2 % kMod return ans","title":"891. Sum of Subsequence Widths $\\star\\star\\star$"},{"location":"python3/0801-0900/0891-0900/#892-surface-area-of-3d-shapes-star","text":"class Solution : def surfaceArea ( self , grid : List [ List [ int ]]) -> int : ans = 0 for i in range ( len ( grid )): for j in range ( len ( grid )): if grid [ i ][ j ]: ans += grid [ i ][ j ] * 4 + 2 if i : ans -= min ( grid [ i ][ j ], grid [ i - 1 ][ j ]) * 2 if j : ans -= min ( grid [ i ][ j ], grid [ i ][ j - 1 ]) * 2 return ans","title":"892. Surface Area of 3D Shapes $\\star$"},{"location":"python3/0801-0900/0891-0900/#893-groups-of-special-equivalent-strings-star","text":"class Solution : def numSpecialEquivGroups ( self , A : List [ str ]) -> int : return len ({ '' . join ( sorted ( s [:: 2 ])) + '' . join ( sorted ( s [ 1 :: 2 ])) for s in A })","title":"893. Groups of Special-Equivalent Strings $\\star$"},{"location":"python3/0801-0900/0891-0900/#894-all-possible-full-binary-trees-starstar","text":"","title":"894. All Possible Full Binary Trees $\\star\\star$"},{"location":"python3/0801-0900/0891-0900/#895-maximum-frequency-stack-starstarstar","text":"class FreqStack : def __init__ ( self ): self . count = collections . Counter () self . countToStack = collections . defaultdict ( list ) self . maxFreq = 0 def push ( self , x : int ) -> None : self . count [ x ] += 1 self . maxFreq = max ( self . maxFreq , self . count [ x ]) self . countToStack [ self . count [ x ]] . append ( x ) def pop ( self ) -> int : value = self . countToStack [ self . maxFreq ] . pop () self . count [ value ] -= 1 if not self . countToStack [ self . maxFreq ]: self . maxFreq -= 1 return value","title":"895. Maximum Frequency Stack $\\star\\star\\star$"},{"location":"python3/0801-0900/0891-0900/#896-monotonic-array-star","text":"class Solution : def isMonotonic ( self , A : List [ int ]) -> bool : increasing = True decreasing = True for i in range ( 1 , len ( A )): increasing &= A [ i - 1 ] <= A [ i ] decreasing &= A [ i - 1 ] >= A [ i ] return increasing or decreasing","title":"896. Monotonic Array $\\star$"},{"location":"python3/0801-0900/0891-0900/#897-increasing-order-search-tree-star","text":"","title":"897. Increasing Order Search Tree $\\star$"},{"location":"python3/0801-0900/0891-0900/#898-bitwise-ors-of-subarrays-starstar","text":"","title":"898. Bitwise ORs of Subarrays $\\star\\star$"},{"location":"python3/0801-0900/0891-0900/#899-orderly-queue-starstarstar","text":"class Solution : def orderlyQueue ( self , S : str , K : int ) -> str : return '' . join ( sorted ( S )) if K > 1 else min ( S [ i :] + S [: i ] for i in range ( len ( S )))","title":"899. Orderly Queue $\\star\\star\\star$"},{"location":"python3/0801-0900/0891-0900/#900-rle-iterator-starstar","text":"class RLEIterator : def __init__ ( self , A : List [ int ]): self . A = A self . index = 0 def next ( self , n : int ) -> int : while self . index < len ( self . A ) and self . A [ self . index ] < n : n -= self . A [ self . index ] self . index += 2 if self . index == len ( self . A ): return - 1 self . A [ self . index ] -= n return self . A [ self . index + 1 ]","title":"900. RLE Iterator $\\star\\star$"},{"location":"python3/0901-1000/0901-0910/","text":"901. Online Stock Span $\\star\\star$ 902. Numbers At Most N Given Digit Set $\\star\\star\\star$ class Solution : def atMostNGivenDigitSet ( self , D : List [ str ], N : int ) -> int : ans = 0 num = str ( N ) for i in range ( 1 , len ( num )): ans += len ( D ) ** i for i , c in enumerate ( num ): dHasSameNum = False for digit in D : if digit < c : ans += len ( D ) ** ( len ( num ) - i - 1 ) elif digit == c : dHasSameNum = True if not dHasSameNum : return ans return ans + 1 903. Valid Permutations for DI Sequence $\\star\\star\\star$ 904. Fruit Into Baskets $\\star\\star$ class Solution : def totalFruit ( self , tree : List [ int ]) -> int : ans = 0 count = collections . defaultdict ( int ) l = 0 for r , t in enumerate ( tree ): count [ t ] += 1 while len ( count ) > 2 : count [ tree [ l ]] -= 1 if count [ tree [ l ]] == 0 : del count [ tree [ l ]] l += 1 ans = max ( ans , r - l + 1 ) return ans 905. Sort Array By Parity $\\star$ class Solution : def sortArrayByParity ( self , A : List [ int ]) -> List [ int ]: l = 0 r = len ( A ) - 1 while l < r : if A [ l ] % 2 == 1 and A [ r ] % 2 == 0 : A [ l ], A [ r ] = A [ r ], A [ l ] if A [ l ] % 2 == 0 : l += 1 if A [ r ] % 2 == 1 : r -= 1 return A 906. Super Palindromes $\\star\\star\\star$ class Solution : def superpalindromesInRange ( self , L : str , R : str ) -> int : def nextPalindrome ( num : int ) -> int : s = str ( num ) n = len ( s ) half = s [ 0 :( n + 1 ) // 2 ] reversedHalf = half [: n // 2 ][:: - 1 ] candidate = int ( half + reversedHalf ) if candidate >= num : return candidate half = str ( int ( half ) + 1 ) reversedHalf = half [: n // 2 ][:: - 1 ] return int ( half + reversedHalf ) def isPalindrome ( num : int ) -> bool : s = str ( num ) l = 0 r = len ( s ) - 1 while l < r : if s [ l ] != s [ r ]: return False l += 1 r -= 1 return True ans = 0 l = int ( L ) r = int ( R ) i = int ( sqrt ( l )) while i * i <= r : palindrome = nextPalindrome ( i ) squared = palindrome ** 2 if squared <= r and isPalindrome ( squared ): ans += 1 i = palindrome + 1 return ans 907. Sum of Subarray Minimums $\\star\\star$ class Solution : def sumSubarrayMins ( self , A : List [ int ]) -> int : n = len ( A ) kMod = int ( 1e9 + 7 ) ans = 0 prev = [ - 1 ] * n next = [ n ] * n stack1 = [] stack2 = [] for i , a in enumerate ( A ): while stack1 and A [ stack1 [ - 1 ]] > a : stack1 . pop () prev [ i ] = stack1 [ - 1 ] if stack1 else - 1 stack1 . append ( i ) while stack2 and A [ stack2 [ - 1 ]] > a : index = stack2 . pop () next [ index ] = i stack2 . append ( i ) for i , a in enumerate ( A ): ans = ( ans + a * ( i - prev [ i ]) * ( next [ i ] - i )) % kMod return ans 908. Smallest Range I $\\star$ class Solution : def smallestRangeI ( self , A : List [ int ], K : int ) -> int : return max ( 0 , max ( A ) - min ( A ) - 2 * K ) 909. Snakes and Ladders $\\star\\star$ 910. Smallest Range II $\\star\\star$ class Solution : def smallestRangeII ( self , A : List [ int ], K : int ) -> int : A . sort () ans = A [ - 1 ] - A [ 0 ] left = A [ 0 ] + K right = A [ - 1 ] - K for a , b in zip ( A , A [ 1 :]): mini = min ( left , b - K ) maxi = max ( right , a + K ) ans = min ( ans , maxi - mini ) return ans","title":"0901-0910"},{"location":"python3/0901-1000/0901-0910/#901-online-stock-span-starstar","text":"","title":"901. Online Stock Span $\\star\\star$"},{"location":"python3/0901-1000/0901-0910/#902-numbers-at-most-n-given-digit-set-starstarstar","text":"class Solution : def atMostNGivenDigitSet ( self , D : List [ str ], N : int ) -> int : ans = 0 num = str ( N ) for i in range ( 1 , len ( num )): ans += len ( D ) ** i for i , c in enumerate ( num ): dHasSameNum = False for digit in D : if digit < c : ans += len ( D ) ** ( len ( num ) - i - 1 ) elif digit == c : dHasSameNum = True if not dHasSameNum : return ans return ans + 1","title":"902. Numbers At Most N Given Digit Set $\\star\\star\\star$"},{"location":"python3/0901-1000/0901-0910/#903-valid-permutations-for-di-sequence-starstarstar","text":"","title":"903. Valid Permutations for DI Sequence $\\star\\star\\star$"},{"location":"python3/0901-1000/0901-0910/#904-fruit-into-baskets-starstar","text":"class Solution : def totalFruit ( self , tree : List [ int ]) -> int : ans = 0 count = collections . defaultdict ( int ) l = 0 for r , t in enumerate ( tree ): count [ t ] += 1 while len ( count ) > 2 : count [ tree [ l ]] -= 1 if count [ tree [ l ]] == 0 : del count [ tree [ l ]] l += 1 ans = max ( ans , r - l + 1 ) return ans","title":"904. Fruit Into Baskets $\\star\\star$"},{"location":"python3/0901-1000/0901-0910/#905-sort-array-by-parity-star","text":"class Solution : def sortArrayByParity ( self , A : List [ int ]) -> List [ int ]: l = 0 r = len ( A ) - 1 while l < r : if A [ l ] % 2 == 1 and A [ r ] % 2 == 0 : A [ l ], A [ r ] = A [ r ], A [ l ] if A [ l ] % 2 == 0 : l += 1 if A [ r ] % 2 == 1 : r -= 1 return A","title":"905. Sort Array By Parity $\\star$"},{"location":"python3/0901-1000/0901-0910/#906-super-palindromes-starstarstar","text":"class Solution : def superpalindromesInRange ( self , L : str , R : str ) -> int : def nextPalindrome ( num : int ) -> int : s = str ( num ) n = len ( s ) half = s [ 0 :( n + 1 ) // 2 ] reversedHalf = half [: n // 2 ][:: - 1 ] candidate = int ( half + reversedHalf ) if candidate >= num : return candidate half = str ( int ( half ) + 1 ) reversedHalf = half [: n // 2 ][:: - 1 ] return int ( half + reversedHalf ) def isPalindrome ( num : int ) -> bool : s = str ( num ) l = 0 r = len ( s ) - 1 while l < r : if s [ l ] != s [ r ]: return False l += 1 r -= 1 return True ans = 0 l = int ( L ) r = int ( R ) i = int ( sqrt ( l )) while i * i <= r : palindrome = nextPalindrome ( i ) squared = palindrome ** 2 if squared <= r and isPalindrome ( squared ): ans += 1 i = palindrome + 1 return ans","title":"906. Super Palindromes $\\star\\star\\star$"},{"location":"python3/0901-1000/0901-0910/#907-sum-of-subarray-minimums-starstar","text":"class Solution : def sumSubarrayMins ( self , A : List [ int ]) -> int : n = len ( A ) kMod = int ( 1e9 + 7 ) ans = 0 prev = [ - 1 ] * n next = [ n ] * n stack1 = [] stack2 = [] for i , a in enumerate ( A ): while stack1 and A [ stack1 [ - 1 ]] > a : stack1 . pop () prev [ i ] = stack1 [ - 1 ] if stack1 else - 1 stack1 . append ( i ) while stack2 and A [ stack2 [ - 1 ]] > a : index = stack2 . pop () next [ index ] = i stack2 . append ( i ) for i , a in enumerate ( A ): ans = ( ans + a * ( i - prev [ i ]) * ( next [ i ] - i )) % kMod return ans","title":"907. Sum of Subarray Minimums $\\star\\star$"},{"location":"python3/0901-1000/0901-0910/#908-smallest-range-i-star","text":"class Solution : def smallestRangeI ( self , A : List [ int ], K : int ) -> int : return max ( 0 , max ( A ) - min ( A ) - 2 * K )","title":"908. Smallest Range I $\\star$"},{"location":"python3/0901-1000/0901-0910/#909-snakes-and-ladders-starstar","text":"","title":"909. Snakes and Ladders $\\star\\star$"},{"location":"python3/0901-1000/0901-0910/#910-smallest-range-ii-starstar","text":"class Solution : def smallestRangeII ( self , A : List [ int ], K : int ) -> int : A . sort () ans = A [ - 1 ] - A [ 0 ] left = A [ 0 ] + K right = A [ - 1 ] - K for a , b in zip ( A , A [ 1 :]): mini = min ( left , b - K ) maxi = max ( right , a + K ) ans = min ( ans , maxi - mini ) return ans","title":"910. Smallest Range II $\\star\\star$"},{"location":"python3/0901-1000/0911-0920/","text":"911. Online Election $\\star\\star$ 912. Sort an Array $\\star\\star$ 913. Cat and Mouse $\\star\\star\\star$ 914. X of a Kind in a Deck of Cards $\\star$ class Solution : def hasGroupsSizeX ( self , deck : List [ int ]) -> bool : count = collections . Counter ( deck ) return functools . reduce ( math . gcd , count . values ()) >= 2 915. Partition Array into Disjoint Intervals $\\star\\star$ class Solution : def partitionDisjoint ( self , A : List [ int ]) -> int : n = len ( A ) mini = [ 0 ] * ( n - 1 ) + [ A [ - 1 ]] maxi = float ( '-inf' ) for i in range ( n - 2 , - 1 , - 1 ): mini [ i ] = min ( mini [ i + 1 ], A [ i ]) for i , a in enumerate ( A ): maxi = max ( maxi , a ) if maxi <= mini [ i + 1 ]: return i + 1 916. Word Subsets $\\star\\star$ class Solution : def wordSubsets ( self , A : List [ str ], B : List [ str ]) -> List [ str ]: count = collections . Counter () for b in B : count = count | collections . Counter ( b ) return [ a for a in A if collections . Counter ( a ) & count == count ] 917. Reverse Only Letters $\\star$ class Solution : def reverseOnlyLetters ( self , S : str ) -> str : S = list ( S ) i = 0 j = len ( S ) - 1 while i < j : while i < j and not S [ i ] . isalpha (): i += 1 while i < j and not S [ j ] . isalpha (): j -= 1 S [ i ], S [ j ] = S [ j ], S [ i ] i += 1 j -= 1 return '' . join ( S ) 918. Maximum Sum Circular Subarray $\\star\\star$ class Solution : def maxSubarraySumCircular ( self , A : List [ int ]) -> int : totalSum = 0 currMaxSum = 0 currMinSum = 0 maxSum = float ( '-inf' ) minSum = float ( 'inf' ) for a in A : totalSum += a currMaxSum = max ( currMaxSum + a , a ) currMinSum = min ( currMinSum + a , a ) maxSum = max ( maxSum , currMaxSum ) minSum = min ( minSum , currMinSum ) return maxSum if maxSum < 0 else max ( maxSum , totalSum - minSum ) 919. Complete Binary Tree Inserter $\\star\\star$ 920. Number of Music Playlists $\\star\\star\\star$","title":"0911-0920"},{"location":"python3/0901-1000/0911-0920/#911-online-election-starstar","text":"","title":"911. Online Election $\\star\\star$"},{"location":"python3/0901-1000/0911-0920/#912-sort-an-array-starstar","text":"","title":"912. Sort an Array $\\star\\star$"},{"location":"python3/0901-1000/0911-0920/#913-cat-and-mouse-starstarstar","text":"","title":"913. Cat and Mouse $\\star\\star\\star$"},{"location":"python3/0901-1000/0911-0920/#914-x-of-a-kind-in-a-deck-of-cards-star","text":"class Solution : def hasGroupsSizeX ( self , deck : List [ int ]) -> bool : count = collections . Counter ( deck ) return functools . reduce ( math . gcd , count . values ()) >= 2","title":"914. X of a Kind in a Deck of Cards $\\star$"},{"location":"python3/0901-1000/0911-0920/#915-partition-array-into-disjoint-intervals-starstar","text":"class Solution : def partitionDisjoint ( self , A : List [ int ]) -> int : n = len ( A ) mini = [ 0 ] * ( n - 1 ) + [ A [ - 1 ]] maxi = float ( '-inf' ) for i in range ( n - 2 , - 1 , - 1 ): mini [ i ] = min ( mini [ i + 1 ], A [ i ]) for i , a in enumerate ( A ): maxi = max ( maxi , a ) if maxi <= mini [ i + 1 ]: return i + 1","title":"915. Partition Array into Disjoint Intervals $\\star\\star$"},{"location":"python3/0901-1000/0911-0920/#916-word-subsets-starstar","text":"class Solution : def wordSubsets ( self , A : List [ str ], B : List [ str ]) -> List [ str ]: count = collections . Counter () for b in B : count = count | collections . Counter ( b ) return [ a for a in A if collections . Counter ( a ) & count == count ]","title":"916. Word Subsets $\\star\\star$"},{"location":"python3/0901-1000/0911-0920/#917-reverse-only-letters-star","text":"class Solution : def reverseOnlyLetters ( self , S : str ) -> str : S = list ( S ) i = 0 j = len ( S ) - 1 while i < j : while i < j and not S [ i ] . isalpha (): i += 1 while i < j and not S [ j ] . isalpha (): j -= 1 S [ i ], S [ j ] = S [ j ], S [ i ] i += 1 j -= 1 return '' . join ( S )","title":"917. Reverse Only Letters $\\star$"},{"location":"python3/0901-1000/0911-0920/#918-maximum-sum-circular-subarray-starstar","text":"class Solution : def maxSubarraySumCircular ( self , A : List [ int ]) -> int : totalSum = 0 currMaxSum = 0 currMinSum = 0 maxSum = float ( '-inf' ) minSum = float ( 'inf' ) for a in A : totalSum += a currMaxSum = max ( currMaxSum + a , a ) currMinSum = min ( currMinSum + a , a ) maxSum = max ( maxSum , currMaxSum ) minSum = min ( minSum , currMinSum ) return maxSum if maxSum < 0 else max ( maxSum , totalSum - minSum )","title":"918. Maximum Sum Circular Subarray $\\star\\star$"},{"location":"python3/0901-1000/0911-0920/#919-complete-binary-tree-inserter-starstar","text":"","title":"919. Complete Binary Tree Inserter $\\star\\star$"},{"location":"python3/0901-1000/0911-0920/#920-number-of-music-playlists-starstarstar","text":"","title":"920. Number of Music Playlists $\\star\\star\\star$"},{"location":"python3/0901-1000/0921-0930/","text":"921. Minimum Add to Make Parentheses Valid $\\star\\star$ 922. Sort Array By Parity II $\\star$ class Solution : def sortArrayByParityII ( self , A : List [ int ]) -> List [ int ]: n = len ( A ) i = 0 j = 1 while i < n : while i < n and A [ i ] % 2 == 0 : i += 2 while j < n and A [ j ] % 2 == 1 : j += 2 if i < n : A [ i ], A [ j ] = A [ j ], A [ i ] i += 2 j += 2 return A 923. 3Sum With Multiplicity $\\star\\star$ class Solution : def threeSumMulti ( self , A : List [ int ], target : int ) -> int : kMod = int ( 1e9 + 7 ) ans = 0 count = collections . Counter ( A ) for i , x in count . items (): for j , y in count . items (): k = target - i - j if k not in count : continue if i == j and j == k : ans += x * ( x - 1 ) * ( x - 2 ) // 6 elif i == j and j != k : ans += x * ( x - 1 ) // 2 * count [ k ] elif i < j and j < k : ans += x * y * count [ k ] return ans % kMod 924. Minimize Malware Spread $\\star\\star\\star$ 925. Long Pressed Name $\\star$ class Solution : def isLongPressedName ( self , name : str , typed : str ) -> bool : i = 0 for j , t in enumerate ( typed ): if i < len ( name ) and name [ i ] == t : i += 1 elif j == 0 or t != typed [ j - 1 ]: return False return i == len ( name ) 926. Flip String to Monotone Increasing $\\star\\star$ class Solution : def minFlipsMonoIncr ( self , S : str ) -> int : dp = [ 0 ] * 2 for i , c in enumerate ( S ): dp [ 0 ], dp [ 1 ] = dp [ 0 ] + ( c == '1' ), min ( dp [ 0 ], dp [ 1 ]) + ( c == '0' ) return min ( dp [ 0 ], dp [ 1 ]) 927. Three Equal Parts $\\star\\star\\star$ class Solution : def threeEqualParts ( self , A : List [ int ]) -> List [ int ]: ones = sum ( a == 1 for a in A ) if ones == 0 : return [ 0 , len ( A ) - 1 ] if ones % 3 != 0 : return [ - 1 , - 1 ] k = ones // 3 i = 0 for i in range ( len ( A )): if A [ i ] == 1 : first = i break gapOnes = k for j in range ( i + 1 , len ( A )): if A [ j ] == 1 : gapOnes -= 1 if gapOnes == 0 : second = j break gapOnes = k for i in range ( j + 1 , len ( A )): if A [ i ] == 1 : gapOnes -= 1 if gapOnes == 0 : third = i break while third < len ( A ) and A [ first ] == A [ second ] == A [ third ]: first += 1 second += 1 third += 1 if third == len ( A ): return [ first - 1 , second ] return [ - 1 , - 1 ] 928. Minimize Malware Spread II $\\star\\star\\star$ 929. Unique Email Addresses $\\star$ class Solution : def numUniqueEmails ( self , emails : List [ str ]) -> int : seen = set () for email in emails : local , domain = email . split ( '@' ) local = local . split ( '+' )[ 0 ] . replace ( '.' , '' ) seen . add ( local + '@' + domain ) return len ( seen ) 930. Binary Subarrays With Sum $\\star\\star$ class Solution : def numSubarraysWithSum ( self , A : List [ int ], S : int ) -> int : ans = 0 prefixSum = 0 count = collections . Counter ({ 0 : 1 }) for a in A : prefixSum += a ans += count [ prefixSum - S ] count [ prefixSum ] += 1 return ans","title":"0921-0930"},{"location":"python3/0901-1000/0921-0930/#921-minimum-add-to-make-parentheses-valid-starstar","text":"","title":"921. Minimum Add to Make Parentheses Valid $\\star\\star$"},{"location":"python3/0901-1000/0921-0930/#922-sort-array-by-parity-ii-star","text":"class Solution : def sortArrayByParityII ( self , A : List [ int ]) -> List [ int ]: n = len ( A ) i = 0 j = 1 while i < n : while i < n and A [ i ] % 2 == 0 : i += 2 while j < n and A [ j ] % 2 == 1 : j += 2 if i < n : A [ i ], A [ j ] = A [ j ], A [ i ] i += 2 j += 2 return A","title":"922. Sort Array By Parity II $\\star$"},{"location":"python3/0901-1000/0921-0930/#923-3sum-with-multiplicity-starstar","text":"class Solution : def threeSumMulti ( self , A : List [ int ], target : int ) -> int : kMod = int ( 1e9 + 7 ) ans = 0 count = collections . Counter ( A ) for i , x in count . items (): for j , y in count . items (): k = target - i - j if k not in count : continue if i == j and j == k : ans += x * ( x - 1 ) * ( x - 2 ) // 6 elif i == j and j != k : ans += x * ( x - 1 ) // 2 * count [ k ] elif i < j and j < k : ans += x * y * count [ k ] return ans % kMod","title":"923. 3Sum With Multiplicity $\\star\\star$"},{"location":"python3/0901-1000/0921-0930/#924-minimize-malware-spread-starstarstar","text":"","title":"924. Minimize Malware Spread $\\star\\star\\star$"},{"location":"python3/0901-1000/0921-0930/#925-long-pressed-name-star","text":"class Solution : def isLongPressedName ( self , name : str , typed : str ) -> bool : i = 0 for j , t in enumerate ( typed ): if i < len ( name ) and name [ i ] == t : i += 1 elif j == 0 or t != typed [ j - 1 ]: return False return i == len ( name )","title":"925. Long Pressed Name $\\star$"},{"location":"python3/0901-1000/0921-0930/#926-flip-string-to-monotone-increasing-starstar","text":"class Solution : def minFlipsMonoIncr ( self , S : str ) -> int : dp = [ 0 ] * 2 for i , c in enumerate ( S ): dp [ 0 ], dp [ 1 ] = dp [ 0 ] + ( c == '1' ), min ( dp [ 0 ], dp [ 1 ]) + ( c == '0' ) return min ( dp [ 0 ], dp [ 1 ])","title":"926. Flip String to Monotone Increasing $\\star\\star$"},{"location":"python3/0901-1000/0921-0930/#927-three-equal-parts-starstarstar","text":"class Solution : def threeEqualParts ( self , A : List [ int ]) -> List [ int ]: ones = sum ( a == 1 for a in A ) if ones == 0 : return [ 0 , len ( A ) - 1 ] if ones % 3 != 0 : return [ - 1 , - 1 ] k = ones // 3 i = 0 for i in range ( len ( A )): if A [ i ] == 1 : first = i break gapOnes = k for j in range ( i + 1 , len ( A )): if A [ j ] == 1 : gapOnes -= 1 if gapOnes == 0 : second = j break gapOnes = k for i in range ( j + 1 , len ( A )): if A [ i ] == 1 : gapOnes -= 1 if gapOnes == 0 : third = i break while third < len ( A ) and A [ first ] == A [ second ] == A [ third ]: first += 1 second += 1 third += 1 if third == len ( A ): return [ first - 1 , second ] return [ - 1 , - 1 ]","title":"927. Three Equal Parts $\\star\\star\\star$"},{"location":"python3/0901-1000/0921-0930/#928-minimize-malware-spread-ii-starstarstar","text":"","title":"928. Minimize Malware Spread II $\\star\\star\\star$"},{"location":"python3/0901-1000/0921-0930/#929-unique-email-addresses-star","text":"class Solution : def numUniqueEmails ( self , emails : List [ str ]) -> int : seen = set () for email in emails : local , domain = email . split ( '@' ) local = local . split ( '+' )[ 0 ] . replace ( '.' , '' ) seen . add ( local + '@' + domain ) return len ( seen )","title":"929. Unique Email Addresses $\\star$"},{"location":"python3/0901-1000/0921-0930/#930-binary-subarrays-with-sum-starstar","text":"class Solution : def numSubarraysWithSum ( self , A : List [ int ], S : int ) -> int : ans = 0 prefixSum = 0 count = collections . Counter ({ 0 : 1 }) for a in A : prefixSum += a ans += count [ prefixSum - S ] count [ prefixSum ] += 1 return ans","title":"930. Binary Subarrays With Sum $\\star\\star$"},{"location":"python3/0901-1000/0931-0940/","text":"931. Minimum Falling Path Sum $\\star\\star$ class Solution : def minFallingPathSum ( self , A : List [ List [ int ]]) -> int : n = len ( A ) for i in range ( 1 , n ): for j in range ( n ): mini = float ( 'inf' ) for k in range ( max ( 0 , j - 1 ), min ( n , j + 2 )): mini = min ( mini , A [ i - 1 ][ k ]) A [ i ][ j ] += mini return min ( A [ - 1 ]) 932. Beautiful Array $\\star\\star$ 933. Number of Recent Calls $\\star$ 934. Shortest Bridge $\\star\\star$ 935. Knight Dialer $\\star\\star$ 936. Stamping The Sequence $\\star\\star\\star$ class Solution : def movesToStamp ( self , stamp : str , target : str ) -> List [ int ]: def stampify ( s : int ) -> int : stampified = len ( stamp ) for i , st in enumerate ( stamp ): if target [ s + i ] == '*' : stampified -= 1 elif target [ s + i ] != st : return 0 for i in range ( s , s + len ( stamp )): target [ i ] = '*' return stampified ans = [] target = list ( target ) stamped = [ False ] * len ( target ) stampedCount = 0 while stampedCount < len ( target ): isStamped = False for i in range ( len ( target ) - len ( stamp ) + 1 ): if stamped [ i ]: continue stampified = stampify ( i ) if stampified == 0 : continue stampedCount += stampified isStamped = True stamped [ i ] = True ans . append ( i ) if not isStamped : return [] return ans [:: - 1 ] 937. Reorder Data in Log Files $\\star$ class Solution : def reorderLogFiles ( self , logs : List [ str ]) -> List [ str ]: digitLogs = [] letterLogs = [] for log in logs : i = log . index ( ' ' ) if log [ i + 1 ] . isdigit (): digitLogs . append ( log ) else : letterLogs . append (( log [: i ], log [ i + 1 :])) letterLogs . sort ( key = lambda l : ( l [ 1 ], l [ 0 ])) return [ identifier + ' ' + letters for identifier , letters in letterLogs ] + digitLogs 938. Range Sum of BST $\\star$ 939. Minimum Area Rectangle $\\star\\star$ class Solution : def minAreaRect ( self , points : List [ List [ int ]]) -> int : ans = float ( 'inf' ) xToYs = collections . defaultdict ( set ) for x , y in points : xToYs [ x ] . add ( y ) for i in range ( len ( points )): for j in range ( i ): x1 , y1 = points [ i ] x2 , y2 = points [ j ] if x1 == x2 or y1 == y2 : continue if y2 in xToYs [ x1 ] and y1 in xToYs [ x2 ]: ans = min ( ans , abs ( x1 - x2 ) * abs ( y1 - y2 )) return ans if ans < float ( 'inf' ) else 0 940. Distinct Subsequences II $\\star\\star\\star$ class Solution : def distinctSubseqII ( self , S : str ) -> int : kMod = int ( 1e9 + 7 ) dict = [ 0 ] * 26 for c in S : dict [ ord ( c ) - ord ( 'a' )] = ( sum ( dict ) + 1 ) % kMod return sum ( dict ) % kMod","title":"0931-0940"},{"location":"python3/0901-1000/0931-0940/#931-minimum-falling-path-sum-starstar","text":"class Solution : def minFallingPathSum ( self , A : List [ List [ int ]]) -> int : n = len ( A ) for i in range ( 1 , n ): for j in range ( n ): mini = float ( 'inf' ) for k in range ( max ( 0 , j - 1 ), min ( n , j + 2 )): mini = min ( mini , A [ i - 1 ][ k ]) A [ i ][ j ] += mini return min ( A [ - 1 ])","title":"931. Minimum Falling Path Sum $\\star\\star$"},{"location":"python3/0901-1000/0931-0940/#932-beautiful-array-starstar","text":"","title":"932. Beautiful Array $\\star\\star$"},{"location":"python3/0901-1000/0931-0940/#933-number-of-recent-calls-star","text":"","title":"933. Number of Recent Calls $\\star$"},{"location":"python3/0901-1000/0931-0940/#934-shortest-bridge-starstar","text":"","title":"934. Shortest Bridge $\\star\\star$"},{"location":"python3/0901-1000/0931-0940/#935-knight-dialer-starstar","text":"","title":"935. Knight Dialer $\\star\\star$"},{"location":"python3/0901-1000/0931-0940/#936-stamping-the-sequence-starstarstar","text":"class Solution : def movesToStamp ( self , stamp : str , target : str ) -> List [ int ]: def stampify ( s : int ) -> int : stampified = len ( stamp ) for i , st in enumerate ( stamp ): if target [ s + i ] == '*' : stampified -= 1 elif target [ s + i ] != st : return 0 for i in range ( s , s + len ( stamp )): target [ i ] = '*' return stampified ans = [] target = list ( target ) stamped = [ False ] * len ( target ) stampedCount = 0 while stampedCount < len ( target ): isStamped = False for i in range ( len ( target ) - len ( stamp ) + 1 ): if stamped [ i ]: continue stampified = stampify ( i ) if stampified == 0 : continue stampedCount += stampified isStamped = True stamped [ i ] = True ans . append ( i ) if not isStamped : return [] return ans [:: - 1 ]","title":"936. Stamping The Sequence $\\star\\star\\star$"},{"location":"python3/0901-1000/0931-0940/#937-reorder-data-in-log-files-star","text":"class Solution : def reorderLogFiles ( self , logs : List [ str ]) -> List [ str ]: digitLogs = [] letterLogs = [] for log in logs : i = log . index ( ' ' ) if log [ i + 1 ] . isdigit (): digitLogs . append ( log ) else : letterLogs . append (( log [: i ], log [ i + 1 :])) letterLogs . sort ( key = lambda l : ( l [ 1 ], l [ 0 ])) return [ identifier + ' ' + letters for identifier , letters in letterLogs ] + digitLogs","title":"937. Reorder Data in Log Files $\\star$"},{"location":"python3/0901-1000/0931-0940/#938-range-sum-of-bst-star","text":"","title":"938. Range Sum of BST $\\star$"},{"location":"python3/0901-1000/0931-0940/#939-minimum-area-rectangle-starstar","text":"class Solution : def minAreaRect ( self , points : List [ List [ int ]]) -> int : ans = float ( 'inf' ) xToYs = collections . defaultdict ( set ) for x , y in points : xToYs [ x ] . add ( y ) for i in range ( len ( points )): for j in range ( i ): x1 , y1 = points [ i ] x2 , y2 = points [ j ] if x1 == x2 or y1 == y2 : continue if y2 in xToYs [ x1 ] and y1 in xToYs [ x2 ]: ans = min ( ans , abs ( x1 - x2 ) * abs ( y1 - y2 )) return ans if ans < float ( 'inf' ) else 0","title":"939. Minimum Area Rectangle $\\star\\star$"},{"location":"python3/0901-1000/0931-0940/#940-distinct-subsequences-ii-starstarstar","text":"class Solution : def distinctSubseqII ( self , S : str ) -> int : kMod = int ( 1e9 + 7 ) dict = [ 0 ] * 26 for c in S : dict [ ord ( c ) - ord ( 'a' )] = ( sum ( dict ) + 1 ) % kMod return sum ( dict ) % kMod","title":"940. Distinct Subsequences II $\\star\\star\\star$"},{"location":"python3/0901-1000/0941-0950/","text":"941. Valid Mountain Array $\\star$ class Solution : def validMountainArray ( self , A : List [ int ]) -> bool : if len ( A ) < 3 : return False l = 0 r = len ( A ) - 1 while l + 1 < len ( A ) and A [ l ] < A [ l + 1 ]: l += 1 while r > 0 and A [ r ] < A [ r - 1 ]: r -= 1 return l > 0 and r < len ( A ) - 1 and l == r 942. DI String Match $\\star$ class Solution : def diStringMatch ( self , S : str ) -> List [ int ]: ans = [] mini = 0 maxi = len ( S ) for c in S : if c == 'I' : ans . append ( mini ) mini += 1 else : ans . append ( maxi ) maxi -= 1 ans . append ( mini ) return ans 943. Find the Shortest Superstring $\\star\\star\\star$ 944. Delete Columns to Make Sorted $\\star$ 945. Minimum Increment to Make Array Unique $\\star\\star$ class Solution : def minIncrementForUnique ( self , A : List [ int ]) -> int : ans = 0 minAvailable = 0 A . sort () for a in A : ans += max ( minAvailable - a , 0 ) minAvailable = max ( minAvailable , a ) + 1 return ans 946. Validate Stack Sequences $\\star\\star$ 947. Most Stones Removed with Same Row or Column $\\star\\star$ 948. Bag of Tokens $\\star\\star$ 949. Largest Time for Given Digits $\\star$ class Solution : def largestTimeFromDigits ( self , A : List [ int ]) -> str : for time in itertools . permutations ( sorted ( A , reverse = True )): if time [: 2 ] < ( 2 , 4 ) and time [ 2 ] < 6 : return ' %d%d : %d%d ' % time return '' 950. Reveal Cards In Increasing Order $\\star\\star$ class Solution : def deckRevealedIncreasing ( self , deck : List [ int ]) -> List [ int ]: deque = collections . deque () for card in sorted ( deck )[:: - 1 ]: deque . rotate () deque . appendleft ( card ) return list ( deque )","title":"0941-0950"},{"location":"python3/0901-1000/0941-0950/#941-valid-mountain-array-star","text":"class Solution : def validMountainArray ( self , A : List [ int ]) -> bool : if len ( A ) < 3 : return False l = 0 r = len ( A ) - 1 while l + 1 < len ( A ) and A [ l ] < A [ l + 1 ]: l += 1 while r > 0 and A [ r ] < A [ r - 1 ]: r -= 1 return l > 0 and r < len ( A ) - 1 and l == r","title":"941. Valid Mountain Array $\\star$"},{"location":"python3/0901-1000/0941-0950/#942-di-string-match-star","text":"class Solution : def diStringMatch ( self , S : str ) -> List [ int ]: ans = [] mini = 0 maxi = len ( S ) for c in S : if c == 'I' : ans . append ( mini ) mini += 1 else : ans . append ( maxi ) maxi -= 1 ans . append ( mini ) return ans","title":"942. DI String Match $\\star$"},{"location":"python3/0901-1000/0941-0950/#943-find-the-shortest-superstring-starstarstar","text":"","title":"943. Find the Shortest Superstring $\\star\\star\\star$"},{"location":"python3/0901-1000/0941-0950/#944-delete-columns-to-make-sorted-star","text":"","title":"944. Delete Columns to Make Sorted $\\star$"},{"location":"python3/0901-1000/0941-0950/#945-minimum-increment-to-make-array-unique-starstar","text":"class Solution : def minIncrementForUnique ( self , A : List [ int ]) -> int : ans = 0 minAvailable = 0 A . sort () for a in A : ans += max ( minAvailable - a , 0 ) minAvailable = max ( minAvailable , a ) + 1 return ans","title":"945. Minimum Increment to Make Array Unique $\\star\\star$"},{"location":"python3/0901-1000/0941-0950/#946-validate-stack-sequences-starstar","text":"","title":"946. Validate Stack Sequences $\\star\\star$"},{"location":"python3/0901-1000/0941-0950/#947-most-stones-removed-with-same-row-or-column-starstar","text":"","title":"947. Most Stones Removed with Same Row or Column $\\star\\star$"},{"location":"python3/0901-1000/0941-0950/#948-bag-of-tokens-starstar","text":"","title":"948. Bag of Tokens $\\star\\star$"},{"location":"python3/0901-1000/0941-0950/#949-largest-time-for-given-digits-star","text":"class Solution : def largestTimeFromDigits ( self , A : List [ int ]) -> str : for time in itertools . permutations ( sorted ( A , reverse = True )): if time [: 2 ] < ( 2 , 4 ) and time [ 2 ] < 6 : return ' %d%d : %d%d ' % time return ''","title":"949. Largest Time for Given Digits $\\star$"},{"location":"python3/0901-1000/0941-0950/#950-reveal-cards-in-increasing-order-starstar","text":"class Solution : def deckRevealedIncreasing ( self , deck : List [ int ]) -> List [ int ]: deque = collections . deque () for card in sorted ( deck )[:: - 1 ]: deque . rotate () deque . appendleft ( card ) return list ( deque )","title":"950. Reveal Cards In Increasing Order $\\star\\star$"},{"location":"python3/0901-1000/0951-0960/","text":"951. Flip Equivalent Binary Trees $\\star\\star$ 952. Largest Component Size by Common Factor $\\star\\star\\star$ class Solution : def largestComponentSize ( self , A : List [ int ]) -> int : n = max ( A ) ans = 0 uf = UF ( n ) count = collections . Counter () for a in A : for num in range ( 2 , int ( sqrt ( a ) + 1 )): if a % num == 0 : uf . union ( a , num ) uf . union ( a , a // num ) for a in A : pa = uf . find ( a ) count [ pa ] += 1 ans = max ( ans , count [ pa ]) return ans class UF : def __init__ ( self , n : int ): self . rank = [ 0 ] * ( n + 1 ) self . parent = [ i for i in range ( n + 1 )] def union ( self , u : int , v : int ) -> None : pu = self . parent [ u ] pv = self . parent [ v ] if pu == pv : return if self . rank [ pu ] < self . rank [ pv ]: self . parent [ pu ] = pv elif self . rank [ pv ] < self . rank [ pu ]: self . parent [ pv ] = pu else : self . parent [ pu ] = pv self . rank [ pv ] += 1 def find ( self , u : int ) -> int : while u != self . parent [ u ]: self . parent [ u ] = self . parent [ self . parent [ u ]] u = self . parent [ u ] return u 953. Verifying an Alien Dictionary $\\star$ class Solution : def isAlienSorted ( self , words : List [ str ], order : str ) -> bool : dict = { c : i for i , c in enumerate ( order )} words = [[ dict [ c ] for c in word ] for word in words ] return all ( w1 <= w2 for w1 , w2 in zip ( words , words [ 1 :])) 954. Array of Doubled Pairs $\\star\\star$ class Solution : def canReorderDoubled ( self , A : List [ int ]) -> bool : count = collections . Counter ( A ) for key in sorted ( count , key = abs ): if count [ key ] > count [ 2 * key ]: return False count [ 2 * key ] -= count [ key ] return True 955. Delete Columns to Make Sorted II $\\star\\star$ 956. Tallest Billboard $\\star\\star\\star$ 957. Prison Cells After N Days $\\star\\star$ class Solution : def prisonAfterNDays ( self , cells : List [ int ], N : int ) -> List [ int ]: nextDayCells = [ 0 ] * len ( cells ) day = 0 while N > 0 : N -= 1 for i in range ( 1 , len ( cells ) - 1 ): nextDayCells [ i ] = 1 if cells [ i - 1 ] == cells [ i + 1 ] else 0 if day == 0 : firstDayCells = nextDayCells . copy () elif nextDayCells == firstDayCells : N %= day cells = nextDayCells . copy () day += 1 return cells 958. Check Completeness of a Binary Tree $\\star\\star$ 959. Regions Cut By Slashes $\\star\\star$ 960. Delete Columns to Make Sorted III $\\star\\star\\star$","title":"0951-0960"},{"location":"python3/0901-1000/0951-0960/#951-flip-equivalent-binary-trees-starstar","text":"","title":"951. Flip Equivalent Binary Trees $\\star\\star$"},{"location":"python3/0901-1000/0951-0960/#952-largest-component-size-by-common-factor-starstarstar","text":"class Solution : def largestComponentSize ( self , A : List [ int ]) -> int : n = max ( A ) ans = 0 uf = UF ( n ) count = collections . Counter () for a in A : for num in range ( 2 , int ( sqrt ( a ) + 1 )): if a % num == 0 : uf . union ( a , num ) uf . union ( a , a // num ) for a in A : pa = uf . find ( a ) count [ pa ] += 1 ans = max ( ans , count [ pa ]) return ans class UF : def __init__ ( self , n : int ): self . rank = [ 0 ] * ( n + 1 ) self . parent = [ i for i in range ( n + 1 )] def union ( self , u : int , v : int ) -> None : pu = self . parent [ u ] pv = self . parent [ v ] if pu == pv : return if self . rank [ pu ] < self . rank [ pv ]: self . parent [ pu ] = pv elif self . rank [ pv ] < self . rank [ pu ]: self . parent [ pv ] = pu else : self . parent [ pu ] = pv self . rank [ pv ] += 1 def find ( self , u : int ) -> int : while u != self . parent [ u ]: self . parent [ u ] = self . parent [ self . parent [ u ]] u = self . parent [ u ] return u","title":"952. Largest Component Size by Common Factor $\\star\\star\\star$"},{"location":"python3/0901-1000/0951-0960/#953-verifying-an-alien-dictionary-star","text":"class Solution : def isAlienSorted ( self , words : List [ str ], order : str ) -> bool : dict = { c : i for i , c in enumerate ( order )} words = [[ dict [ c ] for c in word ] for word in words ] return all ( w1 <= w2 for w1 , w2 in zip ( words , words [ 1 :]))","title":"953. Verifying an Alien Dictionary $\\star$"},{"location":"python3/0901-1000/0951-0960/#954-array-of-doubled-pairs-starstar","text":"class Solution : def canReorderDoubled ( self , A : List [ int ]) -> bool : count = collections . Counter ( A ) for key in sorted ( count , key = abs ): if count [ key ] > count [ 2 * key ]: return False count [ 2 * key ] -= count [ key ] return True","title":"954. Array of Doubled Pairs $\\star\\star$"},{"location":"python3/0901-1000/0951-0960/#955-delete-columns-to-make-sorted-ii-starstar","text":"","title":"955. Delete Columns to Make Sorted II $\\star\\star$"},{"location":"python3/0901-1000/0951-0960/#956-tallest-billboard-starstarstar","text":"","title":"956. Tallest Billboard $\\star\\star\\star$"},{"location":"python3/0901-1000/0951-0960/#957-prison-cells-after-n-days-starstar","text":"class Solution : def prisonAfterNDays ( self , cells : List [ int ], N : int ) -> List [ int ]: nextDayCells = [ 0 ] * len ( cells ) day = 0 while N > 0 : N -= 1 for i in range ( 1 , len ( cells ) - 1 ): nextDayCells [ i ] = 1 if cells [ i - 1 ] == cells [ i + 1 ] else 0 if day == 0 : firstDayCells = nextDayCells . copy () elif nextDayCells == firstDayCells : N %= day cells = nextDayCells . copy () day += 1 return cells","title":"957. Prison Cells After N Days $\\star\\star$"},{"location":"python3/0901-1000/0951-0960/#958-check-completeness-of-a-binary-tree-starstar","text":"","title":"958. Check Completeness of a Binary Tree $\\star\\star$"},{"location":"python3/0901-1000/0951-0960/#959-regions-cut-by-slashes-starstar","text":"","title":"959. Regions Cut By Slashes $\\star\\star$"},{"location":"python3/0901-1000/0951-0960/#960-delete-columns-to-make-sorted-iii-starstarstar","text":"","title":"960. Delete Columns to Make Sorted III $\\star\\star\\star$"},{"location":"python3/0901-1000/0961-0970/","text":"961. N-Repeated Element in Size 2N Array $\\star$ class Solution : def repeatedNTimes ( self , A : List [ int ]) -> int : for i in range ( len ( A ) - 2 ): if A [ i ] == A [ i + 1 ] or A [ i ] == A [ i + 2 ]: return A [ i ] return A [ - 1 ] 962. Maximum Width Ramp $\\star\\star$ class Solution : def maxWidthRamp ( self , A : List [ int ]) -> int : ans = 0 stack = [] for i , a in enumerate ( A ): if stack == [] or a <= A [ stack [ - 1 ]]: stack . append ( i ) for i in range ( len ( A ))[:: - 1 ]: while stack and A [ i ] >= A [ stack [ - 1 ]]: ans = max ( ans , i - stack . pop ()) return ans 963. Minimum Area Rectangle II $\\star\\star$ class Solution : def minAreaFreeRect ( self , points : List [ List [ int ]]) -> float : def dist ( px : int , py : int , qx : int , qy : int ) -> float : return ( px - qx ) ** 2 + ( py - qy ) ** 2 ans = float ( 'inf' ) centerToPoints = collections . defaultdict ( list ) for ax , ay in points : for bx , by in points : center = (( ax + bx ) / 2 , ( ay + by ) / 2 ) centerToPoints [ center ] . append (( ax , ay , bx , by )) for points in centerToPoints . values (): for ax , ay , _ , _ in points : for cx , cy , dx , dy in points : if ( cx - ax ) * ( dx - ax ) + ( cy - ay ) * ( dy - ay ) == 0 : squaredArea = dist ( ax , ay , cx , cy ) * \\ dist ( ax , ay , dx , dy ) if squaredArea > 0 : ans = min ( ans , squaredArea ) return 0 if ans == float ( 'inf' ) else sqrt ( ans ) 964. Least Operators to Express Number $\\star\\star\\star$ class Solution : def leastOpsExpressTarget ( self , x : int , target : int ) -> int : def dfs ( x : int , target : int ) -> int : if target in memo : return memo [ target ] if x > target : return min ( 2 * target - 1 , 2 * ( x - target )) if x == target : return 0 prod = x n = 0 while prod < target : prod *= x n += 1 if prod == target : memo [ target ] = n return memo [ target ] memo [ target ] = float ( 'inf' ) if prod < 2 * target : memo [ target ] = dfs ( x , prod - target ) + n + 1 memo [ target ] = min ( memo [ target ], dfs ( x , target - prod // x ) + n ) return memo [ target ] memo = {} return dfs ( x , target ) 965. Univalued Binary Tree $\\star$ 966. Vowel Spellchecker $\\star\\star$ class Solution : def spellchecker ( self , wordlist : List [ str ], queries : List [ str ]) -> List [ str ]: def lowerKey ( word : str ) -> str : return '$' + '' . join ([ c . lower () for c in word ]) def vowelKey ( word : str ) -> str : return '' . join ([ '*' if c . lower () in 'aeiou' else c . lower () for c in word ]) ans = [] dict = {} for word in wordlist : dict . setdefault ( word , word ) dict . setdefault ( lowerKey ( word ), word ) dict . setdefault ( vowelKey ( word ), word ) for query in queries : if query in dict : ans . append ( dict [ query ]) elif lowerKey ( query ) in dict : ans . append ( dict [ lowerKey ( query )]) elif vowelKey ( query ) in dict : ans . append ( dict [ vowelKey ( query )]) else : ans . append ( '' ) return ans 967. Numbers With Same Consecutive Differences $\\star\\star$ 968. Binary Tree Cameras $\\star\\star\\star$ 969. Pancake Sorting $\\star\\star$ class Solution : def pancakeSort ( self , A : List [ int ]) -> List [ int ]: ans = [] for target in range ( len ( A ), 0 , - 1 ): index = A . index ( target ) A [: index + 1 ] = A [: index + 1 ][:: - 1 ] A [: target ] = A [: target ][:: - 1 ] ans . append ( index + 1 ) ans . append ( target ) return ans 970. Powerful Integers $\\star$ class Solution : def powerfulIntegers ( self , x : int , y : int , bound : int ) -> List [ int ]: xs = { x ** i for i in range ( 20 ) if x ** i < bound } ys = { y ** i for i in range ( 20 ) if y ** i < bound } return list ({ i + j for i in xs for j in ys if i + j <= bound })","title":"0961-0970"},{"location":"python3/0901-1000/0961-0970/#961-n-repeated-element-in-size-2n-array-star","text":"class Solution : def repeatedNTimes ( self , A : List [ int ]) -> int : for i in range ( len ( A ) - 2 ): if A [ i ] == A [ i + 1 ] or A [ i ] == A [ i + 2 ]: return A [ i ] return A [ - 1 ]","title":"961. N-Repeated Element in Size 2N Array $\\star$"},{"location":"python3/0901-1000/0961-0970/#962-maximum-width-ramp-starstar","text":"class Solution : def maxWidthRamp ( self , A : List [ int ]) -> int : ans = 0 stack = [] for i , a in enumerate ( A ): if stack == [] or a <= A [ stack [ - 1 ]]: stack . append ( i ) for i in range ( len ( A ))[:: - 1 ]: while stack and A [ i ] >= A [ stack [ - 1 ]]: ans = max ( ans , i - stack . pop ()) return ans","title":"962. Maximum Width Ramp $\\star\\star$"},{"location":"python3/0901-1000/0961-0970/#963-minimum-area-rectangle-ii-starstar","text":"class Solution : def minAreaFreeRect ( self , points : List [ List [ int ]]) -> float : def dist ( px : int , py : int , qx : int , qy : int ) -> float : return ( px - qx ) ** 2 + ( py - qy ) ** 2 ans = float ( 'inf' ) centerToPoints = collections . defaultdict ( list ) for ax , ay in points : for bx , by in points : center = (( ax + bx ) / 2 , ( ay + by ) / 2 ) centerToPoints [ center ] . append (( ax , ay , bx , by )) for points in centerToPoints . values (): for ax , ay , _ , _ in points : for cx , cy , dx , dy in points : if ( cx - ax ) * ( dx - ax ) + ( cy - ay ) * ( dy - ay ) == 0 : squaredArea = dist ( ax , ay , cx , cy ) * \\ dist ( ax , ay , dx , dy ) if squaredArea > 0 : ans = min ( ans , squaredArea ) return 0 if ans == float ( 'inf' ) else sqrt ( ans )","title":"963. Minimum Area Rectangle II $\\star\\star$"},{"location":"python3/0901-1000/0961-0970/#964-least-operators-to-express-number-starstarstar","text":"class Solution : def leastOpsExpressTarget ( self , x : int , target : int ) -> int : def dfs ( x : int , target : int ) -> int : if target in memo : return memo [ target ] if x > target : return min ( 2 * target - 1 , 2 * ( x - target )) if x == target : return 0 prod = x n = 0 while prod < target : prod *= x n += 1 if prod == target : memo [ target ] = n return memo [ target ] memo [ target ] = float ( 'inf' ) if prod < 2 * target : memo [ target ] = dfs ( x , prod - target ) + n + 1 memo [ target ] = min ( memo [ target ], dfs ( x , target - prod // x ) + n ) return memo [ target ] memo = {} return dfs ( x , target )","title":"964. Least Operators to Express Number $\\star\\star\\star$"},{"location":"python3/0901-1000/0961-0970/#965-univalued-binary-tree-star","text":"","title":"965. Univalued Binary Tree $\\star$"},{"location":"python3/0901-1000/0961-0970/#966-vowel-spellchecker-starstar","text":"class Solution : def spellchecker ( self , wordlist : List [ str ], queries : List [ str ]) -> List [ str ]: def lowerKey ( word : str ) -> str : return '$' + '' . join ([ c . lower () for c in word ]) def vowelKey ( word : str ) -> str : return '' . join ([ '*' if c . lower () in 'aeiou' else c . lower () for c in word ]) ans = [] dict = {} for word in wordlist : dict . setdefault ( word , word ) dict . setdefault ( lowerKey ( word ), word ) dict . setdefault ( vowelKey ( word ), word ) for query in queries : if query in dict : ans . append ( dict [ query ]) elif lowerKey ( query ) in dict : ans . append ( dict [ lowerKey ( query )]) elif vowelKey ( query ) in dict : ans . append ( dict [ vowelKey ( query )]) else : ans . append ( '' ) return ans","title":"966. Vowel Spellchecker $\\star\\star$"},{"location":"python3/0901-1000/0961-0970/#967-numbers-with-same-consecutive-differences-starstar","text":"","title":"967. Numbers With Same Consecutive Differences $\\star\\star$"},{"location":"python3/0901-1000/0961-0970/#968-binary-tree-cameras-starstarstar","text":"","title":"968. Binary Tree Cameras $\\star\\star\\star$"},{"location":"python3/0901-1000/0961-0970/#969-pancake-sorting-starstar","text":"class Solution : def pancakeSort ( self , A : List [ int ]) -> List [ int ]: ans = [] for target in range ( len ( A ), 0 , - 1 ): index = A . index ( target ) A [: index + 1 ] = A [: index + 1 ][:: - 1 ] A [: target ] = A [: target ][:: - 1 ] ans . append ( index + 1 ) ans . append ( target ) return ans","title":"969. Pancake Sorting $\\star\\star$"},{"location":"python3/0901-1000/0961-0970/#970-powerful-integers-star","text":"class Solution : def powerfulIntegers ( self , x : int , y : int , bound : int ) -> List [ int ]: xs = { x ** i for i in range ( 20 ) if x ** i < bound } ys = { y ** i for i in range ( 20 ) if y ** i < bound } return list ({ i + j for i in xs for j in ys if i + j <= bound })","title":"970. Powerful Integers $\\star$"},{"location":"python3/0901-1000/0971-0980/","text":"971. Flip Binary Tree To Match Preorder Traversal $\\star\\star$ 972. Equal Rational Numbers $\\star\\star\\star$ class Solution : def isRationalEqual ( self , S : str , T : str ) -> bool : def valueOf ( s : str ) -> float : if s . find ( '(' ) == - 1 : return float ( s ) integer_nonRepeating = float ( s [: s . find ( '(' )]) nonRepeatingLength = s . find ( '(' ) - s . find ( '.' ) - 1 repeating = float ( s [ s . find ( '(' ) + 1 : s . find ( ')' )]) repeatingLength = s . find ( ')' ) - s . find ( '(' ) - 1 return integer_nonRepeating + repeating * 0.1 ** nonRepeatingLength * ratios [ repeatingLength ] ratios = [ 1 , 1 / 9 , 1 / 99 , 1 / 999 , 1 / 9999 ] return abs ( valueOf ( S ) - valueOf ( T )) < 1e-9 973. K Closest Points to Origin $\\star\\star$ 974. Subarray Sums Divisible by K $\\star\\star$ class Solution : def subarraysDivByK ( self , A : List [ int ], K : int ) -> int : ans = 0 prefixSum = 0 count = [ 1 ] + [ 0 ] * ( K - 1 ) for a in A : prefixSum = ( prefixSum + a ) % K ans += count [ prefixSum ] count [ prefixSum ] += 1 return ans 975. Odd Even Jump $\\star\\star\\star$ 976. Largest Perimeter Triangle $\\star$ class Solution : def largestPerimeter ( self , A : List [ int ]) -> int : A = sorted ( A ) for i in range ( len ( A ) - 1 , 1 , - 1 ): if A [ i - 2 ] + A [ i - 1 ] > A [ i ]: return A [ i - 2 ] + A [ i - 1 ] + A [ i ] return 0 977. Squares of a Sorted Array $\\star$ class Solution : def sortedSquares ( self , A : List [ int ]) -> List [ int ]: n = len ( A ) l = 0 r = n - 1 ans = [ 0 ] * n while n : n -= 1 if abs ( A [ l ]) > abs ( A [ r ]): ans [ n ] = A [ l ] * A [ l ] l += 1 else : ans [ n ] = A [ r ] * A [ r ] r -= 1 return ans 978. Longest Turbulent Subarray $\\star\\star$ Time: $O(n)$ Space: $O(1)$ class Solution : def maxTurbulenceSize ( self , A : List [ int ]) -> int : ans = 1 increasing = 1 decreasing = 1 for i in range ( 1 , len ( A )): if A [ i ] > A [ i - 1 ]: increasing = decreasing + 1 decreasing = 1 elif A [ i ] < A [ i - 1 ]: decreasing = increasing + 1 increasing = 1 else : increasing = 1 decreasing = 1 ans = max ( ans , max ( increasing , decreasing )) return ans 979. Distribute Coins in Binary Tree $\\star\\star$ 980. Unique Paths III $\\star\\star\\star$","title":"0971-0980"},{"location":"python3/0901-1000/0971-0980/#971-flip-binary-tree-to-match-preorder-traversal-starstar","text":"","title":"971. Flip Binary Tree To Match Preorder Traversal $\\star\\star$"},{"location":"python3/0901-1000/0971-0980/#972-equal-rational-numbers-starstarstar","text":"class Solution : def isRationalEqual ( self , S : str , T : str ) -> bool : def valueOf ( s : str ) -> float : if s . find ( '(' ) == - 1 : return float ( s ) integer_nonRepeating = float ( s [: s . find ( '(' )]) nonRepeatingLength = s . find ( '(' ) - s . find ( '.' ) - 1 repeating = float ( s [ s . find ( '(' ) + 1 : s . find ( ')' )]) repeatingLength = s . find ( ')' ) - s . find ( '(' ) - 1 return integer_nonRepeating + repeating * 0.1 ** nonRepeatingLength * ratios [ repeatingLength ] ratios = [ 1 , 1 / 9 , 1 / 99 , 1 / 999 , 1 / 9999 ] return abs ( valueOf ( S ) - valueOf ( T )) < 1e-9","title":"972. Equal Rational Numbers $\\star\\star\\star$"},{"location":"python3/0901-1000/0971-0980/#973-k-closest-points-to-origin-starstar","text":"","title":"973. K Closest Points to Origin $\\star\\star$"},{"location":"python3/0901-1000/0971-0980/#974-subarray-sums-divisible-by-k-starstar","text":"class Solution : def subarraysDivByK ( self , A : List [ int ], K : int ) -> int : ans = 0 prefixSum = 0 count = [ 1 ] + [ 0 ] * ( K - 1 ) for a in A : prefixSum = ( prefixSum + a ) % K ans += count [ prefixSum ] count [ prefixSum ] += 1 return ans","title":"974. Subarray Sums Divisible by K $\\star\\star$"},{"location":"python3/0901-1000/0971-0980/#975-odd-even-jump-starstarstar","text":"","title":"975. Odd Even Jump $\\star\\star\\star$"},{"location":"python3/0901-1000/0971-0980/#976-largest-perimeter-triangle-star","text":"class Solution : def largestPerimeter ( self , A : List [ int ]) -> int : A = sorted ( A ) for i in range ( len ( A ) - 1 , 1 , - 1 ): if A [ i - 2 ] + A [ i - 1 ] > A [ i ]: return A [ i - 2 ] + A [ i - 1 ] + A [ i ] return 0","title":"976. Largest Perimeter Triangle $\\star$"},{"location":"python3/0901-1000/0971-0980/#977-squares-of-a-sorted-array-star","text":"class Solution : def sortedSquares ( self , A : List [ int ]) -> List [ int ]: n = len ( A ) l = 0 r = n - 1 ans = [ 0 ] * n while n : n -= 1 if abs ( A [ l ]) > abs ( A [ r ]): ans [ n ] = A [ l ] * A [ l ] l += 1 else : ans [ n ] = A [ r ] * A [ r ] r -= 1 return ans","title":"977. Squares of a Sorted Array $\\star$"},{"location":"python3/0901-1000/0971-0980/#978-longest-turbulent-subarray-starstar","text":"Time: $O(n)$ Space: $O(1)$ class Solution : def maxTurbulenceSize ( self , A : List [ int ]) -> int : ans = 1 increasing = 1 decreasing = 1 for i in range ( 1 , len ( A )): if A [ i ] > A [ i - 1 ]: increasing = decreasing + 1 decreasing = 1 elif A [ i ] < A [ i - 1 ]: decreasing = increasing + 1 increasing = 1 else : increasing = 1 decreasing = 1 ans = max ( ans , max ( increasing , decreasing )) return ans","title":"978. Longest Turbulent Subarray $\\star\\star$"},{"location":"python3/0901-1000/0971-0980/#979-distribute-coins-in-binary-tree-starstar","text":"","title":"979. Distribute Coins in Binary Tree $\\star\\star$"},{"location":"python3/0901-1000/0971-0980/#980-unique-paths-iii-starstarstar","text":"","title":"980. Unique Paths III $\\star\\star\\star$"},{"location":"python3/0901-1000/0981-0990/","text":"981. Time Based Key-Value Store $\\star\\star$ class TimeMap : def __init__ ( self ): self . timestamps = collections . defaultdict ( list ) self . values = collections . defaultdict ( list ) def set ( self , key : str , value : str , timestamp : int ) -> None : self . timestamps [ key ] . append ( timestamp ) self . values [ key ] . append ( value ) def get ( self , key : str , timestamp : int ) -> str : i = bisect . bisect ( self . timestamps [ key ], timestamp ) return self . values [ key ][ i - 1 ] if i > 0 else '' 982. Triples with Bitwise AND Equal To Zero $\\star\\star\\star$ 983. Minimum Cost For Tickets $\\star\\star$ class Solution : def mincostTickets ( self , days : List [ int ], costs : List [ int ]) -> int : ans = 0 last7 = collections . deque () last30 = collections . deque () for day in days : while last7 and last7 [ 0 ][ 0 ] + 7 <= day : last7 . popleft () while last30 and last30 [ 0 ][ 0 ] + 30 <= day : last30 . popleft () last7 . append ([ day , ans + costs [ 1 ]]) last30 . append ([ day , ans + costs [ 2 ]]) ans = min ( ans + costs [ 0 ], last7 [ 0 ][ 1 ], last30 [ 0 ][ 1 ]) return ans 984. String Without AAA or BBB $\\star\\star$ 985. Sum of Even Numbers After Queries $\\star$ class Solution : def sumEvenAfterQueries ( self , A : List [ int ], queries : List [ List [ int ]]) -> List [ int ]: ans = [] summ = sum ( a for a in A if a % 2 == 0 ) for query in queries : if A [ query [ 1 ]] % 2 == 0 : summ -= A [ query [ 1 ]] A [ query [ 1 ]] += query [ 0 ] if A [ query [ 1 ]] % 2 == 0 : summ += A [ query [ 1 ]] ans . append ( summ ) return ans 986. Interval List Intersections $\\star\\star$ 987. Vertical Order Traversal of a Binary Tree $\\star\\star$ class Solution : def verticalTraversal ( self , root : TreeNode ) -> List [ List [ int ]]: def dfs ( node : TreeNode , x : int , y : int ) -> None : if not node : return xToNodes [ x ] . append (( - y , node . val )) dfs ( node . left , x - 1 , y - 1 ) dfs ( node . right , x + 1 , y - 1 ) ans = [] xToNodes = collections . defaultdict ( list ) dfs ( root , 0 , 0 ) for _ , nodes in sorted ( xToNodes . items (), key = lambda item : item [ 0 ]): ans . append ([ val for _ , val in sorted ( nodes )]) return ans 988. Smallest String Starting From Leaf $\\star\\star$ 989. Add to Array-Form of Integer $\\star$ class Solution : def addToArrayForm ( self , A : List [ int ], K : int ) -> List [ int ]: for i in range ( len ( A ))[:: - 1 ]: K , A [ i ] = divmod ( A [ i ] + K , 10 ) while K > 0 : A = [ K % 10 ] + A K //= 10 return A 990. Satisfiability of Equality Equations $\\star\\star$","title":"0981-0990"},{"location":"python3/0901-1000/0981-0990/#981-time-based-key-value-store-starstar","text":"class TimeMap : def __init__ ( self ): self . timestamps = collections . defaultdict ( list ) self . values = collections . defaultdict ( list ) def set ( self , key : str , value : str , timestamp : int ) -> None : self . timestamps [ key ] . append ( timestamp ) self . values [ key ] . append ( value ) def get ( self , key : str , timestamp : int ) -> str : i = bisect . bisect ( self . timestamps [ key ], timestamp ) return self . values [ key ][ i - 1 ] if i > 0 else ''","title":"981. Time Based Key-Value Store $\\star\\star$"},{"location":"python3/0901-1000/0981-0990/#982-triples-with-bitwise-and-equal-to-zero-starstarstar","text":"","title":"982. Triples with Bitwise AND Equal To Zero $\\star\\star\\star$"},{"location":"python3/0901-1000/0981-0990/#983-minimum-cost-for-tickets-starstar","text":"class Solution : def mincostTickets ( self , days : List [ int ], costs : List [ int ]) -> int : ans = 0 last7 = collections . deque () last30 = collections . deque () for day in days : while last7 and last7 [ 0 ][ 0 ] + 7 <= day : last7 . popleft () while last30 and last30 [ 0 ][ 0 ] + 30 <= day : last30 . popleft () last7 . append ([ day , ans + costs [ 1 ]]) last30 . append ([ day , ans + costs [ 2 ]]) ans = min ( ans + costs [ 0 ], last7 [ 0 ][ 1 ], last30 [ 0 ][ 1 ]) return ans","title":"983. Minimum Cost For Tickets $\\star\\star$"},{"location":"python3/0901-1000/0981-0990/#984-string-without-aaa-or-bbb-starstar","text":"","title":"984. String Without AAA or BBB $\\star\\star$"},{"location":"python3/0901-1000/0981-0990/#985-sum-of-even-numbers-after-queries-star","text":"class Solution : def sumEvenAfterQueries ( self , A : List [ int ], queries : List [ List [ int ]]) -> List [ int ]: ans = [] summ = sum ( a for a in A if a % 2 == 0 ) for query in queries : if A [ query [ 1 ]] % 2 == 0 : summ -= A [ query [ 1 ]] A [ query [ 1 ]] += query [ 0 ] if A [ query [ 1 ]] % 2 == 0 : summ += A [ query [ 1 ]] ans . append ( summ ) return ans","title":"985. Sum of Even Numbers After Queries $\\star$"},{"location":"python3/0901-1000/0981-0990/#986-interval-list-intersections-starstar","text":"","title":"986. Interval List Intersections $\\star\\star$"},{"location":"python3/0901-1000/0981-0990/#987-vertical-order-traversal-of-a-binary-tree-starstar","text":"class Solution : def verticalTraversal ( self , root : TreeNode ) -> List [ List [ int ]]: def dfs ( node : TreeNode , x : int , y : int ) -> None : if not node : return xToNodes [ x ] . append (( - y , node . val )) dfs ( node . left , x - 1 , y - 1 ) dfs ( node . right , x + 1 , y - 1 ) ans = [] xToNodes = collections . defaultdict ( list ) dfs ( root , 0 , 0 ) for _ , nodes in sorted ( xToNodes . items (), key = lambda item : item [ 0 ]): ans . append ([ val for _ , val in sorted ( nodes )]) return ans","title":"987. Vertical Order Traversal of a Binary Tree $\\star\\star$"},{"location":"python3/0901-1000/0981-0990/#988-smallest-string-starting-from-leaf-starstar","text":"","title":"988. Smallest String Starting From Leaf $\\star\\star$"},{"location":"python3/0901-1000/0981-0990/#989-add-to-array-form-of-integer-star","text":"class Solution : def addToArrayForm ( self , A : List [ int ], K : int ) -> List [ int ]: for i in range ( len ( A ))[:: - 1 ]: K , A [ i ] = divmod ( A [ i ] + K , 10 ) while K > 0 : A = [ K % 10 ] + A K //= 10 return A","title":"989. Add to Array-Form of Integer $\\star$"},{"location":"python3/0901-1000/0981-0990/#990-satisfiability-of-equality-equations-starstar","text":"","title":"990. Satisfiability of Equality Equations $\\star\\star$"},{"location":"python3/0901-1000/0991-1000/","text":"991. Broken Calculator $\\star\\star$ class Solution : def brokenCalc ( self , X : int , Y : int ) -> int : ops = 0 while X < Y : if Y % 2 == 0 : Y //= 2 else : Y += 1 ops += 1 return ops + X - Y 992. Subarrays with K Different Integers $\\star\\star\\star$ class Solution : def subarraysWithKDistinct ( self , A : List [ int ], K : int ) -> int : def subarraysWithAtMostKDistinct ( K : int ) -> int : ans = 0 count = collections . Counter () l = 0 for r , a in enumerate ( A ): count [ a ] += 1 if count [ a ] == 1 : K -= 1 while K < 0 : count [ A [ l ]] -= 1 if count [ A [ l ]] == 0 : K += 1 l += 1 ans += r - l + 1 return ans return subarraysWithAtMostKDistinct ( K ) - subarraysWithAtMostKDistinct ( K - 1 ) 993. Cousins in Binary Tree $\\star$ 994. Rotting Oranges $\\star\\star$ 995. Minimum Number of K Consecutive Bit Flips $\\star\\star\\star$ class Solution : def minKBitFlips ( self , A : List [ int ], K : int ) -> int : ans = 0 flippedTime = 0 for r , a in enumerate ( A ): if r >= K and A [ r - K ] == 2 : flippedTime -= 1 if flippedTime % 2 == a : if r + K > len ( A ): return - 1 ans += 1 flippedTime += 1 A [ r ] = 2 return ans 996. Number of Squareful Arrays $\\star\\star\\star$ class Solution : def numSquarefulPerms ( self , A : List [ int ]) -> int : def isSquare ( num : int ) -> bool : root = int ( sqrt ( num )) return root * root == num def dfs ( path : List [ int ]) -> None : if len ( path ) > 1 and not isSquare ( path [ - 1 ] + path [ - 2 ]): return if len ( path ) == len ( A ): self . ans += 1 return for i , a in enumerate ( A ): if used [ i ]: continue if i > 0 and A [ i ] == A [ i - 1 ] and not used [ i - 1 ]: continue used [ i ] = True dfs ( path + [ a ]) used [ i ] = False self . ans = 0 used = [ False ] * len ( A ) A . sort () dfs ([]) return self . ans 997. Find the Town Judge $\\star$ class Solution : def findJudge ( self , N : int , trust : List [ List [ int ]]) -> int : count = [ 0 ] * ( N + 1 ) for a , b in trust : count [ a ] -= 1 count [ b ] += 1 for i in range ( 1 , N + 1 ): if count [ i ] == N - 1 : return i return - 1 998. Maximum Binary Tree II $\\star\\star$ 999. Available Captures for Rook $\\star$ class Solution : def numRookCaptures ( self , board : List [ List [ str ]]) -> int : ans = 0 for i in range ( 8 ): for j in range ( 8 ): if board [ i ][ j ] == 'R' : i0 = i j0 = j for d in [[ 1 , 0 ], [ 0 , 1 ], [ - 1 , 0 ], [ 0 , - 1 ]]: i = i0 + d [ 0 ] j = j0 + d [ 1 ] while 0 <= i < 8 and 0 <= j < 8 : if board [ i ][ j ] == 'p' : ans += 1 if board [ i ][ j ] != '.' : break i += d [ 0 ] j += d [ 1 ] return ans 1000. Minimum Cost to Merge Stones $\\star\\star\\star$","title":"0991-1000"},{"location":"python3/0901-1000/0991-1000/#991-broken-calculator-starstar","text":"class Solution : def brokenCalc ( self , X : int , Y : int ) -> int : ops = 0 while X < Y : if Y % 2 == 0 : Y //= 2 else : Y += 1 ops += 1 return ops + X - Y","title":"991. Broken Calculator $\\star\\star$"},{"location":"python3/0901-1000/0991-1000/#992-subarrays-with-k-different-integers-starstarstar","text":"class Solution : def subarraysWithKDistinct ( self , A : List [ int ], K : int ) -> int : def subarraysWithAtMostKDistinct ( K : int ) -> int : ans = 0 count = collections . Counter () l = 0 for r , a in enumerate ( A ): count [ a ] += 1 if count [ a ] == 1 : K -= 1 while K < 0 : count [ A [ l ]] -= 1 if count [ A [ l ]] == 0 : K += 1 l += 1 ans += r - l + 1 return ans return subarraysWithAtMostKDistinct ( K ) - subarraysWithAtMostKDistinct ( K - 1 )","title":"992. Subarrays with K Different Integers $\\star\\star\\star$"},{"location":"python3/0901-1000/0991-1000/#993-cousins-in-binary-tree-star","text":"","title":"993. Cousins in Binary Tree $\\star$"},{"location":"python3/0901-1000/0991-1000/#994-rotting-oranges-starstar","text":"","title":"994. Rotting Oranges $\\star\\star$"},{"location":"python3/0901-1000/0991-1000/#995-minimum-number-of-k-consecutive-bit-flips-starstarstar","text":"class Solution : def minKBitFlips ( self , A : List [ int ], K : int ) -> int : ans = 0 flippedTime = 0 for r , a in enumerate ( A ): if r >= K and A [ r - K ] == 2 : flippedTime -= 1 if flippedTime % 2 == a : if r + K > len ( A ): return - 1 ans += 1 flippedTime += 1 A [ r ] = 2 return ans","title":"995. Minimum Number of K Consecutive Bit Flips $\\star\\star\\star$"},{"location":"python3/0901-1000/0991-1000/#996-number-of-squareful-arrays-starstarstar","text":"class Solution : def numSquarefulPerms ( self , A : List [ int ]) -> int : def isSquare ( num : int ) -> bool : root = int ( sqrt ( num )) return root * root == num def dfs ( path : List [ int ]) -> None : if len ( path ) > 1 and not isSquare ( path [ - 1 ] + path [ - 2 ]): return if len ( path ) == len ( A ): self . ans += 1 return for i , a in enumerate ( A ): if used [ i ]: continue if i > 0 and A [ i ] == A [ i - 1 ] and not used [ i - 1 ]: continue used [ i ] = True dfs ( path + [ a ]) used [ i ] = False self . ans = 0 used = [ False ] * len ( A ) A . sort () dfs ([]) return self . ans","title":"996. Number of Squareful Arrays $\\star\\star\\star$"},{"location":"python3/0901-1000/0991-1000/#997-find-the-town-judge-star","text":"class Solution : def findJudge ( self , N : int , trust : List [ List [ int ]]) -> int : count = [ 0 ] * ( N + 1 ) for a , b in trust : count [ a ] -= 1 count [ b ] += 1 for i in range ( 1 , N + 1 ): if count [ i ] == N - 1 : return i return - 1","title":"997. Find the Town Judge $\\star$"},{"location":"python3/0901-1000/0991-1000/#998-maximum-binary-tree-ii-starstar","text":"","title":"998. Maximum Binary Tree II $\\star\\star$"},{"location":"python3/0901-1000/0991-1000/#999-available-captures-for-rook-star","text":"class Solution : def numRookCaptures ( self , board : List [ List [ str ]]) -> int : ans = 0 for i in range ( 8 ): for j in range ( 8 ): if board [ i ][ j ] == 'R' : i0 = i j0 = j for d in [[ 1 , 0 ], [ 0 , 1 ], [ - 1 , 0 ], [ 0 , - 1 ]]: i = i0 + d [ 0 ] j = j0 + d [ 1 ] while 0 <= i < 8 and 0 <= j < 8 : if board [ i ][ j ] == 'p' : ans += 1 if board [ i ][ j ] != '.' : break i += d [ 0 ] j += d [ 1 ] return ans","title":"999. Available Captures for Rook $\\star$"},{"location":"python3/0901-1000/0991-1000/#1000-minimum-cost-to-merge-stones-starstarstar","text":"","title":"1000. Minimum Cost to Merge Stones $\\star\\star\\star$"},{"location":"python3/1001-1100/1001-1010/","text":"1001. Grid Illumination $\\star\\star\\star$ class Solution : def gridIllumination ( self , N : int , lamps : List [ List [ int ]], queries : List [ List [ int ]]) -> List [ int ]: ans = [] rows = collections . Counter () cols = collections . Counter () diag1 = collections . Counter () diag2 = collections . Counter () lampsSet = set () for i , j in lamps : if ( i , j ) not in lampsSet : lampsSet . add (( i , j )) rows [ i ] += 1 cols [ j ] += 1 diag1 [ i + j ] += 1 diag2 [ i - j ] += 1 for i , j in queries : if rows [ i ] or cols [ j ] or diag1 [ i + j ] or diag2 [ i - j ]: ans . append ( 1 ) for y in range ( max ( 0 , i - 1 ), min ( N , i + 2 )): for x in range ( max ( 0 , j - 1 ), min ( N , j + 2 )): if ( y , x ) in lampsSet : lampsSet . remove (( y , x )) rows [ y ] -= 1 cols [ x ] -= 1 diag1 [ y + x ] -= 1 diag2 [ y - x ] -= 1 else : ans . append ( 0 ) return ans 1002. Find Common Characters $\\star$ class Solution : def commonChars ( self , A : List [ str ]) -> List [ str ]: ans = [] commonCount = [ float ( 'inf' )] * 26 for a in A : count = [ 0 ] * 26 for c in a : count [ ord ( c ) - ord ( 'a' )] += 1 for i in range ( 26 ): commonCount [ i ] = min ( commonCount [ i ], count [ i ]) for c in string . ascii_lowercase : for j in range ( commonCount [ ord ( c ) - ord ( 'a' )]): ans . append ( c ) return ans 1003. Check If Word Is Valid After Substitutions $\\star\\star$ class Solution : def isValid ( self , S : str ) -> bool : stack = [] for c in S : if c == 'c' : if len ( stack ) < 2 or stack [ - 2 ] != 'a' or stack [ - 1 ] != 'b' : return False stack . pop () stack . pop () else : stack . append ( c ) return not stack 1004. Max Consecutive Ones III $\\star\\star$ class Solution : def longestOnes ( self , A : List [ int ], K : int ) -> int : ans = 0 l = 0 for r , a in enumerate ( A ): if a == 0 : K -= 1 while K < 0 : if A [ l ] == 0 : K += 1 l += 1 ans = max ( ans , r - l + 1 ) return ans 1005. Maximize Sum Of Array After K Negations $\\star$ class Solution : def largestSumAfterKNegations ( self , A : List [ int ], K : int ) -> int : A . sort () for i in range ( len ( A )): if A [ i ] > 0 or K == 0 : break A [ i ] = - A [ i ] K -= 1 return sum ( A ) - ( K % 2 ) * min ( A ) * 2 1006. Clumsy Factorial $\\star\\star$ class Solution : def clumsy ( self , N : int ) -> int : if N == 1 : return 1 if N == 2 : return 2 if N == 3 : return 6 if N == 4 : return 7 if N % 4 == 1 : return N + 2 if N % 4 == 2 : return N + 2 if N % 4 == 3 : return N - 1 return N + 1 1007. Minimum Domino Rotations For Equal Row $\\star\\star$ class Solution : def minDominoRotations ( self , A : List [ int ], B : List [ int ]) -> int : for num in range ( 1 , 7 ): if all ( num in pair for pair in zip ( A , B )): return len ( A ) - max ( A . count ( num ), B . count ( num )) return - 1 1008. Construct Binary Search Tree from Preorder Traversal $\\star\\star$ 1009. Complement of Base 10 Integer $\\star$ class Solution : def bitwiseComplement ( self , N : int ) -> int : mask = 1 while mask < N : mask = ( mask << 1 ) + 1 return mask ^ N 1010. Pairs of Songs With Total Durations Divisible by 60 $\\star$ class Solution : def numPairsDivisibleBy60 ( self , time : List [ int ]) -> int : ans = 0 count = [ 0 ] * 60 for t in time : t %= 60 ans += count [( 60 - t ) % 60 ] count [ t ] += 1 return ans","title":"1001-1010"},{"location":"python3/1001-1100/1001-1010/#1001-grid-illumination-starstarstar","text":"class Solution : def gridIllumination ( self , N : int , lamps : List [ List [ int ]], queries : List [ List [ int ]]) -> List [ int ]: ans = [] rows = collections . Counter () cols = collections . Counter () diag1 = collections . Counter () diag2 = collections . Counter () lampsSet = set () for i , j in lamps : if ( i , j ) not in lampsSet : lampsSet . add (( i , j )) rows [ i ] += 1 cols [ j ] += 1 diag1 [ i + j ] += 1 diag2 [ i - j ] += 1 for i , j in queries : if rows [ i ] or cols [ j ] or diag1 [ i + j ] or diag2 [ i - j ]: ans . append ( 1 ) for y in range ( max ( 0 , i - 1 ), min ( N , i + 2 )): for x in range ( max ( 0 , j - 1 ), min ( N , j + 2 )): if ( y , x ) in lampsSet : lampsSet . remove (( y , x )) rows [ y ] -= 1 cols [ x ] -= 1 diag1 [ y + x ] -= 1 diag2 [ y - x ] -= 1 else : ans . append ( 0 ) return ans","title":"1001. Grid Illumination $\\star\\star\\star$"},{"location":"python3/1001-1100/1001-1010/#1002-find-common-characters-star","text":"class Solution : def commonChars ( self , A : List [ str ]) -> List [ str ]: ans = [] commonCount = [ float ( 'inf' )] * 26 for a in A : count = [ 0 ] * 26 for c in a : count [ ord ( c ) - ord ( 'a' )] += 1 for i in range ( 26 ): commonCount [ i ] = min ( commonCount [ i ], count [ i ]) for c in string . ascii_lowercase : for j in range ( commonCount [ ord ( c ) - ord ( 'a' )]): ans . append ( c ) return ans","title":"1002. Find Common Characters $\\star$"},{"location":"python3/1001-1100/1001-1010/#1003-check-if-word-is-valid-after-substitutions-starstar","text":"class Solution : def isValid ( self , S : str ) -> bool : stack = [] for c in S : if c == 'c' : if len ( stack ) < 2 or stack [ - 2 ] != 'a' or stack [ - 1 ] != 'b' : return False stack . pop () stack . pop () else : stack . append ( c ) return not stack","title":"1003. Check If Word Is Valid After Substitutions $\\star\\star$"},{"location":"python3/1001-1100/1001-1010/#1004-max-consecutive-ones-iii-starstar","text":"class Solution : def longestOnes ( self , A : List [ int ], K : int ) -> int : ans = 0 l = 0 for r , a in enumerate ( A ): if a == 0 : K -= 1 while K < 0 : if A [ l ] == 0 : K += 1 l += 1 ans = max ( ans , r - l + 1 ) return ans","title":"1004. Max Consecutive Ones III $\\star\\star$"},{"location":"python3/1001-1100/1001-1010/#1005-maximize-sum-of-array-after-k-negations-star","text":"class Solution : def largestSumAfterKNegations ( self , A : List [ int ], K : int ) -> int : A . sort () for i in range ( len ( A )): if A [ i ] > 0 or K == 0 : break A [ i ] = - A [ i ] K -= 1 return sum ( A ) - ( K % 2 ) * min ( A ) * 2","title":"1005. Maximize Sum Of Array After K Negations $\\star$"},{"location":"python3/1001-1100/1001-1010/#1006-clumsy-factorial-starstar","text":"class Solution : def clumsy ( self , N : int ) -> int : if N == 1 : return 1 if N == 2 : return 2 if N == 3 : return 6 if N == 4 : return 7 if N % 4 == 1 : return N + 2 if N % 4 == 2 : return N + 2 if N % 4 == 3 : return N - 1 return N + 1","title":"1006. Clumsy Factorial $\\star\\star$"},{"location":"python3/1001-1100/1001-1010/#1007-minimum-domino-rotations-for-equal-row-starstar","text":"class Solution : def minDominoRotations ( self , A : List [ int ], B : List [ int ]) -> int : for num in range ( 1 , 7 ): if all ( num in pair for pair in zip ( A , B )): return len ( A ) - max ( A . count ( num ), B . count ( num )) return - 1","title":"1007. Minimum Domino Rotations For Equal Row $\\star\\star$"},{"location":"python3/1001-1100/1001-1010/#1008-construct-binary-search-tree-from-preorder-traversal-starstar","text":"","title":"1008. Construct Binary Search Tree from Preorder Traversal $\\star\\star$"},{"location":"python3/1001-1100/1001-1010/#1009-complement-of-base-10-integer-star","text":"class Solution : def bitwiseComplement ( self , N : int ) -> int : mask = 1 while mask < N : mask = ( mask << 1 ) + 1 return mask ^ N","title":"1009. Complement of Base 10 Integer $\\star$"},{"location":"python3/1001-1100/1001-1010/#1010-pairs-of-songs-with-total-durations-divisible-by-60-star","text":"class Solution : def numPairsDivisibleBy60 ( self , time : List [ int ]) -> int : ans = 0 count = [ 0 ] * 60 for t in time : t %= 60 ans += count [( 60 - t ) % 60 ] count [ t ] += 1 return ans","title":"1010. Pairs of Songs With Total Durations Divisible by 60 $\\star$"},{"location":"python3/1001-1100/1011-1020/","text":"1011. Capacity To Ship Packages Within D Days $\\star\\star$ class Solution : def shipWithinDays ( self , weights : List [ int ], D : int ) -> int : l = max ( weights ) r = sum ( weights ) while l < r : m = ( l + r ) // 2 day = 1 capacity = 0 for weight in weights : if capacity + weight > m : day += 1 capacity = weight else : capacity += weight if day <= D : r = m else : l = m + 1 return l 1012. Numbers With Repeated Digits $\\star\\star\\star$ 1013. Partition Array Into Three Parts With Equal Sum $\\star$ class Solution : def canThreePartsEqualSum ( self , A : List [ int ]) -> bool : summ = sum ( A ) prefixSum = 0 parts = 1 for a in A : prefixSum += a if prefixSum == summ * parts // 3 : parts += 1 return summ % 3 == 0 and parts >= 3 1014. Best Sightseeing Pair $\\star\\star$ class Solution : def maxScoreSightseeingPair ( self , A : List [ int ]) -> int : ans = 0 bestPrev = 0 for a in A : ans = max ( ans , a + bestPrev ) bestPrev = max ( bestPrev , a ) - 1 return ans 1015. Smallest Integer Divisible by K $\\star\\star$ class Solution : def smallestRepunitDivByK ( self , K : int ) -> int : if K % 10 not in { 1 , 3 , 7 , 9 }: return - 1 seen = set () N = 0 for length in range ( 1 , K + 1 ): N = ( N * 10 + 1 ) % K if N == 0 : return length if N in seen : return - 1 seen . add ( N ) return - 1 1016. Binary String With Substrings Representing 1 To N $\\star\\star$ class Solution : def queryString ( self , S : str , N : int ) -> bool : if N > 1511 : return False for i in range ( N , N // 2 , - 1 ): if format ( i , 'b' ) not in S : return False return True 1017. Convert to Base -2 $\\star\\star$ class Solution : def baseNeg2 ( self , N : int ) -> str : ans = '' while N : ans = str ( N & 1 ) + ans N = - ( N >> 1 ) return '0' if ans == '' else ans 1018. Binary Prefix Divisible By 5 $\\star$ class Solution : def prefixesDivBy5 ( self , A : List [ int ]) -> List [ bool ]: ans = [] num = 0 for a in A : num = ( num * 2 + a ) % 5 ans . append ( num % 5 == 0 ) return ans 1019. Next Greater Node In Linked List $\\star\\star$ class Solution : def nextLargerNodes ( self , head : ListNode ) -> List [ int ]: ans = [] stack = [] while head : while stack and head . val > ans [ stack [ - 1 ]]: index = stack . pop () ans [ index ] = head . val stack . append ( len ( ans )) ans . append ( head . val ) head = head . next for i in stack : ans [ i ] = 0 return ans 1020. Number of Enclaves $\\star\\star$","title":"1011-1020"},{"location":"python3/1001-1100/1011-1020/#1011-capacity-to-ship-packages-within-d-days-starstar","text":"class Solution : def shipWithinDays ( self , weights : List [ int ], D : int ) -> int : l = max ( weights ) r = sum ( weights ) while l < r : m = ( l + r ) // 2 day = 1 capacity = 0 for weight in weights : if capacity + weight > m : day += 1 capacity = weight else : capacity += weight if day <= D : r = m else : l = m + 1 return l","title":"1011. Capacity To Ship Packages Within D Days $\\star\\star$"},{"location":"python3/1001-1100/1011-1020/#1012-numbers-with-repeated-digits-starstarstar","text":"","title":"1012. Numbers With Repeated Digits $\\star\\star\\star$"},{"location":"python3/1001-1100/1011-1020/#1013-partition-array-into-three-parts-with-equal-sum-star","text":"class Solution : def canThreePartsEqualSum ( self , A : List [ int ]) -> bool : summ = sum ( A ) prefixSum = 0 parts = 1 for a in A : prefixSum += a if prefixSum == summ * parts // 3 : parts += 1 return summ % 3 == 0 and parts >= 3","title":"1013. Partition Array Into Three Parts With Equal Sum $\\star$"},{"location":"python3/1001-1100/1011-1020/#1014-best-sightseeing-pair-starstar","text":"class Solution : def maxScoreSightseeingPair ( self , A : List [ int ]) -> int : ans = 0 bestPrev = 0 for a in A : ans = max ( ans , a + bestPrev ) bestPrev = max ( bestPrev , a ) - 1 return ans","title":"1014. Best Sightseeing Pair $\\star\\star$"},{"location":"python3/1001-1100/1011-1020/#1015-smallest-integer-divisible-by-k-starstar","text":"class Solution : def smallestRepunitDivByK ( self , K : int ) -> int : if K % 10 not in { 1 , 3 , 7 , 9 }: return - 1 seen = set () N = 0 for length in range ( 1 , K + 1 ): N = ( N * 10 + 1 ) % K if N == 0 : return length if N in seen : return - 1 seen . add ( N ) return - 1","title":"1015. Smallest Integer Divisible by K $\\star\\star$"},{"location":"python3/1001-1100/1011-1020/#1016-binary-string-with-substrings-representing-1-to-n-starstar","text":"class Solution : def queryString ( self , S : str , N : int ) -> bool : if N > 1511 : return False for i in range ( N , N // 2 , - 1 ): if format ( i , 'b' ) not in S : return False return True","title":"1016. Binary String With Substrings Representing 1 To N $\\star\\star$"},{"location":"python3/1001-1100/1011-1020/#1017-convert-to-base-2-starstar","text":"class Solution : def baseNeg2 ( self , N : int ) -> str : ans = '' while N : ans = str ( N & 1 ) + ans N = - ( N >> 1 ) return '0' if ans == '' else ans","title":"1017. Convert to Base -2 $\\star\\star$"},{"location":"python3/1001-1100/1011-1020/#1018-binary-prefix-divisible-by-5-star","text":"class Solution : def prefixesDivBy5 ( self , A : List [ int ]) -> List [ bool ]: ans = [] num = 0 for a in A : num = ( num * 2 + a ) % 5 ans . append ( num % 5 == 0 ) return ans","title":"1018. Binary Prefix Divisible By 5 $\\star$"},{"location":"python3/1001-1100/1011-1020/#1019-next-greater-node-in-linked-list-starstar","text":"class Solution : def nextLargerNodes ( self , head : ListNode ) -> List [ int ]: ans = [] stack = [] while head : while stack and head . val > ans [ stack [ - 1 ]]: index = stack . pop () ans [ index ] = head . val stack . append ( len ( ans )) ans . append ( head . val ) head = head . next for i in stack : ans [ i ] = 0 return ans","title":"1019. Next Greater Node In Linked List $\\star\\star$"},{"location":"python3/1001-1100/1011-1020/#1020-number-of-enclaves-starstar","text":"","title":"1020. Number of Enclaves $\\star\\star$"},{"location":"python3/1001-1100/1021-1030/","text":"1021. Remove Outermost Parentheses $\\star$ 1022. Sum of Root To Leaf Binary Numbers $\\star$ 1023. Camelcase Matching $\\star\\star$ class Solution : def camelMatch ( self , queries : List [ str ], pattern : str ) -> List [ bool ]: def isMatch ( query : str ) -> bool : j = 0 for i , c in enumerate ( query ): if j < len ( pattern ) and c == pattern [ j ]: j += 1 elif c . isupper (): return False return j == len ( pattern ) return [ isMatch ( query ) for query in queries ] 1024. Video Stitching $\\star\\star$ class Solution : def videoStitching ( self , clips : List [ List [ int ]], T : int ) -> int : ans = 0 end = 0 farthest = 0 clips . sort () i = 0 while farthest < T : while i < len ( clips ) and clips [ i ][ 0 ] <= end : farthest = max ( farthest , clips [ i ][ 1 ]) i += 1 if end == farthest : return - 1 ans += 1 end = farthest return ans 1025. Divisor Game $\\star$ class Solution : def divisorGame ( self , N : int ) -> bool : return N % 2 == 0 1026. Maximum Difference Between Node and Ancestor $\\star\\star$ 1027. Longest Arithmetic Sequence $\\star\\star$ 1028. Recover a Tree From Preorder Traversal $\\star\\star\\star$ 1029. Two City Scheduling $\\star$ 1030. Matrix Cells in Distance Order $\\star$","title":"1021-1030"},{"location":"python3/1001-1100/1021-1030/#1021-remove-outermost-parentheses-star","text":"","title":"1021. Remove Outermost Parentheses $\\star$"},{"location":"python3/1001-1100/1021-1030/#1022-sum-of-root-to-leaf-binary-numbers-star","text":"","title":"1022. Sum of Root To Leaf Binary Numbers $\\star$"},{"location":"python3/1001-1100/1021-1030/#1023-camelcase-matching-starstar","text":"class Solution : def camelMatch ( self , queries : List [ str ], pattern : str ) -> List [ bool ]: def isMatch ( query : str ) -> bool : j = 0 for i , c in enumerate ( query ): if j < len ( pattern ) and c == pattern [ j ]: j += 1 elif c . isupper (): return False return j == len ( pattern ) return [ isMatch ( query ) for query in queries ]","title":"1023. Camelcase Matching $\\star\\star$"},{"location":"python3/1001-1100/1021-1030/#1024-video-stitching-starstar","text":"class Solution : def videoStitching ( self , clips : List [ List [ int ]], T : int ) -> int : ans = 0 end = 0 farthest = 0 clips . sort () i = 0 while farthest < T : while i < len ( clips ) and clips [ i ][ 0 ] <= end : farthest = max ( farthest , clips [ i ][ 1 ]) i += 1 if end == farthest : return - 1 ans += 1 end = farthest return ans","title":"1024. Video Stitching $\\star\\star$"},{"location":"python3/1001-1100/1021-1030/#1025-divisor-game-star","text":"class Solution : def divisorGame ( self , N : int ) -> bool : return N % 2 == 0","title":"1025. Divisor Game $\\star$"},{"location":"python3/1001-1100/1021-1030/#1026-maximum-difference-between-node-and-ancestor-starstar","text":"","title":"1026. Maximum Difference Between Node and Ancestor $\\star\\star$"},{"location":"python3/1001-1100/1021-1030/#1027-longest-arithmetic-sequence-starstar","text":"","title":"1027. Longest Arithmetic Sequence $\\star\\star$"},{"location":"python3/1001-1100/1021-1030/#1028-recover-a-tree-from-preorder-traversal-starstarstar","text":"","title":"1028. Recover a Tree From Preorder Traversal $\\star\\star\\star$"},{"location":"python3/1001-1100/1021-1030/#1029-two-city-scheduling-star","text":"","title":"1029. Two City Scheduling $\\star$"},{"location":"python3/1001-1100/1021-1030/#1030-matrix-cells-in-distance-order-star","text":"","title":"1030. Matrix Cells in Distance Order $\\star$"},{"location":"python3/1001-1100/1031-1040/","text":"1031. Maximum Sum of Two Non-Overlapping Subarrays $\\star\\star$ class Solution : def maxSumTwoNoOverlap ( self , A : List [ int ], L : int , M : int ) -> int : def helper ( l : int , r : int ) -> int : n = len ( A ) left = [ 0 ] * n sum = 0 for i in range ( n ): sum += A [ i ] if i >= l : sum -= A [ i - l ] if i >= l - 1 : left [ i ] = max ( left [ i - 1 ], sum ) if i > 0 else sum right = [ 0 ] * n sum = 0 for i in range ( n )[:: - 1 ]: sum += A [ i ] if i <= n - r - 1 : sum -= A [ i + r ] if i <= n - r : right [ i ] = max ( right [ i + 1 ], sum ) if i < n - 1 else sum return max ( left [ i ] + right [ i + 1 ] for i in range ( n - 1 )) return max ( helper ( L , M ), helper ( M , L )) 1032. Stream of Characters $\\star\\star\\star$ 1033. Moving Stones Until Consecutive $\\star$ class Solution : def numMovesStones ( self , a : int , b : int , c : int ) -> List [ int ]: nums = sorted ([ a , b , c ]) if nums [ 2 ] - nums [ 0 ] == 2 : return [ 0 , 0 ] return [ 1 if min ( nums [ 1 ] - nums [ 0 ], nums [ 2 ] - nums [ 1 ]) <= 2 else 2 , nums [ 2 ] - nums [ 0 ] - 2 ] 1034. Coloring A Border $\\star\\star$ class Solution : def colorBorder ( self , grid : List [ List [ int ]], r0 : int , c0 : int , color : int ) -> List [ List [ int ]]: def dfs ( i : int , j : int , originalColor : int ) -> None : if not 0 <= i < len ( grid ) or not 0 <= j < len ( grid [ 0 ]) or grid [ i ][ j ] != originalColor : return grid [ i ][ j ] = - originalColor dfs ( i + 1 , j , originalColor ) dfs ( i - 1 , j , originalColor ) dfs ( i , j + 1 , originalColor ) dfs ( i , j - 1 , originalColor ) if 0 < i < len ( grid ) - 1 and 0 < j < len ( grid [ 0 ]) - 1 and \\ abs ( grid [ i + 1 ][ j ]) == originalColor and \\ abs ( grid [ i - 1 ][ j ]) == originalColor and \\ abs ( grid [ i ][ j + 1 ]) == originalColor and \\ abs ( grid [ i ][ j - 1 ]) == originalColor : grid [ i ][ j ] = originalColor dfs ( r0 , c0 , grid [ r0 ][ c0 ]) for i in range ( len ( grid )): for j in range ( len ( grid [ 0 ])): if grid [ i ][ j ] < 0 : grid [ i ][ j ] = color return grid 1035. Uncrossed Lines $\\star\\star$ class Solution : def maxUncrossedLines ( self , A : List [ int ], B : List [ int ]) -> int : m = len ( A ) n = len ( B ) dp = [[ 0 ] * ( n + 1 ) for _ in range ( m + 1 )] for i in range ( 1 , m + 1 ): for j in range ( 1 , n + 1 ): dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ] + 1 if A [ i - 1 ] == B [ j - 1 ] \\ else max ( dp [ i - 1 ][ j ], dp [ i ][ j - 1 ]) return dp [ m ][ n ] 1036. Escape a Large Maze $\\star\\star\\star$ class Solution : def isEscapePossible ( self , blocked : List [ List [ int ]], source : List [ int ], target : List [ int ]) -> bool : def dfs ( i : int , j : int , target : List [ int ], visited : set ) -> bool : if not 0 <= i < 10 ** 6 or not 0 <= j < 10 ** 6 or ( i , j ) in blocked or ( i , j ) in visited : return False visited . add (( i , j )) if len ( visited ) > ( 1 + 199 ) * 199 // 2 or [ i , j ] == target : return True return dfs ( i + 1 , j , target , visited ) or \\ dfs ( i - 1 , j , target , visited ) or \\ dfs ( i , j + 1 , target , visited ) or \\ dfs ( i , j - 1 , target , visited ) blocked = set ( tuple ( b ) for b in blocked ) return dfs ( source [ 0 ], source [ 1 ], target , set ()) and dfs ( target [ 0 ], target [ 1 ], source , set ()) 1037. Valid Boomerang $\\star$ class Solution : def isBoomerang ( self , points : List [ List [ int ]]) -> bool : return ( points [ 1 ][ 0 ] - points [ 0 ][ 0 ]) * ( points [ 2 ][ 1 ] - points [ 1 ][ 1 ]) != \\ ( points [ 1 ][ 1 ] - points [ 0 ][ 1 ]) * ( points [ 2 ][ 0 ] - points [ 1 ][ 0 ]) 1038. Binary Search Tree to Greater Sum Tree $\\star\\star$ 1039. Minimum Score Triangulation of Polygon $\\star\\star$ 1040. Moving Stones Until Consecutive II $\\star\\star$ class Solution : def numMovesStonesII ( self , stones : List [ int ]) -> List [ int ]: n = len ( stones ) minMoves = n stones . sort () l = 0 for r , stone in enumerate ( stones ): while stone - stones [ l ] + 1 > n : l += 1 alreadyStored = r - l + 1 if alreadyStored == n - 1 and stone - stones [ l ] + 1 == n - 1 : minMoves = 2 else : minMoves = min ( minMoves , n - alreadyStored ) return [ minMoves , max ( stones [ n - 1 ] - stones [ 1 ] - n + 2 , stones [ n - 2 ] - stones [ 0 ] - n + 2 )]","title":"1031-1040"},{"location":"python3/1001-1100/1031-1040/#1031-maximum-sum-of-two-non-overlapping-subarrays-starstar","text":"class Solution : def maxSumTwoNoOverlap ( self , A : List [ int ], L : int , M : int ) -> int : def helper ( l : int , r : int ) -> int : n = len ( A ) left = [ 0 ] * n sum = 0 for i in range ( n ): sum += A [ i ] if i >= l : sum -= A [ i - l ] if i >= l - 1 : left [ i ] = max ( left [ i - 1 ], sum ) if i > 0 else sum right = [ 0 ] * n sum = 0 for i in range ( n )[:: - 1 ]: sum += A [ i ] if i <= n - r - 1 : sum -= A [ i + r ] if i <= n - r : right [ i ] = max ( right [ i + 1 ], sum ) if i < n - 1 else sum return max ( left [ i ] + right [ i + 1 ] for i in range ( n - 1 )) return max ( helper ( L , M ), helper ( M , L ))","title":"1031. Maximum Sum of Two Non-Overlapping Subarrays $\\star\\star$"},{"location":"python3/1001-1100/1031-1040/#1032-stream-of-characters-starstarstar","text":"","title":"1032. Stream of Characters $\\star\\star\\star$"},{"location":"python3/1001-1100/1031-1040/#1033-moving-stones-until-consecutive-star","text":"class Solution : def numMovesStones ( self , a : int , b : int , c : int ) -> List [ int ]: nums = sorted ([ a , b , c ]) if nums [ 2 ] - nums [ 0 ] == 2 : return [ 0 , 0 ] return [ 1 if min ( nums [ 1 ] - nums [ 0 ], nums [ 2 ] - nums [ 1 ]) <= 2 else 2 , nums [ 2 ] - nums [ 0 ] - 2 ]","title":"1033. Moving Stones Until Consecutive $\\star$"},{"location":"python3/1001-1100/1031-1040/#1034-coloring-a-border-starstar","text":"class Solution : def colorBorder ( self , grid : List [ List [ int ]], r0 : int , c0 : int , color : int ) -> List [ List [ int ]]: def dfs ( i : int , j : int , originalColor : int ) -> None : if not 0 <= i < len ( grid ) or not 0 <= j < len ( grid [ 0 ]) or grid [ i ][ j ] != originalColor : return grid [ i ][ j ] = - originalColor dfs ( i + 1 , j , originalColor ) dfs ( i - 1 , j , originalColor ) dfs ( i , j + 1 , originalColor ) dfs ( i , j - 1 , originalColor ) if 0 < i < len ( grid ) - 1 and 0 < j < len ( grid [ 0 ]) - 1 and \\ abs ( grid [ i + 1 ][ j ]) == originalColor and \\ abs ( grid [ i - 1 ][ j ]) == originalColor and \\ abs ( grid [ i ][ j + 1 ]) == originalColor and \\ abs ( grid [ i ][ j - 1 ]) == originalColor : grid [ i ][ j ] = originalColor dfs ( r0 , c0 , grid [ r0 ][ c0 ]) for i in range ( len ( grid )): for j in range ( len ( grid [ 0 ])): if grid [ i ][ j ] < 0 : grid [ i ][ j ] = color return grid","title":"1034. Coloring A Border $\\star\\star$"},{"location":"python3/1001-1100/1031-1040/#1035-uncrossed-lines-starstar","text":"class Solution : def maxUncrossedLines ( self , A : List [ int ], B : List [ int ]) -> int : m = len ( A ) n = len ( B ) dp = [[ 0 ] * ( n + 1 ) for _ in range ( m + 1 )] for i in range ( 1 , m + 1 ): for j in range ( 1 , n + 1 ): dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ] + 1 if A [ i - 1 ] == B [ j - 1 ] \\ else max ( dp [ i - 1 ][ j ], dp [ i ][ j - 1 ]) return dp [ m ][ n ]","title":"1035. Uncrossed Lines $\\star\\star$"},{"location":"python3/1001-1100/1031-1040/#1036-escape-a-large-maze-starstarstar","text":"class Solution : def isEscapePossible ( self , blocked : List [ List [ int ]], source : List [ int ], target : List [ int ]) -> bool : def dfs ( i : int , j : int , target : List [ int ], visited : set ) -> bool : if not 0 <= i < 10 ** 6 or not 0 <= j < 10 ** 6 or ( i , j ) in blocked or ( i , j ) in visited : return False visited . add (( i , j )) if len ( visited ) > ( 1 + 199 ) * 199 // 2 or [ i , j ] == target : return True return dfs ( i + 1 , j , target , visited ) or \\ dfs ( i - 1 , j , target , visited ) or \\ dfs ( i , j + 1 , target , visited ) or \\ dfs ( i , j - 1 , target , visited ) blocked = set ( tuple ( b ) for b in blocked ) return dfs ( source [ 0 ], source [ 1 ], target , set ()) and dfs ( target [ 0 ], target [ 1 ], source , set ())","title":"1036. Escape a Large Maze $\\star\\star\\star$"},{"location":"python3/1001-1100/1031-1040/#1037-valid-boomerang-star","text":"class Solution : def isBoomerang ( self , points : List [ List [ int ]]) -> bool : return ( points [ 1 ][ 0 ] - points [ 0 ][ 0 ]) * ( points [ 2 ][ 1 ] - points [ 1 ][ 1 ]) != \\ ( points [ 1 ][ 1 ] - points [ 0 ][ 1 ]) * ( points [ 2 ][ 0 ] - points [ 1 ][ 0 ])","title":"1037. Valid Boomerang $\\star$"},{"location":"python3/1001-1100/1031-1040/#1038-binary-search-tree-to-greater-sum-tree-starstar","text":"","title":"1038. Binary Search Tree to Greater Sum Tree $\\star\\star$"},{"location":"python3/1001-1100/1031-1040/#1039-minimum-score-triangulation-of-polygon-starstar","text":"","title":"1039. Minimum Score Triangulation of Polygon $\\star\\star$"},{"location":"python3/1001-1100/1031-1040/#1040-moving-stones-until-consecutive-ii-starstar","text":"class Solution : def numMovesStonesII ( self , stones : List [ int ]) -> List [ int ]: n = len ( stones ) minMoves = n stones . sort () l = 0 for r , stone in enumerate ( stones ): while stone - stones [ l ] + 1 > n : l += 1 alreadyStored = r - l + 1 if alreadyStored == n - 1 and stone - stones [ l ] + 1 == n - 1 : minMoves = 2 else : minMoves = min ( minMoves , n - alreadyStored ) return [ minMoves , max ( stones [ n - 1 ] - stones [ 1 ] - n + 2 , stones [ n - 2 ] - stones [ 0 ] - n + 2 )]","title":"1040. Moving Stones Until Consecutive II $\\star\\star$"},{"location":"python3/1001-1100/1041-1050/","text":"1041. Robot Bounded In Circle $\\star\\star$ class Solution : def isRobotBounded ( self , instructions : str ) -> bool : x = 0 y = 0 d = 0 directions = [( 0 , 1 ), ( 1 , 0 ), ( 0 , - 1 ), ( - 1 , 0 )] for instruction in instructions : if instruction == 'G' : x += directions [ d ][ 0 ] y += directions [ d ][ 1 ] elif instruction == 'L' : d = ( d + 3 ) % 4 else : d = ( d + 1 ) % 4 return ( x , y ) == ( 0 , 0 ) or d > 0 1042. Flower Planting With No Adjacent $\\star$ 1043. Partition Array for Maximum Sum $\\star\\star$ 1044. Longest Duplicate Substring $\\star\\star\\star$ 1045. Customers Who Bought All Products $\\star\\star$ \ud83d\udd12 1046. Last Stone Weight $\\star$ 1047. Remove All Adjacent Duplicates In String $\\star$ 1048. Longest String Chain $\\star\\star$ class Solution : def longestStrChain ( self , words : List [ str ]) -> int : dp = {} for word in sorted ( words , key = len ): dp [ word ] = max ( dp . get ( word [: i ] + word [ i + 1 :], 0 ) + 1 for i in range ( len ( word ))) return max ( dp . values ()) 1049. Last Stone Weight II $\\star\\star$ class Solution : def lastStoneWeightII ( self , stones : List [ int ]) -> int : summ = sum ( stones ) s = 0 dp = [ True ] + [ False ] * summ for stone in stones : for w in range ( summ // 2 + 1 )[:: - 1 ]: if w >= stone : dp [ w ] = dp [ w ] or dp [ w - stone ] if dp [ w ]: s = max ( s , w ) return summ - 2 * s 1050. Actors and Directors Who Cooperated At Least Three Times $\\star$ \ud83d\udd12","title":"1041-1050"},{"location":"python3/1001-1100/1041-1050/#1041-robot-bounded-in-circle-starstar","text":"class Solution : def isRobotBounded ( self , instructions : str ) -> bool : x = 0 y = 0 d = 0 directions = [( 0 , 1 ), ( 1 , 0 ), ( 0 , - 1 ), ( - 1 , 0 )] for instruction in instructions : if instruction == 'G' : x += directions [ d ][ 0 ] y += directions [ d ][ 1 ] elif instruction == 'L' : d = ( d + 3 ) % 4 else : d = ( d + 1 ) % 4 return ( x , y ) == ( 0 , 0 ) or d > 0","title":"1041. Robot Bounded In Circle $\\star\\star$"},{"location":"python3/1001-1100/1041-1050/#1042-flower-planting-with-no-adjacent-star","text":"","title":"1042. Flower Planting With No Adjacent $\\star$"},{"location":"python3/1001-1100/1041-1050/#1043-partition-array-for-maximum-sum-starstar","text":"","title":"1043. Partition Array for Maximum Sum $\\star\\star$"},{"location":"python3/1001-1100/1041-1050/#1044-longest-duplicate-substring-starstarstar","text":"","title":"1044. Longest Duplicate Substring $\\star\\star\\star$"},{"location":"python3/1001-1100/1041-1050/#1045-customers-who-bought-all-products-starstar","text":"","title":"1045. Customers Who Bought All Products $\\star\\star$ \ud83d\udd12"},{"location":"python3/1001-1100/1041-1050/#1046-last-stone-weight-star","text":"","title":"1046. Last Stone Weight $\\star$"},{"location":"python3/1001-1100/1041-1050/#1047-remove-all-adjacent-duplicates-in-string-star","text":"","title":"1047. Remove All Adjacent Duplicates In String $\\star$"},{"location":"python3/1001-1100/1041-1050/#1048-longest-string-chain-starstar","text":"class Solution : def longestStrChain ( self , words : List [ str ]) -> int : dp = {} for word in sorted ( words , key = len ): dp [ word ] = max ( dp . get ( word [: i ] + word [ i + 1 :], 0 ) + 1 for i in range ( len ( word ))) return max ( dp . values ())","title":"1048. Longest String Chain $\\star\\star$"},{"location":"python3/1001-1100/1041-1050/#1049-last-stone-weight-ii-starstar","text":"class Solution : def lastStoneWeightII ( self , stones : List [ int ]) -> int : summ = sum ( stones ) s = 0 dp = [ True ] + [ False ] * summ for stone in stones : for w in range ( summ // 2 + 1 )[:: - 1 ]: if w >= stone : dp [ w ] = dp [ w ] or dp [ w - stone ] if dp [ w ]: s = max ( s , w ) return summ - 2 * s","title":"1049. Last Stone Weight II $\\star\\star$"},{"location":"python3/1001-1100/1041-1050/#1050-actors-and-directors-who-cooperated-at-least-three-times-star","text":"","title":"1050. Actors and Directors Who Cooperated At Least Three Times $\\star$ \ud83d\udd12"},{"location":"python3/1001-1100/1051-1060/","text":"1051. Height Checker $\\star$ class Solution : def heightChecker ( self , heights : List [ int ]) -> int : ans = 0 currentHeight = 1 count = [ 0 ] * 101 for height in heights : count [ height ] += 1 for height in heights : while count [ currentHeight ] == 0 : currentHeight += 1 if height != currentHeight : ans += 1 count [ currentHeight ] -= 1 return ans 1052. Grumpy Bookstore Owner $\\star\\star$ class Solution : def maxSatisfied ( self , customers : List [ int ], grumpy : List [ int ], X : int ) -> int : satisfied = sum ( c for i , c in enumerate ( customers ) if grumpy [ i ] == 0 ) madeSatisfied = 0 windowSatisfied = 0 for i , customer in enumerate ( customers ): if grumpy [ i ] == 1 : windowSatisfied += customer if i >= X and grumpy [ i - X ] == 1 : windowSatisfied -= customers [ i - X ] madeSatisfied = max ( madeSatisfied , windowSatisfied ) return satisfied + madeSatisfied 1053. Previous Permutation With One Swap $\\star\\star$ class Solution : def prevPermOpt1 ( self , A : List [ int ]) -> List [ int ]: n = len ( A ) l = n - 2 r = n - 1 while l >= 0 and A [ l ] <= A [ l + 1 ]: l -= 1 if l < 0 : return A while A [ r ] >= A [ l ] or A [ r ] == A [ r - 1 ]: r -= 1 A [ l ], A [ r ] = A [ r ], A [ l ] return A 1054. Distant Barcodes $\\star\\star$ 1055. Shortest Way to Form String $\\star\\star$ \ud83d\udd12 1056. Confusing Number $\\star$ \ud83d\udd12 1057. Campus Bikes $\\star\\star$ \ud83d\udd12 1058. Minimize Rounding Error to Meet Target $\\star\\star$ \ud83d\udd12 1059. All Paths from Source Lead to Destination $\\star\\star$ \ud83d\udd12 1060. Missing Element in Sorted Array $\\star\\star$ \ud83d\udd12","title":"1051-1060"},{"location":"python3/1001-1100/1051-1060/#1051-height-checker-star","text":"class Solution : def heightChecker ( self , heights : List [ int ]) -> int : ans = 0 currentHeight = 1 count = [ 0 ] * 101 for height in heights : count [ height ] += 1 for height in heights : while count [ currentHeight ] == 0 : currentHeight += 1 if height != currentHeight : ans += 1 count [ currentHeight ] -= 1 return ans","title":"1051. Height Checker $\\star$"},{"location":"python3/1001-1100/1051-1060/#1052-grumpy-bookstore-owner-starstar","text":"class Solution : def maxSatisfied ( self , customers : List [ int ], grumpy : List [ int ], X : int ) -> int : satisfied = sum ( c for i , c in enumerate ( customers ) if grumpy [ i ] == 0 ) madeSatisfied = 0 windowSatisfied = 0 for i , customer in enumerate ( customers ): if grumpy [ i ] == 1 : windowSatisfied += customer if i >= X and grumpy [ i - X ] == 1 : windowSatisfied -= customers [ i - X ] madeSatisfied = max ( madeSatisfied , windowSatisfied ) return satisfied + madeSatisfied","title":"1052. Grumpy Bookstore Owner $\\star\\star$"},{"location":"python3/1001-1100/1051-1060/#1053-previous-permutation-with-one-swap-starstar","text":"class Solution : def prevPermOpt1 ( self , A : List [ int ]) -> List [ int ]: n = len ( A ) l = n - 2 r = n - 1 while l >= 0 and A [ l ] <= A [ l + 1 ]: l -= 1 if l < 0 : return A while A [ r ] >= A [ l ] or A [ r ] == A [ r - 1 ]: r -= 1 A [ l ], A [ r ] = A [ r ], A [ l ] return A","title":"1053. Previous Permutation With One Swap $\\star\\star$"},{"location":"python3/1001-1100/1051-1060/#1054-distant-barcodes-starstar","text":"","title":"1054. Distant Barcodes $\\star\\star$"},{"location":"python3/1001-1100/1051-1060/#1055-shortest-way-to-form-string-starstar","text":"","title":"1055. Shortest Way to Form String $\\star\\star$ \ud83d\udd12"},{"location":"python3/1001-1100/1051-1060/#1056-confusing-number-star","text":"","title":"1056. Confusing Number $\\star$ \ud83d\udd12"},{"location":"python3/1001-1100/1051-1060/#1057-campus-bikes-starstar","text":"","title":"1057. Campus Bikes $\\star\\star$ \ud83d\udd12"},{"location":"python3/1001-1100/1051-1060/#1058-minimize-rounding-error-to-meet-target-starstar","text":"","title":"1058. Minimize Rounding Error to Meet Target $\\star\\star$ \ud83d\udd12"},{"location":"python3/1001-1100/1051-1060/#1059-all-paths-from-source-lead-to-destination-starstar","text":"","title":"1059. All Paths from Source Lead to Destination $\\star\\star$ \ud83d\udd12"},{"location":"python3/1001-1100/1051-1060/#1060-missing-element-in-sorted-array-starstar","text":"","title":"1060. Missing Element in Sorted Array $\\star\\star$ \ud83d\udd12"},{"location":"python3/1001-1100/1061-1070/","text":"1061. Lexicographically Smallest Equivalent String $\\star\\star$ \ud83d\udd12 1062. Longest Repeating Substring $\\star\\star$ \ud83d\udd12 1063. Number of Valid Subarrays $\\star\\star\\star$ \ud83d\udd12 1064. Fixed Point $\\star$ \ud83d\udd12 1065. Index Pairs of a String $\\star$ \ud83d\udd12 1066. Campus Bikes II $\\star\\star$ \ud83d\udd12 1067. Digit Count in Range $\\star\\star\\star$ \ud83d\udd12 1068. Product Sales Analysis I $\\star$ \ud83d\udd12 1069. Product Sales Analysis II $\\star$ \ud83d\udd12 1070. Product Sales Analysis III $\\star\\star$ \ud83d\udd12","title":"1061-1070"},{"location":"python3/1001-1100/1061-1070/#1061-lexicographically-smallest-equivalent-string-starstar","text":"","title":"1061. Lexicographically Smallest Equivalent String $\\star\\star$ \ud83d\udd12"},{"location":"python3/1001-1100/1061-1070/#1062-longest-repeating-substring-starstar","text":"","title":"1062. Longest Repeating Substring $\\star\\star$ \ud83d\udd12"},{"location":"python3/1001-1100/1061-1070/#1063-number-of-valid-subarrays-starstarstar","text":"","title":"1063. Number of Valid Subarrays $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/1001-1100/1061-1070/#1064-fixed-point-star","text":"","title":"1064. Fixed Point $\\star$ \ud83d\udd12"},{"location":"python3/1001-1100/1061-1070/#1065-index-pairs-of-a-string-star","text":"","title":"1065. Index Pairs of a String $\\star$ \ud83d\udd12"},{"location":"python3/1001-1100/1061-1070/#1066-campus-bikes-ii-starstar","text":"","title":"1066. Campus Bikes II $\\star\\star$ \ud83d\udd12"},{"location":"python3/1001-1100/1061-1070/#1067-digit-count-in-range-starstarstar","text":"","title":"1067. Digit Count in Range $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/1001-1100/1061-1070/#1068-product-sales-analysis-i-star","text":"","title":"1068. Product Sales Analysis I $\\star$ \ud83d\udd12"},{"location":"python3/1001-1100/1061-1070/#1069-product-sales-analysis-ii-star","text":"","title":"1069. Product Sales Analysis II $\\star$ \ud83d\udd12"},{"location":"python3/1001-1100/1061-1070/#1070-product-sales-analysis-iii-starstar","text":"","title":"1070. Product Sales Analysis III $\\star\\star$ \ud83d\udd12"},{"location":"python3/1001-1100/1071-1080/","text":"1071. Greatest Common Divisor of Strings $\\star$ class Solution : def gcdOfStrings ( self , str1 : str , str2 : str ) -> str : def mod ( s1 : str , s2 : str ) -> str : while s1 . startswith ( s2 ): s1 = s1 [ len ( s2 ):] return s1 if len ( str1 ) < len ( str2 ): return self . gcdOfStrings ( str2 , str1 ) if not str1 . startswith ( str2 ): return '' if not str2 : return str1 return self . gcdOfStrings ( str2 , mod ( str1 , str2 )) 1072. Flip Columns For Maximum Number of Equal Rows $\\star\\star$ class Solution : def maxEqualRowsAfterFlips ( self , matrix : List [ List [ int ]]) -> int : patterns = [ tuple ( a ^ row [ 0 ] for a in row ) for row in matrix ] return max ( collections . Counter ( patterns ) . values ()) 1073. Adding Two Negabinary Numbers $\\star\\star$ class Solution : def addNegabinary ( self , arr1 : List [ int ], arr2 : List [ int ]) -> List [ int ]: ans = [] carry = 0 while carry or arr1 or arr2 : if arr1 : carry += arr1 . pop () if arr2 : carry += arr2 . pop () ans . append ( carry & 1 ) carry = - ( carry >> 1 ) while len ( ans ) > 1 and ans [ - 1 ] == 0 : ans . pop () return ans [:: - 1 ] 1074. Number of Submatrices That Sum to Target $\\star\\star\\star$ class Solution : def numSubmatrixSumTarget ( self , matrix : List [ List [ int ]], target : int ) -> int : m = len ( matrix ) n = len ( matrix [ 0 ]) ans = 0 for row in matrix : for j in range ( 1 , n ): row [ j ] += row [ j - 1 ] for col in range ( n ): for j in range ( col , n ): count = { 0 : 1 } sum = 0 for i in range ( m ): sum += matrix [ i ][ j ] - \\ ( matrix [ i ][ col - 1 ] if col > 0 else 0 ) ans += count . get ( sum - target , 0 ) count [ sum ] = count . get ( sum , 0 ) + 1 return ans 1075. Project Employees I $\\star$ \ud83d\udd12 1076. Project Employees II $\\star$ \ud83d\udd12 1077. Project Employees III $\\star\\star$ \ud83d\udd12 1078. Occurrences After Bigram $\\star$ class Solution : def findOcurrences ( self , text : str , first : str , second : str ) -> List [ str ]: words = text . split () return [ c for a , b , c in zip ( words , words [ 1 :], words [ 2 :]) if a == first and b == second ] 1079. Letter Tile Possibilities $\\star\\star$ 1080. Insufficient Nodes in Root to Leaf Paths $\\star\\star$","title":"1071-1080"},{"location":"python3/1001-1100/1071-1080/#1071-greatest-common-divisor-of-strings-star","text":"class Solution : def gcdOfStrings ( self , str1 : str , str2 : str ) -> str : def mod ( s1 : str , s2 : str ) -> str : while s1 . startswith ( s2 ): s1 = s1 [ len ( s2 ):] return s1 if len ( str1 ) < len ( str2 ): return self . gcdOfStrings ( str2 , str1 ) if not str1 . startswith ( str2 ): return '' if not str2 : return str1 return self . gcdOfStrings ( str2 , mod ( str1 , str2 ))","title":"1071. Greatest Common Divisor of Strings $\\star$"},{"location":"python3/1001-1100/1071-1080/#1072-flip-columns-for-maximum-number-of-equal-rows-starstar","text":"class Solution : def maxEqualRowsAfterFlips ( self , matrix : List [ List [ int ]]) -> int : patterns = [ tuple ( a ^ row [ 0 ] for a in row ) for row in matrix ] return max ( collections . Counter ( patterns ) . values ())","title":"1072. Flip Columns For Maximum Number of Equal Rows $\\star\\star$"},{"location":"python3/1001-1100/1071-1080/#1073-adding-two-negabinary-numbers-starstar","text":"class Solution : def addNegabinary ( self , arr1 : List [ int ], arr2 : List [ int ]) -> List [ int ]: ans = [] carry = 0 while carry or arr1 or arr2 : if arr1 : carry += arr1 . pop () if arr2 : carry += arr2 . pop () ans . append ( carry & 1 ) carry = - ( carry >> 1 ) while len ( ans ) > 1 and ans [ - 1 ] == 0 : ans . pop () return ans [:: - 1 ]","title":"1073. Adding Two Negabinary Numbers $\\star\\star$"},{"location":"python3/1001-1100/1071-1080/#1074-number-of-submatrices-that-sum-to-target-starstarstar","text":"class Solution : def numSubmatrixSumTarget ( self , matrix : List [ List [ int ]], target : int ) -> int : m = len ( matrix ) n = len ( matrix [ 0 ]) ans = 0 for row in matrix : for j in range ( 1 , n ): row [ j ] += row [ j - 1 ] for col in range ( n ): for j in range ( col , n ): count = { 0 : 1 } sum = 0 for i in range ( m ): sum += matrix [ i ][ j ] - \\ ( matrix [ i ][ col - 1 ] if col > 0 else 0 ) ans += count . get ( sum - target , 0 ) count [ sum ] = count . get ( sum , 0 ) + 1 return ans","title":"1074. Number of Submatrices That Sum to Target $\\star\\star\\star$"},{"location":"python3/1001-1100/1071-1080/#1075-project-employees-i-star","text":"","title":"1075. Project Employees I $\\star$ \ud83d\udd12"},{"location":"python3/1001-1100/1071-1080/#1076-project-employees-ii-star","text":"","title":"1076. Project Employees II $\\star$ \ud83d\udd12"},{"location":"python3/1001-1100/1071-1080/#1077-project-employees-iii-starstar","text":"","title":"1077. Project Employees III $\\star\\star$ \ud83d\udd12"},{"location":"python3/1001-1100/1071-1080/#1078-occurrences-after-bigram-star","text":"class Solution : def findOcurrences ( self , text : str , first : str , second : str ) -> List [ str ]: words = text . split () return [ c for a , b , c in zip ( words , words [ 1 :], words [ 2 :]) if a == first and b == second ]","title":"1078. Occurrences After Bigram $\\star$"},{"location":"python3/1001-1100/1071-1080/#1079-letter-tile-possibilities-starstar","text":"","title":"1079. Letter Tile Possibilities $\\star\\star$"},{"location":"python3/1001-1100/1071-1080/#1080-insufficient-nodes-in-root-to-leaf-paths-starstar","text":"","title":"1080. Insufficient Nodes in Root to Leaf Paths $\\star\\star$"},{"location":"python3/1001-1100/1081-1090/","text":"1081. Smallest Subsequence of Distinct Characters $\\star\\star$ class Solution : def smallestSubsequence ( self , text : str ) -> str : ans = [] count = collections . Counter ( text ) used = [ False ] * 26 for c in text : count [ c ] -= 1 if used [ ord ( c ) - ord ( 'a' )]: continue while ans and ans [ - 1 ] > c and count [ ans [ - 1 ]] > 0 : used [ ord ( ans [ - 1 ]) - ord ( 'a' )] = False ans . pop () ans . append ( c ) used [ ord ( ans [ - 1 ]) - ord ( 'a' )] = True return '' . join ( ans ) 1082. Sales Analysis I $\\star$ \ud83d\udd12 1083. Sales Analysis II $\\star$ \ud83d\udd12 1084. Sales Analysis III $\\star$ \ud83d\udd12 1085. Sum of Digits in the Minimum Number $\\star$ \ud83d\udd12 1086. High Five $\\star$ \ud83d\udd12 1087. Brace Expansion $\\star\\star$ \ud83d\udd12 1088. Confusing Number II $\\star\\star\\star$ \ud83d\udd12 1089. Duplicate Zeros $\\star$ class Solution : def duplicateZeros ( self , arr : List [ int ]) -> None : zeros = arr . count ( 0 ) i = len ( arr ) - 1 j = len ( arr ) + zeros - 1 while i < j : if j < len ( arr ): arr [ j ] = arr [ i ] if arr [ i ] == 0 : j -= 1 if j < len ( arr ): arr [ j ] = arr [ i ] i -= 1 j -= 1 1090. Largest Values From Labels $\\star\\star$","title":"1081-1090"},{"location":"python3/1001-1100/1081-1090/#1081-smallest-subsequence-of-distinct-characters-starstar","text":"class Solution : def smallestSubsequence ( self , text : str ) -> str : ans = [] count = collections . Counter ( text ) used = [ False ] * 26 for c in text : count [ c ] -= 1 if used [ ord ( c ) - ord ( 'a' )]: continue while ans and ans [ - 1 ] > c and count [ ans [ - 1 ]] > 0 : used [ ord ( ans [ - 1 ]) - ord ( 'a' )] = False ans . pop () ans . append ( c ) used [ ord ( ans [ - 1 ]) - ord ( 'a' )] = True return '' . join ( ans )","title":"1081. Smallest Subsequence of Distinct Characters $\\star\\star$"},{"location":"python3/1001-1100/1081-1090/#1082-sales-analysis-i-star","text":"","title":"1082. Sales Analysis I $\\star$ \ud83d\udd12"},{"location":"python3/1001-1100/1081-1090/#1083-sales-analysis-ii-star","text":"","title":"1083. Sales Analysis II $\\star$ \ud83d\udd12"},{"location":"python3/1001-1100/1081-1090/#1084-sales-analysis-iii-star","text":"","title":"1084. Sales Analysis III $\\star$ \ud83d\udd12"},{"location":"python3/1001-1100/1081-1090/#1085-sum-of-digits-in-the-minimum-number-star","text":"","title":"1085. Sum of Digits in the Minimum Number $\\star$ \ud83d\udd12"},{"location":"python3/1001-1100/1081-1090/#1086-high-five-star","text":"","title":"1086. High Five $\\star$ \ud83d\udd12"},{"location":"python3/1001-1100/1081-1090/#1087-brace-expansion-starstar","text":"","title":"1087. Brace Expansion $\\star\\star$ \ud83d\udd12"},{"location":"python3/1001-1100/1081-1090/#1088-confusing-number-ii-starstarstar","text":"","title":"1088. Confusing Number II $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/1001-1100/1081-1090/#1089-duplicate-zeros-star","text":"class Solution : def duplicateZeros ( self , arr : List [ int ]) -> None : zeros = arr . count ( 0 ) i = len ( arr ) - 1 j = len ( arr ) + zeros - 1 while i < j : if j < len ( arr ): arr [ j ] = arr [ i ] if arr [ i ] == 0 : j -= 1 if j < len ( arr ): arr [ j ] = arr [ i ] i -= 1 j -= 1","title":"1089. Duplicate Zeros $\\star$"},{"location":"python3/1001-1100/1081-1090/#1090-largest-values-from-labels-starstar","text":"","title":"1090. Largest Values From Labels $\\star\\star$"},{"location":"python3/1001-1100/1091-1100/","text":"1091. Shortest Path in Binary Matrix $\\star\\star$ 1092. Shortest Common Supersequence $\\star\\star\\star$ 1093. Statistics from a Large Sample $\\star\\star$ class Solution : def sampleStats ( self , count : List [ int ]) -> List [ float ]: minimum = 0 maximum = 0 mean = 0 leftMedian = 0 rightMedian = 0 mode = - 1 numCount = sum ( count ) newNumCount = 0 maxCount = 0 for i , c in enumerate ( count ): if c > 0 : minimum = i break for i in range ( len ( count ) - 1 , - 1 , - 1 ): if count [ i ] > 0 : maximum = i break for i , c in enumerate ( count ): mean += ( i * c ) / numCount for i , c in enumerate ( count ): newNumCount += c if newNumCount >= numCount // 2 : leftMedian = i break newNumCount = 0 for i in range ( len ( count ) - 1 , - 1 , - 1 ): newNumCount += count [ i ] if newNumCount >= numCount // 2 : rightMedian = i break for i , c in enumerate ( count ): if c > maxCount : maxCount = c mode = i return [ minimum , maximum , mean , ( leftMedian + rightMedian ) / 2 , mode ] 1094. Car Pooling $\\star\\star$ 1095. Find in Mountain Array $\\star\\star\\star$ 1096. Brace Expansion II $\\star\\star\\star$ class Solution : def braceExpansionII ( self , expression : str ) -> List [ str ]: def merge ( groups : List [ List [ str ]], group : List [ str ]) -> None : if not groups [ - 1 ]: groups [ - 1 ] = group return groups [ - 1 ] = [ word1 + word2 for word1 in groups [ - 1 ] for word2 in group ] def dfs ( s : int , e : int ) -> List [ str ]: ans = [] groups = [[]] layer = 0 for i in range ( s , e + 1 ): c = expression [ i ] if c == '{' : layer += 1 if layer == 1 : left = i + 1 elif c == '}' : layer -= 1 if layer == 0 : group = dfs ( left , i - 1 ) merge ( groups , group ) elif c == ',' and layer == 0 : groups . append ([]) elif layer == 0 : merge ( groups , [ c ]) return sorted ( list ({ word for group in groups for word in group })) return dfs ( 0 , len ( expression ) - 1 ) 1097. Game Play Analysis V $\\star\\star\\star$ \ud83d\udd12 1098. Unpopular Books $\\star\\star$ \ud83d\udd12 1099. Two Sum Less Than K $\\star$ \ud83d\udd12 1100. Find K-Length Substrings With No Repeated Characters $\\star\\star$ \ud83d\udd12","title":"1091-1100"},{"location":"python3/1001-1100/1091-1100/#1091-shortest-path-in-binary-matrix-starstar","text":"","title":"1091. Shortest Path in Binary Matrix $\\star\\star$"},{"location":"python3/1001-1100/1091-1100/#1092-shortest-common-supersequence-starstarstar","text":"","title":"1092. Shortest Common Supersequence  $\\star\\star\\star$"},{"location":"python3/1001-1100/1091-1100/#1093-statistics-from-a-large-sample-starstar","text":"class Solution : def sampleStats ( self , count : List [ int ]) -> List [ float ]: minimum = 0 maximum = 0 mean = 0 leftMedian = 0 rightMedian = 0 mode = - 1 numCount = sum ( count ) newNumCount = 0 maxCount = 0 for i , c in enumerate ( count ): if c > 0 : minimum = i break for i in range ( len ( count ) - 1 , - 1 , - 1 ): if count [ i ] > 0 : maximum = i break for i , c in enumerate ( count ): mean += ( i * c ) / numCount for i , c in enumerate ( count ): newNumCount += c if newNumCount >= numCount // 2 : leftMedian = i break newNumCount = 0 for i in range ( len ( count ) - 1 , - 1 , - 1 ): newNumCount += count [ i ] if newNumCount >= numCount // 2 : rightMedian = i break for i , c in enumerate ( count ): if c > maxCount : maxCount = c mode = i return [ minimum , maximum , mean , ( leftMedian + rightMedian ) / 2 , mode ]","title":"1093. Statistics from a Large Sample $\\star\\star$"},{"location":"python3/1001-1100/1091-1100/#1094-car-pooling-starstar","text":"","title":"1094. Car Pooling $\\star\\star$"},{"location":"python3/1001-1100/1091-1100/#1095-find-in-mountain-array-starstarstar","text":"","title":"1095. Find in Mountain Array $\\star\\star\\star$"},{"location":"python3/1001-1100/1091-1100/#1096-brace-expansion-ii-starstarstar","text":"class Solution : def braceExpansionII ( self , expression : str ) -> List [ str ]: def merge ( groups : List [ List [ str ]], group : List [ str ]) -> None : if not groups [ - 1 ]: groups [ - 1 ] = group return groups [ - 1 ] = [ word1 + word2 for word1 in groups [ - 1 ] for word2 in group ] def dfs ( s : int , e : int ) -> List [ str ]: ans = [] groups = [[]] layer = 0 for i in range ( s , e + 1 ): c = expression [ i ] if c == '{' : layer += 1 if layer == 1 : left = i + 1 elif c == '}' : layer -= 1 if layer == 0 : group = dfs ( left , i - 1 ) merge ( groups , group ) elif c == ',' and layer == 0 : groups . append ([]) elif layer == 0 : merge ( groups , [ c ]) return sorted ( list ({ word for group in groups for word in group })) return dfs ( 0 , len ( expression ) - 1 )","title":"1096. Brace Expansion II $\\star\\star\\star$"},{"location":"python3/1001-1100/1091-1100/#1097-game-play-analysis-v-starstarstar","text":"","title":"1097. Game Play Analysis V $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/1001-1100/1091-1100/#1098-unpopular-books-starstar","text":"","title":"1098. Unpopular Books $\\star\\star$ \ud83d\udd12"},{"location":"python3/1001-1100/1091-1100/#1099-two-sum-less-than-k-star","text":"","title":"1099. Two Sum Less Than K $\\star$ \ud83d\udd12"},{"location":"python3/1001-1100/1091-1100/#1100-find-k-length-substrings-with-no-repeated-characters-starstar","text":"","title":"1100. Find K-Length Substrings With No Repeated Characters $\\star\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1101-1110/","text":"1101. The Earliest Moment When Everyone Become Friends $\\star\\star$ \ud83d\udd12 1102. Path With Maximum Minimum Value $\\star\\star$ \ud83d\udd12 1103. Distribute Candies to People $\\star$ class Solution : def distributeCandies ( self , candies : int , n : int ) -> List [ int ]: ans = [ 0 ] * n rows = int (( - n + ( n ** 2 + 8 * n ** 2 * candies ) ** 0.5 ) / ( 2 * n ** 2 )) accumN = rows * ( rows - 1 ) * n // 2 for i in range ( n ): ans [ i ] = accumN + rows * ( i + 1 ) givenCandies = ( n ** 2 * rows ** 2 + n * rows ) // 2 candies -= givenCandies lastGiven = rows * n i = 0 while candies > 0 : lastGiven += 1 actualGiven = min ( lastGiven , candies ) candies -= actualGiven ans [ i ] += actualGiven i += 1 return ans 1104. Path In Zigzag Labelled Binary Tree $\\star\\star$ class Solution : def pathInZigZagTree ( self , label : int ) -> List [ int ]: def boundarySum ( level : int ): return 2 ** level + 2 ** ( level + 1 ) - 1 ans = [] for l in range ( 21 ): if 2 ** l > label : level = l - 1 break if level & 1 : label = boundarySum ( level ) - label for l in range ( level + 1 )[:: - 1 ]: ans . append ( boundarySum ( l ) - label if l & 1 else label ) label //= 2 return ans [:: - 1 ] 1105. Filling Bookcase Shelves $\\star\\star$ 1106. Parsing A Boolean Expression $\\star\\star\\star$ class Solution : def parseBoolExpr ( self , expression : str ) -> bool : def dfs ( s : int , e : int ) -> List [ str ]: if s == e : return True if expression [ s ] == 't' else False exps = [] layer = 0 for i in range ( s , e + 1 ): c = expression [ i ] if layer == 0 and c in '!&|' : op = c elif c == '(' : layer += 1 if layer == 1 : left = i + 1 elif c == ')' : layer -= 1 if layer == 0 : exps . append ( dfs ( left , i - 1 )) elif c == ',' and layer == 1 : exps . append ( dfs ( left , i - 1 )) left = i + 1 if op == '|' : return functools . reduce ( lambda x , y : x | y , exps ) if op == '&' : return functools . reduce ( lambda x , y : x & y , exps ) if op == '!' : return not exps [ 0 ] return dfs ( 0 , len ( expression ) - 1 ) 1107. New Users Daily Count $\\star\\star$ \ud83d\udd12 1108. Defanging an IP Address $\\star$ class Solution : def defangIPaddr ( self , address : str ) -> str : return address . replace ( '.' , '[.]' ) 1109. Corporate Flight Bookings $\\star\\star$ class Solution : def corpFlightBookings ( self , bookings : List [ List [ int ]], n : int ) -> List [ int ]: ans = [ 0 ] * n for booking in bookings : ans [ booking [ 0 ] - 1 ] += booking [ 2 ] if booking [ 1 ] < n : ans [ booking [ 1 ]] -= booking [ 2 ] for i in range ( 1 , n ): ans [ i ] += ans [ i - 1 ] return ans 1110. Delete Nodes And Return Forest $\\star\\star$","title":"1101-1110"},{"location":"python3/1101-1200/1101-1110/#1101-the-earliest-moment-when-everyone-become-friends-starstar","text":"","title":"1101. The Earliest Moment When Everyone Become Friends $\\star\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1101-1110/#1102-path-with-maximum-minimum-value-starstar","text":"","title":"1102. Path With Maximum Minimum Value $\\star\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1101-1110/#1103-distribute-candies-to-people-star","text":"class Solution : def distributeCandies ( self , candies : int , n : int ) -> List [ int ]: ans = [ 0 ] * n rows = int (( - n + ( n ** 2 + 8 * n ** 2 * candies ) ** 0.5 ) / ( 2 * n ** 2 )) accumN = rows * ( rows - 1 ) * n // 2 for i in range ( n ): ans [ i ] = accumN + rows * ( i + 1 ) givenCandies = ( n ** 2 * rows ** 2 + n * rows ) // 2 candies -= givenCandies lastGiven = rows * n i = 0 while candies > 0 : lastGiven += 1 actualGiven = min ( lastGiven , candies ) candies -= actualGiven ans [ i ] += actualGiven i += 1 return ans","title":"1103. Distribute Candies to People $\\star$"},{"location":"python3/1101-1200/1101-1110/#1104-path-in-zigzag-labelled-binary-tree-starstar","text":"class Solution : def pathInZigZagTree ( self , label : int ) -> List [ int ]: def boundarySum ( level : int ): return 2 ** level + 2 ** ( level + 1 ) - 1 ans = [] for l in range ( 21 ): if 2 ** l > label : level = l - 1 break if level & 1 : label = boundarySum ( level ) - label for l in range ( level + 1 )[:: - 1 ]: ans . append ( boundarySum ( l ) - label if l & 1 else label ) label //= 2 return ans [:: - 1 ]","title":"1104. Path In Zigzag Labelled Binary Tree $\\star\\star$"},{"location":"python3/1101-1200/1101-1110/#1105-filling-bookcase-shelves-starstar","text":"","title":"1105. Filling Bookcase Shelves $\\star\\star$"},{"location":"python3/1101-1200/1101-1110/#1106-parsing-a-boolean-expression-starstarstar","text":"class Solution : def parseBoolExpr ( self , expression : str ) -> bool : def dfs ( s : int , e : int ) -> List [ str ]: if s == e : return True if expression [ s ] == 't' else False exps = [] layer = 0 for i in range ( s , e + 1 ): c = expression [ i ] if layer == 0 and c in '!&|' : op = c elif c == '(' : layer += 1 if layer == 1 : left = i + 1 elif c == ')' : layer -= 1 if layer == 0 : exps . append ( dfs ( left , i - 1 )) elif c == ',' and layer == 1 : exps . append ( dfs ( left , i - 1 )) left = i + 1 if op == '|' : return functools . reduce ( lambda x , y : x | y , exps ) if op == '&' : return functools . reduce ( lambda x , y : x & y , exps ) if op == '!' : return not exps [ 0 ] return dfs ( 0 , len ( expression ) - 1 )","title":"1106. Parsing A Boolean Expression $\\star\\star\\star$"},{"location":"python3/1101-1200/1101-1110/#1107-new-users-daily-count-starstar","text":"","title":"1107. New Users Daily Count $\\star\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1101-1110/#1108-defanging-an-ip-address-star","text":"class Solution : def defangIPaddr ( self , address : str ) -> str : return address . replace ( '.' , '[.]' )","title":"1108. Defanging an IP Address $\\star$"},{"location":"python3/1101-1200/1101-1110/#1109-corporate-flight-bookings-starstar","text":"class Solution : def corpFlightBookings ( self , bookings : List [ List [ int ]], n : int ) -> List [ int ]: ans = [ 0 ] * n for booking in bookings : ans [ booking [ 0 ] - 1 ] += booking [ 2 ] if booking [ 1 ] < n : ans [ booking [ 1 ]] -= booking [ 2 ] for i in range ( 1 , n ): ans [ i ] += ans [ i - 1 ] return ans","title":"1109. Corporate Flight Bookings $\\star\\star$"},{"location":"python3/1101-1200/1101-1110/#1110-delete-nodes-and-return-forest-starstar","text":"","title":"1110. Delete Nodes And Return Forest $\\star\\star$"},{"location":"python3/1101-1200/1111-1120/","text":"1111. Maximum Nesting Depth of Two Valid Parentheses Strings $\\star\\star$ 1112. Highest Grade For Each Student $\\star\\star$ \ud83d\udd12 1113. Reported Posts $\\star$ \ud83d\udd12 1114. Print in Order $\\star$ from threading import Lock class Foo : def __init__ ( self ): self . mutex2 = Lock () self . mutex3 = Lock () self . mutex2 . acquire () self . mutex3 . acquire () def first ( self , printFirst : 'Callable[[], None]' ) -> None : printFirst () self . mutex2 . release () def second ( self , printSecond : 'Callable[[], None]' ) -> None : self . mutex2 . acquire () printSecond () self . mutex3 . release () def third ( self , printThird : 'Callable[[], None]' ) -> None : self . mutex3 . acquire () printThird () 1115. Print FooBar Alternately $\\star\\star$ 1116. Print Zero Even Odd $\\star\\star$ 1117. Building H2O $\\star\\star$ 1118. Number of Days in a Month $\\star$ \ud83d\udd12 1119. Remove Vowels from a String $\\star$ \ud83d\udd12 1120. Maximum Average Subtree $\\star\\star$ \ud83d\udd12","title":"1111-1120"},{"location":"python3/1101-1200/1111-1120/#1111-maximum-nesting-depth-of-two-valid-parentheses-strings-starstar","text":"","title":"1111. Maximum Nesting Depth of Two Valid Parentheses Strings $\\star\\star$"},{"location":"python3/1101-1200/1111-1120/#1112-highest-grade-for-each-student-starstar","text":"","title":"1112. Highest Grade For Each Student $\\star\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1111-1120/#1113-reported-posts-star","text":"","title":"1113. Reported Posts $\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1111-1120/#1114-print-in-order-star","text":"from threading import Lock class Foo : def __init__ ( self ): self . mutex2 = Lock () self . mutex3 = Lock () self . mutex2 . acquire () self . mutex3 . acquire () def first ( self , printFirst : 'Callable[[], None]' ) -> None : printFirst () self . mutex2 . release () def second ( self , printSecond : 'Callable[[], None]' ) -> None : self . mutex2 . acquire () printSecond () self . mutex3 . release () def third ( self , printThird : 'Callable[[], None]' ) -> None : self . mutex3 . acquire () printThird ()","title":"1114. Print in Order $\\star$"},{"location":"python3/1101-1200/1111-1120/#1115-print-foobar-alternately-starstar","text":"","title":"1115. Print FooBar Alternately $\\star\\star$"},{"location":"python3/1101-1200/1111-1120/#1116-print-zero-even-odd-starstar","text":"","title":"1116. Print Zero Even Odd $\\star\\star$"},{"location":"python3/1101-1200/1111-1120/#1117-building-h2o-starstar","text":"","title":"1117. Building H2O $\\star\\star$"},{"location":"python3/1101-1200/1111-1120/#1118-number-of-days-in-a-month-star","text":"","title":"1118. Number of Days in a Month $\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1111-1120/#1119-remove-vowels-from-a-string-star","text":"","title":"1119. Remove Vowels from a String $\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1111-1120/#1120-maximum-average-subtree-starstar","text":"","title":"1120. Maximum Average Subtree $\\star\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1121-1130/","text":"1121. Divide Array Into Increasing Sequences $\\star\\star\\star$ \ud83d\udd12 1122. Relative Sort Array $\\star$ class Solution : def relativeSortArray ( self , arr1 : List [ int ], arr2 : List [ int ]) -> List [ int ]: ans = [] count = [ 0 ] * 1001 for a in arr1 : count [ a ] += 1 for a in arr2 : while count [ a ] > 0 : ans . append ( a ) count [ a ] -= 1 for num in range ( 1001 ): for _ in range ( count [ num ]): ans . append ( num ) return ans 1123. Lowest Common Ancestor of Deepest Leaves $\\star\\star$ 1124. Longest Well-Performing Interval $\\star\\star$ class Solution : def longestWPI ( self , hours : List [ int ]) -> int : ans = 0 prefixSum = 0 dict = {} for i in range ( len ( hours )): prefixSum += 1 if hours [ i ] > 8 else - 1 if prefixSum > 0 : ans = i + 1 else : if prefixSum not in dict : dict [ prefixSum ] = i if prefixSum - 1 in dict : ans = max ( ans , i - dict [ prefixSum - 1 ]) return ans 1125. Smallest Sufficient Team $\\star\\star\\star$ 1126. Active Businesses $\\star\\star$ \ud83d\udd12 1127. User Purchase Platform $\\star\\star\\star$ \ud83d\udd12 1128. Number of Equivalent Domino Pairs $\\star$ class Solution : def numEquivDominoPairs ( self , dominoes : List [ List [ int ]]) -> int : ans = 0 count = collections . Counter () for domino in dominoes : key = min ( domino [ 0 ], domino [ 1 ]) * 10 + max ( domino [ 0 ], domino [ 1 ]) ans += count [ key ] count [ key ] += 1 return ans 1129. Shortest Path with Alternating Colors $\\star\\star$ 1130. Minimum Cost Tree From Leaf Values $\\star\\star$","title":"1121-1130"},{"location":"python3/1101-1200/1121-1130/#1121-divide-array-into-increasing-sequences-starstarstar","text":"","title":"1121. Divide Array Into Increasing Sequences $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1121-1130/#1122-relative-sort-array-star","text":"class Solution : def relativeSortArray ( self , arr1 : List [ int ], arr2 : List [ int ]) -> List [ int ]: ans = [] count = [ 0 ] * 1001 for a in arr1 : count [ a ] += 1 for a in arr2 : while count [ a ] > 0 : ans . append ( a ) count [ a ] -= 1 for num in range ( 1001 ): for _ in range ( count [ num ]): ans . append ( num ) return ans","title":"1122. Relative Sort Array $\\star$"},{"location":"python3/1101-1200/1121-1130/#1123-lowest-common-ancestor-of-deepest-leaves-starstar","text":"","title":"1123. Lowest Common Ancestor of Deepest Leaves $\\star\\star$"},{"location":"python3/1101-1200/1121-1130/#1124-longest-well-performing-interval-starstar","text":"class Solution : def longestWPI ( self , hours : List [ int ]) -> int : ans = 0 prefixSum = 0 dict = {} for i in range ( len ( hours )): prefixSum += 1 if hours [ i ] > 8 else - 1 if prefixSum > 0 : ans = i + 1 else : if prefixSum not in dict : dict [ prefixSum ] = i if prefixSum - 1 in dict : ans = max ( ans , i - dict [ prefixSum - 1 ]) return ans","title":"1124. Longest Well-Performing Interval $\\star\\star$"},{"location":"python3/1101-1200/1121-1130/#1125-smallest-sufficient-team-starstarstar","text":"","title":"1125. Smallest Sufficient Team $\\star\\star\\star$"},{"location":"python3/1101-1200/1121-1130/#1126-active-businesses-starstar","text":"","title":"1126. Active Businesses $\\star\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1121-1130/#1127-user-purchase-platform-starstarstar","text":"","title":"1127. User Purchase Platform $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1121-1130/#1128-number-of-equivalent-domino-pairs-star","text":"class Solution : def numEquivDominoPairs ( self , dominoes : List [ List [ int ]]) -> int : ans = 0 count = collections . Counter () for domino in dominoes : key = min ( domino [ 0 ], domino [ 1 ]) * 10 + max ( domino [ 0 ], domino [ 1 ]) ans += count [ key ] count [ key ] += 1 return ans","title":"1128. Number of Equivalent Domino Pairs $\\star$"},{"location":"python3/1101-1200/1121-1130/#1129-shortest-path-with-alternating-colors-starstar","text":"","title":"1129. Shortest Path with Alternating Colors $\\star\\star$"},{"location":"python3/1101-1200/1121-1130/#1130-minimum-cost-tree-from-leaf-values-starstar","text":"","title":"1130. Minimum Cost Tree From Leaf Values $\\star\\star$"},{"location":"python3/1101-1200/1131-1140/","text":"1131. Maximum of Absolute Value Expression $\\star\\star$ class Solution : def maxAbsValExpr ( self , arr1 : List [ int ], arr2 : List [ int ]) -> int : n = len ( arr1 ) a = [ arr1 [ i ] + arr2 [ i ] + i for i in range ( n )] b = [ arr1 [ i ] + arr2 [ i ] - i for i in range ( n )] c = [ arr1 [ i ] - arr2 [ i ] + i for i in range ( n )] d = [ arr1 [ i ] - arr2 [ i ] - i for i in range ( n )] return max ( map ( lambda x : max ( x ) - min ( x ), ( a , b , c , d ))) 1132. Reported Posts II $\\star\\star$ \ud83d\udd12 1133. Largest Unique Number $\\star$ \ud83d\udd12 1134. Armstrong Number $\\star$ \ud83d\udd12 1135. Connecting Cities With Minimum Cost $\\star\\star$ \ud83d\udd12 1136. Parallel Courses $\\star\\star\\star$ \ud83d\udd12 1137. N-th Tribonacci Number $\\star$ 1138. Alphabet Board Path $\\star\\star$ 1139. Largest 1-Bordered Square $\\star\\star$ 1140. Stone Game II $\\star\\star$","title":"1131-1140"},{"location":"python3/1101-1200/1131-1140/#1131-maximum-of-absolute-value-expression-starstar","text":"class Solution : def maxAbsValExpr ( self , arr1 : List [ int ], arr2 : List [ int ]) -> int : n = len ( arr1 ) a = [ arr1 [ i ] + arr2 [ i ] + i for i in range ( n )] b = [ arr1 [ i ] + arr2 [ i ] - i for i in range ( n )] c = [ arr1 [ i ] - arr2 [ i ] + i for i in range ( n )] d = [ arr1 [ i ] - arr2 [ i ] - i for i in range ( n )] return max ( map ( lambda x : max ( x ) - min ( x ), ( a , b , c , d )))","title":"1131. Maximum of Absolute Value Expression $\\star\\star$"},{"location":"python3/1101-1200/1131-1140/#1132-reported-posts-ii-starstar","text":"","title":"1132. Reported Posts II $\\star\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1131-1140/#1133-largest-unique-number-star","text":"","title":"1133. Largest Unique Number $\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1131-1140/#1134-armstrong-number-star","text":"","title":"1134. Armstrong Number $\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1131-1140/#1135-connecting-cities-with-minimum-cost-starstar","text":"","title":"1135. Connecting Cities With Minimum Cost $\\star\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1131-1140/#1136-parallel-courses-starstarstar","text":"","title":"1136. Parallel Courses $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1131-1140/#1137-n-th-tribonacci-number-star","text":"","title":"1137. N-th Tribonacci Number $\\star$"},{"location":"python3/1101-1200/1131-1140/#1138-alphabet-board-path-starstar","text":"","title":"1138. Alphabet Board Path $\\star\\star$"},{"location":"python3/1101-1200/1131-1140/#1139-largest-1-bordered-square-starstar","text":"","title":"1139. Largest 1-Bordered Square $\\star\\star$"},{"location":"python3/1101-1200/1131-1140/#1140-stone-game-ii-starstar","text":"","title":"1140. Stone Game II $\\star\\star$"},{"location":"python3/1101-1200/1141-1150/","text":"1141. User Activity for the Past 30 Days I $\\star$ \ud83d\udd12 1142. User Activity for the Past 30 Days II $\\star$ \ud83d\udd12 1143. Longest Common Subsequence $\\star\\star$ 1144. Decrease Elements To Make Array Zigzag $\\star\\star$ class Solution : def movesToMakeZigzag ( self , nums : List [ int ]) -> int : decreasing = [ 0 ] * 2 for i , num in enumerate ( nums ): l = nums [ i - 1 ] if i > 0 else 1001 r = nums [ i + 1 ] if i + 1 < len ( nums ) else 1001 decreasing [ i % 2 ] += max ( 0 , num - min ( l , r ) + 1 ) return min ( decreasing [ 0 ], decreasing [ 1 ]) 1145. Binary Tree Coloring Game $\\star\\star$ 1146. Snapshot Array $\\star\\star$ class SnapshotArray : def __init__ ( self , length : int ): self . map = [[[ 0 , 0 ]] for _ in range ( length )] self . snap_id = 0 def set ( self , index : int , val : int ) -> None : self . map [ index ] . append ([ self . snap_id , val ]) def snap ( self ) -> int : self . snap_id += 1 return self . snap_id - 1 def get ( self , index : int , snap_id : int ) -> int : i = bisect . bisect ( self . map [ index ], [ snap_id + 1 ]) - 1 return self . map [ index ][ i ][ 1 ] 1147. Longest Chunked Palindrome Decomposition $\\star\\star\\star$ 1148. Article Views I $\\star$ \ud83d\udd12 1149. Article Views II $\\star\\star$ \ud83d\udd12 1150. Check If a Number Is Majority Element in a Sorted Array $\\star$ \ud83d\udd12","title":"1141-1150"},{"location":"python3/1101-1200/1141-1150/#1141-user-activity-for-the-past-30-days-i-star","text":"","title":"1141. User Activity for the Past 30 Days I $\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1141-1150/#1142-user-activity-for-the-past-30-days-ii-star","text":"","title":"1142. User Activity for the Past 30 Days II $\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1141-1150/#1143-longest-common-subsequence-starstar","text":"","title":"1143. Longest Common Subsequence $\\star\\star$"},{"location":"python3/1101-1200/1141-1150/#1144-decrease-elements-to-make-array-zigzag-starstar","text":"class Solution : def movesToMakeZigzag ( self , nums : List [ int ]) -> int : decreasing = [ 0 ] * 2 for i , num in enumerate ( nums ): l = nums [ i - 1 ] if i > 0 else 1001 r = nums [ i + 1 ] if i + 1 < len ( nums ) else 1001 decreasing [ i % 2 ] += max ( 0 , num - min ( l , r ) + 1 ) return min ( decreasing [ 0 ], decreasing [ 1 ])","title":"1144. Decrease Elements To Make Array Zigzag $\\star\\star$"},{"location":"python3/1101-1200/1141-1150/#1145-binary-tree-coloring-game-starstar","text":"","title":"1145. Binary Tree Coloring Game $\\star\\star$"},{"location":"python3/1101-1200/1141-1150/#1146-snapshot-array-starstar","text":"class SnapshotArray : def __init__ ( self , length : int ): self . map = [[[ 0 , 0 ]] for _ in range ( length )] self . snap_id = 0 def set ( self , index : int , val : int ) -> None : self . map [ index ] . append ([ self . snap_id , val ]) def snap ( self ) -> int : self . snap_id += 1 return self . snap_id - 1 def get ( self , index : int , snap_id : int ) -> int : i = bisect . bisect ( self . map [ index ], [ snap_id + 1 ]) - 1 return self . map [ index ][ i ][ 1 ]","title":"1146. Snapshot Array $\\star\\star$"},{"location":"python3/1101-1200/1141-1150/#1147-longest-chunked-palindrome-decomposition-starstarstar","text":"","title":"1147. Longest Chunked Palindrome Decomposition $\\star\\star\\star$"},{"location":"python3/1101-1200/1141-1150/#1148-article-views-i-star","text":"","title":"1148. Article Views I $\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1141-1150/#1149-article-views-ii-starstar","text":"","title":"1149. Article Views II $\\star\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1141-1150/#1150-check-if-a-number-is-majority-element-in-a-sorted-array-star","text":"","title":"1150. Check If a Number Is Majority Element in a Sorted Array $\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1151-1160/","text":"1151. Minimum Swaps to Group All 1's Together $\\star\\star$ \ud83d\udd12 1152. Analyze User Website Visit Pattern $\\star\\star$ \ud83d\udd12 1153. String Transforms Into Another String $\\star\\star\\star$ \ud83d\udd12 1154. Day of the Year $\\star$ class Solution : def dayOfYear ( self , date : str ) -> int : def isLeapYear ( year : int ) -> bool : return ( year % 4 == 0 and year % 100 != 0 ) or year % 400 == 0 year = int ( date [: 4 ]) month = int ( date [ 5 : 7 ]) day = int ( date [ 8 :]) days = [ 31 , 29 if isLeapYear ( year ) else 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] return sum ( days [: month - 1 ]) + day 1155. Number of Dice Rolls With Target Sum $\\star\\star$ class Solution : def numRollsToTarget ( self , d : int , f : int , target : int ) -> int : def dfs ( d : int , target : int ) -> int : if d == 0 or target <= 0 : return d == 0 and target == 0 if dp [ d ][ target ]: return dp [ d ][ target ] - 1 # -1 here ans = 0 for i in range ( 1 , f + 1 ): ans = ( ans + dfs ( d - 1 , target - i )) % kMod dp [ d ][ target ] = ans + 1 # +1 here return ans kMod = int ( 1e9 + 7 ) dp = [[ 0 ] * ( target + 1 ) for _ in range ( d + 1 )] return dfs ( d , target ) 1156. Swap For Longest Repeated Character Substring $\\star\\star$ class Solution : def maxRepOpt1 ( self , text : str ) -> int : count = collections . Counter ( text ) groups = [[ c , len ( list ( group ))] for c , group in itertools . groupby ( text )] ans = max ( min ( length + 1 , count [ c ]) for c , length in groups ) for i in range ( 1 , len ( groups ) - 1 ): if groups [ i - 1 ][ 0 ] == groups [ i + 1 ][ 0 ] and groups [ i ][ 1 ] == 1 : ans = max ( ans , min ( groups [ i - 1 ][ 1 ] + groups [ i + 1 ][ 1 ] + 1 , count [ groups [ i - 1 ][ 0 ]])) return ans 1157. Online Majority Element In Subarray $\\star\\star\\star$ class MajorityChecker : def __init__ ( self , arr : List [ int ]): self . map = collections . defaultdict ( list ) for i , a in enumerate ( arr ): self . map [ a ] . append ( i ) def query ( self , left : int , right : int , threshold : int ) -> int : for num , indices in self . map . items (): if len ( indices ) < threshold : continue l = bisect . bisect ( indices , left - 1 ) r = bisect . bisect ( indices , right ) if r - l >= threshold : return num return - 1 1158. Market Analysis I $\\star\\star$ \ud83d\udd12 1159. Market Analysis II $\\star\\star\\star$ \ud83d\udd12 1160. Find Words That Can Be Formed by Characters $\\star$ class Solution : def countCharacters ( self , words : List [ str ], chars : str ) -> int : ans = 0 count = collections . Counter ( chars ) for word in words : tempCount = count . copy () for c in word : tempCount [ c ] -= 1 if tempCount [ c ] < 0 : ans -= len ( word ) break ans += len ( word ) return ans","title":"1151-1160"},{"location":"python3/1101-1200/1151-1160/#1151-minimum-swaps-to-group-all-1s-together-starstar","text":"","title":"1151. Minimum Swaps to Group All 1's Together $\\star\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1151-1160/#1152-analyze-user-website-visit-pattern-starstar","text":"","title":"1152. Analyze User Website Visit Pattern $\\star\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1151-1160/#1153-string-transforms-into-another-string-starstarstar","text":"","title":"1153. String Transforms Into Another String $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1151-1160/#1154-day-of-the-year-star","text":"class Solution : def dayOfYear ( self , date : str ) -> int : def isLeapYear ( year : int ) -> bool : return ( year % 4 == 0 and year % 100 != 0 ) or year % 400 == 0 year = int ( date [: 4 ]) month = int ( date [ 5 : 7 ]) day = int ( date [ 8 :]) days = [ 31 , 29 if isLeapYear ( year ) else 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] return sum ( days [: month - 1 ]) + day","title":"1154. Day of the Year $\\star$"},{"location":"python3/1101-1200/1151-1160/#1155-number-of-dice-rolls-with-target-sum-starstar","text":"class Solution : def numRollsToTarget ( self , d : int , f : int , target : int ) -> int : def dfs ( d : int , target : int ) -> int : if d == 0 or target <= 0 : return d == 0 and target == 0 if dp [ d ][ target ]: return dp [ d ][ target ] - 1 # -1 here ans = 0 for i in range ( 1 , f + 1 ): ans = ( ans + dfs ( d - 1 , target - i )) % kMod dp [ d ][ target ] = ans + 1 # +1 here return ans kMod = int ( 1e9 + 7 ) dp = [[ 0 ] * ( target + 1 ) for _ in range ( d + 1 )] return dfs ( d , target )","title":"1155. Number of Dice Rolls With Target Sum $\\star\\star$"},{"location":"python3/1101-1200/1151-1160/#1156-swap-for-longest-repeated-character-substring-starstar","text":"class Solution : def maxRepOpt1 ( self , text : str ) -> int : count = collections . Counter ( text ) groups = [[ c , len ( list ( group ))] for c , group in itertools . groupby ( text )] ans = max ( min ( length + 1 , count [ c ]) for c , length in groups ) for i in range ( 1 , len ( groups ) - 1 ): if groups [ i - 1 ][ 0 ] == groups [ i + 1 ][ 0 ] and groups [ i ][ 1 ] == 1 : ans = max ( ans , min ( groups [ i - 1 ][ 1 ] + groups [ i + 1 ][ 1 ] + 1 , count [ groups [ i - 1 ][ 0 ]])) return ans","title":"1156. Swap For Longest Repeated Character Substring $\\star\\star$"},{"location":"python3/1101-1200/1151-1160/#1157-online-majority-element-in-subarray-starstarstar","text":"class MajorityChecker : def __init__ ( self , arr : List [ int ]): self . map = collections . defaultdict ( list ) for i , a in enumerate ( arr ): self . map [ a ] . append ( i ) def query ( self , left : int , right : int , threshold : int ) -> int : for num , indices in self . map . items (): if len ( indices ) < threshold : continue l = bisect . bisect ( indices , left - 1 ) r = bisect . bisect ( indices , right ) if r - l >= threshold : return num return - 1","title":"1157. Online Majority Element In Subarray $\\star\\star\\star$"},{"location":"python3/1101-1200/1151-1160/#1158-market-analysis-i-starstar","text":"","title":"1158. Market Analysis I $\\star\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1151-1160/#1159-market-analysis-ii-starstarstar","text":"","title":"1159. Market Analysis II $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1151-1160/#1160-find-words-that-can-be-formed-by-characters-star","text":"class Solution : def countCharacters ( self , words : List [ str ], chars : str ) -> int : ans = 0 count = collections . Counter ( chars ) for word in words : tempCount = count . copy () for c in word : tempCount [ c ] -= 1 if tempCount [ c ] < 0 : ans -= len ( word ) break ans += len ( word ) return ans","title":"1160. Find Words That Can Be Formed by Characters $\\star$"},{"location":"python3/1101-1200/1161-1170/","text":"1161. Maximum Level Sum of a Binary Tree $\\star\\star$ 1162. As Far from Land as Possible $\\star\\star$ 1163. Last Substring in Lexicographical Order $\\star\\star\\star$ 1164. Product Price at a Given Date $\\star\\star$ \ud83d\udd12 1165. Single-Row Keyboard $\\star$ \ud83d\udd12 1166. Design File System $\\star\\star$ \ud83d\udd12 1167. Minimum Cost to Connect Sticks $\\star\\star$ \ud83d\udd12 1168. Optimize Water Distribution in a Village $\\star\\star\\star$ \ud83d\udd12 1169. Invalid Transactions $\\star\\star$ class Solution : def invalidTransactions ( self , transactions : List [ str ]) -> List [ str ]: ans = set () nameToTransactions = collections . defaultdict ( list ) for transaction in transactions : name , time , amount , city = transaction . split ( ',' ) time , amount = int ( time ), int ( amount ) nameToTransactions [ name ] . append ({ 'time' : time , 'city' : city }) for transaction in transactions : name , time , amount , city = transaction . split ( ',' ) time , amount = int ( time ), int ( amount ) if amount > 1000 : ans . add ( transaction ) elif name in nameToTransactions : for sameName in nameToTransactions [ name ]: if 0 <= abs ( sameName [ 'time' ] - time ) <= 60 and sameName [ 'city' ] != city : ans . add ( transaction ) return ans 1170. Compare Strings by Frequency of the Smallest Character $\\star$ class Solution : def numSmallerByFrequency ( self , queries : List [ str ], words : List [ str ]) -> List [ int ]: ans = [] wordsFreq = sorted ([ word . count ( min ( word )) for word in words ]) for query in queries : count = query . count ( min ( query )) index = bisect . bisect ( wordsFreq , count ) ans . append ( len ( words ) - index ) return ans","title":"1161-1170"},{"location":"python3/1101-1200/1161-1170/#1161-maximum-level-sum-of-a-binary-tree-starstar","text":"","title":"1161. Maximum Level Sum of a Binary Tree $\\star\\star$"},{"location":"python3/1101-1200/1161-1170/#1162-as-far-from-land-as-possible-starstar","text":"","title":"1162. As Far from Land as Possible $\\star\\star$"},{"location":"python3/1101-1200/1161-1170/#1163-last-substring-in-lexicographical-order-starstarstar","text":"","title":"1163. Last Substring in Lexicographical Order $\\star\\star\\star$"},{"location":"python3/1101-1200/1161-1170/#1164-product-price-at-a-given-date-starstar","text":"","title":"1164. Product Price at a Given Date $\\star\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1161-1170/#1165-single-row-keyboard-star","text":"","title":"1165. Single-Row Keyboard $\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1161-1170/#1166-design-file-system-starstar","text":"","title":"1166. Design File System $\\star\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1161-1170/#1167-minimum-cost-to-connect-sticks-starstar","text":"","title":"1167. Minimum Cost to Connect Sticks $\\star\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1161-1170/#1168-optimize-water-distribution-in-a-village-starstarstar","text":"","title":"1168. Optimize Water Distribution in a Village $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1161-1170/#1169-invalid-transactions-starstar","text":"class Solution : def invalidTransactions ( self , transactions : List [ str ]) -> List [ str ]: ans = set () nameToTransactions = collections . defaultdict ( list ) for transaction in transactions : name , time , amount , city = transaction . split ( ',' ) time , amount = int ( time ), int ( amount ) nameToTransactions [ name ] . append ({ 'time' : time , 'city' : city }) for transaction in transactions : name , time , amount , city = transaction . split ( ',' ) time , amount = int ( time ), int ( amount ) if amount > 1000 : ans . add ( transaction ) elif name in nameToTransactions : for sameName in nameToTransactions [ name ]: if 0 <= abs ( sameName [ 'time' ] - time ) <= 60 and sameName [ 'city' ] != city : ans . add ( transaction ) return ans","title":"1169. Invalid Transactions $\\star\\star$"},{"location":"python3/1101-1200/1161-1170/#1170-compare-strings-by-frequency-of-the-smallest-character-star","text":"class Solution : def numSmallerByFrequency ( self , queries : List [ str ], words : List [ str ]) -> List [ int ]: ans = [] wordsFreq = sorted ([ word . count ( min ( word )) for word in words ]) for query in queries : count = query . count ( min ( query )) index = bisect . bisect ( wordsFreq , count ) ans . append ( len ( words ) - index ) return ans","title":"1170. Compare Strings by Frequency of the Smallest Character $\\star$"},{"location":"python3/1101-1200/1171-1180/","text":"1171. Remove Zero Sum Consecutive Nodes from Linked List $\\star\\star$ class Solution : def removeZeroSumSublists ( self , head : ListNode ) -> ListNode : dummy = ListNode ( 0 ) dummy . next = head prefixSum = 0 prefixSumToNode = { 0 : dummy } while head : prefixSum += head . val prefixSumToNode [ prefixSum ] = head head = head . next prefixSum = 0 head = dummy while head : prefixSum += head . val head . next = prefixSumToNode [ prefixSum ] . next head = head . next return dummy . next 1172. Dinner Plate Stacks $\\star\\star\\star$ 1173. Immediate Food Delivery I $\\star$ \ud83d\udd12 1174. Immediate Food Delivery II $\\star\\star$ \ud83d\udd12 1175. Prime Arrangements $\\star$ class Solution : def numPrimeArrangements ( self , n : int ) -> int : def countPrimes ( n : int ) -> int : isPrime = [ False ] * 2 + [ True ] * ( n - 1 ) for i in range ( 2 , int ( n ** 0.5 ) + 1 ): if isPrime [ i ]: for j in range ( i * i , n + 1 , i ): isPrime [ j ] = False return sum ( isPrime ) def factorial ( n : int ) -> int : fact = 1 for i in range ( 1 , n + 1 ): fact = fact * i % kMod return fact kMod = int ( 1e9 + 7 ) count = countPrimes ( n ) return factorial ( count ) * factorial ( n - count ) % kMod 1176. Diet Plan Performance $\\star$ \ud83d\udd12 1177. Can Make Palindrome from Substring $\\star\\star$ class Solution : def canMakePaliQueries ( self , s : str , queries : List [ List [ int ]]) -> List [ bool ]: def ones ( x ): return bin ( x ) . count ( '1' ) dp = [ 0 ] * ( len ( s ) + 1 ) for i in range ( 1 , len ( s ) + 1 ): dp [ i ] = dp [ i - 1 ] ^ ( 1 << ord ( s [ i - 1 ]) - ord ( 'a' )) return [ ones ( dp [ right + 1 ] ^ dp [ left ]) // 2 <= k for left , right , k in queries ] 1178. Number of Valid Words for Each Puzzle $\\star\\star\\star$ class Solution : def findNumOfValidWords ( self , words : List [ str ], puzzles : List [ str ]) -> List [ int ]: ans = [] binaryCount = collections . Counter () for word in words : mask = 0 for c in word : mask |= 1 << ( ord ( c ) - ord ( 'a' )) binaryCount [ mask ] += 1 for puzzle in puzzles : valid = 0 n = len ( puzzle ) - 1 for i in range ( 1 << n ): mask = 1 << ( ord ( puzzle [ 0 ]) - ord ( 'a' )) for j in range ( n ): if i & ( 1 << j ): mask |= 1 << ( ord ( puzzle [ j + 1 ]) - ord ( 'a' )) if mask in binaryCount : valid += binaryCount [ mask ] ans . append ( valid ) return ans 1179. Reformat Department Table $\\star$ 1180. Count Substrings with Only One Distinct Letter $\\star$ \ud83d\udd12","title":"1171-1180"},{"location":"python3/1101-1200/1171-1180/#1171-remove-zero-sum-consecutive-nodes-from-linked-list-starstar","text":"class Solution : def removeZeroSumSublists ( self , head : ListNode ) -> ListNode : dummy = ListNode ( 0 ) dummy . next = head prefixSum = 0 prefixSumToNode = { 0 : dummy } while head : prefixSum += head . val prefixSumToNode [ prefixSum ] = head head = head . next prefixSum = 0 head = dummy while head : prefixSum += head . val head . next = prefixSumToNode [ prefixSum ] . next head = head . next return dummy . next","title":"1171. Remove Zero Sum Consecutive Nodes from Linked List $\\star\\star$"},{"location":"python3/1101-1200/1171-1180/#1172-dinner-plate-stacks-starstarstar","text":"","title":"1172. Dinner Plate Stacks $\\star\\star\\star$"},{"location":"python3/1101-1200/1171-1180/#1173-immediate-food-delivery-i-star","text":"","title":"1173. Immediate Food Delivery I $\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1171-1180/#1174-immediate-food-delivery-ii-starstar","text":"","title":"1174. Immediate Food Delivery II $\\star\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1171-1180/#1175-prime-arrangements-star","text":"class Solution : def numPrimeArrangements ( self , n : int ) -> int : def countPrimes ( n : int ) -> int : isPrime = [ False ] * 2 + [ True ] * ( n - 1 ) for i in range ( 2 , int ( n ** 0.5 ) + 1 ): if isPrime [ i ]: for j in range ( i * i , n + 1 , i ): isPrime [ j ] = False return sum ( isPrime ) def factorial ( n : int ) -> int : fact = 1 for i in range ( 1 , n + 1 ): fact = fact * i % kMod return fact kMod = int ( 1e9 + 7 ) count = countPrimes ( n ) return factorial ( count ) * factorial ( n - count ) % kMod","title":"1175. Prime Arrangements $\\star$"},{"location":"python3/1101-1200/1171-1180/#1176-diet-plan-performance-star","text":"","title":"1176. Diet Plan Performance $\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1171-1180/#1177-can-make-palindrome-from-substring-starstar","text":"class Solution : def canMakePaliQueries ( self , s : str , queries : List [ List [ int ]]) -> List [ bool ]: def ones ( x ): return bin ( x ) . count ( '1' ) dp = [ 0 ] * ( len ( s ) + 1 ) for i in range ( 1 , len ( s ) + 1 ): dp [ i ] = dp [ i - 1 ] ^ ( 1 << ord ( s [ i - 1 ]) - ord ( 'a' )) return [ ones ( dp [ right + 1 ] ^ dp [ left ]) // 2 <= k for left , right , k in queries ]","title":"1177. Can Make Palindrome from Substring $\\star\\star$"},{"location":"python3/1101-1200/1171-1180/#1178-number-of-valid-words-for-each-puzzle-starstarstar","text":"class Solution : def findNumOfValidWords ( self , words : List [ str ], puzzles : List [ str ]) -> List [ int ]: ans = [] binaryCount = collections . Counter () for word in words : mask = 0 for c in word : mask |= 1 << ( ord ( c ) - ord ( 'a' )) binaryCount [ mask ] += 1 for puzzle in puzzles : valid = 0 n = len ( puzzle ) - 1 for i in range ( 1 << n ): mask = 1 << ( ord ( puzzle [ 0 ]) - ord ( 'a' )) for j in range ( n ): if i & ( 1 << j ): mask |= 1 << ( ord ( puzzle [ j + 1 ]) - ord ( 'a' )) if mask in binaryCount : valid += binaryCount [ mask ] ans . append ( valid ) return ans","title":"1178. Number of Valid Words for Each Puzzle $\\star\\star\\star$"},{"location":"python3/1101-1200/1171-1180/#1179-reformat-department-table-star","text":"","title":"1179. Reformat Department Table $\\star$"},{"location":"python3/1101-1200/1171-1180/#1180-count-substrings-with-only-one-distinct-letter-star","text":"","title":"1180. Count Substrings with Only One Distinct Letter $\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1181-1190/","text":"1181. Before and After Puzzle $\\star\\star$ \ud83d\udd12 1182. Shortest Distance to Target Color $\\star\\star$ \ud83d\udd12 1183. Maximum Number of Ones $\\star\\star\\star$ \ud83d\udd12 1184. Distance Between Bus Stops $\\star$ class Solution : def distanceBetweenBusStops ( self , distance : List [ int ], start : int , destination : int ) -> int : clockwise = 0 counterclockwise = 0 if start > destination : start , destination = destination , start for i , d in enumerate ( distance ): if i >= start and i < destination : clockwise += d else : counterclockwise += d return min ( clockwise , counterclockwise ) 1185. Day of the Week $\\star$ class Solution : def dayOfTheWeek ( self , day : int , month : int , year : int ) -> str : def isLeapYear ( year : int ) -> bool : return ( year % 4 == 0 and year % 100 != 0 ) or year % 400 == 0 week = [ \"Sunday\" , \"Monday\" , \"Tuesday\" , \"Wednesday\" , \"Thursday\" , \"Friday\" , \"Saturday\" ] days = [ 31 , 29 if isLeapYear ( year ) else 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] count = 0 for i in range ( 1971 , year ): count += 366 if i % 4 == 0 else 365 for i in range ( month - 1 ): count += days [ i ] count += day return week [( count + 4 ) % 7 ] 1186. Maximum Subarray Sum with One Deletion $\\star\\star$ 1187. Make Array Strictly Increasing $\\star\\star\\star$ 1188. Design Bounded Blocking Queue $\\star\\star$ \ud83d\udd12 1189. Maximum Number of Balloons $\\star$ class Solution : def maxNumberOfBalloons ( self , text : str ) -> int : count = collections . Counter ( text ) return min ( count [ 'b' ], count [ 'a' ], count [ 'l' ] // 2 , count [ 'o' ] // 2 , count [ 'n' ]) 1190. Reverse Substrings Between Each Pair of Parentheses $\\star\\star$","title":"1181-1190"},{"location":"python3/1101-1200/1181-1190/#1181-before-and-after-puzzle-starstar","text":"","title":"1181. Before and After Puzzle $\\star\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1181-1190/#1182-shortest-distance-to-target-color-starstar","text":"","title":"1182. Shortest Distance to Target Color $\\star\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1181-1190/#1183-maximum-number-of-ones-starstarstar","text":"","title":"1183. Maximum Number of Ones $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1181-1190/#1184-distance-between-bus-stops-star","text":"class Solution : def distanceBetweenBusStops ( self , distance : List [ int ], start : int , destination : int ) -> int : clockwise = 0 counterclockwise = 0 if start > destination : start , destination = destination , start for i , d in enumerate ( distance ): if i >= start and i < destination : clockwise += d else : counterclockwise += d return min ( clockwise , counterclockwise )","title":"1184. Distance Between Bus Stops $\\star$"},{"location":"python3/1101-1200/1181-1190/#1185-day-of-the-week-star","text":"class Solution : def dayOfTheWeek ( self , day : int , month : int , year : int ) -> str : def isLeapYear ( year : int ) -> bool : return ( year % 4 == 0 and year % 100 != 0 ) or year % 400 == 0 week = [ \"Sunday\" , \"Monday\" , \"Tuesday\" , \"Wednesday\" , \"Thursday\" , \"Friday\" , \"Saturday\" ] days = [ 31 , 29 if isLeapYear ( year ) else 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] count = 0 for i in range ( 1971 , year ): count += 366 if i % 4 == 0 else 365 for i in range ( month - 1 ): count += days [ i ] count += day return week [( count + 4 ) % 7 ]","title":"1185. Day of the Week $\\star$"},{"location":"python3/1101-1200/1181-1190/#1186-maximum-subarray-sum-with-one-deletion-starstar","text":"","title":"1186. Maximum Subarray Sum with One Deletion $\\star\\star$"},{"location":"python3/1101-1200/1181-1190/#1187-make-array-strictly-increasing-starstarstar","text":"","title":"1187. Make Array Strictly Increasing $\\star\\star\\star$"},{"location":"python3/1101-1200/1181-1190/#1188-design-bounded-blocking-queue-starstar","text":"","title":"1188. Design Bounded Blocking Queue $\\star\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1181-1190/#1189-maximum-number-of-balloons-star","text":"class Solution : def maxNumberOfBalloons ( self , text : str ) -> int : count = collections . Counter ( text ) return min ( count [ 'b' ], count [ 'a' ], count [ 'l' ] // 2 , count [ 'o' ] // 2 , count [ 'n' ])","title":"1189. Maximum Number of Balloons $\\star$"},{"location":"python3/1101-1200/1181-1190/#1190-reverse-substrings-between-each-pair-of-parentheses-starstar","text":"","title":"1190. Reverse Substrings Between Each Pair of Parentheses $\\star\\star$"},{"location":"python3/1101-1200/1191-1200/","text":"1191. K-Concatenation Maximum Sum $\\star\\star$ 1192. Critical Connections in a Network $\\star\\star\\star$ 1193. Monthly Transactions I $\\star\\star$ \ud83d\udd12 1194. Tournament Winners $\\star\\star\\star$ \ud83d\udd12 1195. Fizz Buzz Multithreaded $\\star\\star$ 1196. How Many Apples Can You Put into the Basket $\\star$ \ud83d\udd12 1197. Minimum Knight Moves $\\star\\star$ \ud83d\udd12 1198. Find Smallest Common Element in All Rows $\\star\\star$ \ud83d\udd12 1199. Minimum Time to Build Blocks $\\star\\star\\star$ \ud83d\udd12 1200. Minimum Absolute Difference $\\star$ class Solution : def minimumAbsDifference ( self , arr : List [ int ]) -> List [ List [ int ]]: ans = [] min = float ( 'inf' ) arr . sort () for i in range ( len ( arr ) - 1 ): diff = arr [ i + 1 ] - arr [ i ] if diff < min : min = diff ans = [] if diff == min : ans . append ([ arr [ i ], arr [ i + 1 ]]) return ans","title":"1191-1200"},{"location":"python3/1101-1200/1191-1200/#1191-k-concatenation-maximum-sum-starstar","text":"","title":"1191. K-Concatenation Maximum Sum $\\star\\star$"},{"location":"python3/1101-1200/1191-1200/#1192-critical-connections-in-a-network-starstarstar","text":"","title":"1192. Critical Connections in a Network $\\star\\star\\star$"},{"location":"python3/1101-1200/1191-1200/#1193-monthly-transactions-i-starstar","text":"","title":"1193. Monthly Transactions I $\\star\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1191-1200/#1194-tournament-winners-starstarstar","text":"","title":"1194. Tournament Winners $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1191-1200/#1195-fizz-buzz-multithreaded-starstar","text":"","title":"1195. Fizz Buzz Multithreaded $\\star\\star$"},{"location":"python3/1101-1200/1191-1200/#1196-how-many-apples-can-you-put-into-the-basket-star","text":"","title":"1196. How Many Apples Can You Put into the Basket $\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1191-1200/#1197-minimum-knight-moves-starstar","text":"","title":"1197. Minimum Knight Moves $\\star\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1191-1200/#1198-find-smallest-common-element-in-all-rows-starstar","text":"","title":"1198. Find Smallest Common Element in All Rows $\\star\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1191-1200/#1199-minimum-time-to-build-blocks-starstarstar","text":"","title":"1199. Minimum Time to Build Blocks $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/1101-1200/1191-1200/#1200-minimum-absolute-difference-star","text":"class Solution : def minimumAbsDifference ( self , arr : List [ int ]) -> List [ List [ int ]]: ans = [] min = float ( 'inf' ) arr . sort () for i in range ( len ( arr ) - 1 ): diff = arr [ i + 1 ] - arr [ i ] if diff < min : min = diff ans = [] if diff == min : ans . append ([ arr [ i ], arr [ i + 1 ]]) return ans","title":"1200. Minimum Absolute Difference $\\star$"},{"location":"python3/1201-1300/1201-1210/","text":"1201. Ugly Number III $\\star\\star$ class Solution : def nthUglyNumber ( self , n : int , a : int , b : int , c : int ) -> int : ab = a * b // math . gcd ( a , b ) ac = a * c // math . gcd ( a , c ) bc = b * c // math . gcd ( b , c ) abc = a * bc // math . gcd ( a , bc ) l = 1 r = 2 * int ( 1e9 ) while l < r : m = ( l + r ) // 2 if m // a + m // b + m // c - m // ab - m // ac - m // bc + m // abc < n : l = m + 1 else : r = m return l 1202. Smallest String With Swaps $\\star\\star$ class Solution : def smallestStringWithSwaps ( self , s : str , pairs : List [ List [ int ]]) -> str : class UF : def __init__ ( self , n : int ): self . size = [ 1 ] * n self . id = list ( range ( n )) def union ( self , p : int , q : int ) -> None : i = self . find ( p ) j = self . find ( q ) if i == j : return if self . size [ i ] < self . size [ j ]: self . id [ i ] = j self . size [ j ] += self . size [ i ] else : self . id [ j ] = i self . size [ i ] += self . size [ j ] def find ( self , i : int ) -> int : while i != self . id [ i ]: self . id [ i ] = self . id [ self . id [ i ]] i = self . id [ i ] return i ans = \"\" uf = UF ( len ( s )) map = collections . defaultdict ( list ) for p , q in pairs : uf . union ( p , q ) for i in range ( len ( s )): map [ uf . find ( i )] . append ( s [ i ]) for key in map . keys (): map [ key ] . sort ( reverse = True ) for i in range ( len ( s )): ans += map [ uf . find ( i )] . pop () return ans 1203. Sort Items by Groups Respecting Dependencies $\\star\\star\\star$ 1204. Last Person to Fit in the Elevator $\\star\\star$ \ud83d\udd12 1205. Monthly Transactions II $\\star\\star$ \ud83d\udd12 1206. Design Skiplist $\\star\\star\\star$ 1207. Unique Number of Occurrences $\\star$ class Solution : def uniqueOccurrences ( self , arr : List [ int ]) -> bool : count = collections . Counter ( arr ) occurrences = set () for value in count . values (): if value in occurrences : return False occurrences . add ( value ) return True 1208. Get Equal Substrings Within Budget $\\star\\star$ class Solution : def equalSubstring ( self , s : str , t : str , maxCost : int ) -> int : j = 0 for i in range ( len ( s )): maxCost -= abs ( ord ( s [ i ]) - ord ( t [ i ])) if maxCost < 0 : maxCost += abs ( ord ( s [ j ]) - ord ( t [ j ])) j += 1 return len ( s ) - j 1209. Remove All Adjacent Duplicates in String II $\\star\\star$ 1210. Minimum Moves to Reach Target with Rotations $\\star\\star\\star$","title":"1201-1210"},{"location":"python3/1201-1300/1201-1210/#1201-ugly-number-iii-starstar","text":"class Solution : def nthUglyNumber ( self , n : int , a : int , b : int , c : int ) -> int : ab = a * b // math . gcd ( a , b ) ac = a * c // math . gcd ( a , c ) bc = b * c // math . gcd ( b , c ) abc = a * bc // math . gcd ( a , bc ) l = 1 r = 2 * int ( 1e9 ) while l < r : m = ( l + r ) // 2 if m // a + m // b + m // c - m // ab - m // ac - m // bc + m // abc < n : l = m + 1 else : r = m return l","title":"1201. Ugly Number III $\\star\\star$"},{"location":"python3/1201-1300/1201-1210/#1202-smallest-string-with-swaps-starstar","text":"class Solution : def smallestStringWithSwaps ( self , s : str , pairs : List [ List [ int ]]) -> str : class UF : def __init__ ( self , n : int ): self . size = [ 1 ] * n self . id = list ( range ( n )) def union ( self , p : int , q : int ) -> None : i = self . find ( p ) j = self . find ( q ) if i == j : return if self . size [ i ] < self . size [ j ]: self . id [ i ] = j self . size [ j ] += self . size [ i ] else : self . id [ j ] = i self . size [ i ] += self . size [ j ] def find ( self , i : int ) -> int : while i != self . id [ i ]: self . id [ i ] = self . id [ self . id [ i ]] i = self . id [ i ] return i ans = \"\" uf = UF ( len ( s )) map = collections . defaultdict ( list ) for p , q in pairs : uf . union ( p , q ) for i in range ( len ( s )): map [ uf . find ( i )] . append ( s [ i ]) for key in map . keys (): map [ key ] . sort ( reverse = True ) for i in range ( len ( s )): ans += map [ uf . find ( i )] . pop () return ans","title":"1202. Smallest String With Swaps $\\star\\star$"},{"location":"python3/1201-1300/1201-1210/#1203-sort-items-by-groups-respecting-dependencies-starstarstar","text":"","title":"1203. Sort Items by Groups Respecting Dependencies $\\star\\star\\star$"},{"location":"python3/1201-1300/1201-1210/#1204-last-person-to-fit-in-the-elevator-starstar","text":"","title":"1204. Last Person to Fit in the Elevator $\\star\\star$ \ud83d\udd12"},{"location":"python3/1201-1300/1201-1210/#1205-monthly-transactions-ii-starstar","text":"","title":"1205. Monthly Transactions II $\\star\\star$ \ud83d\udd12"},{"location":"python3/1201-1300/1201-1210/#1206-design-skiplist-starstarstar","text":"","title":"1206. Design Skiplist $\\star\\star\\star$"},{"location":"python3/1201-1300/1201-1210/#1207-unique-number-of-occurrences-star","text":"class Solution : def uniqueOccurrences ( self , arr : List [ int ]) -> bool : count = collections . Counter ( arr ) occurrences = set () for value in count . values (): if value in occurrences : return False occurrences . add ( value ) return True","title":"1207. Unique Number of Occurrences $\\star$"},{"location":"python3/1201-1300/1201-1210/#1208-get-equal-substrings-within-budget-starstar","text":"class Solution : def equalSubstring ( self , s : str , t : str , maxCost : int ) -> int : j = 0 for i in range ( len ( s )): maxCost -= abs ( ord ( s [ i ]) - ord ( t [ i ])) if maxCost < 0 : maxCost += abs ( ord ( s [ j ]) - ord ( t [ j ])) j += 1 return len ( s ) - j","title":"1208. Get Equal Substrings Within Budget $\\star\\star$"},{"location":"python3/1201-1300/1201-1210/#1209-remove-all-adjacent-duplicates-in-string-ii-starstar","text":"","title":"1209. Remove All Adjacent Duplicates in String II $\\star\\star$"},{"location":"python3/1201-1300/1201-1210/#1210-minimum-moves-to-reach-target-with-rotations-starstarstar","text":"","title":"1210. Minimum Moves to Reach Target with Rotations $\\star\\star\\star$"},{"location":"python3/1201-1300/1211-1220/","text":"1211. Queries Quality and Percentage $\\star$ \ud83d\udd12 1212. Team Scores in Football Tournament $\\star\\star$ \ud83d\udd12 1213. Intersection of Three Sorted Arrays $\\star$ \ud83d\udd12 1214. Two Sum BSTs $\\star\\star$ \ud83d\udd12 1215. Stepping Numbers $\\star\\star$ \ud83d\udd12 1216. Valid Palindrome III $\\star\\star\\star$ \ud83d\udd12 1217. Play with Chips $\\star$ class Solution : def minCostToMoveChips ( self , chips : List [ int ]) -> int : count = [ 0 ] * 2 for chip in chips : count [ chip % 2 ] += 1 return min ( count [ 0 ], count [ 1 ]) 1218. Longest Arithmetic Subsequence of Given Difference $\\star\\star$ class Solution : def longestSubsequence ( self , arr : List [ int ], difference : int ) -> int : ans = 0 lengthAt = {} for a in arr : lengthAt [ a ] = lengthAt . get ( a - difference , 0 ) + 1 ans = max ( ans , lengthAt [ a ]) return ans 1219. Path with Maximum Gold $\\star\\star$ 1220. Count Vowels Permutation $\\star\\star\\star$","title":"1211-1220"},{"location":"python3/1201-1300/1211-1220/#1211-queries-quality-and-percentage-star","text":"","title":"1211. Queries Quality and Percentage $\\star$ \ud83d\udd12"},{"location":"python3/1201-1300/1211-1220/#1212-team-scores-in-football-tournament-starstar","text":"","title":"1212. Team Scores in Football Tournament $\\star\\star$ \ud83d\udd12"},{"location":"python3/1201-1300/1211-1220/#1213-intersection-of-three-sorted-arrays-star","text":"","title":"1213. Intersection of Three Sorted Arrays $\\star$ \ud83d\udd12"},{"location":"python3/1201-1300/1211-1220/#1214-two-sum-bsts-starstar","text":"","title":"1214. Two Sum BSTs $\\star\\star$ \ud83d\udd12"},{"location":"python3/1201-1300/1211-1220/#1215-stepping-numbers-starstar","text":"","title":"1215. Stepping Numbers $\\star\\star$ \ud83d\udd12"},{"location":"python3/1201-1300/1211-1220/#1216-valid-palindrome-iii-starstarstar","text":"","title":"1216. Valid Palindrome III $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/1201-1300/1211-1220/#1217-play-with-chips-star","text":"class Solution : def minCostToMoveChips ( self , chips : List [ int ]) -> int : count = [ 0 ] * 2 for chip in chips : count [ chip % 2 ] += 1 return min ( count [ 0 ], count [ 1 ])","title":"1217. Play with Chips $\\star$"},{"location":"python3/1201-1300/1211-1220/#1218-longest-arithmetic-subsequence-of-given-difference-starstar","text":"class Solution : def longestSubsequence ( self , arr : List [ int ], difference : int ) -> int : ans = 0 lengthAt = {} for a in arr : lengthAt [ a ] = lengthAt . get ( a - difference , 0 ) + 1 ans = max ( ans , lengthAt [ a ]) return ans","title":"1218. Longest Arithmetic Subsequence of Given Difference $\\star\\star$"},{"location":"python3/1201-1300/1211-1220/#1219-path-with-maximum-gold-starstar","text":"","title":"1219. Path with Maximum Gold $\\star\\star$"},{"location":"python3/1201-1300/1211-1220/#1220-count-vowels-permutation-starstarstar","text":"","title":"1220. Count Vowels Permutation $\\star\\star\\star$"},{"location":"python3/1201-1300/1221-1230/","text":"1221. Split a String in Balanced Strings $\\star$ 1222. Queens That Can Attack the King $\\star\\star$ class Solution : def queensAttacktheKing ( self , queens : List [ List [ int ]], king : List [ int ]) -> List [ List [ int ]]: ans = [] queens = {( i , j ) for i , j in queens } for d in [[ - 1 , - 1 ], [ - 1 , 0 ], [ - 1 , 1 ], [ 0 , - 1 ], [ 0 , 1 ], [ 1 , - 1 ], [ 1 , 0 ], [ 1 , 1 ]]: i = king [ 0 ] + d [ 0 ] j = king [ 1 ] + d [ 1 ] while 0 <= i < 8 and 0 <= j < 8 : if ( i , j ) in queens : ans . append ([ i , j ]) break i += d [ 0 ] j += d [ 1 ] return ans 1223. Dice Roll Simulation $\\star\\star$ 1224. Maximum Equal Frequency $\\star\\star\\star$ class Solution : def maxEqualFreq ( self , nums : List [ int ]) -> int : ans = 0 maxFreq = 0 count = collections . Counter () freq = collections . Counter () for i , num in enumerate ( nums ): freq [ count [ num ]] -= 1 count [ num ] += 1 freq [ count [ num ]] += 1 maxFreq = max ( maxFreq , count [ num ]) if maxFreq == 1 or maxFreq * freq [ maxFreq ] == i or ( maxFreq - 1 ) * ( freq [ maxFreq - 1 ] + 1 ) == i : ans = i + 1 return ans 1225. Report Contiguous Dates $\\star\\star\\star$ \ud83d\udd12 1226. The Dining Philosophers $\\star\\star$ 1227. Airplane Seat Assignment Probability $\\star\\star$ class Solution : def nthPersonGetsNthSeat ( self , n : int ) -> float : return 1 if n == 1 else 0.5 1228. Missing Number In Arithmetic Progression $\\star$ \ud83d\udd12 1229. Meeting Scheduler $\\star\\star$ \ud83d\udd12 1230. Toss Strange Coins $\\star\\star$ \ud83d\udd12","title":"1221-1230"},{"location":"python3/1201-1300/1221-1230/#1221-split-a-string-in-balanced-strings-star","text":"","title":"1221. Split a String in Balanced Strings $\\star$"},{"location":"python3/1201-1300/1221-1230/#1222-queens-that-can-attack-the-king-starstar","text":"class Solution : def queensAttacktheKing ( self , queens : List [ List [ int ]], king : List [ int ]) -> List [ List [ int ]]: ans = [] queens = {( i , j ) for i , j in queens } for d in [[ - 1 , - 1 ], [ - 1 , 0 ], [ - 1 , 1 ], [ 0 , - 1 ], [ 0 , 1 ], [ 1 , - 1 ], [ 1 , 0 ], [ 1 , 1 ]]: i = king [ 0 ] + d [ 0 ] j = king [ 1 ] + d [ 1 ] while 0 <= i < 8 and 0 <= j < 8 : if ( i , j ) in queens : ans . append ([ i , j ]) break i += d [ 0 ] j += d [ 1 ] return ans","title":"1222. Queens That Can Attack the King $\\star\\star$"},{"location":"python3/1201-1300/1221-1230/#1223-dice-roll-simulation-starstar","text":"","title":"1223. Dice Roll Simulation $\\star\\star$"},{"location":"python3/1201-1300/1221-1230/#1224-maximum-equal-frequency-starstarstar","text":"class Solution : def maxEqualFreq ( self , nums : List [ int ]) -> int : ans = 0 maxFreq = 0 count = collections . Counter () freq = collections . Counter () for i , num in enumerate ( nums ): freq [ count [ num ]] -= 1 count [ num ] += 1 freq [ count [ num ]] += 1 maxFreq = max ( maxFreq , count [ num ]) if maxFreq == 1 or maxFreq * freq [ maxFreq ] == i or ( maxFreq - 1 ) * ( freq [ maxFreq - 1 ] + 1 ) == i : ans = i + 1 return ans","title":"1224. Maximum Equal Frequency $\\star\\star\\star$"},{"location":"python3/1201-1300/1221-1230/#1225-report-contiguous-dates-starstarstar","text":"","title":"1225. Report Contiguous Dates $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/1201-1300/1221-1230/#1226-the-dining-philosophers-starstar","text":"","title":"1226. The Dining Philosophers $\\star\\star$"},{"location":"python3/1201-1300/1221-1230/#1227-airplane-seat-assignment-probability-starstar","text":"class Solution : def nthPersonGetsNthSeat ( self , n : int ) -> float : return 1 if n == 1 else 0.5","title":"1227. Airplane Seat Assignment Probability $\\star\\star$"},{"location":"python3/1201-1300/1221-1230/#1228-missing-number-in-arithmetic-progression-star","text":"","title":"1228. Missing Number In Arithmetic Progression $\\star$ \ud83d\udd12"},{"location":"python3/1201-1300/1221-1230/#1229-meeting-scheduler-starstar","text":"","title":"1229. Meeting Scheduler $\\star\\star$ \ud83d\udd12"},{"location":"python3/1201-1300/1221-1230/#1230-toss-strange-coins-starstar","text":"","title":"1230. Toss Strange Coins $\\star\\star$ \ud83d\udd12"},{"location":"python3/1201-1300/1231-1240/","text":"1231. Divide Chocolate $\\star\\star\\star$ \ud83d\udd12 1232. Check If It Is a Straight Line $\\star$ class Solution : def checkStraightLine ( self , coordinates : List [ List [ int ]]) -> bool : x0 , y0 , x1 , y1 = * coordinates [ 0 ], * coordinates [ 1 ] dx = x1 - x0 dy = y1 - y0 return all (( x - x0 ) * dy == ( y - y0 ) * dx for x , y in coordinates ) 1233. Remove Sub-Folders from the Filesystem $\\star\\star$ class Solution : def removeSubfolders ( self , folder : List [ str ]) -> List [ str ]: ans = [] prev = \"\" folder . sort () for f in folder : if len ( prev ) > 0 and f . startswith ( prev ) and f [ len ( prev )] == '/' : continue ans . append ( f ) prev = f return ans 1234. Replace the Substring for Balanced String $\\star\\star$ class Solution : def balancedString ( self , s : str ) -> int : ans = len ( s ) count = collections . Counter ( s ) j = 0 for i , c in enumerate ( s ): count [ c ] -= 1 while j < len ( s ) and all ( count [ c ] <= len ( s ) // 4 for c in 'QWER' ): ans = min ( ans , i - j + 1 ) count [ s [ j ]] += 1 j += 1 return ans 1235. Maximum Profit in Job Scheduling $\\star\\star\\star$ 1236. Web Crawler $\\star\\star$ \ud83d\udd12 1237. Find Positive Integer Solution for a Given Equation $\\star$ class Solution : def findSolution ( self , customfunction : 'CustomFunction' , z : int ) -> List [ List [ int ]]: ans = [] x = 1 y = 1000 while x <= 1000 and y >= 1 : f = customfunction . f ( x , y ) if f < z : x += 1 elif f > z : y -= 1 else : ans . append ([ x , y ]) x += 1 y -= 1 return ans 1238. Circular Permutation in Binary Representation $\\star\\star$ class Solution : def circularPermutation ( self , n : int , start : int ) -> List [ int ]: return [ start ^ i ^ i >> 1 for i in range ( 1 << n )] 1239. Maximum Length of a Concatenated String with Unique Characters $\\star\\star$ 1240. Tiling a Rectangle with the Fewest Squares $\\star\\star\\star$","title":"1231-1240"},{"location":"python3/1201-1300/1231-1240/#1231-divide-chocolate-starstarstar","text":"","title":"1231. Divide Chocolate $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/1201-1300/1231-1240/#1232-check-if-it-is-a-straight-line-star","text":"class Solution : def checkStraightLine ( self , coordinates : List [ List [ int ]]) -> bool : x0 , y0 , x1 , y1 = * coordinates [ 0 ], * coordinates [ 1 ] dx = x1 - x0 dy = y1 - y0 return all (( x - x0 ) * dy == ( y - y0 ) * dx for x , y in coordinates )","title":"1232. Check If It Is a Straight Line $\\star$"},{"location":"python3/1201-1300/1231-1240/#1233-remove-sub-folders-from-the-filesystem-starstar","text":"class Solution : def removeSubfolders ( self , folder : List [ str ]) -> List [ str ]: ans = [] prev = \"\" folder . sort () for f in folder : if len ( prev ) > 0 and f . startswith ( prev ) and f [ len ( prev )] == '/' : continue ans . append ( f ) prev = f return ans","title":"1233. Remove Sub-Folders from the Filesystem $\\star\\star$"},{"location":"python3/1201-1300/1231-1240/#1234-replace-the-substring-for-balanced-string-starstar","text":"class Solution : def balancedString ( self , s : str ) -> int : ans = len ( s ) count = collections . Counter ( s ) j = 0 for i , c in enumerate ( s ): count [ c ] -= 1 while j < len ( s ) and all ( count [ c ] <= len ( s ) // 4 for c in 'QWER' ): ans = min ( ans , i - j + 1 ) count [ s [ j ]] += 1 j += 1 return ans","title":"1234. Replace the Substring for Balanced String $\\star\\star$"},{"location":"python3/1201-1300/1231-1240/#1235-maximum-profit-in-job-scheduling-starstarstar","text":"","title":"1235. Maximum Profit in Job Scheduling $\\star\\star\\star$"},{"location":"python3/1201-1300/1231-1240/#1236-web-crawler-starstar","text":"","title":"1236. Web Crawler $\\star\\star$ \ud83d\udd12"},{"location":"python3/1201-1300/1231-1240/#1237-find-positive-integer-solution-for-a-given-equation-star","text":"class Solution : def findSolution ( self , customfunction : 'CustomFunction' , z : int ) -> List [ List [ int ]]: ans = [] x = 1 y = 1000 while x <= 1000 and y >= 1 : f = customfunction . f ( x , y ) if f < z : x += 1 elif f > z : y -= 1 else : ans . append ([ x , y ]) x += 1 y -= 1 return ans","title":"1237. Find Positive Integer Solution for a Given Equation $\\star$"},{"location":"python3/1201-1300/1231-1240/#1238-circular-permutation-in-binary-representation-starstar","text":"class Solution : def circularPermutation ( self , n : int , start : int ) -> List [ int ]: return [ start ^ i ^ i >> 1 for i in range ( 1 << n )]","title":"1238. Circular Permutation in Binary Representation $\\star\\star$"},{"location":"python3/1201-1300/1231-1240/#1239-maximum-length-of-a-concatenated-string-with-unique-characters-starstar","text":"","title":"1239. Maximum Length of a Concatenated String with Unique Characters $\\star\\star$"},{"location":"python3/1201-1300/1231-1240/#1240-tiling-a-rectangle-with-the-fewest-squares-starstarstar","text":"","title":"1240. Tiling a Rectangle with the Fewest Squares $\\star\\star\\star$"},{"location":"python3/1201-1300/1241-1250/","text":"1241. Number of Comments per Post $\\star$ \ud83d\udd12 1242. Web Crawler Multithreaded $\\star\\star$ \ud83d\udd12 1243. Array Transformation $\\star$ \ud83d\udd12 1244. Design A Leaderboard $\\star\\star$ \ud83d\udd12 1245. Tree Diameter $\\star\\star$ \ud83d\udd12 1246. Palindrome Removal $\\star\\star\\star$ \ud83d\udd12 1247. Minimum Swaps to Make Strings Equal $\\star\\star$ 1248. Count Number of Nice Subarrays $\\star\\star$ class Solution : def numberOfSubarrays ( self , nums : List [ int ], k : int ) -> int : def numberOfSubarraysAtMost ( k : int ) -> int : ans = 0 l = 0 r = 0 while r <= len ( nums ): if k >= 0 : ans += r - l if r == len ( nums ): break if nums [ r ] & 1 : k -= 1 r += 1 else : if nums [ l ] & 1 : k += 1 l += 1 return ans return numberOfSubarraysAtMost ( k ) - numberOfSubarraysAtMost ( k - 1 ) 1249. Minimum Remove to Make Valid Parentheses $\\star\\star$ 1250. Check If It Is a Good Array $\\star\\star\\star$","title":"1241-1250"},{"location":"python3/1201-1300/1241-1250/#1241-number-of-comments-per-post-star","text":"","title":"1241. Number of Comments per Post $\\star$ \ud83d\udd12"},{"location":"python3/1201-1300/1241-1250/#1242-web-crawler-multithreaded-starstar","text":"","title":"1242. Web Crawler Multithreaded $\\star\\star$ \ud83d\udd12"},{"location":"python3/1201-1300/1241-1250/#1243-array-transformation-star","text":"","title":"1243. Array Transformation $\\star$ \ud83d\udd12"},{"location":"python3/1201-1300/1241-1250/#1244-design-a-leaderboard-starstar","text":"","title":"1244. Design A Leaderboard $\\star\\star$ \ud83d\udd12"},{"location":"python3/1201-1300/1241-1250/#1245-tree-diameter-starstar","text":"","title":"1245. Tree Diameter $\\star\\star$ \ud83d\udd12"},{"location":"python3/1201-1300/1241-1250/#1246-palindrome-removal-starstarstar","text":"","title":"1246. Palindrome Removal $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/1201-1300/1241-1250/#1247-minimum-swaps-to-make-strings-equal-starstar","text":"","title":"1247. Minimum Swaps to Make Strings Equal $\\star\\star$"},{"location":"python3/1201-1300/1241-1250/#1248-count-number-of-nice-subarrays-starstar","text":"class Solution : def numberOfSubarrays ( self , nums : List [ int ], k : int ) -> int : def numberOfSubarraysAtMost ( k : int ) -> int : ans = 0 l = 0 r = 0 while r <= len ( nums ): if k >= 0 : ans += r - l if r == len ( nums ): break if nums [ r ] & 1 : k -= 1 r += 1 else : if nums [ l ] & 1 : k += 1 l += 1 return ans return numberOfSubarraysAtMost ( k ) - numberOfSubarraysAtMost ( k - 1 )","title":"1248. Count Number of Nice Subarrays $\\star\\star$"},{"location":"python3/1201-1300/1241-1250/#1249-minimum-remove-to-make-valid-parentheses-starstar","text":"","title":"1249. Minimum Remove to Make Valid Parentheses $\\star\\star$"},{"location":"python3/1201-1300/1241-1250/#1250-check-if-it-is-a-good-array-starstarstar","text":"","title":"1250. Check If It Is a Good Array $\\star\\star\\star$"},{"location":"python3/1201-1300/1251-1260/","text":"1251. Average Selling Price $\\star$ \ud83d\udd12 1252. Cells with Odd Values in a Matrix $\\star$ class Solution : def oddCells ( self , n : int , m : int , indices : List [ List [ int ]]) -> int : ans = 0 rows = [ 0 ] * n cols = [ 0 ] * m for indice in indices : rows [ indice [ 0 ]] ^= 1 cols [ indice [ 1 ]] ^= 1 for i in range ( n ): for j in range ( m ): ans += rows [ i ] ^ cols [ j ] return ans 1253. Reconstruct a 2-Row Binary Matrix $\\star\\star$ class Solution : def reconstructMatrix ( self , upper : int , lower : int , colsum : List [ int ]) -> List [ List [ int ]]: if upper + lower != sum ( colsum ): return [] if min ( upper , lower ) < colsum . count ( 2 ): return [] ans = [[ 0 ] * len ( colsum ) for _ in range ( 2 )] for j , c in enumerate ( colsum ): if c == 2 : ans [ 0 ][ j ] = 1 ans [ 1 ][ j ] = 1 upper -= 1 lower -= 1 for j , c in enumerate ( colsum ): if c == 1 and upper > 0 : ans [ 0 ][ j ] = 1 c -= 1 upper -= 1 if c == 1 and lower > 0 : ans [ 1 ][ j ] = 1 lower -= 1 return ans 1254. Number of Closed Islands $\\star\\star$ 1255. Maximum Score Words Formed by Letters $\\star\\star\\star$ 1256. Encode Number $\\star\\star$ \ud83d\udd12 1257. Smallest Common Region $\\star\\star$ \ud83d\udd12 1258. Synonymous Sentences $\\star\\star$ \ud83d\udd12 1259. Handshakes That Don't Cross $\\star\\star\\star$ \ud83d\udd12 1260. Shift 2D Grid $\\star$ class Solution : def shiftGrid ( self , grid : List [ List [ int ]], k : int ) -> List [ List [ int ]]: m = len ( grid ) n = len ( grid [ 0 ]) ans = [[ 0 ] * n for _ in range ( m )] k %= m * n for i in range ( m ): for j in range ( n ): index = ( i * n + j + k ) % ( m * n ) x = index // n y = index % n ans [ x ][ y ] = grid [ i ][ j ] return ans","title":"1251-1260"},{"location":"python3/1201-1300/1251-1260/#1251-average-selling-price-star","text":"","title":"1251. Average Selling Price $\\star$ \ud83d\udd12"},{"location":"python3/1201-1300/1251-1260/#1252-cells-with-odd-values-in-a-matrix-star","text":"class Solution : def oddCells ( self , n : int , m : int , indices : List [ List [ int ]]) -> int : ans = 0 rows = [ 0 ] * n cols = [ 0 ] * m for indice in indices : rows [ indice [ 0 ]] ^= 1 cols [ indice [ 1 ]] ^= 1 for i in range ( n ): for j in range ( m ): ans += rows [ i ] ^ cols [ j ] return ans","title":"1252. Cells with Odd Values in a Matrix $\\star$"},{"location":"python3/1201-1300/1251-1260/#1253-reconstruct-a-2-row-binary-matrix-starstar","text":"class Solution : def reconstructMatrix ( self , upper : int , lower : int , colsum : List [ int ]) -> List [ List [ int ]]: if upper + lower != sum ( colsum ): return [] if min ( upper , lower ) < colsum . count ( 2 ): return [] ans = [[ 0 ] * len ( colsum ) for _ in range ( 2 )] for j , c in enumerate ( colsum ): if c == 2 : ans [ 0 ][ j ] = 1 ans [ 1 ][ j ] = 1 upper -= 1 lower -= 1 for j , c in enumerate ( colsum ): if c == 1 and upper > 0 : ans [ 0 ][ j ] = 1 c -= 1 upper -= 1 if c == 1 and lower > 0 : ans [ 1 ][ j ] = 1 lower -= 1 return ans","title":"1253. Reconstruct a 2-Row Binary Matrix $\\star\\star$"},{"location":"python3/1201-1300/1251-1260/#1254-number-of-closed-islands-starstar","text":"","title":"1254. Number of Closed Islands $\\star\\star$"},{"location":"python3/1201-1300/1251-1260/#1255-maximum-score-words-formed-by-letters-starstarstar","text":"","title":"1255. Maximum Score Words Formed by Letters $\\star\\star\\star$"},{"location":"python3/1201-1300/1251-1260/#1256-encode-number-starstar","text":"","title":"1256. Encode Number $\\star\\star$ \ud83d\udd12"},{"location":"python3/1201-1300/1251-1260/#1257-smallest-common-region-starstar","text":"","title":"1257. Smallest Common Region $\\star\\star$ \ud83d\udd12"},{"location":"python3/1201-1300/1251-1260/#1258-synonymous-sentences-starstar","text":"","title":"1258. Synonymous Sentences $\\star\\star$ \ud83d\udd12"},{"location":"python3/1201-1300/1251-1260/#1259-handshakes-that-dont-cross-starstarstar","text":"","title":"1259. Handshakes That Don't Cross $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/1201-1300/1251-1260/#1260-shift-2d-grid-star","text":"class Solution : def shiftGrid ( self , grid : List [ List [ int ]], k : int ) -> List [ List [ int ]]: m = len ( grid ) n = len ( grid [ 0 ]) ans = [[ 0 ] * n for _ in range ( m )] k %= m * n for i in range ( m ): for j in range ( n ): index = ( i * n + j + k ) % ( m * n ) x = index // n y = index % n ans [ x ][ y ] = grid [ i ][ j ] return ans","title":"1260. Shift 2D Grid $\\star$"},{"location":"python3/1201-1300/1261-1270/","text":"1261. Find Elements in a Contaminated Binary Tree $\\star\\star$ class FindElements : def __init__ ( self , root : TreeNode ): self . vals = set () self . dfs ( root , 0 ) def find ( self , target : int ) -> bool : return target in self . vals def dfs ( self , root : TreeNode , val : int ) -> None : if not root : return root . val = val self . vals . add ( val ) self . dfs ( root . left , val * 2 + 1 ) self . dfs ( root . right , val * 2 + 2 ) 1262. Greatest Sum Divisible by Three $\\star\\star$ 1263. Minimum Moves to Move a Box to Their Target Location $\\star\\star\\star$ 1264. Page Recommendations $\\star\\star$ \ud83d\udd12 1265. Print Immutable Linked List in Reverse $\\star\\star$ \ud83d\udd12 1266. Minimum Time Visiting All Points $\\star$ class Solution : def minTimeToVisitAllPoints ( self , points : List [ List [ int ]]) -> int : ans = 0 for i in range ( 1 , len ( points )): ans += max ( abs ( points [ i ][ 0 ] - points [ i - 1 ][ 0 ]), abs ( points [ i ][ 1 ] - points [ i - 1 ][ 1 ])) return ans 1267. Count Servers that Communicate $\\star\\star$ class Solution : def countServers ( self , grid : List [ List [ int ]]) -> int : m = len ( grid ) n = len ( grid [ 0 ]) ans = 0 rows = [ 0 ] * m cols = [ 0 ] * n for i in range ( m ): for j in range ( n ): if grid [ i ][ j ] == 1 : rows [ i ] += 1 cols [ j ] += 1 for i in range ( m ): for j in range ( n ): if grid [ i ][ j ] == 1 and ( rows [ i ] > 1 or cols [ j ] > 1 ): ans += 1 return ans 1268. Search Suggestions System $\\star\\star$ 1269. Number of Ways to Stay in the Same Place After Some Steps $\\star\\star\\star$ 1270. All People Report to the Given Manager $\\star\\star$ \ud83d\udd12","title":"1261-1270"},{"location":"python3/1201-1300/1261-1270/#1261-find-elements-in-a-contaminated-binary-tree-starstar","text":"class FindElements : def __init__ ( self , root : TreeNode ): self . vals = set () self . dfs ( root , 0 ) def find ( self , target : int ) -> bool : return target in self . vals def dfs ( self , root : TreeNode , val : int ) -> None : if not root : return root . val = val self . vals . add ( val ) self . dfs ( root . left , val * 2 + 1 ) self . dfs ( root . right , val * 2 + 2 )","title":"1261. Find Elements in a Contaminated Binary Tree $\\star\\star$"},{"location":"python3/1201-1300/1261-1270/#1262-greatest-sum-divisible-by-three-starstar","text":"","title":"1262. Greatest Sum Divisible by Three $\\star\\star$"},{"location":"python3/1201-1300/1261-1270/#1263-minimum-moves-to-move-a-box-to-their-target-location-starstarstar","text":"","title":"1263. Minimum Moves to Move a Box to Their Target Location $\\star\\star\\star$"},{"location":"python3/1201-1300/1261-1270/#1264-page-recommendations-starstar","text":"","title":"1264. Page Recommendations $\\star\\star$ \ud83d\udd12"},{"location":"python3/1201-1300/1261-1270/#1265-print-immutable-linked-list-in-reverse-starstar","text":"","title":"1265. Print Immutable Linked List in Reverse $\\star\\star$ \ud83d\udd12"},{"location":"python3/1201-1300/1261-1270/#1266-minimum-time-visiting-all-points-star","text":"class Solution : def minTimeToVisitAllPoints ( self , points : List [ List [ int ]]) -> int : ans = 0 for i in range ( 1 , len ( points )): ans += max ( abs ( points [ i ][ 0 ] - points [ i - 1 ][ 0 ]), abs ( points [ i ][ 1 ] - points [ i - 1 ][ 1 ])) return ans","title":"1266. Minimum Time Visiting All Points $\\star$"},{"location":"python3/1201-1300/1261-1270/#1267-count-servers-that-communicate-starstar","text":"class Solution : def countServers ( self , grid : List [ List [ int ]]) -> int : m = len ( grid ) n = len ( grid [ 0 ]) ans = 0 rows = [ 0 ] * m cols = [ 0 ] * n for i in range ( m ): for j in range ( n ): if grid [ i ][ j ] == 1 : rows [ i ] += 1 cols [ j ] += 1 for i in range ( m ): for j in range ( n ): if grid [ i ][ j ] == 1 and ( rows [ i ] > 1 or cols [ j ] > 1 ): ans += 1 return ans","title":"1267. Count Servers that Communicate $\\star\\star$"},{"location":"python3/1201-1300/1261-1270/#1268-search-suggestions-system-starstar","text":"","title":"1268. Search Suggestions System $\\star\\star$"},{"location":"python3/1201-1300/1261-1270/#1269-number-of-ways-to-stay-in-the-same-place-after-some-steps-starstarstar","text":"","title":"1269. Number of Ways to Stay in the Same Place After Some Steps $\\star\\star\\star$"},{"location":"python3/1201-1300/1261-1270/#1270-all-people-report-to-the-given-manager-starstar","text":"","title":"1270. All People Report to the Given Manager $\\star\\star$ \ud83d\udd12"},{"location":"python3/1201-1300/1271-1280/","text":"1271. Hexspeak $\\star$ \ud83d\udd12 1272. Remove Interval $\\star\\star$ \ud83d\udd12 1273. Delete Tree Nodes $\\star\\star$ \ud83d\udd12 1274. Number of Ships in a Rectangle $\\star\\star\\star$ \ud83d\udd12 1275. Find Winner on a Tic Tac Toe Game $\\star$ class Solution : def tictactoe ( self , moves : List [ List [ int ]]) -> str : row = [[ 0 ] * 3 for _ in range ( 2 )] col = [[ 0 ] * 3 for _ in range ( 2 )] diag1 = [ 0 ] * 2 diag2 = [ 0 ] * 2 i = 0 for r , c in moves : row [ i ][ r ] += 1 col [ i ][ c ] += 1 diag1 [ i ] += r == c diag2 [ i ] += r + c == 2 if 3 in ( row [ i ][ r ], col [ i ][ c ], diag1 [ i ], diag2 [ i ]): return \"A\" if i == 0 else \"B\" i ^= 1 return \"Draw\" if len ( moves ) == 9 else \"Pending\" 1276. Number of Burgers with No Waste of Ingredients $\\star\\star$ class Solution : def numOfBurgers ( self , tomatoSlices : int , cheeseSlices : int ) -> List [ int ]: if tomatoSlices % 2 == 1 or tomatoSlices < 2 * cheeseSlices or tomatoSlices > cheeseSlices * 4 : return [] jumboBurgers = ( tomatoSlices - 2 * cheeseSlices ) // 2 return [ jumboBurgers , cheeseSlices - jumboBurgers ] 1277. Count Square Submatrices with All Ones $\\star\\star$ class Solution : def countSquares ( self , matrix : List [ List [ int ]]) -> int : for i in range ( len ( matrix )): for j in range ( len ( matrix [ 0 ])): if matrix [ i ][ j ] == 1 and i > 0 and j > 0 : matrix [ i ][ j ] += min ( matrix [ i - 1 ][ j - 1 ], matrix [ i - 1 ][ j ], matrix [ i ][ j - 1 ]) return sum ( sum ( row ) for row in matrix ) 1278. Palindrome Partitioning III $\\star\\star\\star$ 1279. Traffic Light Controlled Intersection $\\star$ \ud83d\udd12 1280. Students and Examinations $\\star$ \ud83d\udd12","title":"1271-1280"},{"location":"python3/1201-1300/1271-1280/#1271-hexspeak-star","text":"","title":"1271. Hexspeak $\\star$ \ud83d\udd12"},{"location":"python3/1201-1300/1271-1280/#1272-remove-interval-starstar","text":"","title":"1272. Remove Interval $\\star\\star$ \ud83d\udd12"},{"location":"python3/1201-1300/1271-1280/#1273-delete-tree-nodes-starstar","text":"","title":"1273. Delete Tree Nodes $\\star\\star$ \ud83d\udd12"},{"location":"python3/1201-1300/1271-1280/#1274-number-of-ships-in-a-rectangle-starstarstar","text":"","title":"1274. Number of Ships in a Rectangle $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/1201-1300/1271-1280/#1275-find-winner-on-a-tic-tac-toe-game-star","text":"class Solution : def tictactoe ( self , moves : List [ List [ int ]]) -> str : row = [[ 0 ] * 3 for _ in range ( 2 )] col = [[ 0 ] * 3 for _ in range ( 2 )] diag1 = [ 0 ] * 2 diag2 = [ 0 ] * 2 i = 0 for r , c in moves : row [ i ][ r ] += 1 col [ i ][ c ] += 1 diag1 [ i ] += r == c diag2 [ i ] += r + c == 2 if 3 in ( row [ i ][ r ], col [ i ][ c ], diag1 [ i ], diag2 [ i ]): return \"A\" if i == 0 else \"B\" i ^= 1 return \"Draw\" if len ( moves ) == 9 else \"Pending\"","title":"1275. Find Winner on a Tic Tac Toe Game $\\star$"},{"location":"python3/1201-1300/1271-1280/#1276-number-of-burgers-with-no-waste-of-ingredients-starstar","text":"class Solution : def numOfBurgers ( self , tomatoSlices : int , cheeseSlices : int ) -> List [ int ]: if tomatoSlices % 2 == 1 or tomatoSlices < 2 * cheeseSlices or tomatoSlices > cheeseSlices * 4 : return [] jumboBurgers = ( tomatoSlices - 2 * cheeseSlices ) // 2 return [ jumboBurgers , cheeseSlices - jumboBurgers ]","title":"1276. Number of Burgers with No Waste of Ingredients $\\star\\star$"},{"location":"python3/1201-1300/1271-1280/#1277-count-square-submatrices-with-all-ones-starstar","text":"class Solution : def countSquares ( self , matrix : List [ List [ int ]]) -> int : for i in range ( len ( matrix )): for j in range ( len ( matrix [ 0 ])): if matrix [ i ][ j ] == 1 and i > 0 and j > 0 : matrix [ i ][ j ] += min ( matrix [ i - 1 ][ j - 1 ], matrix [ i - 1 ][ j ], matrix [ i ][ j - 1 ]) return sum ( sum ( row ) for row in matrix )","title":"1277. Count Square Submatrices with All Ones $\\star\\star$"},{"location":"python3/1201-1300/1271-1280/#1278-palindrome-partitioning-iii-starstarstar","text":"","title":"1278. Palindrome Partitioning III $\\star\\star\\star$"},{"location":"python3/1201-1300/1271-1280/#1279-traffic-light-controlled-intersection-star","text":"","title":"1279. Traffic Light Controlled Intersection $\\star$ \ud83d\udd12"},{"location":"python3/1201-1300/1271-1280/#1280-students-and-examinations-star","text":"","title":"1280. Students and Examinations $\\star$ \ud83d\udd12"},{"location":"python3/1201-1300/1281-1290/","text":"1281. Subtract the Product and Sum of Digits of an Integer $\\star$ class Solution : def subtractProductAndSum ( self , n : int ) -> int : prod = 1 summ = 0 while n > 0 : prod *= n % 10 summ += n % 10 n //= 10 return prod - summ 1282. Group the People Given the Group Size They Belong To $\\star\\star$ 1283. Find the Smallest Divisor Given a Threshold $\\star\\star$ 1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix $\\star\\star\\star$ 1285. Find the Start and End Number of Continuous Ranges $\\star\\star$ \ud83d\udd12 1286. Iterator for Combination $\\star\\star$ 1287. Element Appearing More Than 25% In Sorted Array $\\star$ class Solution : def findSpecialInteger ( self , arr : List [ int ]) -> int : n = len ( arr ) quarter = n // 4 for i in range ( n - quarter ): if arr [ i ] == arr [ i + quarter ]: return arr [ i ] 1288. Remove Covered Intervals $\\star\\star$ 1289. Minimum Falling Path Sum II $\\star\\star\\star$ 1290. Convert Binary Number in a Linked List to Integer $\\star$ class Solution : def getDecimalValue ( self , head : ListNode ) -> int : ans = 0 while head : ans = ans * 2 + head . val head = head . next return ans","title":"1281-1290"},{"location":"python3/1201-1300/1281-1290/#1281-subtract-the-product-and-sum-of-digits-of-an-integer-star","text":"class Solution : def subtractProductAndSum ( self , n : int ) -> int : prod = 1 summ = 0 while n > 0 : prod *= n % 10 summ += n % 10 n //= 10 return prod - summ","title":"1281. Subtract the Product and Sum of Digits of an Integer $\\star$"},{"location":"python3/1201-1300/1281-1290/#1282-group-the-people-given-the-group-size-they-belong-to-starstar","text":"","title":"1282. Group the People Given the Group Size They Belong To $\\star\\star$"},{"location":"python3/1201-1300/1281-1290/#1283-find-the-smallest-divisor-given-a-threshold-starstar","text":"","title":"1283. Find the Smallest Divisor Given a Threshold $\\star\\star$"},{"location":"python3/1201-1300/1281-1290/#1284-minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix-starstarstar","text":"","title":"1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix $\\star\\star\\star$"},{"location":"python3/1201-1300/1281-1290/#1285-find-the-start-and-end-number-of-continuous-ranges-starstar","text":"","title":"1285. Find the Start and End Number of Continuous Ranges $\\star\\star$ \ud83d\udd12"},{"location":"python3/1201-1300/1281-1290/#1286-iterator-for-combination-starstar","text":"","title":"1286. Iterator for Combination $\\star\\star$"},{"location":"python3/1201-1300/1281-1290/#1287-element-appearing-more-than-25-in-sorted-array-star","text":"class Solution : def findSpecialInteger ( self , arr : List [ int ]) -> int : n = len ( arr ) quarter = n // 4 for i in range ( n - quarter ): if arr [ i ] == arr [ i + quarter ]: return arr [ i ]","title":"1287. Element Appearing More Than 25% In Sorted Array $\\star$"},{"location":"python3/1201-1300/1281-1290/#1288-remove-covered-intervals-starstar","text":"","title":"1288. Remove Covered Intervals $\\star\\star$"},{"location":"python3/1201-1300/1281-1290/#1289-minimum-falling-path-sum-ii-starstarstar","text":"","title":"1289. Minimum Falling Path Sum II $\\star\\star\\star$"},{"location":"python3/1201-1300/1281-1290/#1290-convert-binary-number-in-a-linked-list-to-integer-star","text":"class Solution : def getDecimalValue ( self , head : ListNode ) -> int : ans = 0 while head : ans = ans * 2 + head . val head = head . next return ans","title":"1290. Convert Binary Number in a Linked List to Integer $\\star$"},{"location":"python3/1201-1300/1291-1300/","text":"1291. Sequential Digits $\\star\\star$ 1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold $\\star\\star$ class Solution : def maxSideLength ( self , mat : List [ List [ int ]], threshold : int ) -> int : def squareSum ( r1 : int , c1 : int , r2 : int , c2 : int ) -> int : return prefixSum [ r2 + 1 ][ c2 + 1 ] - prefixSum [ r1 ][ c2 + 1 ] - prefixSum [ r2 + 1 ][ c1 ] + prefixSum [ r1 ][ c1 ] m = len ( mat ) n = len ( mat [ 0 ]) ans = 0 prefixSum = [[ 0 ] * ( n + 1 ) for _ in range ( m + 1 )] for i in range ( 1 , m + 1 ): for j in range ( 1 , n + 1 ): prefixSum [ i ][ j ] = mat [ i - 1 ][ j - 1 ] + prefixSum [ i ][ j - 1 ] + \\ prefixSum [ i - 1 ][ j ] - prefixSum [ i - 1 ][ j - 1 ] for i in range ( m ): for j in range ( n ): for length in range ( ans , min ( m - i , n - j )): if squareSum ( i , j , i + length , j + length ) > threshold : break ans = max ( ans , length + 1 ) return ans 1293. Shortest Path in a Grid with Obstacles Elimination $\\star\\star\\star$ 1294. Weather Type in Each Country $\\star$ \ud83d\udd12 1295. Find Numbers with Even Number of Digits $\\star$ class Solution : def findNumbers ( self , nums : List [ int ]) -> int : ans = 0 for num in nums : if 9 < num < 100 or 999 < num < 10000 or num == 100000 : ans += 1 return ans 1296. Divide Array in Sets of K Consecutive Numbers $\\star\\star$ class Solution : def isPossibleDivide ( self , nums : List [ int ], k : int ) -> bool : count = collections . Counter ( nums ) for key in sorted ( count ): value = count [ key ] if value > 0 : for i in range ( key , key + k ): count [ i ] -= value if count [ i ] < 0 : return False return True 1297. Maximum Number of Occurrences of a Substring $\\star\\star$ 1298. Maximum Candies You Can Get from Boxes $\\star\\star\\star$ 1299. Replace Elements with Greatest Element on Right Side $\\star$ class Solution : def replaceElements ( self , arr : List [ int ]) -> List [ int ]: maxOfRight = - 1 for i in range ( len ( arr ))[:: - 1 ]: arr [ i ], maxOfRight = maxOfRight , max ( maxOfRight , arr [ i ]) return arr 1300. Sum of Mutated Array Closest to Target $\\star\\star$ class Solution : def findBestValue ( self , arr : List [ int ], target : int ) -> int : prefixSum = 0 arr . sort () for i , a in enumerate ( arr ): ans = round (( target - prefixSum ) / ( len ( arr ) - i )) if ans <= a : return ans prefixSum += a return arr [ - 1 ]","title":"1291-1300"},{"location":"python3/1201-1300/1291-1300/#1291-sequential-digits-starstar","text":"","title":"1291. Sequential Digits $\\star\\star$"},{"location":"python3/1201-1300/1291-1300/#1292-maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold-starstar","text":"class Solution : def maxSideLength ( self , mat : List [ List [ int ]], threshold : int ) -> int : def squareSum ( r1 : int , c1 : int , r2 : int , c2 : int ) -> int : return prefixSum [ r2 + 1 ][ c2 + 1 ] - prefixSum [ r1 ][ c2 + 1 ] - prefixSum [ r2 + 1 ][ c1 ] + prefixSum [ r1 ][ c1 ] m = len ( mat ) n = len ( mat [ 0 ]) ans = 0 prefixSum = [[ 0 ] * ( n + 1 ) for _ in range ( m + 1 )] for i in range ( 1 , m + 1 ): for j in range ( 1 , n + 1 ): prefixSum [ i ][ j ] = mat [ i - 1 ][ j - 1 ] + prefixSum [ i ][ j - 1 ] + \\ prefixSum [ i - 1 ][ j ] - prefixSum [ i - 1 ][ j - 1 ] for i in range ( m ): for j in range ( n ): for length in range ( ans , min ( m - i , n - j )): if squareSum ( i , j , i + length , j + length ) > threshold : break ans = max ( ans , length + 1 ) return ans","title":"1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold $\\star\\star$"},{"location":"python3/1201-1300/1291-1300/#1293-shortest-path-in-a-grid-with-obstacles-elimination-starstarstar","text":"","title":"1293. Shortest Path in a Grid with Obstacles Elimination $\\star\\star\\star$"},{"location":"python3/1201-1300/1291-1300/#1294-weather-type-in-each-country-star","text":"","title":"1294. Weather Type in Each Country $\\star$ \ud83d\udd12"},{"location":"python3/1201-1300/1291-1300/#1295-find-numbers-with-even-number-of-digits-star","text":"class Solution : def findNumbers ( self , nums : List [ int ]) -> int : ans = 0 for num in nums : if 9 < num < 100 or 999 < num < 10000 or num == 100000 : ans += 1 return ans","title":"1295. Find Numbers with Even Number of Digits $\\star$"},{"location":"python3/1201-1300/1291-1300/#1296-divide-array-in-sets-of-k-consecutive-numbers-starstar","text":"class Solution : def isPossibleDivide ( self , nums : List [ int ], k : int ) -> bool : count = collections . Counter ( nums ) for key in sorted ( count ): value = count [ key ] if value > 0 : for i in range ( key , key + k ): count [ i ] -= value if count [ i ] < 0 : return False return True","title":"1296. Divide Array in Sets of K Consecutive Numbers $\\star\\star$"},{"location":"python3/1201-1300/1291-1300/#1297-maximum-number-of-occurrences-of-a-substring-starstar","text":"","title":"1297. Maximum Number of Occurrences of a Substring $\\star\\star$"},{"location":"python3/1201-1300/1291-1300/#1298-maximum-candies-you-can-get-from-boxes-starstarstar","text":"","title":"1298. Maximum Candies You Can Get from Boxes $\\star\\star\\star$"},{"location":"python3/1201-1300/1291-1300/#1299-replace-elements-with-greatest-element-on-right-side-star","text":"class Solution : def replaceElements ( self , arr : List [ int ]) -> List [ int ]: maxOfRight = - 1 for i in range ( len ( arr ))[:: - 1 ]: arr [ i ], maxOfRight = maxOfRight , max ( maxOfRight , arr [ i ]) return arr","title":"1299. Replace Elements with Greatest Element on Right Side $\\star$"},{"location":"python3/1201-1300/1291-1300/#1300-sum-of-mutated-array-closest-to-target-starstar","text":"class Solution : def findBestValue ( self , arr : List [ int ], target : int ) -> int : prefixSum = 0 arr . sort () for i , a in enumerate ( arr ): ans = round (( target - prefixSum ) / ( len ( arr ) - i )) if ans <= a : return ans prefixSum += a return arr [ - 1 ]","title":"1300. Sum of Mutated Array Closest to Target $\\star\\star$"},{"location":"python3/1301-1400/1301-1310/","text":"1301. Number of Paths with Max Score $\\star\\star\\star$ 1302. Deepest Leaves Sum $\\star\\star$ 1303. Find the Team Size $\\star$ \ud83d\udd12 1304. Find N Unique Integers Sum up to Zero $\\star$ class Solution : def sumZero ( self , n : int ) -> List [ int ]: return list ( range ( 1 - n , n , 2 )) 1305. All Elements in Two Binary Search Trees $\\star\\star$ 1306. Jump Game III $\\star\\star$ 1307. Verbal Arithmetic Puzzle $\\star\\star\\star$ class Solution : def isSolvable ( self , words : List [ str ], result : str ) -> bool : def dfs ( row : int , col : int , summ : int ) -> bool : if col == cols : return summ == 0 if row == rows : return summ % 10 == 0 and dfs ( 0 , col + 1 , summ // 10 ) word = words [ row ] if col >= len ( word ): return dfs ( row + 1 , col , summ ) letter = word [ ~ col ] sign = - 1 if row == rows - 1 else 1 if letter in letterToDigit and ( letterToDigit [ letter ] > 0 or col < len ( word ) - 1 ): return dfs ( row + 1 , col , summ + sign * letterToDigit [ letter ]) for digit , used in enumerate ( usedDigit ): if not used and ( digit > 0 or col < len ( word ) - 1 ): letterToDigit [ letter ] = digit usedDigit [ digit ] = True if dfs ( row + 1 , col , summ + sign * digit ): return True usedDigit [ digit ] = False if letter in letterToDigit : del letterToDigit [ letter ] return False words . append ( result ) rows = len ( words ) cols = max ( map ( len , words )) letterToDigit = {} usedDigit = [ False ] * 10 return dfs ( 0 , 0 , 0 ) 1308. Running Total for Different Genders $\\star\\star$ \ud83d\udd12 1309. Decrypt String from Alphabet to Integer Mapping $\\star$ class Solution : def freqAlphabets ( self , s : str ) -> str : ans = '' i = 0 while i < len ( s ): if i + 2 < len ( s ) and s [ i + 2 ] == '#' : ans += chr ( int ( s [ i : i + 2 ]) + ord ( 'a' ) - 1 ) i += 3 else : ans += chr ( int ( s [ i ]) + ord ( 'a' ) - 1 ) i += 1 return ans 1310. XOR Queries of a Subarray $\\star\\star$ class Solution : def xorQueries ( self , arr : List [ int ], queries : List [ List [ int ]]) -> List [ int ]: ans = [] xors = [ 0 ] * ( len ( arr ) + 1 ) for i , a in enumerate ( arr ): xors [ i + 1 ] ^= xors [ i ] ^ a for l , r in queries : ans . append ( xors [ l ] ^ xors [ r + 1 ]) return ans","title":"1301-1310"},{"location":"python3/1301-1400/1301-1310/#1301-number-of-paths-with-max-score-starstarstar","text":"","title":"1301. Number of Paths with Max Score $\\star\\star\\star$"},{"location":"python3/1301-1400/1301-1310/#1302-deepest-leaves-sum-starstar","text":"","title":"1302. Deepest Leaves Sum $\\star\\star$"},{"location":"python3/1301-1400/1301-1310/#1303-find-the-team-size-star","text":"","title":"1303. Find the Team Size $\\star$ \ud83d\udd12"},{"location":"python3/1301-1400/1301-1310/#1304-find-n-unique-integers-sum-up-to-zero-star","text":"class Solution : def sumZero ( self , n : int ) -> List [ int ]: return list ( range ( 1 - n , n , 2 ))","title":"1304. Find N Unique Integers Sum up to Zero $\\star$"},{"location":"python3/1301-1400/1301-1310/#1305-all-elements-in-two-binary-search-trees-starstar","text":"","title":"1305. All Elements in Two Binary Search Trees $\\star\\star$"},{"location":"python3/1301-1400/1301-1310/#1306-jump-game-iii-starstar","text":"","title":"1306. Jump Game III $\\star\\star$"},{"location":"python3/1301-1400/1301-1310/#1307-verbal-arithmetic-puzzle-starstarstar","text":"class Solution : def isSolvable ( self , words : List [ str ], result : str ) -> bool : def dfs ( row : int , col : int , summ : int ) -> bool : if col == cols : return summ == 0 if row == rows : return summ % 10 == 0 and dfs ( 0 , col + 1 , summ // 10 ) word = words [ row ] if col >= len ( word ): return dfs ( row + 1 , col , summ ) letter = word [ ~ col ] sign = - 1 if row == rows - 1 else 1 if letter in letterToDigit and ( letterToDigit [ letter ] > 0 or col < len ( word ) - 1 ): return dfs ( row + 1 , col , summ + sign * letterToDigit [ letter ]) for digit , used in enumerate ( usedDigit ): if not used and ( digit > 0 or col < len ( word ) - 1 ): letterToDigit [ letter ] = digit usedDigit [ digit ] = True if dfs ( row + 1 , col , summ + sign * digit ): return True usedDigit [ digit ] = False if letter in letterToDigit : del letterToDigit [ letter ] return False words . append ( result ) rows = len ( words ) cols = max ( map ( len , words )) letterToDigit = {} usedDigit = [ False ] * 10 return dfs ( 0 , 0 , 0 )","title":"1307. Verbal Arithmetic Puzzle $\\star\\star\\star$"},{"location":"python3/1301-1400/1301-1310/#1308-running-total-for-different-genders-starstar","text":"","title":"1308. Running Total for Different Genders $\\star\\star$ \ud83d\udd12"},{"location":"python3/1301-1400/1301-1310/#1309-decrypt-string-from-alphabet-to-integer-mapping-star","text":"class Solution : def freqAlphabets ( self , s : str ) -> str : ans = '' i = 0 while i < len ( s ): if i + 2 < len ( s ) and s [ i + 2 ] == '#' : ans += chr ( int ( s [ i : i + 2 ]) + ord ( 'a' ) - 1 ) i += 3 else : ans += chr ( int ( s [ i ]) + ord ( 'a' ) - 1 ) i += 1 return ans","title":"1309. Decrypt String from Alphabet to Integer Mapping $\\star$"},{"location":"python3/1301-1400/1301-1310/#1310-xor-queries-of-a-subarray-starstar","text":"class Solution : def xorQueries ( self , arr : List [ int ], queries : List [ List [ int ]]) -> List [ int ]: ans = [] xors = [ 0 ] * ( len ( arr ) + 1 ) for i , a in enumerate ( arr ): xors [ i + 1 ] ^= xors [ i ] ^ a for l , r in queries : ans . append ( xors [ l ] ^ xors [ r + 1 ]) return ans","title":"1310. XOR Queries of a Subarray $\\star\\star$"},{"location":"python3/1301-1400/1311-1320/","text":"1311. Get Watched Videos by Your Friends $\\star\\star$ class Solution : def watchedVideosByFriends ( self , watchedVideos : List [ List [ str ]], friends : List [ List [ int ]], id : int , level : int ) -> List [ str ]: visited = [ False ] * 100 visited [ id ] = True queue = collections . deque ([ id ]) count = collections . Counter () for _ in range ( level ): for _ in range ( len ( queue )): curr = queue . popleft () for friend in friends [ curr ]: if not visited [ friend ]: visited [ friend ] = True queue . append ( friend ) for friend in queue : for video in watchedVideos [ friend ]: count [ video ] += 1 return sorted ( count . keys (), key = lambda video : ( count [ video ], video )) 1312. Minimum Insertion Steps to Make a String Palindrome $\\star\\star\\star$ 1313. Decompress Run-Length Encoded List $\\star$ class Solution : def decompressRLElist ( self , nums : List [ int ]) -> List [ int ]: ans = [] for i in range ( 0 , len ( nums ), 2 ): ans += [ nums [ i + 1 ]] * nums [ i ] return ans 1314. Matrix Block Sum $\\star\\star$ 1315. Sum of Nodes with Even-Valued Grandparent $\\star\\star$ 1316. Distinct Echo Substrings $\\star\\star\\star$ 1317. Convert Integer to the Sum of Two No-Zero Integers $\\star$ class Solution : def getNoZeroIntegers ( self , n : int ) -> List [ int ]: for A in range ( n ): B = n - A if '0' not in str ( A ) and '0' not in str ( B ): return A , B 1318. Minimum Flips to Make a OR b Equal to c $\\star\\star$ 1319. Number of Operations to Make Network Connected $\\star\\star$ 1320. Minimum Distance to Type a Word Using Two Fingers $\\star\\star\\star$","title":"1311-1320"},{"location":"python3/1301-1400/1311-1320/#1311-get-watched-videos-by-your-friends-starstar","text":"class Solution : def watchedVideosByFriends ( self , watchedVideos : List [ List [ str ]], friends : List [ List [ int ]], id : int , level : int ) -> List [ str ]: visited = [ False ] * 100 visited [ id ] = True queue = collections . deque ([ id ]) count = collections . Counter () for _ in range ( level ): for _ in range ( len ( queue )): curr = queue . popleft () for friend in friends [ curr ]: if not visited [ friend ]: visited [ friend ] = True queue . append ( friend ) for friend in queue : for video in watchedVideos [ friend ]: count [ video ] += 1 return sorted ( count . keys (), key = lambda video : ( count [ video ], video ))","title":"1311. Get Watched Videos by Your Friends $\\star\\star$"},{"location":"python3/1301-1400/1311-1320/#1312-minimum-insertion-steps-to-make-a-string-palindrome-starstarstar","text":"","title":"1312. Minimum Insertion Steps to Make a String Palindrome $\\star\\star\\star$"},{"location":"python3/1301-1400/1311-1320/#1313-decompress-run-length-encoded-list-star","text":"class Solution : def decompressRLElist ( self , nums : List [ int ]) -> List [ int ]: ans = [] for i in range ( 0 , len ( nums ), 2 ): ans += [ nums [ i + 1 ]] * nums [ i ] return ans","title":"1313. Decompress Run-Length Encoded List $\\star$"},{"location":"python3/1301-1400/1311-1320/#1314-matrix-block-sum-starstar","text":"","title":"1314. Matrix Block Sum $\\star\\star$"},{"location":"python3/1301-1400/1311-1320/#1315-sum-of-nodes-with-even-valued-grandparent-starstar","text":"","title":"1315. Sum of Nodes with Even-Valued Grandparent $\\star\\star$"},{"location":"python3/1301-1400/1311-1320/#1316-distinct-echo-substrings-starstarstar","text":"","title":"1316. Distinct Echo Substrings $\\star\\star\\star$"},{"location":"python3/1301-1400/1311-1320/#1317-convert-integer-to-the-sum-of-two-no-zero-integers-star","text":"class Solution : def getNoZeroIntegers ( self , n : int ) -> List [ int ]: for A in range ( n ): B = n - A if '0' not in str ( A ) and '0' not in str ( B ): return A , B","title":"1317. Convert Integer to the Sum of Two No-Zero Integers $\\star$"},{"location":"python3/1301-1400/1311-1320/#1318-minimum-flips-to-make-a-or-b-equal-to-c-starstar","text":"","title":"1318. Minimum Flips to Make a OR b Equal to c $\\star\\star$"},{"location":"python3/1301-1400/1311-1320/#1319-number-of-operations-to-make-network-connected-starstar","text":"","title":"1319. Number of Operations to Make Network Connected $\\star\\star$"},{"location":"python3/1301-1400/1311-1320/#1320-minimum-distance-to-type-a-word-using-two-fingers-starstarstar","text":"","title":"1320. Minimum Distance to Type a Word Using Two Fingers $\\star\\star\\star$"},{"location":"python3/1301-1400/1321-1330/","text":"1321. Restaurant Growth $\\star\\star$ \ud83d\udd12 1322. Ads Performance $\\star$ \ud83d\udd12 1323. Maximum 69 Number $\\star$ class Solution : def maximum69Number ( self , num : int ) -> int : return int ( str ( num ) . replace ( '6' , '9' , 1 )) 1324. Print Words Vertically $\\star\\star$ 1325. Delete Leaves With a Given Value $\\star\\star$ 1326. Minimum Number of Taps to Open to Water a Garden $\\star\\star\\star$ class Solution : def minTaps ( self , n : int , ranges : List [ int ]) -> int : nums = [ 0 ] * ( n + 1 ) for i , range_ in enumerate ( ranges ): l = max ( 0 , i - range_ ) r = min ( n , range_ + i ) nums [ l ] = max ( nums [ l ], r - l ) ans = 0 end = 0 farthest = 0 for i in range ( n ): farthest = max ( farthest , i + nums [ i ]) if i == end : ans += 1 end = farthest return ans if end == n else - 1 1327. List the Products Ordered in a Period $\\star$ \ud83d\udd12 1328. Break a Palindrome $\\star\\star$ 1329. Sort the Matrix Diagonally $\\star\\star$ class Solution : def diagonalSort ( self , mat : List [ List [ int ]]) -> List [ List [ int ]]: m = len ( mat ) n = len ( mat [ 0 ]) count = collections . defaultdict ( list ) for i in range ( m ): for j in range ( n ): count [ i - j ] . append ( mat [ i ][ j ]) for value in count . values (): value . sort ( reverse = 1 ) for i in range ( m ): for j in range ( n ): mat [ i ][ j ] = count [ i - j ] . pop () return mat 1330. Reverse Subarray To Maximize Array Value $\\star\\star\\star$ class Solution : def maxValueAfterReverse ( self , nums : List [ int ]) -> int : mini = float ( 'inf' ) maxi = float ( '-inf' ) for a , b in zip ( nums , nums [ 1 :]): mini = min ( mini , max ( a , b )) maxi = max ( maxi , min ( a , b )) diff = max ( 0 , ( maxi - mini ) * 2 ) for a , b in zip ( nums , nums [ 1 :]): headDiff = - abs ( a - b ) + abs ( nums [ 0 ] - b ) tailDiff = - abs ( a - b ) + abs ( nums [ - 1 ] - a ) diff = max ( diff , headDiff , tailDiff ) return sum ( abs ( a - b ) for a , b in zip ( nums , nums [ 1 :])) + diff","title":"1321-1330"},{"location":"python3/1301-1400/1321-1330/#1321-restaurant-growth-starstar","text":"","title":"1321. Restaurant Growth $\\star\\star$ \ud83d\udd12"},{"location":"python3/1301-1400/1321-1330/#1322-ads-performance-star","text":"","title":"1322. Ads Performance $\\star$ \ud83d\udd12"},{"location":"python3/1301-1400/1321-1330/#1323-maximum-69-number-star","text":"class Solution : def maximum69Number ( self , num : int ) -> int : return int ( str ( num ) . replace ( '6' , '9' , 1 ))","title":"1323. Maximum 69 Number $\\star$"},{"location":"python3/1301-1400/1321-1330/#1324-print-words-vertically-starstar","text":"","title":"1324. Print Words Vertically $\\star\\star$"},{"location":"python3/1301-1400/1321-1330/#1325-delete-leaves-with-a-given-value-starstar","text":"","title":"1325. Delete Leaves With a Given Value $\\star\\star$"},{"location":"python3/1301-1400/1321-1330/#1326-minimum-number-of-taps-to-open-to-water-a-garden-starstarstar","text":"class Solution : def minTaps ( self , n : int , ranges : List [ int ]) -> int : nums = [ 0 ] * ( n + 1 ) for i , range_ in enumerate ( ranges ): l = max ( 0 , i - range_ ) r = min ( n , range_ + i ) nums [ l ] = max ( nums [ l ], r - l ) ans = 0 end = 0 farthest = 0 for i in range ( n ): farthest = max ( farthest , i + nums [ i ]) if i == end : ans += 1 end = farthest return ans if end == n else - 1","title":"1326. Minimum Number of Taps to Open to Water a Garden $\\star\\star\\star$"},{"location":"python3/1301-1400/1321-1330/#1327-list-the-products-ordered-in-a-period-star","text":"","title":"1327. List the Products Ordered in a Period $\\star$ \ud83d\udd12"},{"location":"python3/1301-1400/1321-1330/#1328-break-a-palindrome-starstar","text":"","title":"1328. Break a Palindrome $\\star\\star$"},{"location":"python3/1301-1400/1321-1330/#1329-sort-the-matrix-diagonally-starstar","text":"class Solution : def diagonalSort ( self , mat : List [ List [ int ]]) -> List [ List [ int ]]: m = len ( mat ) n = len ( mat [ 0 ]) count = collections . defaultdict ( list ) for i in range ( m ): for j in range ( n ): count [ i - j ] . append ( mat [ i ][ j ]) for value in count . values (): value . sort ( reverse = 1 ) for i in range ( m ): for j in range ( n ): mat [ i ][ j ] = count [ i - j ] . pop () return mat","title":"1329. Sort the Matrix Diagonally $\\star\\star$"},{"location":"python3/1301-1400/1321-1330/#1330-reverse-subarray-to-maximize-array-value-starstarstar","text":"class Solution : def maxValueAfterReverse ( self , nums : List [ int ]) -> int : mini = float ( 'inf' ) maxi = float ( '-inf' ) for a , b in zip ( nums , nums [ 1 :]): mini = min ( mini , max ( a , b )) maxi = max ( maxi , min ( a , b )) diff = max ( 0 , ( maxi - mini ) * 2 ) for a , b in zip ( nums , nums [ 1 :]): headDiff = - abs ( a - b ) + abs ( nums [ 0 ] - b ) tailDiff = - abs ( a - b ) + abs ( nums [ - 1 ] - a ) diff = max ( diff , headDiff , tailDiff ) return sum ( abs ( a - b ) for a , b in zip ( nums , nums [ 1 :])) + diff","title":"1330. Reverse Subarray To Maximize Array Value $\\star\\star\\star$"},{"location":"python3/1301-1400/1331-1340/","text":"1331. Rank Transform of an Array $\\star$ class Solution : def arrayRankTransform ( self , arr : List [ int ]) -> List [ int ]: rank = {} for a in sorted ( arr ): if a not in rank : rank [ a ] = len ( rank ) + 1 return map ( rank . get , arr ) 1332. Remove Palindromic Subsequences $\\star$ 1333. Filter Restaurants by Vegan-Friendly, Price and Distance $\\star\\star$ class Solution : def filterRestaurants ( self , restaurants : List [ List [ int ]], veganFriendly : int , maxPrice : int , maxDistance : int ) -> List [ int ]: restaurants . sort ( key = lambda r : ( - r [ 1 ], - r [ 0 ])) return [ i for i , _ , v , p , d in restaurants if v >= veganFriendly and p <= maxPrice and d <= maxDistance ] 1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance $\\star\\star$ 1335. Minimum Difficulty of a Job Schedule $\\star\\star\\star$ class Solution : def minDifficulty ( self , jobDifficulty : List [ int ], d : int ) -> int : n = len ( jobDifficulty ) if d > n : return - 1 dp = [[ float ( 'inf' )] * ( d + 1 ) for _ in range ( n + 1 )] dp [ 0 ][ 0 ] = 0 for i in range ( 1 , n + 1 ): for k in range ( 1 , d + 1 ): maxDifficulty = 0 for j in range ( i , k - 1 , - 1 ): maxDifficulty = max ( maxDifficulty , jobDifficulty [ j - 1 ]) dp [ i ][ k ] = min ( dp [ i ][ k ], dp [ j - 1 ][ k - 1 ] + maxDifficulty ) return dp [ n ][ d ] 1336. Number of Transactions per Visit $\\star\\star\\star$ \ud83d\udd12 1337. The K Weakest Rows in a Matrix $\\star$ class Solution : def kWeakestRows ( self , mat : List [ List [ int ]], k : int ) -> List [ int ]: candidates = [] for i , row in enumerate ( mat ): candidates . append ([ sum ( row ), i ]) candidates . sort ( key = lambda c : ( c [ 0 ], c [ 1 ])) return [ i for _ , i in candidates [: k ]] 1338. Reduce Array Size to The Half $\\star\\star$ class Solution : def minSetSize ( self , arr : List [ int ]) -> int : n = len ( arr ) count = collections . Counter ( arr ) . most_common () count . sort ( key = lambda c : - c [ 1 ]) sum = 0 for i , c in enumerate ( count ): sum += c [ 1 ] if sum >= n // 2 : return i + 1 1339. Maximum Product of Splitted Binary Tree $\\star\\star$ 1340. Jump Game V $\\star\\star\\star$","title":"1331-1340"},{"location":"python3/1301-1400/1331-1340/#1331-rank-transform-of-an-array-star","text":"class Solution : def arrayRankTransform ( self , arr : List [ int ]) -> List [ int ]: rank = {} for a in sorted ( arr ): if a not in rank : rank [ a ] = len ( rank ) + 1 return map ( rank . get , arr )","title":"1331. Rank Transform of an Array $\\star$"},{"location":"python3/1301-1400/1331-1340/#1332-remove-palindromic-subsequences-star","text":"","title":"1332. Remove Palindromic Subsequences $\\star$"},{"location":"python3/1301-1400/1331-1340/#1333-filter-restaurants-by-vegan-friendly-price-and-distance-starstar","text":"class Solution : def filterRestaurants ( self , restaurants : List [ List [ int ]], veganFriendly : int , maxPrice : int , maxDistance : int ) -> List [ int ]: restaurants . sort ( key = lambda r : ( - r [ 1 ], - r [ 0 ])) return [ i for i , _ , v , p , d in restaurants if v >= veganFriendly and p <= maxPrice and d <= maxDistance ]","title":"1333. Filter Restaurants by Vegan-Friendly, Price and Distance $\\star\\star$"},{"location":"python3/1301-1400/1331-1340/#1334-find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance-starstar","text":"","title":"1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance $\\star\\star$"},{"location":"python3/1301-1400/1331-1340/#1335-minimum-difficulty-of-a-job-schedule-starstarstar","text":"class Solution : def minDifficulty ( self , jobDifficulty : List [ int ], d : int ) -> int : n = len ( jobDifficulty ) if d > n : return - 1 dp = [[ float ( 'inf' )] * ( d + 1 ) for _ in range ( n + 1 )] dp [ 0 ][ 0 ] = 0 for i in range ( 1 , n + 1 ): for k in range ( 1 , d + 1 ): maxDifficulty = 0 for j in range ( i , k - 1 , - 1 ): maxDifficulty = max ( maxDifficulty , jobDifficulty [ j - 1 ]) dp [ i ][ k ] = min ( dp [ i ][ k ], dp [ j - 1 ][ k - 1 ] + maxDifficulty ) return dp [ n ][ d ]","title":"1335. Minimum Difficulty of a Job Schedule $\\star\\star\\star$"},{"location":"python3/1301-1400/1331-1340/#1336-number-of-transactions-per-visit-starstarstar","text":"","title":"1336. Number of Transactions per Visit $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/1301-1400/1331-1340/#1337-the-k-weakest-rows-in-a-matrix-star","text":"class Solution : def kWeakestRows ( self , mat : List [ List [ int ]], k : int ) -> List [ int ]: candidates = [] for i , row in enumerate ( mat ): candidates . append ([ sum ( row ), i ]) candidates . sort ( key = lambda c : ( c [ 0 ], c [ 1 ])) return [ i for _ , i in candidates [: k ]]","title":"1337. The K Weakest Rows in a Matrix $\\star$"},{"location":"python3/1301-1400/1331-1340/#1338-reduce-array-size-to-the-half-starstar","text":"class Solution : def minSetSize ( self , arr : List [ int ]) -> int : n = len ( arr ) count = collections . Counter ( arr ) . most_common () count . sort ( key = lambda c : - c [ 1 ]) sum = 0 for i , c in enumerate ( count ): sum += c [ 1 ] if sum >= n // 2 : return i + 1","title":"1338. Reduce Array Size to The Half $\\star\\star$"},{"location":"python3/1301-1400/1331-1340/#1339-maximum-product-of-splitted-binary-tree-starstar","text":"","title":"1339. Maximum Product of Splitted Binary Tree $\\star\\star$"},{"location":"python3/1301-1400/1331-1340/#1340-jump-game-v-starstarstar","text":"","title":"1340. Jump Game V $\\star\\star\\star$"},{"location":"python3/1301-1400/1341-1350/","text":"1341. Movie Rating $\\star\\star$ \ud83d\udd12 1342. Number of Steps to Reduce a Number to Zero $\\star$ 1343. Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold $\\star\\star$ 1344. Angle Between Hands of a Clock $\\star\\star$ class Solution : def angleClock ( self , hour : int , minutes : int ) -> float : hourAngle = ( hour % 12 ) * 30 + minutes * 0.5 minuteAngle = minutes * 6 ans = abs ( hourAngle - minuteAngle ) return min ( ans , 360 - ans ) 1345. Jump Game IV $\\star\\star\\star$ 1346. Check If N and Its Double Exist $\\star$ 1347. Minimum Number of Steps to Make Two Strings Anagram $\\star\\star$ 1348. Tweet Counts Per Frequency $\\star\\star$ 1349. Maximum Students Taking Exam $\\star\\star\\star$ 1350. Students With Invalid Departments $\\star$ \ud83d\udd12","title":"1341-1350"},{"location":"python3/1301-1400/1341-1350/#1341-movie-rating-starstar","text":"","title":"1341. Movie Rating $\\star\\star$ \ud83d\udd12"},{"location":"python3/1301-1400/1341-1350/#1342-number-of-steps-to-reduce-a-number-to-zero-star","text":"","title":"1342. Number of Steps to Reduce a Number to Zero $\\star$"},{"location":"python3/1301-1400/1341-1350/#1343-number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold-starstar","text":"","title":"1343. Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold $\\star\\star$"},{"location":"python3/1301-1400/1341-1350/#1344-angle-between-hands-of-a-clock-starstar","text":"class Solution : def angleClock ( self , hour : int , minutes : int ) -> float : hourAngle = ( hour % 12 ) * 30 + minutes * 0.5 minuteAngle = minutes * 6 ans = abs ( hourAngle - minuteAngle ) return min ( ans , 360 - ans )","title":"1344. Angle Between Hands of a Clock $\\star\\star$"},{"location":"python3/1301-1400/1341-1350/#1345-jump-game-iv-starstarstar","text":"","title":"1345. Jump Game IV $\\star\\star\\star$"},{"location":"python3/1301-1400/1341-1350/#1346-check-if-n-and-its-double-exist-star","text":"","title":"1346. Check If N and Its Double Exist $\\star$"},{"location":"python3/1301-1400/1341-1350/#1347-minimum-number-of-steps-to-make-two-strings-anagram-starstar","text":"","title":"1347. Minimum Number of Steps to Make Two Strings Anagram $\\star\\star$"},{"location":"python3/1301-1400/1341-1350/#1348-tweet-counts-per-frequency-starstar","text":"","title":"1348. Tweet Counts Per Frequency $\\star\\star$"},{"location":"python3/1301-1400/1341-1350/#1349-maximum-students-taking-exam-starstarstar","text":"","title":"1349. Maximum Students Taking Exam $\\star\\star\\star$"},{"location":"python3/1301-1400/1341-1350/#1350-students-with-invalid-departments-star","text":"","title":"1350. Students With Invalid Departments $\\star$ \ud83d\udd12"},{"location":"python3/1301-1400/1351-1360/","text":"1351. Count Negative Numbers in a Sorted Matrix $\\star$ 1352. Product of the Last K Numbers $\\star\\star$ 1353. Maximum Number of Events That Can Be Attended $\\star\\star$ 1354. Construct Target Array With Multiple Sums $\\star\\star\\star$ 1355. Activity Participants $\\star\\star$ \ud83d\udd12 1356. Sort Integers by The Number of 1 Bits $\\star$ 1357. Apply Discount Every n Orders $\\star\\star$ 1358. Number of Substrings Containing All Three Characters $\\star\\star$ 1359. Count All Valid Pickup and Delivery Options $\\star\\star\\star$ class Solution : def countOrders ( self , n : int ) -> int : kMod = int ( 1e9 + 7 ) ans = 1 for i in range ( 1 , n + 1 ): ans = ans * i * ( i * 2 - 1 ) % kMod return ans 1360. Number of Days Between Two Dates $\\star$","title":"1351-1360"},{"location":"python3/1301-1400/1351-1360/#1351-count-negative-numbers-in-a-sorted-matrix-star","text":"","title":"1351. Count Negative Numbers in a Sorted Matrix $\\star$"},{"location":"python3/1301-1400/1351-1360/#1352-product-of-the-last-k-numbers-starstar","text":"","title":"1352. Product of the Last K Numbers $\\star\\star$"},{"location":"python3/1301-1400/1351-1360/#1353-maximum-number-of-events-that-can-be-attended-starstar","text":"","title":"1353. Maximum Number of Events That Can Be Attended $\\star\\star$"},{"location":"python3/1301-1400/1351-1360/#1354-construct-target-array-with-multiple-sums-starstarstar","text":"","title":"1354. Construct Target Array With Multiple Sums $\\star\\star\\star$"},{"location":"python3/1301-1400/1351-1360/#1355-activity-participants-starstar","text":"","title":"1355. Activity Participants $\\star\\star$ \ud83d\udd12"},{"location":"python3/1301-1400/1351-1360/#1356-sort-integers-by-the-number-of-1-bits-star","text":"","title":"1356. Sort Integers by The Number of 1 Bits $\\star$"},{"location":"python3/1301-1400/1351-1360/#1357-apply-discount-every-n-orders-starstar","text":"","title":"1357. Apply Discount Every n Orders $\\star\\star$"},{"location":"python3/1301-1400/1351-1360/#1358-number-of-substrings-containing-all-three-characters-starstar","text":"","title":"1358. Number of Substrings Containing All Three Characters $\\star\\star$"},{"location":"python3/1301-1400/1351-1360/#1359-count-all-valid-pickup-and-delivery-options-starstarstar","text":"class Solution : def countOrders ( self , n : int ) -> int : kMod = int ( 1e9 + 7 ) ans = 1 for i in range ( 1 , n + 1 ): ans = ans * i * ( i * 2 - 1 ) % kMod return ans","title":"1359. Count All Valid Pickup and Delivery Options $\\star\\star\\star$"},{"location":"python3/1301-1400/1351-1360/#1360-number-of-days-between-two-dates-star","text":"","title":"1360. Number of Days Between Two Dates $\\star$"},{"location":"python3/1301-1400/1361-1370/","text":"1361. Validate Binary Tree Nodes $\\star\\star$ 1362. Closest Divisors $\\star\\star$ class Solution : def closestDivisors ( self , num : int ) -> List [ int ]: for root in range ( int ( sqrt ( num + 2 )) + 1 )[:: - 1 ]: for cand in [ num + 1 , num + 2 ]: if cand % root == 0 : return [ root , cand // root ] 1363. Largest Multiple of Three $\\star\\star\\star$ class Solution : def largestMultipleOfThree ( self , digits : List [ int ]) -> str : ans = '' mod1 = [ 1 , 4 , 7 , 2 , 5 , 8 ] mod2 = [ 2 , 5 , 8 , 1 , 4 , 7 ] count = collections . Counter ( digits ) summ = sum ( digits ) while summ % 3 != 0 : for digit in ( mod1 if summ % 3 == 1 else mod2 ): if count [ digit ]: count [ digit ] -= 1 summ -= digit break for digit in range ( 9 , - 1 , - 1 ): ans += str ( digit ) * count [ digit ] return '0' if len ( ans ) and ans [ 0 ] == '0' else ans 1364. Number of Trusted Contacts of a Customer $\\star\\star$ \ud83d\udd12 1365. How Many Numbers Are Smaller Than the Current Number $\\star$ 1366. Rank Teams by Votes $\\star\\star$ 1367. Linked List in Binary Tree $\\star\\star$ 1368. Minimum Cost to Make at Least One Valid Path in a Grid $\\star\\star\\star$ 1369. Get the Second Most Recent Activity $\\star\\star\\star$ \ud83d\udd12 1370. Increasing Decreasing String $\\star$","title":"1361-1370"},{"location":"python3/1301-1400/1361-1370/#1361-validate-binary-tree-nodes-starstar","text":"","title":"1361. Validate Binary Tree Nodes $\\star\\star$"},{"location":"python3/1301-1400/1361-1370/#1362-closest-divisors-starstar","text":"class Solution : def closestDivisors ( self , num : int ) -> List [ int ]: for root in range ( int ( sqrt ( num + 2 )) + 1 )[:: - 1 ]: for cand in [ num + 1 , num + 2 ]: if cand % root == 0 : return [ root , cand // root ]","title":"1362. Closest Divisors $\\star\\star$"},{"location":"python3/1301-1400/1361-1370/#1363-largest-multiple-of-three-starstarstar","text":"class Solution : def largestMultipleOfThree ( self , digits : List [ int ]) -> str : ans = '' mod1 = [ 1 , 4 , 7 , 2 , 5 , 8 ] mod2 = [ 2 , 5 , 8 , 1 , 4 , 7 ] count = collections . Counter ( digits ) summ = sum ( digits ) while summ % 3 != 0 : for digit in ( mod1 if summ % 3 == 1 else mod2 ): if count [ digit ]: count [ digit ] -= 1 summ -= digit break for digit in range ( 9 , - 1 , - 1 ): ans += str ( digit ) * count [ digit ] return '0' if len ( ans ) and ans [ 0 ] == '0' else ans","title":"1363. Largest Multiple of Three $\\star\\star\\star$"},{"location":"python3/1301-1400/1361-1370/#1364-number-of-trusted-contacts-of-a-customer-starstar","text":"","title":"1364. Number of Trusted Contacts of a Customer $\\star\\star$ \ud83d\udd12"},{"location":"python3/1301-1400/1361-1370/#1365-how-many-numbers-are-smaller-than-the-current-number-star","text":"","title":"1365. How Many Numbers Are Smaller Than the Current Number $\\star$"},{"location":"python3/1301-1400/1361-1370/#1366-rank-teams-by-votes-starstar","text":"","title":"1366. Rank Teams by Votes $\\star\\star$"},{"location":"python3/1301-1400/1361-1370/#1367-linked-list-in-binary-tree-starstar","text":"","title":"1367. Linked List in Binary Tree $\\star\\star$"},{"location":"python3/1301-1400/1361-1370/#1368-minimum-cost-to-make-at-least-one-valid-path-in-a-grid-starstarstar","text":"","title":"1368. Minimum Cost to Make at Least One Valid Path in a Grid $\\star\\star\\star$"},{"location":"python3/1301-1400/1361-1370/#1369-get-the-second-most-recent-activity-starstarstar","text":"","title":"1369. Get the Second Most Recent Activity $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/1301-1400/1361-1370/#1370-increasing-decreasing-string-star","text":"","title":"1370. Increasing Decreasing String $\\star$"},{"location":"python3/1301-1400/1371-1380/","text":"1371. Find the Longest Substring Containing Vowels in Even Counts $\\star\\star$ 1372. Longest ZigZag Path in a Binary Tree $\\star\\star$ 1373. Maximum Sum BST in Binary Tree $\\star\\star\\star$ class Solution : def maxSumBST ( self , root : TreeNode ) -> int : def dfs ( root : TreeNode ) -> tuple : if not root : return float ( 'inf' ), float ( '-inf' ), 0 , True leftMin , leftMax , leftSum , leftValid = dfs ( root . left ) rightMin , rightMax , rightSum , rightValid = dfs ( root . right ) valid = leftValid and rightValid and root . val > leftMax and root . val < rightMin summ = root . val + leftSum + rightSum if valid else - 1 self . ans = max ( self . ans , summ ) return min ( root . val , leftMin ), max ( root . val , rightMax ), summ , valid self . ans = 0 dfs ( root ) return self . ans 1374. Generate a String With Characters That Have Odd Counts $\\star$ 1375. Bulb Switcher III $\\star\\star$ 1376. Time Needed to Inform All Employees $\\star\\star$ 1377. Frog Position After T Seconds $\\star\\star\\star$ class Solution : def frogPosition ( self , n : int , edges : List [ List [ int ]], t : int , target : int ) -> float : prob = [ 0 ] * ( n + 1 ) visited = [ False ] * ( n + 1 ) graph = [[] for _ in range ( n + 1 )] queue = collections . deque ([ 1 ]) prob [ 1 ] = 1 visited [ 1 ] = True for fr , to in edges : graph [ fr ] . append ( to ) graph [ to ] . append ( fr ) for _ in range ( t ): for _ in range ( len ( queue )): curr = queue . popleft () children = sum ( not visited [ child ] for child in graph [ curr ]) for child in graph [ curr ]: if not visited [ child ]: visited [ child ] = True prob [ child ] = prob [ curr ] / children queue . append ( child ) if children > 0 : prob [ curr ] = 0 return prob [ target ] 1378. Replace Employee ID With The Unique Identifier $\\star$ \ud83d\udd12 1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree $\\star\\star$ 1380. Lucky Numbers in a Matrix $\\star$","title":"1371-1380"},{"location":"python3/1301-1400/1371-1380/#1371-find-the-longest-substring-containing-vowels-in-even-counts-starstar","text":"","title":"1371. Find the Longest Substring Containing Vowels in Even Counts $\\star\\star$"},{"location":"python3/1301-1400/1371-1380/#1372-longest-zigzag-path-in-a-binary-tree-starstar","text":"","title":"1372. Longest ZigZag Path in a Binary Tree $\\star\\star$"},{"location":"python3/1301-1400/1371-1380/#1373-maximum-sum-bst-in-binary-tree-starstarstar","text":"class Solution : def maxSumBST ( self , root : TreeNode ) -> int : def dfs ( root : TreeNode ) -> tuple : if not root : return float ( 'inf' ), float ( '-inf' ), 0 , True leftMin , leftMax , leftSum , leftValid = dfs ( root . left ) rightMin , rightMax , rightSum , rightValid = dfs ( root . right ) valid = leftValid and rightValid and root . val > leftMax and root . val < rightMin summ = root . val + leftSum + rightSum if valid else - 1 self . ans = max ( self . ans , summ ) return min ( root . val , leftMin ), max ( root . val , rightMax ), summ , valid self . ans = 0 dfs ( root ) return self . ans","title":"1373. Maximum Sum BST in Binary Tree $\\star\\star\\star$"},{"location":"python3/1301-1400/1371-1380/#1374-generate-a-string-with-characters-that-have-odd-counts-star","text":"","title":"1374. Generate a String With Characters That Have Odd Counts $\\star$"},{"location":"python3/1301-1400/1371-1380/#1375-bulb-switcher-iii-starstar","text":"","title":"1375. Bulb Switcher III $\\star\\star$"},{"location":"python3/1301-1400/1371-1380/#1376-time-needed-to-inform-all-employees-starstar","text":"","title":"1376. Time Needed to Inform All Employees $\\star\\star$"},{"location":"python3/1301-1400/1371-1380/#1377-frog-position-after-t-seconds-starstarstar","text":"class Solution : def frogPosition ( self , n : int , edges : List [ List [ int ]], t : int , target : int ) -> float : prob = [ 0 ] * ( n + 1 ) visited = [ False ] * ( n + 1 ) graph = [[] for _ in range ( n + 1 )] queue = collections . deque ([ 1 ]) prob [ 1 ] = 1 visited [ 1 ] = True for fr , to in edges : graph [ fr ] . append ( to ) graph [ to ] . append ( fr ) for _ in range ( t ): for _ in range ( len ( queue )): curr = queue . popleft () children = sum ( not visited [ child ] for child in graph [ curr ]) for child in graph [ curr ]: if not visited [ child ]: visited [ child ] = True prob [ child ] = prob [ curr ] / children queue . append ( child ) if children > 0 : prob [ curr ] = 0 return prob [ target ]","title":"1377. Frog Position After T Seconds $\\star\\star\\star$"},{"location":"python3/1301-1400/1371-1380/#1378-replace-employee-id-with-the-unique-identifier-star","text":"","title":"1378. Replace Employee ID With The Unique Identifier $\\star$ \ud83d\udd12"},{"location":"python3/1301-1400/1371-1380/#1379-find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree-starstar","text":"","title":"1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree $\\star\\star$"},{"location":"python3/1301-1400/1371-1380/#1380-lucky-numbers-in-a-matrix-star","text":"","title":"1380. Lucky Numbers in a Matrix $\\star$"},{"location":"python3/1301-1400/1381-1390/","text":"1381. Design a Stack With Increment Operation $\\star\\star$ 1382. Balance a Binary Search Tree $\\star\\star$ 1383. Maximum Performance of a Team $\\star\\star\\star$ 1384. Total Sales Amount by Year $\\star\\star\\star$ \ud83d\udd12 1385. Find the Distance Value Between Two Arrays $\\star$ 1386. Cinema Seat Allocation $\\star\\star$ 1387. Sort Integers by The Power Value $\\star\\star$ 1388. Pizza With 3n Slices $\\star\\star\\star$ 1389. Create Target Array in the Given Order $\\star$ 1390. Four Divisors $\\star\\star$ class Solution : def sumFourDivisors ( self , nums : List [ int ]) -> int : ans = 0 for num in nums : divisor = 0 for i in range ( 2 , int ( sqrt ( num )) + 1 ): if num % i == 0 : if divisor == 0 : divisor = i else : divisor = 0 break if divisor > 0 and divisor * divisor < num : ans += 1 + num + divisor + num // divisor return ans","title":"1381-1390"},{"location":"python3/1301-1400/1381-1390/#1381-design-a-stack-with-increment-operation-starstar","text":"","title":"1381. Design a Stack With Increment Operation $\\star\\star$"},{"location":"python3/1301-1400/1381-1390/#1382-balance-a-binary-search-tree-starstar","text":"","title":"1382. Balance a Binary Search Tree $\\star\\star$"},{"location":"python3/1301-1400/1381-1390/#1383-maximum-performance-of-a-team-starstarstar","text":"","title":"1383. Maximum Performance of a Team $\\star\\star\\star$"},{"location":"python3/1301-1400/1381-1390/#1384-total-sales-amount-by-year-starstarstar","text":"","title":"1384. Total Sales Amount by Year $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/1301-1400/1381-1390/#1385-find-the-distance-value-between-two-arrays-star","text":"","title":"1385. Find the Distance Value Between Two Arrays $\\star$"},{"location":"python3/1301-1400/1381-1390/#1386-cinema-seat-allocation-starstar","text":"","title":"1386. Cinema Seat Allocation $\\star\\star$"},{"location":"python3/1301-1400/1381-1390/#1387-sort-integers-by-the-power-value-starstar","text":"","title":"1387. Sort Integers by The Power Value $\\star\\star$"},{"location":"python3/1301-1400/1381-1390/#1388-pizza-with-3n-slices-starstarstar","text":"","title":"1388. Pizza With 3n Slices $\\star\\star\\star$"},{"location":"python3/1301-1400/1381-1390/#1389-create-target-array-in-the-given-order-star","text":"","title":"1389. Create Target Array in the Given Order $\\star$"},{"location":"python3/1301-1400/1381-1390/#1390-four-divisors-starstar","text":"class Solution : def sumFourDivisors ( self , nums : List [ int ]) -> int : ans = 0 for num in nums : divisor = 0 for i in range ( 2 , int ( sqrt ( num )) + 1 ): if num % i == 0 : if divisor == 0 : divisor = i else : divisor = 0 break if divisor > 0 and divisor * divisor < num : ans += 1 + num + divisor + num // divisor return ans","title":"1390. Four Divisors $\\star\\star$"},{"location":"python3/1301-1400/1391-1400/","text":"1391. Check if There is a Valid Path in a Grid $\\star\\star$ 1392. Longest Happy Prefix $\\star\\star\\star$ 1393. Capital Gain/Loss $\\star\\star$ \ud83d\udd12 1394. Find Lucky Integer in an Array $\\star$ 1395. Count Number of Teams $\\star\\star$ 1396. Design Underground System $\\star\\star$ 1397. Find All Good Strings $\\star\\star\\star$ 1398. Customers Who Bought Products A and B but Not C $\\star\\star$ \ud83d\udd12 1399. Count Largest Group $\\star$ 1400. Construct K Palindrome Strings $\\star\\star$","title":"1391-1400"},{"location":"python3/1301-1400/1391-1400/#1391-check-if-there-is-a-valid-path-in-a-grid-starstar","text":"","title":"1391. Check if There is a Valid Path in a Grid $\\star\\star$"},{"location":"python3/1301-1400/1391-1400/#1392-longest-happy-prefix-starstarstar","text":"","title":"1392. Longest Happy Prefix $\\star\\star\\star$"},{"location":"python3/1301-1400/1391-1400/#1393-capital-gainloss-starstar","text":"","title":"1393. Capital Gain/Loss $\\star\\star$ \ud83d\udd12"},{"location":"python3/1301-1400/1391-1400/#1394-find-lucky-integer-in-an-array-star","text":"","title":"1394. Find Lucky Integer in an Array $\\star$"},{"location":"python3/1301-1400/1391-1400/#1395-count-number-of-teams-starstar","text":"","title":"1395. Count Number of Teams $\\star\\star$"},{"location":"python3/1301-1400/1391-1400/#1396-design-underground-system-starstar","text":"","title":"1396. Design Underground System $\\star\\star$"},{"location":"python3/1301-1400/1391-1400/#1397-find-all-good-strings-starstarstar","text":"","title":"1397. Find All Good Strings $\\star\\star\\star$"},{"location":"python3/1301-1400/1391-1400/#1398-customers-who-bought-products-a-and-b-but-not-c-starstar","text":"","title":"1398. Customers Who Bought Products A and B but Not C $\\star\\star$ \ud83d\udd12"},{"location":"python3/1301-1400/1391-1400/#1399-count-largest-group-star","text":"","title":"1399. Count Largest Group $\\star$"},{"location":"python3/1301-1400/1391-1400/#1400-construct-k-palindrome-strings-starstar","text":"","title":"1400. Construct K Palindrome Strings $\\star\\star$"},{"location":"python3/1401-1500/1401-1410/","text":"1401. Circle and Rectangle Overlapping $\\star\\star$ 1402. Reducing Dishes $\\star\\star\\star$ 1403. Minimum Subsequence in Non-Increasing Order $\\star$ 1404. Number of Steps to Reduce a Number in Binary Representation to One $\\star\\star$ 1405. Longest Happy String $\\star\\star$ 1406. Stone Game III $\\star\\star\\star$ 1407. Top Travellers $\\star$ \ud83d\udd12 1408. String Matching in an Array $\\star$ 1409. Queries on a Permutation With Key $\\star\\star$ 1410. HTML Entity Parser $\\star\\star$","title":"1401-1410"},{"location":"python3/1401-1500/1401-1410/#1401-circle-and-rectangle-overlapping-starstar","text":"","title":"1401. Circle and Rectangle Overlapping $\\star\\star$"},{"location":"python3/1401-1500/1401-1410/#1402-reducing-dishes-starstarstar","text":"","title":"1402. Reducing Dishes $\\star\\star\\star$"},{"location":"python3/1401-1500/1401-1410/#1403-minimum-subsequence-in-non-increasing-order-star","text":"","title":"1403. Minimum Subsequence in Non-Increasing Order $\\star$"},{"location":"python3/1401-1500/1401-1410/#1404-number-of-steps-to-reduce-a-number-in-binary-representation-to-one-starstar","text":"","title":"1404. Number of Steps to Reduce a Number in Binary Representation to One $\\star\\star$"},{"location":"python3/1401-1500/1401-1410/#1405-longest-happy-string-starstar","text":"","title":"1405. Longest Happy String $\\star\\star$"},{"location":"python3/1401-1500/1401-1410/#1406-stone-game-iii-starstarstar","text":"","title":"1406. Stone Game III $\\star\\star\\star$"},{"location":"python3/1401-1500/1401-1410/#1407-top-travellers-star","text":"","title":"1407. Top Travellers $\\star$ \ud83d\udd12"},{"location":"python3/1401-1500/1401-1410/#1408-string-matching-in-an-array-star","text":"","title":"1408. String Matching in an Array $\\star$"},{"location":"python3/1401-1500/1401-1410/#1409-queries-on-a-permutation-with-key-starstar","text":"","title":"1409. Queries on a Permutation With Key $\\star\\star$"},{"location":"python3/1401-1500/1401-1410/#1410-html-entity-parser-starstar","text":"","title":"1410. HTML Entity Parser $\\star\\star$"},{"location":"python3/1401-1500/1411-1420/","text":"1411. Number of Ways to Paint N \u00d7 3 Grid $\\star\\star\\star$ 1412. Find the Quiet Students in All Exams $\\star\\star\\star$ \ud83d\udd12 1413. Minimum Value to Get Positive Step by Step Sum $\\star$ 1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K $\\star\\star$ 1415. The k-th Lexicographical String of All Happy Strings of Length n $\\star\\star$ 1416. Restore The Array $\\star\\star\\star$ 1417. Reformat The String $\\star$ 1418. Display Table of Food Orders in a Restaurant $\\star\\star$ 1419. Minimum Number of Frogs Croaking $\\star\\star$ 1420. Build Array Where You Can Find The Maximum Exactly K Comparisons $\\star\\star\\star$","title":"1411-1420"},{"location":"python3/1401-1500/1411-1420/#1411-number-of-ways-to-paint-n-3-grid-starstarstar","text":"","title":"1411. Number of Ways to Paint N \u00d7 3 Grid $\\star\\star\\star$"},{"location":"python3/1401-1500/1411-1420/#1412-find-the-quiet-students-in-all-exams-starstarstar","text":"","title":"1412. Find the Quiet Students in All Exams $\\star\\star\\star$ \ud83d\udd12"},{"location":"python3/1401-1500/1411-1420/#1413-minimum-value-to-get-positive-step-by-step-sum-star","text":"","title":"1413. Minimum Value to Get Positive Step by Step Sum $\\star$"},{"location":"python3/1401-1500/1411-1420/#1414-find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k-starstar","text":"","title":"1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K $\\star\\star$"},{"location":"python3/1401-1500/1411-1420/#1415-the-k-th-lexicographical-string-of-all-happy-strings-of-length-n-starstar","text":"","title":"1415. The k-th Lexicographical String of All Happy Strings of Length n $\\star\\star$"},{"location":"python3/1401-1500/1411-1420/#1416-restore-the-array-starstarstar","text":"","title":"1416. Restore The Array $\\star\\star\\star$"},{"location":"python3/1401-1500/1411-1420/#1417-reformat-the-string-star","text":"","title":"1417. Reformat The String $\\star$"},{"location":"python3/1401-1500/1411-1420/#1418-display-table-of-food-orders-in-a-restaurant-starstar","text":"","title":"1418. Display Table of Food Orders in a Restaurant $\\star\\star$"},{"location":"python3/1401-1500/1411-1420/#1419-minimum-number-of-frogs-croaking-starstar","text":"","title":"1419. Minimum Number of Frogs Croaking $\\star\\star$"},{"location":"python3/1401-1500/1411-1420/#1420-build-array-where-you-can-find-the-maximum-exactly-k-comparisons-starstarstar","text":"","title":"1420. Build Array Where You Can Find The Maximum Exactly K Comparisons $\\star\\star\\star$"},{"location":"python3/1401-1500/1421-1430/","text":"1421. NPV Queries $\\star\\star$ \ud83d\udd12 1422. Maximum Score After Splitting a String $\\star$ 1423. Maximum Points You Can Obtain from Cards $\\star\\star$ 1424. Diagonal Traverse II $\\star\\star$ 1425. Constrained Subsequence Sum $\\star\\star\\star$ class Solution : def constrainedSubsetSum ( self , nums : List [ int ], k : int ) -> int : ans = float ( '-inf' ) dp = [ 0 ] * len ( nums ) q = collections . deque () for i , num in enumerate ( nums ): if q : dp [ i ] = max ( q [ 0 ], 0 ) + num else : dp [ i ] = num ans = max ( ans , dp [ i ]) while q and q [ - 1 ] < dp [ i ]: q . pop () q . append ( dp [ i ]) if i >= k and dp [ i - k ] == q [ 0 ]: q . popleft () return ans 1426. Counting Elements $\\star$ \ud83d\udd12 1427. Perform String Shifts $\\star$ \ud83d\udd12 1428. Leftmost Column with at Least a One $\\star\\star$ \ud83d\udd12 1429. First Unique Number $\\star\\star$ \ud83d\udd12 1430. Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree $\\star\\star$ \ud83d\udd12","title":"1421-1430"},{"location":"python3/1401-1500/1421-1430/#1421-npv-queries-starstar","text":"","title":"1421. NPV Queries $\\star\\star$ \ud83d\udd12"},{"location":"python3/1401-1500/1421-1430/#1422-maximum-score-after-splitting-a-string-star","text":"","title":"1422. Maximum Score After Splitting a String $\\star$"},{"location":"python3/1401-1500/1421-1430/#1423-maximum-points-you-can-obtain-from-cards-starstar","text":"","title":"1423. Maximum Points You Can Obtain from Cards $\\star\\star$"},{"location":"python3/1401-1500/1421-1430/#1424-diagonal-traverse-ii-starstar","text":"","title":"1424. Diagonal Traverse II $\\star\\star$"},{"location":"python3/1401-1500/1421-1430/#1425-constrained-subsequence-sum-starstarstar","text":"class Solution : def constrainedSubsetSum ( self , nums : List [ int ], k : int ) -> int : ans = float ( '-inf' ) dp = [ 0 ] * len ( nums ) q = collections . deque () for i , num in enumerate ( nums ): if q : dp [ i ] = max ( q [ 0 ], 0 ) + num else : dp [ i ] = num ans = max ( ans , dp [ i ]) while q and q [ - 1 ] < dp [ i ]: q . pop () q . append ( dp [ i ]) if i >= k and dp [ i - k ] == q [ 0 ]: q . popleft () return ans","title":"1425. Constrained Subsequence Sum $\\star\\star\\star$"},{"location":"python3/1401-1500/1421-1430/#1426-counting-elements-star","text":"","title":"1426. Counting Elements $\\star$ \ud83d\udd12"},{"location":"python3/1401-1500/1421-1430/#1427-perform-string-shifts-star","text":"","title":"1427. Perform String Shifts $\\star$ \ud83d\udd12"},{"location":"python3/1401-1500/1421-1430/#1428-leftmost-column-with-at-least-a-one-starstar","text":"","title":"1428. Leftmost Column with at Least a One $\\star\\star$ \ud83d\udd12"},{"location":"python3/1401-1500/1421-1430/#1429-first-unique-number-starstar","text":"","title":"1429. First Unique Number $\\star\\star$ \ud83d\udd12"},{"location":"python3/1401-1500/1421-1430/#1430-check-if-a-string-is-a-valid-sequence-from-root-to-leaves-path-in-a-binary-tree-starstar","text":"","title":"1430. Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree $\\star\\star$ \ud83d\udd12"},{"location":"python3/1401-1500/1431-1440/","text":"1431. Kids With the Greatest Number of Candies $\\star$ 1432. Max Difference You Can Get From Changing an Integer $\\star\\star$ 1433. Check If a String Can Break Another String $\\star\\star$ 1434. Number of Ways to Wear Different Hats to Each Other $\\star\\star\\star$ 1435. Create a Session Bar Chart $\\star$ \ud83d\udd12 1436. Destination City $\\star$ 1437. Check If All 1's Are at Least Length K Places Away $\\star\\star$ 1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit $\\star\\star$ 1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows $\\star\\star\\star$ 1440. Evaluate Boolean Expression $\\star\\star$ \ud83d\udd12","title":"1431-1440"},{"location":"python3/1401-1500/1431-1440/#1431-kids-with-the-greatest-number-of-candies-star","text":"","title":"1431. Kids With the Greatest Number of Candies $\\star$"},{"location":"python3/1401-1500/1431-1440/#1432-max-difference-you-can-get-from-changing-an-integer-starstar","text":"","title":"1432. Max Difference You Can Get From Changing an Integer $\\star\\star$"},{"location":"python3/1401-1500/1431-1440/#1433-check-if-a-string-can-break-another-string-starstar","text":"","title":"1433. Check If a String Can Break Another String $\\star\\star$"},{"location":"python3/1401-1500/1431-1440/#1434-number-of-ways-to-wear-different-hats-to-each-other-starstarstar","text":"","title":"1434. Number of Ways to Wear Different Hats to Each Other $\\star\\star\\star$"},{"location":"python3/1401-1500/1431-1440/#1435-create-a-session-bar-chart-star","text":"","title":"1435. Create a Session Bar Chart $\\star$ \ud83d\udd12"},{"location":"python3/1401-1500/1431-1440/#1436-destination-city-star","text":"","title":"1436. Destination City $\\star$"},{"location":"python3/1401-1500/1431-1440/#1437-check-if-all-1s-are-at-least-length-k-places-away-starstar","text":"","title":"1437. Check If All 1's Are at Least Length K Places Away $\\star\\star$"},{"location":"python3/1401-1500/1431-1440/#1438-longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit-starstar","text":"","title":"1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit $\\star\\star$"},{"location":"python3/1401-1500/1431-1440/#1439-find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows-starstarstar","text":"","title":"1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows $\\star\\star\\star$"},{"location":"python3/1401-1500/1431-1440/#1440-evaluate-boolean-expression-starstar","text":"","title":"1440. Evaluate Boolean Expression $\\star\\star$ \ud83d\udd12"},{"location":"python3/1401-1500/1441-1450/","text":"1441. Build an Array With Stack Operations $\\star$ 1442. Count Triplets That Can Form Two Arrays of Equal XOR $\\star\\star$ 1443. Minimum Time to Collect All Apples in a Tree $\\star\\star$ 1444. Number of Ways of Cutting a Pizza $\\star\\star\\star$ 1445. Apples & Oranges $\\star\\star$ \ud83d\udd12 1446. Consecutive Characters $\\star$ 1447. Simplified Fractions $\\star\\star$ 1448. Count Good Nodes in Binary Tree $\\star\\star$ 1449. Form Largest Integer With Digits That Add up to Target $\\star\\star\\star$ 1450. Number of Students Doing Homework at a Given Time $\\star$","title":"1441-1450"},{"location":"python3/1401-1500/1441-1450/#1441-build-an-array-with-stack-operations-star","text":"","title":"1441. Build an Array With Stack Operations $\\star$"},{"location":"python3/1401-1500/1441-1450/#1442-count-triplets-that-can-form-two-arrays-of-equal-xor-starstar","text":"","title":"1442. Count Triplets That Can Form Two Arrays of Equal XOR $\\star\\star$"},{"location":"python3/1401-1500/1441-1450/#1443-minimum-time-to-collect-all-apples-in-a-tree-starstar","text":"","title":"1443. Minimum Time to Collect All Apples in a Tree $\\star\\star$"},{"location":"python3/1401-1500/1441-1450/#1444-number-of-ways-of-cutting-a-pizza-starstarstar","text":"","title":"1444. Number of Ways of Cutting a Pizza $\\star\\star\\star$"},{"location":"python3/1401-1500/1441-1450/#1445-apples-oranges-starstar","text":"","title":"1445. Apples &amp; Oranges $\\star\\star$ \ud83d\udd12"},{"location":"python3/1401-1500/1441-1450/#1446-consecutive-characters-star","text":"","title":"1446. Consecutive Characters $\\star$"},{"location":"python3/1401-1500/1441-1450/#1447-simplified-fractions-starstar","text":"","title":"1447. Simplified Fractions $\\star\\star$"},{"location":"python3/1401-1500/1441-1450/#1448-count-good-nodes-in-binary-tree-starstar","text":"","title":"1448. Count Good Nodes in Binary Tree $\\star\\star$"},{"location":"python3/1401-1500/1441-1450/#1449-form-largest-integer-with-digits-that-add-up-to-target-starstarstar","text":"","title":"1449. Form Largest Integer With Digits That Add up to Target $\\star\\star\\star$"},{"location":"python3/1401-1500/1441-1450/#1450-number-of-students-doing-homework-at-a-given-time-star","text":"","title":"1450. Number of Students Doing Homework at a Given Time $\\star$"},{"location":"python3/1401-1500/1451-1460/","text":"1451. Rearrange Words in a Sentence $\\star\\star$ 1452. People Whose List of Favorite Companies Is Not a Subset of Another List $\\star\\star$ 1453. Maximum Number of Darts Inside of a Circular Dartboard $\\star\\star\\star$ 1454. Active Users $\\star\\star$ \ud83d\udd12 1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence $\\star$ 1456. Maximum Number of Vowels in a Substring of Given Length $\\star\\star$ 1457. Pseudo-Palindromic Paths in a Binary Tree $\\star\\star$ 1458. Max Dot Product of Two Subsequences $\\star\\star\\star$","title":"1451-1460"},{"location":"python3/1401-1500/1451-1460/#1451-rearrange-words-in-a-sentence-starstar","text":"","title":"1451. Rearrange Words in a Sentence $\\star\\star$"},{"location":"python3/1401-1500/1451-1460/#1452-people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list-starstar","text":"","title":"1452. People Whose List of Favorite Companies Is Not a Subset of Another List $\\star\\star$"},{"location":"python3/1401-1500/1451-1460/#1453-maximum-number-of-darts-inside-of-a-circular-dartboard-starstarstar","text":"","title":"1453. Maximum Number of Darts Inside of a Circular Dartboard $\\star\\star\\star$"},{"location":"python3/1401-1500/1451-1460/#1454-active-users-starstar","text":"","title":"1454. Active Users $\\star\\star$ \ud83d\udd12"},{"location":"python3/1401-1500/1451-1460/#1455-check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence-star","text":"","title":"1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence $\\star$"},{"location":"python3/1401-1500/1451-1460/#1456-maximum-number-of-vowels-in-a-substring-of-given-length-starstar","text":"","title":"1456. Maximum Number of Vowels in a Substring of Given Length $\\star\\star$"},{"location":"python3/1401-1500/1451-1460/#1457-pseudo-palindromic-paths-in-a-binary-tree-starstar","text":"","title":"1457. Pseudo-Palindromic Paths in a Binary Tree $\\star\\star$"},{"location":"python3/1401-1500/1451-1460/#1458-max-dot-product-of-two-subsequences-starstarstar","text":"","title":"1458. Max Dot Product of Two Subsequences $\\star\\star\\star$"}]}